---
title: Doc Chat Bot
lastUpdated: false
---

<h1>Ioto Doc ChatBot</h1>
<div class="chat">
    <p>This prototype documentation ChatBot has been trained on the Ioto documentation.</p>
    <div _class="mb-5" v-for="item in page.questions">
        <div class="question"> {{ item.question}} </div>
        <div class="answer" v-html="item.answer"></div>
    </div>
    <form @submit.prevent="onSubmit">
        <div class="ask">
            <input
                ref="questionRef"
                v-model="page.question"
                type="text"
                name="question"
                id="question"
                size="80"
                placeholder="Ask any question about Ioto ..."
                required>
        </div>
        <div class="thinking" v-if="page.thinking">Thinking ...{{page.dots}}</div>
        <!--
        <button class="button" @click="newChat">New Chat</button>
        Thread: {{page.threadId}}
        -->
    </form>
</div>

<script setup>
import { onMounted, reactive, ref } from 'vue'
import { marked } from "marked"

const count = ref(0)

const questionRef = ref(null)

const page = reactive({
    dots: '',
    lifespan: 86400 * 1000 * 5,
    question: null,
    questions: [],
    thinking: null,
    threadId: null,
})

onMounted(() => {
    if (questionRef.value) {
        questionRef.value.focus()
    }
    localStorage['/embedthis/thread'] = {}
})

async function newChat() {
    localStorage['/embedthis/thread'] = {}
}

async function onSubmit(event) {
    event.preventDefault()
    let thread
    try {
        thread = JSON.parse(localStorage['/embedthis/thread'] || '{}') || {}
    } catch {}
    if (!thread || (thread.id && thread.expire > Date.now() + page.lifespan)) {
        thread = {}
    }
    page.threadId = thread.id

    let question = page.question
    let magic = '5ed3de37-dcc9-4d78-b1e9-546d8a9a2270'
    if (question) {
        try {
            let args = {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                    Origin: window.location.origin,
                },
                mode: 'cors',
                credentials: 'include',
            }
            page.thinking = true
            let response = await fetch('https://api.admin.embedthis.com/api/ai/chat',
                Object.assign({}, args, {
                    body: JSON.stringify({ message: question, threadId: thread.id, magic, }),
                })
            )
            if (response.status != 200) {
                // Clear thread.id?
                throw new Error(await response.text())
            }
            let answer = await response.json()
            let expire = Date.now() + page.lifespan
            page.threadId = thread.id = answer.threadId
            localStorage['/embedthis/thread'] = JSON.stringify({id: thread.id, expire })
            let runId = answer.runId

            let timeout = Date.now() + 60 * 1000
            while (Date.now() < timeout && answer.status != 'completed') {
                let response = await fetch('https://api.admin.embedthis.com/api/ai/poll',
                    Object.assign({}, args, { 
                        body: JSON.stringify({ runId, threadId: thread.id, magic }) 
                    })
                )
                if (response.status != 200) {
                    throw new Error(await response.text())
                }
                answer = await response.json()
                if (answer.status == 'completed') {
                    break
                }
                await new Promise(resolve => setTimeout(resolve, 1000))
                page.dots = page.dots + '.'
            }
            console.log(answer)
            let text
            if (answer.text.indexOf('<html') >= 0) {
                text = answer.text.replace(/```html\n/, '').replace(/\n```/, '')
            } else {
                text = marked.parse(answer.text)
            }
            console.log(text)
            //  Remove cross-references
            text = text.replace(/.*<body>\n/s, '').replace(/<\/body>.*/, '').replace(/.\d+:\d+.source./g, '')

            page.questions.push({question: page.question, answer: text})
            page.question = null
            page.dots = ''
        } catch (err) {
            console.log(`Cannot submit form, please email`, {err})
            alert(
                `${err.message}.\n\nSorry, your form was not uploaded. Please contact sales via email at sales@embedthis.com`
            )
        } finally {
            page.thinking = false
        }
    }
}
</script>

<style module>
button {
  margin-top: 20px;
  background-color: #42b983;
  color: white;
  border: none;
  padding: 10px;
  cursor: pointer;
}
</style>
```text
URL(1)                           User Commands                          URL(1)

NAME
       url

SYNOPSIS
       url [options] [METHOD] URL [items,...]

DESCRIPTION
       URL: A simple client HTTP test program

       url [options] [METHOD] URL [items,...]

       Url
         /path
         port/path
         host:port/path
         scheme://host:port/path

       Options
         --benchmark 3
         --ca file
         --cert file
         --chunk size
         --ciphers cipher,...
         --clients count
         --continue
         --cookie CookieString
         --count NUM
         --debug
         --header 'key: value'
         --key file
         --nofollow
         --printable
         --protocol 0|1
         --quiet
         --range byteRanges
         --retries count
         --save file
         --show [HBhb]
         --timeout secs
         --trace file[:type:from]
         --upload
         --verify
         --verbose
         --webSockets
         --webSocketsProtocol proto
         --webSocketsSize num
         --zero

       The URL program is a pragmatic, simple, compact HTTP test client. It
       does not attempt to implement all the HTTP specifications. It supports
       HTTP/1 keep-alive and transfer-chunking encoding.


ARGUMENTS

       The url command takes an optional METHOD as the first argument. This
       must be an upper case word. If absent, the POST method is used if there
       is supplied body data items and otherwise the GET method is used.

       After the optional method is the required URL. The request URL uses a
       flexible format so you can supply only the essential URL components.
       For example.

           $ url /index.html
           $ url :8080
           $ url /
           $ url https:///index.html


URL

       The request URL is of the form:

           [http://|https://][hostname][:port][/path][?query][#hash]

       All portions of the URL are optional. You can supply just the
       components that are non-default.

       If the HTTP scheme is absent, "http" is used. If the hostname is
       missing, "localhost" is used. If the port is absent, the default HTTP
       port for the relevant scheme is used. If the path is not supplied, "/"
       is used. If the query or hash are absent, they are not used.


REQUEST ITEMS

       Requests can supply body data by appending request items to the command
       line. The following request item formats are supported.

           key=value       Request form parameters.

           {key:value,..} Request form parameters as a JSON string.

           @file           Request body supplied via a file.

           "Literal Data"  Request body as a literal string.

           Header:Value    HTTP headers

       If JSON is supplied, only one JSON item can be provided and a Content-
       Type of application/json will be added to the HTTP request headers.

       If a Key=Value parse are provided, multiple such values can be use and
       a Content-Type of x-www-form-urlencoded will be added to the headers.


SHOW TRACE

       By default, url will display the response HTTP headers and response
       data. This can be modified via the --show command option. Use the
       --quiet or --show "" to squelch outputting the response HTTP headers.


OPTIONS

       --benchmark
              Compute benchmark statistics for the requests.

       --ca file
              Certifiate authority. This is used to validate peer site
              certificates.

       --chunk size
              Send request body data using transfer chunk encoding of this
              maximum size.

       --ciphers cipher,cipher
              List of TLS cipers to use for the request.

       --clients count
              Use the requested number of simulated clients to run
              simultaneous requests. Default is 1.

       --continue
              Continue testing despite request errors.

       --cookie
              Cookie string header.

       --debug
              Enable debug tracing. (Shortcut -d).

       --header key:value
              Include the HTTP header key:value in the requeset.

       --key file
              Use the supplied private key when sending client certificates to
              the server.

       --nofollow
              Do not follow redirections. Default is to follow.

       --printable
              If the returned content contains binary data, convert to a
              printable hex format.

       --protocol 0|1
              If set to 0, use the HTTP/1.0 protocol, otherwise use the
              default HTTP/1.1

       --quiet
              Do not display HTTP response headers. Alias for --show "".

       --range byteRanges
              Add to the request the specified byte ranges.

       --retries count
              Define the retry limit for the request. This is used to retry
              requests and to follow redirections.  Default is 3.

       --save filename
              Save the response content to the given filename.

       --show [HBhb]
              Show the request headers/body (HB) and response headers/body
              (hb). Defaults to --show h. Set to an empty string to disable
              all tracing.

       --timeout secs
              Timeout the request if it does not complete in the required
              number of seconds.

       --trace file[:types[:sources]]
              Name the Ioto trace file. The types are a comma separated list
              of message types. Valid types include: info, debug, error, and
              trace. Sources are the code module names originating the trace
              messages. You can use "all" for types and sources to match all
              types/sources. You can also use "!type" and "!source" to negate
              a type or source.

       --upload
              POST the supplied data items (or files) using multipart-mime
              file upload.

       --verify
              Verify the server certificate using the certificate authority
              bundle supplied with the --ca file option. The default is to not
              verify.

       --verbose
              Run with more verbose tracing. (Shortcut -v).

       --version
              Output the product version number.

       --webSockets
              Force enable the WebSockets protocol. This is enabled automatically if using the ws:// or wss:// URL scheme.

       --webSocketsProtocol proto
              Select the given WebSockets sub-protocol.

       --webSocketsSize num
              Send test messages of the given size to the server.

       --zero 
              Exit with a zero status for any valid HTTP response.

REPORTING BUGS
       Report bugs to dev@embedthis.com.

COPYRIGHT
       Copyright (c) Embedthis Software.

url                                June 2024                            URL(1)
```
```text
NAME
    json - JSON parsing and query program

SYNOPSIS
    json [options] [cmd] file
    json --stdin [cmd] < file
    json field=value
    json field
    json .

DESCRIPTION
    JSON: A JSON parsing and query program

    json [options] [cmd] [file]

        --blend
        --check
        --compress
        --default value
        --env
        --header
        --json
        --json5
        --noerror
        --profile name
        --quiet
        --stdin
        --remove
        --overwrite

    Commands:
        property=value
        property
        .

    The JSON program is a pragmatic, simple JSON parse and query client.

COMMANDS
    json field=value
    json field
    json .

    The json command has several command forms.

        json [options] [cmd] file

    This form reads the supplied JSON or JSON5 file and performs the specified command and emits the result.

        json --stdin [cmd] < file

    When given the --stdin option, the command reads from stdin instead of a file.

QUERYING PROPERTIES
    You can query a property value using the "field" form.

        json address.zip file.json

    This will query the "address.zip" property from the JSON file and emit the result. You can specify the output format with the --json, --json5, --env, --header, and --blend options. For example, to emit the result as a shell environment variable, use the --env option.

        json --env address.zip file.json

SETTING PROPERTIES
    You can update a property value using the "field=value" form.

        json address.zip=98052 file.json

    The field can be a dotted path.

CONVERTING formats
        json --json5 file.json .

    This will convert the JSON file to JSON5 format and emit the result.

OPTIONS
    --blend
        Blend included files from blend[]

    --check
        Check syntax with no output

    --compress
        Emit without redundant whitespace

    --default value
        Default value to use if query not found

    --env
        Emit results as shell environment variables

    --header
        Emit query results as C header defines

    --json
        Emit output as JSON

    --json5
        Emit output as JSON5

    --noerror
        Ignore file open errors

    --profile name
        Merge properties from the named profile

    --quiet
        Quiet mode with no error messages

    --stdin
        Read from stdin

    --remove
        Remove queried property

    --overwrite
        Overwrite file when converting instead of outputting to stdout

COMMANDS
    property=value
        Set queried property

    property
        Query property which can be a dotted path.

    .
        Convert input to desired format.

REPORTING BUGS
    Report bugs to dev@embedthis.com.

COPYRIGHT
    Copyright (c) Embedthis Software.
``````text
IOTO(1)                          User Commands                         IOTO(1)

NAME
       ioto- Embedded Device Agent

SYNOPSIS

       ioto [options]

       ioto
           --account ID
           --background
           --cloud Token
           --config dir
           --count Number
           --debug
           --exit event|minutes
           --gen
           --home directory
           --id UCI
           --ioto path
           --nosave
           --product Token
           --profile profile
           --reset
           --show [bhBH]
           --state dir
           --test suite
           --timeouts
           --trace file[:type:from]
           --verbose
           --version

DESCRIPTION

       Ioto is a compact device agent that includes an MQTT client, HTTP web
       server, HTTP client, embedded database, JSON parser and integration
       with AWS IoT. It can run as a stand-alone as a device agent or the Ioto
       library can be embedded in applications.

       The Ioto web server supports HTTP/1.0, HTTP/1.1, TLS, user
       authentication, sessions, chunked transfers, file upload, and security
       limits.

       Ioto normally reads a set of JSON configuration files. It reads the
       ioto.json5 file for general configuration, the web.json5 for web server
       configuration, and shadow.json5 for persisted device shadow state.

       Ioto can trace activities to a file that defaults to 'stdout'. This can
       be modified via the --trace command line option.

       The --trace option specifies a destination file for trace messages.
       This will override the trace property in the Ioto ioto.json5 file. The
       trace argument syntax is fileName[:types:sources].

       The types are a comma separated list of message types. Valid types
       include: info, debug, error, and trace.  Sources are the code module
       names originating the trace messages.

       You can use "all" for types and sources to match all types/sources. You
       can also use "!type" and "!source" to negate a type or source.

       Ioto responds to the SIGUSR2 signal and increases the trace level.

OPTIONS

       --account ID
              Override the account property in the device.json5 configuration
              file when using pre-claimed device provisioning. The account
              property should be set to the user's device manager account ID
              obtained from the Account/Settings page in the manager site.
              --background Run Ioto in the background and detach from the
              console.

       --cloud Token
              Override the cloudToken property in the device.json5
              configuration file when using pre-claimed device provisioning.
              The cloudToken property should be set to the Builder cloud claim
              token.

       --config dir
              Override the directory containing config files.

       --count Number
              Override the number of test iterations.

       --debug
              Enable debug tracing. (Shortcut -d).

       --exit event|minutes
              Exit Ioto when the given event is triggered or when the
              specified number of minutes have elapsed. Useful when performing
              limited tests.

       --gen  Generate a UID

       --home directory
              Change to the specified directory before running Ioto.

       --id UCI
              Override the id property in the device.json5 configuration file.
              The id property should be set to unique device claim ID for the
              device.

       --ioto path
              Override the path to the ioto.json5 configuration file.

       --nosave
              Run in-memory and do not save state.

       --product Token
              Override the "product" property in the device.json5
              configuration file when using pre-claimed device provisioning.
              The product property should be set to the Builder product token.

       --profile profile
              Override the operational profile. Defaults to "prod".

       --quiet
              Don't show web server HTTP headers. Alias for --show "".

       --reset
              Reset Ioto state to factory defaults. This erases database state
              under the ./state directory.

       --show [hbHB]
              Show request headers/body (HB) and resposne headers/body (hb).

       --state dir
              Override the directory where state is persisted.

       --test suite
              Run the select test described in the config/test.json5 test
              configuration file.

       --timeouts
              Run Ioto in debug mode and disable all timeouts. This disables
              request and session timeouts.

       --trace file[:types[:sources]]
              Name the Ioto trace file. The types are a comma separated list
              of message types. Valid types include: info, debug, error, and
              trace. Sources are the code module names originating the trace
              messages. You can use "all" for types and sources to match all
              types/sources. You can also use "!type" and "!source" to negate
              a type or source.

       --verbose
              Run with more verbose tracing. (Shortcut -v)

       --version
              Output the product version number.

FILES
       /etc/ioto
       /var/www/ioto
       /usr/local/lib/ioto

REPORTING BUGS

       Report bugs to dev@embedthis.com.

COPYRIGHT

       Copyright (c) Embedthis Software.

ioto                               June 2022                           IOTO(1)
```
```text
PASS(1)                          User Commands                         PASS(1)

NAME
       pass - Create and manage passwords

SYNOPSIS

       pass [--cipher bcrypt|sha256] [--password password] username

DESCRIPTION

       The pass program creates encrypted (hashed) authentication passwords
       for use by the Ioto embedded web server.

       These hashed passwords are typically stored in the Ioto embedded
       database.

            pass --password pass1 joshua


OPTIONS

       --cipher bcrypt|sha256
              Specifies the cipher to use to hash the password. Default is
              Bcrypt. Blowfish is substantially more secure.

       --password password
              Specifies a password to use to for the user.

DESCRIPTION

       The pass program is used to create and manage user passwords.

REPORTING BUGS

       Report bugs to dev@embedthis.com.

COPYRIGHT

       Copyright (c) Embedthis Software.

pass                               June 2024                           PASS(1)
```text
DB(1)                            User Commands                           DB(1)

NAME
       db- Ioto database command


SYNOPSIS
       db- Ioto database command

       db [options] --schema schema.json database [model] [field=value]

       Options
           --load data.json
           --reset
           --schema schema.json

DESCRIPTION

       The db utility is a database manager and query utility to interact with
       the Ioto embedded database. It can be used to query and set database
       values and reset or load seed data into the Ioto database.

       The --schema option specifies the database schema that defines the
       database entities, fields and data types. This option is required.


       The database file is specified as the first non-option argument. If no
       other arguments are provided, the data items of the database are
       printed to stdout as a series of JSON objects.

       If a model argument is provided after the database file, then only data
       items of that model type are printed.

       If a field=value argument is provided, database items that have a field
       with the specified value will be printed.

OPTIONS

       The --load option specifies a JSON file from which to load data. The
       JSON format is an object map of entities with an array of data items.

       For example:

       {
           User: [
               { name: 'Peter', role: 'user' },
               { name: 'Elisha', role: 'admin' },
           ] }

       The --reset command will reset the database and erase all existing
       items in the database.


REPORTING BUGS

       Report bugs to dev@embedthis.com.

COPYRIGHT

       Copyright (c) Embedthis Software.

db                                 June 2024                             DB(1)

```# Metrics

For device data that is synchronized to the cloud, you can create custom metrics from the data stream. These metrics can then be displayed or graphed in the Device Manager.

Ioto metrics automatically calculate statistics for the last "5 minutes", "hour", "day", "week" "month", or "year". For each timespan, you can query the average, minimum, maximum or sum value for the metric. 

## Metric Naming

Metrics are created and subsequently queried by a set of naming properties including:

* namespace 
* metric name
* dimensions

The **namespace** is a global name to group related metrics. Currently, this must be set to `Embedthis/Device`.

The **metric** name is the specific metric name. For example: a device's `temperature`.

The **dimensions** select specific instances of a metric. For example, each device may have a `temperature` metric and we may also have an overall device pool average `temperature` metric.

### Defining Metrics

In the **process** section for a model, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:
```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
            }]
        }
    },
    ...
}
```

This will create a `temperature` metric from the item's `temp` attribute.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| where | `string` | Conditional expression to select items for which to create metrics. |
| buffer | `map` | Metric buffering directives. Defaults to null|.

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.

#### Where Expressions

The `where` property can be used to select matching items (rows).

The `where` query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

will select those items which have the `error` attribute set to "critical" and the `component` attribute set to "PS1".

The query language supports the operators:
    + - * / ( ) ^ ! % == != < <= > >= ^= ^!= $= $!= << >> && || <> ><

These extension operators have the following meaning
    a ^= b     a starts with the string b
    a ^!= b    a does not start with the string b
    a $= b     a ends with the string b
    a $!= b    a does not end with the string b
    a >< b     a contains the string b
    a <> b     a does not contain the string b

Sub-expressions can be grouped with parenthesis and the boolean operators && and || can group conditional operands.

Regular expressions (delimited by slashes) may be used with the "==" and "!=" operators. The regular expression can be on either side of the operator.

The query language understands the types: Numbers, Boolean, String literals, Regular Expressions and null.

For example:

```js
{
    ModelName: {
        metrics: [
            {
                namespace: 'Embedthis/Device',
                fields: [{CPU: 'value'}],
                where: 'key == "cpu"',
            }
        ]
    }
}
```

## Displaying Metrics

The Device Manager can display metric data via graphical widgets

![Manager](/images/manager/home.png){class="screen"}

You can select from the following widget types:

* gauge
* graph
* table
* progress
* number
* leds

When creating or modifying a widget, you can select the data source to be either a database table item or a metric.

When selecting a metric, you enter the metric name, statistic and resource dimensions.

When selecting data directly from the database, you enter the database table model name, the model field (attribute) and a row selection expression.

![Manager Widget Edit](/images/manager/widget-edit.png){class="screen"}# Database Synchronization

The Ioto agent database (DB) supports optional transparent synchronization of data to and from the cloud.

Ioto takes the pain out of exporting device data into the cloud by automatically and transparently synchronizing data between your devices and a cloud device database.

Ioto will synchronize data from the device cloud database and the embedded database in your devices. This is similar to AWS Global Tables, but instead of between AWS regions, it is between an AWS region and a device.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-table basis.

The Ioto database is designed to be compatible with AWS DynamoDB so that it can easily replicate structured device data to the cloud. It is modeled after [AWS DynamoDB](https://aws.amazon.com/dynamodb/) and the [OneTable](https://doc.onetable.io/) access library.

## Database Replication Features

-   Transparent replication.
-   Bi-directional synchronization to and from the cloud.
-   Per-table synchronization control.
-   Resilient catch-up should the device or cloud go offline.
-   Database triggers for notification when changes arrive.

## Databases

The Ioto service creates a DynamoDB table called _ioto_ in each device cloud. A device cloud is created by the Embedthis Builder for your account to host your device data in an AWS account and region of your choosing. The _ioto_ database table contains the device data for all connected devices in that cloud.

The Ioto device agent creates a local database to hold structured data for the device.

These two databases are then connected and changes are replicated between device and cloud to keep them in sync.

## Why Synchronization

The Ioto Database Synchronization service dramatically eases the task of centralizing the data management of a pool of devices. Each device can store data locally and it will be transparently, efficiently and automatically replicated to the cloud. Once in the cloud, it can be easily interrogated and queried for analytics, operational control and intelligence.

Each side has fast, predictable local access to the data. Coupled with reliable replication semantics you can work locally while Ioto takes care of the replication.

## How It Works

To replicate cloud-side data, the Ioto service uses DynamoDB streams to capture modifications made to the table data. The stream is connected to an Ioto service Lambda which posts MQTT messages to a special topic that is only known to the device.

The Ioto device agent subscribes to this topic and receives MQTT messages containing the changed data. The agent then applies those changes to the local database.

In reverse, the Ioto agent registers a database trigger that is called whenever local changes are made to the device's database. When the trigger is invoked, the agent sends an MQTT message with the changes to the Ioto service that updates the cloud database.

When the device is rebooted, it sends a "sync" message to the Ioto service to retrieve all changes made to the cloud database since the last change notification was received from the cloud. In this way, changes made while the device is offline are not lost.

## Controlling Replication

Ioto can synchronize changes to the cloud on a per item basis. The schema **process** property defines how to synchronize each item type. You can "enable" a database item to be stored in the cloud, in the device or in both places. You can also control the replication direction flow of changes.

For each item type in the schema, a property under **process** specifies where the item resides and how it should be synchronized.

For example:

```c
{
    process: {
        Status:  { enable: 'cloud' },
        Fault:   { sync: 'up' },
    },
}
```

In this example: The **Status** type is only enabled (exists) in the cloud. The **Fault** type exists in both the cloud and on the device and synchronization occurs only from the device "up" to the cloud.

A type's **enable** property can be set to "cloud", "device" or "both" to define where the item can exist. The default is "both".

A type's **sync** property can be set to "up", "down", "both" or "none" to define the directional flow of replication updates. A value of "up" means replicate changes from the device "up" to the cloud. A value of "down" means replicate changes only from the cloud "down" to the device. The default is "none".

## Replication Best Practices

Synchronization of items is done on a per-item basis and not field by field. This means that a change of one field by the cloud can overwrite a change of another field on the device. For this reason, it is best to have the **sync** direction be either "up" or "down".

You should only select "both" as your **sync** direction for items that can be updated by both cloud and device at the same time without loss of data or conflict.

## Optimizations

To optimize network traffic, database changes will be sent up to the cloud in batches. These are controlled by the **database.syncDelay** and the **database.syncLimit** properties. The **syncDelay** is a delay before sending change batches to the cloud. The **syncLimit** is a size limit of the change set before sending a change batch. These are set to 5 seconds and 10K by default.

You can force a sync save at any point by calling **ioSync**.

Read more in [Database Replication](../database/replication.md).

## References

[OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).# Database Indexes

Schema indexes are defined using the **schema.indexes** property.

The **indexes** property can contain one or more indexes and must contain the **primary** key. Additional indexes will be treated as secondary Indexes.

!!!Note
    Ioto currently only supports the primary index.

```js
const MySchema = {
    indexes: {
        primary: {
            hash: 'pk',         //  Schema property name of the hash key
            sort: 'sk',         //  Schema property name of the sort key
        },
        //  Zero or more global secondary or local secondary indexes
        gs1: {
            hash: 'gs1pk',
            sort: 'gs1sk',
        }
    }
}
```
# Database Processing

The **schema.process** is a map of properties that control how data is stored in the database and how the data is processed. 

The `process` definitions define the following attributes:

* Where the database item will be stored: device / cloud / both.
* In what direction the database syncronization will flow: to-device / to-cloud / both.
* What metrics should be created from the data stream.

For each schema model, you may define an entry in the **process** collection. For example:

```js
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

Each map entry may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| enable | `string` | Control where the model is stored. Set to 'cloud' for in the cloud, 'device' for on the device and 'both' if in both locations. Defaults to 'both'. |
| sync | `string` | Define the direction of the data synchronization. Set to 'down' for down to the device, 'up' for up to the cloud, or 'both' for bi-directional. Defaults to null. |
| metrics | `Array` | Array of metric definitions. See below for details.|
| notify | `boolean` | Issue an AWS EventBridge notification event for matching data. Defaults to false.|

## Database Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-model basis.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

>To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for models that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Metrics

For data that is synchronized to the cloud, you can create custom metrics from the data stream. These metrics can then be displayed or graphed in the Device Manager.

In the **process** section for a model, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:
```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
            }]
        }
    },
    ...
}
```

This will create a `temperature` metric from the item's `temp` attribute.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| where | `string` | Conditional expression to select items for which to create metrics. |
| buffer | `map` | Metric buffering directives. Defaults to null|.

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.

#### Where Expressions

The `where` property can be used to select matching items for which to create metrics. `Where` expressions use a query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

See [Database Metrics](/agent/metrics/) for details.

## Event Notification

For dedicated device clouds, you can issue AWS EventBridge events for matching database items via the **notify** property. 

The `notify` property is set to the EventBridge bus name. It can be set to "default" or any custom EventBridge bus name.

The database item will be passed to the EventBridge bus as the event context data.

For example:

```js
{
    Store: {
        enable: 'both',
        sync: 'up',
        notify: 'default',
    }
}
```
The following attribute properties are supported:

| Property | Type | Description |
| -------- | :--: | ----------- |
| default | `string` | Default value to use when creating items or when reading items without a value.|
| generate | `string|boolean` | Set to 'ulid' or 'uuid' to automatically create a new ID value for the attribute when creating new items.|
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. If unset, the field will use the table default value for isoDates. Default to the schema params value. |
| nulls | `boolean` | Set to true to store null values or false to remove attributes set to null. Default false. |
| required | `boolean` | Set to true if the attribute is required. |
| schema | `object` | Nested schema. |
| type | `Type or string` | Field data type. |
| value | `string` | Template to derive the value of the attribute. These attributes are "hidden" by default. |


If the **default** property defines the default value for an attribute. If no value is provided for the attribute when creating a new item, the **default** value will be used.

If the **isoDates** property is defined and not-null, it will override the table isoDates value. Set to true to store the field date value as an ISO date string. Set to false to store the date as a Unix epoch date number.

The **schema** property permits nested field definitions. The parent property must be an Object as the type of items in arrays are defined using the **items** property.

The **type** properties defines the attribute data type. Valid types include: String, Number, Boolean, Date, Object, Null, Array, Buffer (or Binary) and Set. The object type is mapped to a **map**, the array type is mapped to a **list**. Dates are stored as Unix numeric epoch date stamps unless the **isoDates** parameter is true, in which case the dates are store as ISO date strings. Binary data is supplied via **buffer** types and is stored as base64 strings in DynamoDB.

The **value** property defines a literal string template that is used to compute the attribute value. This is useful for computing key values from other properties, creating compound (composite) sort keys or for packing fields into a single DynamoDB attribute when using GSIs.

String templates are similar to JavaScript string templates. The template string may contain **${name}** references to other fields defined in the item. If any of the variable references are undefined when an API is called, the computed field value will be undefined and the attribute will be omitted from the operation.

If you call **find** or any query API and do not provide all the properties needed to resolve the complete value template. i.e. some of the ${var} references are unresolved, OneTable will take the resolved leading portion and create a **begins with** key condition for that portion of the value template.
# Database Schemas

Ioto database schemas define how items will be stored in the database and in the cloud. A schema specifies the application models (entities), entity fields, indexes and other data access and replication parameters.

Schemas look like this:

```js
const DeviceSchema = {
    format: 'onetable:1.1.0',
    version: '0.0.1',
    indexes: {
        primary: { hash: 'pk', sort: 'sk' },
    },
    process: {
        /*
            Where the model is enabled (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status:  { enable: 'cloud' },
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        },
    },    
    models: {
        Status: {
            pk:             { type: 'string', value: 'status#' },
            sk:             { type: 'string', value: 'status#' },
            parameters:     { type: 'object' },
            version:        { type: 'string' },
            updated:        { type: 'date' },
        },
        Fault: {
            pk:             { type: 'string', value: 'device#${deviceId}' },
            sk:             { type: 'string', value: 'fault#${id}' },
            deviceId:       { type: 'string', required: true },
            id:             { type: 'string', generate: 'ulid' },
            timestamp:      { type: 'date', required: true },
            source:         { type: 'string', required: true },
            severity:       { type: 'string', required: true, enum: ['info', 'warn', 'error', 'critical', 'fatal'] },
            subject:        { type: 'string', required: true },
            message:        { type: 'string', required: true },
            expires:        { type: 'date', ttl: true },
        },

    },
    params: {
        'isoDates': true,
        'timestamps': true,
    },
}
```


## Schema Properties

The valid properties of the **schema** object are:

| Property | Type | Description |
| -------- | :--: | ----------- |
| format | `string` | Reserved. Must be set to 'onetable:1.1.0' |
| indexes | `object` | Hash of indexes used by the table. |
| models | `object` | Hash of model entities describing the model keys, indexes and attributes. |
| params | `object` | Hash of properties controlling how data is stored in the table. |
| process | `object` | Hash of model entities describing where the model should be stored and how it should be processed. |
| version | `string` | A SemVer compatible version string. |

The **format** property specifies the schema format version and must be set to **onetable:1.1.0**.

The **indexes** property specifies the key structure for the primary, local and secondary indexes.

The **models** property contains one or more models with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties.

The **params** property defines additional parameters for table data formats.

The **process** map defines how database model data should be processed, stored, replicated and whether metrics should be calculated from the data stream.

The **version** property defines a version for your DynamoDB model design. It must be a [SemVer](https://semver.org/) compatible version string. The version string is used by tools and consumers of the schema to understand compatibility constraints for the schema and stored data.


## Schema Models

The schema defines a model for each application entity. For example, consider a music example:

```js
{
    album: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        songs:  { type: 'number' },
    },
    artist: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        address: {
            type: Object, schema: {
                street: { type: 'string' },
                city: { type: 'string' },
                zip: { type: 'string' },
            },
        },
    }
}
```

For each model, all the entity fields are defined by specifying the field type, validations and other operational characteristics (uniqueness, IDs and templates).

The valid types are: 'array', 'binary', 'boolean', 'date', 'number', 'object', and 'string'.

Ioto will ensure that values are of the correct type before they are written to the database. Where possible, values will be cast to their correct types. For example: 'false' will be cast to false for Boolean types and 1000 will be cast to '1000' for String types.

The database will automatically add a model type via the **_type** attribute to each model. This is set to the name of the model. You can modify this via the **params.typeField** setting.


## Value Templates

The value of a field can be computed based on the value of other fields and a formatting "value template". This is useful for decoupling your key structure from your entity fields.

The value template is like a Javascript string literal where the value of fields are expressed in a "${field}" format. At runtime, the field references are expanded with the item's value for the named field.

In the example above, the primary key "pk" is calculated from the entity type **_type** and the **name** field by using the value template: **${_type}:${name}**.

## Expiring Items

Items can be automatically removed by defining a date field that specifies when the item should be removed. To do this, define a date field and set the **ttl: true** schema attribute. This supports the AWS DynamoDB TTL feature.

Database items are removed when the database service routine is run. This is run each hour by default. Additionally, expired items are removed transparently if a retrieval is attempted.

## Nested Schemas

For object attributes, you can define a nested schema for the object properties, as in the example above (repeated below).

A nested schema uses the **schema** property to define a nested map of attributes. Schemas can be nested to an arbitrary depth.

```js
address: {
    type: Object, schema: {
        street: { type: 'string' },
        city: { type: 'string' },
        zip: { type: 'string' }
    }
}
```


## Indexes

DB uses red-black balanced binary trees for indexes to provided ordered, rapid indexing of data. Currently, the database only supports a single primary index, but in the future, multiple indexes will be supported.


## References

[OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).
# Database Schema Parameters

The **schema.params** is a map of properties that control how data is stored in the database. It may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| createdField | `string` | Name of the "created" timestamp attribute. Defaults to "created". |
| hidden | `boolean` | Hide templated (value) attributes in Javascript properties. Default true. |
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. Default false. |
| nulls | `boolean` | Store nulls in database attributes vs remove attributes set to null. Default false. |
| timestamps | `boolean | string` | Make "created" and "updated" timestamps in items. Set to true to create both. Set to 'create' for only "created" timestamp and set to "update" for only an "updated" timestamp. See also: "updatedField" and "createdField" properties. Default false. |
| typeField | `string` | Name of the "type" attribute. Default "_type". |
| updatedField | `string` | Name of the "updated" timestamp attribute. Default "updated". |

For example:

```js
const MySchema = {
    params: {
        isoDates: true,
        timestamps: true,
    }
}
```
# Database Persistency

The Ioto database operates in-memory with a lazy save to persistent storage.

When changes are made to database items, a save to storage will be performed after a configurable delay as specified in the **database.saveDelay** property in the **ioto.json5** file. This is set to 1 second by default.

You can force a database save at any time via the *dbSave* API:

```c
dbSave(db, NULL);
```

This will persist data changes to the database file specified via *dbOpen*. You can supply a filename as the second argument to save to a different (backup) database file.
# Database Overview

The Ioto agent database (DB) is an ultra high performance NoSQL database for embedded applications. It supports fast, in-memory, local data access and optional transparent synchronization of data to and from the cloud. It is modeled after [AWS DynamoDB](https://aws.amazon.com/dynamodb/) and the [OneTable](https://doc.onetable.io/) access library.

The Ioto database stores items as JSON documents of arbitrary complexity. Data items are organized into entity tables via an entity schema that specifies data fields, types, attributes and validations.

The database uses Red/black binary search indexes and has controllable local persistency to disk and to the cloud on a per-table basis.

## Database Features

* High performance NoSQL management document database.
* JSON document items with flexible query API.
* Efficient import and export of database items.
* Red/black binary search indexes.
* Simple, non-waiting API.
* Controllable persistency with change triggers.
* Transparent bi-directional data synchronization with the cloud.
* Custom metrics extracted from synchronized data.
* Unified data schema between device and cloud databases.
* Based on AWS DynamoDB and DynamoDB OneTable.


### Default Database

The Ioto agent will open a default database for general purpose use. This database is loaded from the file "state.db" using the schema file "schema.json5". The filename and schema file can be modified via the **ioto.json5** properties under the **database** key. Most users would typically use this database and would not need to open another database instance.

The database instance reference is stored in the global **ioto** object in the **db** property.

```c
ioto->db
```

## JSON documents

The database stores items as JSON documents that are a nested collection of properties to arbitrary depth. As JSON is one of the most prevalent data exchange formats, storing data in JSON greatly reduces exchange costs.

Ioto includes a powerful JSON query engine that you can use to query and manipulate JSON documents.

## Data Types

All data types are stored internally as strings to optimize data transfer. Return values from database APIs typically return static strings that you do not need to free (const char*). To convert numbers, use the safe runtime conversion routines: stoi() and stoiradix().


## API Quick Tour

If you do choose to open another database rather than use the default database, use *dbOpen*:

```c
Db *db = dbOpen("./data.db", "./schema.json5", 0);
```

The dbOpen API will open the named database and schema.  Data is loaded from the database file and stored in-memory. The schema file describes the application entities, data fields and indexes. Read more about [Schemas](./schemas/).


### Creating an Item

Use *dbCreate* to create an item:

```c
CDbItem *item = dbCreate(ioto->db, "Fault", DB_PROPS(
    "timestamp", rGetTime(),
    "source", "bluetooth",
    "severity", "warn",
    "subject", "Failed to sync",
), NULL);
```

This creates an item in the database and returns a reference to the item. The item properties are provided using the DB_PROPS macro with key/value pairs for each property.

Database items are documents that store item properties in JSON format using JSON types (Objects, arrays, strings, numbers, booleans and dates). Properties can be nested to arbitrary depth.

You can also specify the item properties using the DB_JSON macro. This is useful when you have nested item properties:

```c
item = dbCreate(db, "User",
    DB_JSON("{name: 'user', details: {role: '%s'}}", role), NULL);
```

### Retrieving Fields

To retrieve a field from an item, use *dbGetField*:

```c
const char *id = dbGetField(item, "id");
```

This will retrieve a reference to the the "id" field from the previously read item.

You can also read nested properties from within the item's JSON document.

```c
cchar *errors = dbGetField(item, "interfaces.bluetooth.if1.errors");
```

### Reading Items

To read an item from the database, supply the required item key and call *dbGet*. The key can be the actual item key or it can be a set of fields that are used by the schema to create the key. See [Value Templates](./schemas/#value-templates) for details.

```c
CDbItem *item = dbGet(db, "Fault", DB_PROPS("id", id), NULL);
```

When debugging, you can use the utility routine *dbPrintItem* to print the contents of an item:

```c
dbPrintItem(item);
```

### Finding Items

To retrieve a set of matching items, use *dbFind*:

```c
DbGrid *items = dbFind(db, "Fault", DB_PROPS("severity", "critcal"), 0);
```

You can provide one or more properties to be used as a filter. Items will be returned that match all supplied properties.

When finished with the items, you must free the returned grid via dbFreeGrid.

```c
dbFreeGrid(items);
```

To iterate over the item list, use *ITERATE_ITEMS*:

```c
DbItem *item;
int    n;
for (ITERATE_ITEMS(items, item, n)) {
    dbPrintItem(item);
}
```

You can also use DB_JSON instead of DB_PROPS to provide query parameters as json:

```c
items = dbFind(db, "FAULT", DB_JSON("{severity:'%s'}", severity), 0);
```

The JSON can be provided as [JSON/5](../user/) which allows single quotes around string values.

### Getting and Setting Fields

To get a single field from an item, use *dbGet*:

```c
cchar *severity = dbGet(db, "Fault", "severity", DB_PROPS("id", id), NULL);
```

To set a single field in an item, use *dbSet*:

```c
DbItem *item = dbSetField(db, "Fault", "severity", "info", DB_PROPS("id", id), NULL);
```

You can also use the type specific set routines: dbSetBool, dbSetDate, dbSetDouble and dbSetNum.

### Updating Items

To update multiple fields in an item, use *dbUpdate*:

```c
item = dbUpdate(db, "Fault", DB_PROPS("id", id, "severity", "info", "subject": "Fault resolved"), NULL);
```

### Removing Items

To remove an item, use *dbRemove*:

```c
dbRemove(db, "Fault", DB_PROPS("id", id), NULL);
```

### Pagination

When retrieving items from a large data set, you may need to paginate your results.

You can specify a limit to the number of returned results via the `limit` param. The dbFind routine can take a **next** parameter that specifies where to begin returning results. The `next` parameter is actually the key of the last returned item and the search begins "after" that point.

```c
cchar *next = NULL;
do {
    DbGrid *grid = dbFind(db, NULL, NULL, DB_PARAMS(.next = next, .limit = 20));
    next = dbNext(grid);
    dbFreeGrid(grid);
} while (next);

```

### Cloud Replication

You can transparently replicate device data to the cloud using Ioto cloud synchronization. Data can be synchronized in either direction: from the cloud to the device, or from the device to the cloud.

Replication is controllable on a per-item basis via the database schema. The schema **process** property defines how to process and synchronize each database item type. The schema names database items as "models". You can "enable" an model to be stored in the cloud, in the device or in both places. You can also control the replication direction flow of changes to be "up" to the cloud, or "down" to the device.

For each item type in the schema, a property under the **process** collection specifies where the items reside and how they should be synchronized. 

```c
{
    process: {
        Status:  { enable: 'cloud' },
        Fault:   { sync: 'up' },
    },  
}
```

This enables the Status items to be stored only in the cloud whereas Fault items will be stored on the device and in the cloud and will be synchronized up from the device to the cloud.

### Custom Metrics

For items that are synchronized to the cloud, you can configure custom metrics to be created from the data stream. These metrics can then be displayed or graphed in the device manager.

Metrics are specified via the **process** property. For example:

```json5
{
    process:
        Item: {
            enable: 'both',
            sync: 'up',
            metrics: [ {
                namespace: 'Embedthis/Device',
                fields: [{CPU: 'value'}],
                where: 'key == "cpu"',
                dimensions: [{Device: 'deviceId'}],
                buffer: {count: 5, elapsed: 10}
            } ]
        }
    }
}
```

This will create a **CPU** metric from the `value` item attribute. The `where` clause selects the appropriate matching rows. The metric is created in the `Embedthis/Device` namespace and is dimensioned by the device ID. The metrics are buffered and aggregated for up to 10 seconds or a maximum of 5 data points.

### Configuration

You can configure the Ioto database via the **ioto.json5** **database** property collection.

See [Database Configuration](../user/properties.md#database) for details.

```js
database: {
    path: 'db/state.db',
    schema: 'db/schema.json5',
    maxJournalSize: '1mb',
    maxJournalAge: '5mins',
    maxSyncSize: '10k',
},
```

### Debugging

Ioto provides a few routines that help with debugging DB API usage.

* dbPrint
* dbPrintItem
* dbPrintProperties
* jsonToString


## API Reference

The full API is specified here:

[DB API](/agent/ref/api/db.md)
# Ioto Licensing

The Ioto agent is licensed via a commercial license that provides you with the following benefits:

* The right to embed the Ioto agent software in your products.
* The right to develop and modify the software in your products.
* The ability to redistribute your products with the Ioto agent software.
* The ability to connect to the Ioto cloud service.
* The ability to keep your source code private.
* Apply security updates and upgrades.
* Receive priority support service plans.

You may use Ioto provided you fully comply with the governing terms.

* [EmbedThis License Terms](https://www.embedthis.com/about/terms.html)

Please contact us at: [licensing@embedthis.com](mailto:licensing@embedthis.com) if you have any licensing questions.
# Ioto Agent Reference Guide

This guide describes the Ioto agent programming APIs.

Before reading the APIs, you may wish to review some architectural overviews that explain the programming paradigms used by Ioto.

## Architectural Overviews

* [Ioto Background](../user/background.md)
* [Memory Allocation](../dev/memory.md)
* [Fiber Coroutine Programming](../dev/fiber.md)

## Programming APIs

The Ioto agent native APIs consist of C language headers, function prototypes, structure definitions and defines. They are divided into one of these areas.

| Area | Description |
|-|-|
| [Ioto](api/ioto.md) | Agent API |
| [Web Server](api/web.md) | Embedded Web Server |
| [DB](api/db.md) | Embedded Database |
| [MQTT](api/mqtt.md) | MQTT protocol client |
| [URL](api/url.md) | Http Client |
| [JSON](api/json.md) | JSON parser and query engine |
| [Crypt](api/crypt.md) | Crypto APIs |
| [R](api/r.md) | Portable Runtime |
| [OSDEP](api/osdep.md) | O/S Portability Layer |

## Stability Classifications

In addition to supporting <a href="https://semver.org/">SemVer</a> for Ioto version policy, we provide stability classifications.

APIs stability classifications document the likelihood of future change on a per-API basis. Rather than a general, meaningless backwards compatibility promise, these [Stability Classifications](stability.md) assist developers to understand the future risk of change.
# API Stability Classification

The programming interfaces and data structures are classified with a stability class. These classifications help developers understand which interfaces may change in future releases and may need to be wrapped within their applications.

When the classification is applied to an API, it applies to the complete function signature. When applied to a data structure or typedef, it applies to the structure name and not the internal structure fields. All structure fields are regarded as internal unless explicitly stated otherwise.

The version numbering for EmbedThis products follows the [SemVer](https://semver.org/) scheme. For example 2.1.3 is major version 2, minor version 1 and patch version 3.

| Classification | Description |
|-|-|
| Mature | Must be interoperable across at least two consecutive major releases so that applications are not required to change. These APIs must be deprecated before change or removal. |
| Stable | Will not change between minor releases (e.g. 2.0 to 2.1). May change between major releases. |
| Evolving | May change between major or minor releases. May not change between patch releases (e.g. 2.0.0 to 2.0.1) release. |
| Prototype | May change between any major, minor or patch releases. |
| Deprecated | For use by legacy applications only. Customers are advised that these interfaces may be removed in the next major or minor release. |
| Internal | Internal API or data structure and may change at any time. Customers are strongly advised not to use these APIs. Please notify EmbedThis if you feel compelled to use an internal API and we'll consider providing a better public interface that can be supported. |
# Compatibility

Ioto APIs are evolving, and are thus subject to change between minor releases.

The Ioto documentation provides a [Stability Classification](stability.md) for each API group that reflects their stability with respect to forward changes.

<!--
<a id="r5"></a>
<h2>Migrating from Earlier Releases</h2>
<p>Ioto 4 to 7 are highly compatible. Code written for Ioto 4 to 6 should migrate easily to Ioto 7.
Ioto 4 introduced new build tools, and a garbage collector for memory allocation, so if you are migrating from Ioto 2 or 3, you will have to perform more significant changes to your application, handlers or filters. </p>
-->

## Migrating to from Appweb or GoAhead

The Ioto web server configuration and APIs are simpler and different to those in Appweb or GoAhead. Porting from Appweb or GoAhead is feasible, but not trivial.

### Web Server Action Routines

The Ioto web server action routines are very similar to those in GoAhead and Appweb. So action code written for GoAhead and Appweb and should map easily to Ioto. However, some of the web server utility routines to read and write data are different.

The Ioto portable runtime (R) was adapted from GoAhead 5 and Appweb 8 and so the string, list, hashing and buffering APIs are very similar.

## Standards

Ioto supports the following standards web standards:

* [HTTP/1.1](http://www.w3.org/Protocols/rfc2616/rfc2616.html)
* [File Upload](http://www.ietf.org/rfc/rfc1867.txt)
# Ioto Manual Pages

This Ioto distribution provides manual pages that can be viewed (on Unix-like systems) using the systems **man** command. Text copies of the pages are included below:

| Topic | Description |
|-|-|
| [ioto](../man/ioto.md) | Ioto device agent. |
| [db](../man/db.md) | Database command line tool. |
| [json](../man/json.md) | JSON tool. |
| [url](../man/url.md) | URL HTTP client command line tool. |
| [pass](../man/pass.md) | Password manager. |
# Authentication

Authentication is the process by which a client's identity and capabilities are verified before granting access to server resources. Authentication is essential when you have content that you wish to protect and provide only to specific, approved clients.

The Ioto web server implements a powerful and flexible authentication framework that verifies username and password and controls client capabilities using a role based authorization mechanism.


## Overview

Web authentication has historically used [Basic or Digest](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication) authentication. However these two methods have security and usability flaws and should not be used.

A preferred method is to use a web form to capture the username and password and then transmit them securely using an encrypted TLS connection where the credentials are validated by the web server.

## Access Roles

Once authenticated, users are authorized with a role that defines their capabilities.

In Ioto, access roles are an ordered list of user roles with increasing capabilities. Typical roles are: "user", "admin" or "support".

Authentication roles for the Ioto web server are defined in the **web.json5** configuration file via the **auth.roles** property.

Here is a sample:

```js
{
    auth: {
        roles: ["user", "admin"],
        login: '/api/public/login',
        logout: '/api/public/logout',
    }
}
```

The Ioto web server controls access to resources by assigning a specific "role" on a route that provides access to a document or resource. If the authenticated user has the required role or better, then the user is granted access.

For example:

```js
web: {
    routes: [
        {match: '/api/admin/', role: 'admin'},
        {match: '/api/user/', role: 'user'},
        {match: '/api/'},
        {match: '/admin/', role: 'admin'},
        {match: '/user/', role: 'user'},
        {},
    ],
}
```

Each route specifies a matching URL prefix except for the last route which is a catchall. To restrict access, the route provides a "**role**" property that specifies the required user role to permit access.

## Users and Passwords

Users are defined in the Ioto database together with their hashed and salted passwords and access role. 

User entries are typically created by the device management or admin apps using the cryptMakePassword API. 

However, during development, users may be created in the database via the [dbcmd](../man/db.md) and [pass](../man/pass.md) programs.

To generate a hashed password for a user, use the **pass** program. For example:

```bash
pass --password demo-pass ralph
```

This will print the hashed password for "ralph". 

You can modify the **config/seed.json5** file with the required users and hashed passwords. Then apply this file to the
database using the "reset" make target.

    $ make reset

This will run the command:

    $ dbcmd --reset --load config/seed.json5 --schema modes/$(MODE)/schema.json5 state/state.db


## Verifying Passwords

Authentication schemes define how the user credentials are captured from the user and supplied to Ioto. 
There are two classes of authentication schemes.

* <a href="#form">Web Form Authentication</a>
* <a href="#app">Custom Authentication</a>

<a id="form"></a>

## Form Authentication

The form authentication scheme uses a HTML web form for the user to enter their username and password credentials and a HTTP Post request to submit credentials to the server for verification. Ioto manages the login/logout process and if authentication succeeds, a login session is created and a cookie is returned to the client's browser. Subsequent requests that include the cookie will be automatically authenticated using the session.

### Web Form

Here is a sample minimal example login page:

```html
<html><head><title>login.html</title></head>
<body>
    <p>Please log in</p>
    <form name="details" method="post" action="/api/public/login">
        Username <input type="text" name="username"><br/>
        Password <input type="password" name="password"><br/>
        <input type="submit" name="submit" value="OK">
    </form>
</body>
</html>
```

After the user enters their username and password and clicks OK, the form is posted and the **/api/public/login** URL is requested. This URL should be bound to an Action via **webAddAction** that will verify the password and then call **webLogin**.

You can use the inbuilt **webLoginUser** routine to validate the password against the value stored in the database by
setting the **auth.login** property in the **web.json5** config file.

For example:

```js
    auth: {
        login: '/api/public/login',
        logout: '/api/public/logout',
    },
```

If you require custom user authentication, you can define your own login action and leave the **auth.login** property 
unset. For example:

```c
static int login(Web *web)
{
    cchar *password, *username;

    username = webGetVar(web, "username", 0);
    password = webGetVar(web, "password", 0);

    // Your own custom password checking routine
    if (CheckPassword(username, password)) {
        webLogin(web, username, password);
        webRedirect(web, 302, "/welcome.html");
    } else {
        webRedirect(web, 401, "/login-failed.html");
    }
    return 0;
}
webAddAction(host, "/auth/login", login);
```

The login function will retrieve the username and password entered by the user from the form post data and then 
validate these in the custom CheckPassword function.

**SECURITY CAUTION:** The login request should only be performed over a secure TLS encrypted connection and never over plain "HTTP".

### Route Configuration

To implement the form based authentication, you should ensure the login and log out pages and all required graphics and stylesheets are accessible without authentication.

A typical set of routes for an authenticated web site is:

```js
web: {
    routes: [
        {match: '/api/admin/', role: 'admin'},
        {match: '/api/user/', role: 'user'},
        {match: '/api/'},
        {match: '/admin/', role: 'admin'},
        {match: '/user/', role: 'user'},
        {},
    ],
}
```

Authenticated users can access documents under the **/user** section. Administrators have access to the **/admin** section.  All other documents outside **/user** and **/admin** are public, such as the home page (/index.html), other HTML pages, stylesheets, javascript and images. These can be accessed without authentication. 

The **/api/admin** section is accessible only to administrators and the **/api/user** is accessible to all authenticated users. All other actions under **/api** including the login and logout actions do not require authentication to access.

The **{}** route is used to match all other URLs and does not require authentication.

### Route Table

|URL|Description|Required Role|
|:-|:-|:-|
/index.html | Home page | none
/css/ | Stylesheets | none
/js/ | JavaScripts | none
/images/ | Images | none
/api/admin | Actions requiring an administrator user | user
/api/user | Actions requiring an authenticated user | user
/api | Public actions including Login and logout | none
/admin | Documents visible only to administrative users | admin
/user | Documents visible to authenticated users | user

## Custom Authentication

You can easily create a custom or hybrid authentication scheme. You can choose to pass the username and password to the login action via other means such as an "Authorization" HTTP header or JSON payload. You would then adjust your login() function accordingly.

<a name="api"></a>

## Authentication APIs

See the the following API to manage authentication and authorization under program control.

* [webLogin](../ref/api/web.html#web_8h_1a6d153144eddd26485b974529adf88455)
* [webLogout](../ref/api/web.html#web_8h_1a85313a553af93814d35f794ac9eace84)

## Samples

Ioto provides a sample for user login:

* [Auth Sample](https://github.com/embedthis/ioto-doc/tree/master/samples/web-auth)
# Request Routing

Ioto includes a flexible request routing engine that routes client HTTP requests to appropriate request handlers. An Ioto configuration will typically have several routes. When a request is received, Ioto tests routes in sequence and selects the first matching route to handle the request.

<a id="configuration"></a>

## Route Configuration

Routes are defined in the **web.json5** configuration file.

```js
routes: [
    { match: '/public/' },
    { match: '/auth/' }
    { match: '/members/', role: 'user' }
    { match: '/admin/', role: 'admin' },
    { redirect: '/auth/login' },
],
```

This example defines five routes. Routes can specify a **match** property that defines a matching URL prefix for the route to be used.

## Route Ordering

When multiple routes are defined, a client request will test each route in the order in which they are declared in the routes array.

To process a request, Ioto compares the request URL with the route **match** property prefix. If the URL begins with the **match** property, the route is selected. So ordering is very important.

## Route Matching

A route that terminates with "/" will match any URL that begins with that pattern. If the route does not end with "/" it must match the entire URL path (without query or reference fragment).

The special route match pattern "/" will match only the URL "/". i.e. the site home page.

If the route does not contain a match pattern, all URLs will match. In this case, the route becomes a "catch-all".

Routes with longer or more qualified route **match** properties should be defined first before more general routes.

## Route Authorization

If the selected route contains an authorization **role** property, the user must be logged in and possess the required role specified by the **role** property.

If the user is not logged in, or if the user does not have the requisite ability, the request will not proceed.

In that case, if the route contains a **redirect** property, the request will receive a redirect 302 response toward the URL specified by the **redirect** property. If there is no such property, the request will receive a 401 Not Authorized response.


## Route Patterns

A common pattern for web management applications is to require user authentication for all operations. Such web apps may have two levels of authorization, registered users and administrators.

To support such two-level access control, consider the following route list:

```js
routes: [
    {match: '/api/admin/', role: 'admin'},
    {match: '/api/user/', role: 'user'},
    {match: '/api/'},
    {match: '/admin/', role: 'admin'},
    {match: '/user/', role: 'user'},
    {},
],
```

The following directory and URL structure could then be employed.

* /index.html &mdash; public home page
* /css &mdash; public stylesheets
* /js &mdash; public javascript
* /images &mdash; public images
* /login.html &mdash; login form
* /user &mdash; documents accessible by all authenticated users
* /admin &mdash; documents accessible by administrators only
* /api/admin &mdash; for action routines accessible by administrators
* /api/user &mdash; for action routines accessible by authenticated users
* /api &mdash; public action routines including login and logout actions

The {} route is used to match all other URLs and does not require authentication.
# Dynamic Web Content

The Ioto embedded web server can serve static files and can also render dynamically generated responses.

Dynamic content is generated via the Action handler that binds specific URLs to corresponding C functions. The action handler is ideal for situations when you want to generate a dynamic response using C code.

Previously, earlier web servers used the [CGI](https://www.embedthis.com/blog/stories/stop-using-cgi/stop-using-cgi.html) and web frameworks like [PHP](https://www.php.net/) or [ESP](https://www.embedthis.com/esp/) to generate dynamic content. But these solutions are a poor fit for modern management applications that use [SPA](https://en.wikipedia.org/wiki/Single-page_application) techniques. They also consume considerable CPU and memory resources and are not the best approach for embedded devices. Further, they expose large attack surfaces due to excess features that are not essential.

Ioto uses a more efficient direct binding from URLs to C functions coupled with a flexible streaming, non-blocking API. When coupled with a JSON parser and query engine, a dramatically simpler and more efficient solution emerges.

## Registering Actions

Action routines are registered by calling [webAddAction](/agent/ref/api/web.md#group___web_1gaad50b8cbf88372dc6cdd7d08050b8de4). This API takes a function to run and a corresponding URI prefix.

```C
static void hello(Web *web)
{
    webWrite(web, "Hello World\n", -1);

    //  Signal end of output
    webWrite(web, NULL, 0);
}

//  Register the action
webAddAction(host, "/action/hello", hello);
```

The **webAddAction** call registers the hello C function to be invoked whenever the request URL begins with the string "/action/hello". By using a string prefix, you can have a single action match an entire set of URLs that being with a given URL prefix.

An action routine is responsible for rendering a complete response to the client. If your action routine needs to wait for I/O or block while reading required data from another service, read [Blocking](#blocking) below.

## Streaming Data

Ioto supports full-duplex streaming.

Clients can stream body data to the web server and the server can stream response data back to the client. Ioto supports full-duplex streaming via non-blocking, fiber enabled APIs.

The **webRead** routine is used to read body data from the client. The webRead call has the following signature:

    ssize webRead(Web *web, char *buf, ssize bufsize);

The webRead function will read data from the client and return the number of bytes read. The routine will block if required until data is available. Other fibers continue to run while blocked. The function returns zero when the end of the body data is received.

The **webWrite** routine is used to write data back to the client. The webWrite call uses the following signature:

    ssize webWrite (Web *web, cvoid *buf, ssize bufsize)

The **bufsize** argument is set to the length of data to write. It can be set to -1 if the data to write is a null terminated string and the length of the string will be determined by strlen.

The **web** parameter is passed to the action routine as its only argument.

A response to the client is concluded by calling [WebWrite](/agent/ref/api/web.md#group___web_1ga9bb3b0c8b44804e8cc329ca946c39aaa) with a NULL buffer or data length of zero. This signifies the end of the response.

Ioto uses [Transfer-Encoding](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding) by default for dynamically written data, so you don't need to define a response [Content-Length](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding). Each write will be wrapped in a transfer chunk.

## Web Forms

Web forms requests are a special case. They use POST requests with url encoded body data. Ioto will read and buffer form data and parse into form variables before invoking the appropriate Action routine. The action can then retrieve via the **webGetVar** API.

## Writing Headers

Ioto will automatically write the HTTP response headers when you first call **webWrite** in your action routine. However, you can call [webWriteHeaders](/agent/ref/api/web.md#group___web_1ga24c1f17628b8b1c854a378e0b47bcb89) to customize the HTTP headers. For example:

```c
static void hello(Web *web)
{
    cchar   *msg;

    msg = "Hello World\n";

    webWriteHeaders(web, "Content-Length: %d\r\n", slen(msg));

    webWrite(web, msg, -1);
    webWrite(web, NULL, 0);
}
```

The **webWriteHeaders** routine accepts one or more headers, each of which is terminated by "\r\n". It is essential that you use "\r\n" and not just a single new line character after each header.

Ioto will blend your supplied headers with other essential headers such as Date, Connection, Content-Length, Content-Type and Transfer-Encoding.

You can only issue one call to **webWriteHeaders, subsequent calls for a given request will be ignored.

## Status Code

HTTP responses always contain a [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status). This is set to 200 for successful requests, 301/302 for redirections, 4XX for client errors, etc.

By default, Ioto responds with a 200 successful HTTP status. You can set the status code via the [webSetStatus](/agent/ref/api/web.md#group___web_1ga12ab5a43c00f2a54c787d653af51430a) or
via **webWriteResponse**.

```c
static void failure(Web *web)
{
    cchar   *msg;

    webSetStatus(web, 404);
    webWrite(web, "Cannot find requested resource\n", -1);
    webWrite(web, NULL, 0);
}
```

## Reading Body Data

Ioto supports streaming request data via the [webRead](/agent/ref/api/web.md#group___web_1gab6843af41aa5abdaec4062d4a5f46a8b) API. For example:

```c
static void readStream(Web *web)
{
    char  buf[ME_BUFSIZE];
    ssize nbytes;

    while ((nbytes = webRead(web, buf, sizeof(buf))) > 0) {
        printf("Got %ld bytes\n", nbyte);
        //  Process buffer here
    }
    return webWriteResponse(web, 200, "Request processed");
}
```

The **webRead** routine will read body data and return the number of bytes read. It will return 0 when all the body data has been read. This routine supports requests with an explicit known Content-Length and those requests with indeterminate body lengths that use transfer encoding.

The **webRead** routine will block the current fiber if necessary to wait for more body data. Other fibers continue to run.

## Blocking

Because Ioto uses fiber coroutines, you can wait for I/O inside an action routine provided you are using the fiber-safe blocking routines provided by Ioto. Don't call Posix "sleep" as that can block the entire Ioto process.

If you need to wait for data from an external API or service, you have two options:

1. Create a thread to wait for the data and then call [rYieldFiber](/agent/ref/api/r.md#r_8h_1a531c892493b60bb2088705d7f4e447cb) in your action routine. When the thread has the required data, call [rResumefiber](/agent/ref/api/r.md#r_8h_1a059333256cfab39b5037149625e1133b) from the thread to resume the fiber.

2. Use the [Ioto R Portable Runtime](../runtime/) non-blocking socket I/O routines such as [rReadSocket](/agent/ref/api/r.md#r_8h_1a5e68016e4b9381eb07d94855361e4a6d) and [rWriteSocket](/agent/ref/api/r.md#r_8h_1a59d42a597c69a42387f41d62f0e8c5b2).

Note: that the Ioto request and inactivity timeouts in ioto.conf may terminate a long running request. If you need to extend these timeouts for a request, call
<a href="/doc/agent/ref/api/web.html#group___web_1gaa1b625ec1407586d184636914f284dfe">webExtendTimeout</a>.
# Configuring TLS

Ioto supports the TLS / SSL protocol for authenticating systems and encrypting data. Use of this protocol enables secure data transmission to and from clients in a standards-based manner.

This document provides step-by-step instructions for configuring TLS in the Ioto web server. If you are unfamiliar with TLS, please read the **[TLS Overview](./tlsOverview.md)** first.

## TLS Quick Start

The default source build of Ioto will support TLS for use by the Ioto web server. You can immediately test TLS access to documents by using the <b>https://</b> scheme. For example, to access the home page using TLS, use this URL in your browser:

    https://localhost/

<a name="tlsProviders"></a>
## TLS Providers

Ioto employs an open architecture TLS Provider interface so that customers can select or create an TLS provider for their needs.

Ioto provides multiple TLS implementations:

* OpenSSL -- default TLS. See <a href="http://www.openssl.org">http://www.openssl.org</a>.
* MbedTLS -- compact TLS (smaller but slower).

The default source build will use the OpenSSL provider by default. See the README.md file for details about how to build with MbedTLS.

<a id="sslConfigurationDirectives"></a>
## SSL Configuration Directives

Ioto uses several configuration [TLS properties](./properties.md#tls) to control TLS and manage secure access to the web server.

The relevant TLS properties are:

* [tls.certificate](./properties.md#certificate)
* [tls.key](./properties.md#key)

There are some additional properties that are necessary should you wish to have Ioto verify client
certificates. These :

* [tls.authority](./properties.md#tls.authority)
* [tls.verify.*](./properties.md#tls.verify)

<a id="sslConfigurationExample"></a>

## TLS Configuration Example

Consider the default Ioto TLS configuration in the web.json5 configuration file:

```js
web: {
    listen: [ "https://:443" ]
},
redirect: [
    { status: 302, to: "https://" },
},
tls: {
    certificate: "server.crt",
    key: "server.key",
    verify: {
        issuer: true
    }
}
```

This set of properties enables TLS on port 443 for all network interfaces and uses the default supplied self-signed certificate to identify the server.

The **listen** property instructs Ioto to process requests from all interfaces on port 443 using TLS.

The **certificate** property specifies the server certificate to use and the **key** property specifies the server private key for signing.

<b>SECURITY WARNING</b>: You must obtain or generate a SSL certificate before using this example in a production environment.

The server key file is a PEM encoded private key. You may supply either an encrypted private key or a
decrypted private key. If you use an encrypted private key, the server will prompt you for a pass-phrase to
decrypt the key when the server boots.

## Self-Signed Certificate

Ioto is shipped with a self-signed certificate to identify the web server.

<b>SECURITY WARNING</b>: This certificate is suitable for testing purposes only and your browser will issue a warning when you access the server. For production use, you should obtain your own service certificate from signing authorities such as <a href="http://www.verisign.com">Verisign</a>.

<a id="generatingKeys"></a>

## Generating Keys and Certificates

To generate a request file that you can send to a certificate issuing authority such as <a href= "http://www.verisign.com">Verisign</a>, use the following openssl command or equivalent command from your TLS provider:

```bash
openssl genrsa -des3 -out server.key 1024
openssl req -new -key server.key -out server.csr
```

This will generate a server key in the file "server.key" and will generate a certificate request in the file "server.csr" that you can send to the issuing authority. The issuing authority will generate a server certificate for your server and they will sign it with their private key. Subsequently, clients will be able to use the signing authorities public key to decrypt your server certificate and thus verify the identity of your server when negotiating a SSL session. When running these commands, you will be prompted to enter a pass-phrase password to decrypt the server private key. REMEMBER this password.

<b>SECURITY WARNING</b>: Safeguard the "server.key" private key jealously. If this falls into malicious
hands, then your server identity may be hijacked by another site.
# Web Properties

When Ioto starts, the contents of the **web.json5** configuration are blended with the **ioto.json5** and made available via the **ioto->config** in-memory JSON tree.

## documents

| Name | documents |
|-|-|
| Description | Directory containing the static file documents to be published for context. |
| Synopsis | `documents: "directoryPath"` |
| Notes | The documents property defines the directory containing the documents that will be served. All routes share the same documents directory. The directoryPath should not have a trailing slash.|

**Example**

```js
documents: "/var/www"
```

## headers

| Name | headers |
|-|-|
| Description | Define HTTP headers to add to the client response.|
| Synopsis | `headers: { "Header-Key": "Header-Value", ... }` |
| Notes | The **headers** property defines one or more HTTP headers that are added to the client response. You should only define unique headers that are not already added by action routines or by the Ioto web server core. Otherwise, your response will have duplicate headers. |

**Example**

```js
headers: {
    "Content-Security-Policy":   "default-src 'self'",
    "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
    "CrossOrigin":               "origin=* credentials=yes headers=X-CORS-HEADER age=3000",
}
```

## index

| Name | index |
|-|-|
| Description | Define the default index file to serve for directory requests. |
| Synopsis | `index: "filename"` |
| Notes | The index property specifies a document to be served when a HTTP request is made for a directory. <br><br>If a client requests a directory, but without a trailing "/" in the URI, the client will be redirected to the URI with a trailing "/". When the client then uses that URI, the directory index file will be used for the response.<br> <br>For example: if an index of "index.html" is specified and a user requests http://www.acme.com/products/, then the document /products/index.html will be returned to the user. |

**Example**

```js
index: "index.html"
```

## limits

The Ioto web server supports configuration properties that improve security by limiting the size and scale of incoming requests. This technique is know as "sandboxing" because it creates a limited or safer area in which Ioto executes.

| Name | limits |
|-|-|
| Description | Collection of limit properties |
| Synopsis | `limits: { "Limit-Property": "Limit-Value", ...}` |
| Notes | All limit values may be numbers or human-readable strings with unit suffixes. The unit suffixes can be upper or lower case. The supported units are: unlimited, infinite, kb, k, mb, m, gb, g, byte and bytes. Ioto has sensible defaults for these limits if not explicitly specified. |

**Example**

```js
limits: {
    body: "100K",
    connections: "100",
    header: "10K",
    sessions: "20",
    upload: "20MB",
},
```


## limits.body

| Name | limits.body |
|-|-|
| Description | Sets the maximum size of the request body in POST and PUT requests. |
| Synopsis | `body: "max-size"` |
| Notes | The body limit defines a maximum size for a POST request body data. For embedded applications, it is useful to limit the request body to the expected maximum. This ensures that rogue or malicious requests will not cause the server to allocate unwanted memory to servicing the request. The default limit is 100K. |

**Example**

```
body: "100K"
```


## limits.connections

| Name | limits.connections |
|-|-|
| Description | Defines the maximum number of simultaneous client connections. |
| Synopsis | `connections: "value"` |
| Notes | The connections limit defines the maximum number of simultaneous client connections to the server. Connections in excess of this count will be rejected. Set to "unlimited" for no limit. This property counts the number of client socket connections. A single browser may open many separate connections (typically up to 6). |

**Examples**

```js
connections: "100"
```

## limits.header

| Name | limits.header |
|-|-|
| Description | Sets the maximum header size of a request. |
| Synopsis | `header: "max-size"` |
| Notes | The header limit defines a maximum size for the request headers. For embedded applications, it is useful to limit the maximum headers size to ensure that rogue or malicious requests will not cause the agent to allocate unwanted memory for servicing the request. The default limit is 10K. |
| Security | This property can be quite useful in certain denial-of-service attacks where the attacker sends large documents of a certain type. |

**Example**

```js
header: "32K"
```


## limits.sessions

| Name | limits.sessions |
|-|-|
| Description | Sets the maximum number of active client sessions |
| Synopsis | `sessions: "max-sessions"` |
| Notes | The sessions limit property defines the maximum number of active client sessions that utilize server-side session state storage. Requests in excess of this count will be rejected. Set to "unlimited" for no limit. This property limits the number of client sessions, whereas the "connections" limit will limit the number of simultaneously connected client systems. NOTE: that many browsers can and will initiate multiple requests when requesting a page. These will share the same session state storage. |

**Examples**

```js
sessions: "40"
```

## limits.upload

| Name | limits.upload |
|-|-|
| Description | Maximum size of an uploaded file.|
| Synopsis | `upload: "max-size"` |
| Notes | The upload limit defines the maximum size of an uploaded file. In embedded applications, it is useful to limit the maximum file upload size to ensure that rogue or malicious requests will not cause the server to allocate unwanted space for uploads. Set to "unlimited" for no limit. If a file larger than the limit is uploaded, Ioto will reject the request and the client will receive an error. The default value is unlimited. |
| Security | This directive can be quite useful in certain denial-of-service attacks where the attacker sends requests with bogus URLs. |

**Example**

```js
upload: "20MB"
```

## listen

| Name | listen |
|-|-|
| Description | IP addresses and ports on which to listing for incoming requests.<
| Synopsis | `listen: [ "http(s)://[IP address:]portNumber", ...]` |
| Notes | The Listen directive specifies the IP endpoints on which Ioto will listen for incoming HTTP requests. If you specify only the port number and omit the IP address, Ioto will listen on all network interfaces including the loop-back adaptor. It will listen on both IPv4 and IPv6 if only a portNumber is specified. >To listen on IPv6 endpoints, enclose the IP address in square brackets. For example: Listen [2001:05c0:9168:0000:0000:0000:0000:0001]. To listen on IPv4 endpoints, supply an IPv4 IP address. You may use 0.0.0.0 to listen on all IPv4 interfaces. To listen for TLS requests, use a "https://" prefix. |



**Example**

```js
listen: [
    "http://:80",
    "https://:443",
]
```


## mime

| Name | mime |
|-|-|
| Description | Mime map to map document extensions to mime types. |
| Synopsis | `mime: { "ext": "mime-type", ...}` |
| Notes | The mime property defines additional mime types to be added to the Ioto mime type table. Mime type properties are indexed by the document file extension with the value of each key set to the corresponding mime type. |

**Example**

```js
mime: {
    ".html": "text/html",
    ".ico": "image/vnd.microsoft.icon",
}
```


## name

| Name | name |
|-|-|
| Description | Define the public hostname by which the server is known |
| Synopsis | `name: "hostname.com"` |
| Notes: | The name property specifies the preferred, public, fully qualified hostname for the server. If specified, this address will be used when constructing URLs and redirections. The given hostname should be a fully qualified domain name with port number if using a port other than the default port. If a name is not defined, a value will be determined from the listening endpoint that accepted the connection. |

**Example**

```js
name: "www.acme.com"
```


## redirect

| Name | redirect |
|-|-|
| Description | Redirect requests to a new target. |
| Synopsis | `redirect: [ { status: code, from: "URL", to: "URL" }, ... ]` |
| Notes | The redirect property maps requests from one URL to a new URL. <br><br>The status argument may be either 301 for a permanent redirect or 302 for a temporary redirect. The default is 302.<br><br>The **from** property defines a URL portion that must match for the redirect. If the **from** property is omitted, it will match all URLs.<br><br>The **to** URL defines a URL portion that will be combined with the existing URL. The **to** URL may be local to the system, in which case it will begin with a "/" character, or it may be on another system, in which case it will begin with "http://" or "https://". In both cases, the user will receive a HTTP redirection response informing them of the new location of the document. <br><br>The **from** and **to** URLs are of the form:<br><br>[http\|https]\[://][hostname][:port][/path][?query][#hash]. <br><br>Any of the URL components may be present or absent. For example, if only a path is supplied for the **to**, then the client will be redirected to the new path on the current site. |


**Example**

```js
redirect: [
    { status: 302, from: "example.com", to: "new-example.com" },
    { status: 302, from: "http://example.com:80", to: "https://example.com:443" },
    { status: 302, from: "http://example.com", to: "https://new-example.com" },
    { status: 302, from: ":443", to: "https://:4443" },
    { status: 301, from: "/old", to: "/new.html" },
],
```

## route

The Ioto web server responds to requests by selecting a matching request route that describes the processing for the request.

| Name | route |
|-|-|
| Description | Define a configuration to apply to a set of URLs. |
| Synopsis | `routes: [ match: "url-prefix", role: 'ability', ... ]` |
| Notes | The routes property specifies an ordered set of routes that defines the required request properties for the request to be accepted.<br><br>A route entry has a <b>match</b> property that defines the URL prefix that must match for the route to be used.<br><br>The <b>handler</b> property defines the handler to process the request. Valid handlers include 'file' and 'action'. The optional <b>methods</b> property specifies the valid HTTP methods for the route. If absent, the GET and POST methods are supported. <br><br>The optional "<b>role</b>" property defines a role that the user must possess for the route to be used. If the "<b>role</b>" property is absent, all users will match. If specified, the user must be authenticated first to determine their abilities.<br><br>If the route matches, but the user fails to be authorized, the "<b>redirect</b>" property will be used to redirect the user to the given URL.<br><br>Ioto tests routes in order and the first matching route is used. If no routes match, the client request is rejected with a 401 status code.|

**Example**

```js
routes: [
    { match: '/public/', handler: 'file' },
    { match: '/auth/', handler: 'action' }
    { match: '/members/', role: 'user', handler: 'action' }
    { match: '/admin/', role: 'admin', handler: 'action' },
    { match: '', handler: 'file', methods: ['GET'] },
],
```


## route[].handler

| Name | route[].handler |
|-|-|
| Description | Define the handler to process the request. |
| Synopsis | `handler: 'action'` |
| Notes | The handler property defines the routine to process the request. There are two builtin handlers: 'file' and 'action'. The file handler serves static files from the file system (like /index.html). The action handler invokes registered action routines that are bound to a specific URL. |

**Example**

```js
routes: [
    { match: '/public/', handler: 'file' },
    { match: '/ai/chat/', handler: 'action', methods: ['GET', 'POST'] },
    { /* Match all */, role: 'guest' }
],
```

## route[].match

| Name | route[].match |
|-|-|
| Description | Define the matching URL to accept the request. |
| Synopsis | `match: '/path'` |
| Notes | The match property defines the URL for the request to be accepted.<br><br>The match defines an exact URL match unless it terminates in a "/" in which case it defines the leading URL prefix. For example, a match of "/directory/" will match all requests that begin with "/directory/", and a match of "/file" will only match URLs equal to "/file".<br><br>An empty match or missing match property will cause the route to match all requests. This is useful as a catch-all route.|

**Example**

```js
routes: [
    { match: '/public/' },
    { match: '/private.html', role: 'admin' }
    { match: '/members/', role: 'user' }
    { match: '/admin/', role: 'admin' },
    { /* Match all */, role: 'guest' }
],
```


## route[].methods

| Name | route[].methods |
|-|-|
| Description | Array of supported HTTP method verbs. |
| Synopsis | `methods: [ 'GET', 'POST' ]` |
| Notes | The methods property defines the set of supported HTTP method verbs for the request to match the route. Any HTTP verb can be specified, however, different request handlers and action routines may only support specific methods. Common HTTP method verbse are: DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT and TRACE. <br><br>If the methods property is absent, the default method set of ['GET', 'POST'] is enabled. <br><br>WARNING: be careful enabling OPTIONS and TRACE as they have known adverse security implications.<br><br>The trim property can be useful to remove a leading portion of the request path. |

**Example**

```js
routes: [
    { match: '/trace/', methods: ['OPTIONS', 'TRACE'], trim: '/trace' },
],
```

## route[].redirect

| Name | route[].redirect |
|-|-|
| Description | Redirect matching requests that fail authentication |
| Synopsis | `redirect: '/auth/login' ]` |
| Notes | If the route matches, but the user fails to be authorized, the "<b>redirect</b>" property will be used to redirect the user to the given URL.|

**Example**

```js
routes: [
    { redirect: '/auth/login' }
],
```

## route[].role

| Name | route[].role |
|-|-|
| Description | Required authentication role |
| Synopsis | `role: 'user' ]` |
| Notes | The optional "<b>role</b>" property defines a role that the user must possess for the route to be used. If the "<b>role</b>" property is absent, all users will match. If specified, the user must be authenticated first to determine their abilities.<br><br>If the route matches, but the user fails to be authorized, the "<b>redirect</b>" property will be used to redirect the user to the given URL.<br><br>Call `webLogin` after authenticating the user's credentials to login the user and define the user's role. |

**Example**

```js
routes: [
    { match: '/public/' },
    { match: '/private.html', role: 'admin' }
    { match: '/members/', role: 'user' }
    { match: '/admin/', role: 'admin' },
],
```

## route[].trim

| Name | route[].trim |
|-|-|
| Description | Trim a leading portion from the request URL |
| Synopsis | `trim: '/prefix' ]` |
| Notes | The optional "<b>trim</b>" property defines a leading path segment that will be trimmed from the path before processing the request. This can be useful to define different URL spaces that require different user authentication or processing.|

**Example**

```js
routes: [
    { match: '/trace/', methods: ['OPTIONS', 'TRACE'], trim: '/trace' },
],
```

## sessions

The Ioto web server supports server-side sessions that are indexed by a session cookie. Ioto manages the creation of the session cookie and the management of sessions. APIs to get and set values in session state are provided.

The default session cookie name is **-web-session-**. You can modify this when building by defining WEB_SESSION_COOKIE to be the cookie name of your choice.


| Name | session |
|-|-|
| Description | Collection of session properties. |
| Synopsis | `sessions: { "Sessions-Property": "Session-Value", ...}` |

**Example**

```js
sessions: {
    cookie: "-web-cookie-",
    enable: true,
    sameSite: "lax",
},
```


## session.cookie

| Name | session.cookie |
|-|-|
| Description | Controls whether to create session state for a request.|
| Synopsis | `enable: true|false` |

**Example**

```js
enable: true
```

## session.sameSite

| Name | session.sameSite |
|-|-|
| Description | Sets the sameSite property in the cookie. |
| Synopsis | `sameSite: "Lax|None|Strict"` |
| Notes | The sameSite property defines the Set-Cookie HTTP header SameSite field. It may be set to "Lax" (the default), "None" or Strict.<br><br>See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite">MDN Set-Cookie SameSite</a> for more information. |
| Security | This property is used to effectively defend against CSRF attacks. |

**Example**

```js
sameSite: "Lax"
```


## timeouts

The Ioto web server supports timeout properties that improve security by limiting the duration of requests. These timeouts are blended with the timeouts provided via the [ioto.json5 timeouts](../user/properties.md#timeouts) configuration.

| Name | timeouts |
|-|-|
| Description | Collection of timeout properties. |
| Synopsis | `timeouts: { "Timeout-Property": "Timeout-Value", ...}` |
| Notes | All timeout values are strings, not numbers.<br><br>The string values may take human-readable suffixes which indicate the units for the value. The suffixes can be upper or lower case. The supported units are: infinite, never, sec, secs, seconds, min, mins, minute, minutes, hr, hrs, hour, hours, day, days, week, weeks, month, months, year, years.<br><br>Ioto has sensible defaults for these timeouts if not explicitly specified.|

**Example**
```js
timeouts: {
    parse: "10 secs",
    inactivity: "300 secs",
    request: "10 mins",
    session: "30 mins",
    tls: "1 day",
}
```

## timeouts.inactivity

| Name | timeouts.inactivity |
|-|-|
| Description | Defines the maximum duration of no I/O activity before the request will be terminated. |
| Synopsis | `inactivity: "duration"` |
| Notes | The inactivity timeout will be triggered if there is no read or write activity on the network connection to the client over the specified timeout period. |

**Example**

```js
inactivity: "30 secs"
```

## timeouts.parse

| Name | timeouts.parse |
|-|-|
| Description | Defines the maximum duration for parsing the request HTTP headers |
| Synopsis | `parse: "duration"` |
| Notes | The parse timeout will be triggered if Ioto cannot read and parse the HTTP headers over the specified timeout period.<br><br>It is a security attack vector to open a connection to a web server and then be very slow, or stall writing the HTTP headers. This consumes a network connection and can lead to a denial of service. Setting the parse timeout to be short will limit this attack. |

**Example**

```js
parse: "15 secs"
```


## timeouts.request

| Name | timeouts.request |
|-|-|
| Description | Defines the maximum duration for a request. |
| Synopsis | `request: "duration"` |
| Notes | The request timeout will be triggered if the request cannot be completed inside the specified timeout period.<br><br>It is good practice to set a request timeout to the maximum duration you expect the longest request to take. |


**Example**

```js
request: "2mins"
```


## timeouts.session

| Name | timeouts.session |
|-|-|
| Description | Defines the maximum duration of session inactivity for preserving session state. |
| Synopsis | `session: "duration"` |
| Notes | Session state will be preserved for up to the session timeout. When a client accesses or updates the session state, the timeout is restarted. |

**Example**

```js
session: "1hr"
```



## upload

| Name | upload |
|-|-|
| Description | Collection of Upload properties. |
| Synopsis | `upload: { "Upload-Property": "Upload-Value", ... }` |
| Notes | The Upload properties control requests that use multi-part mime file upload. They control where the files are placed and how long the files are retained. |


**Example**

```js
upload: {
    dir: '/tmp',
    remove: true,
}
```

## upload.dir

| Name | upload.dir |
|-|-|
| Description | Defines the directory to receive uploaded files. |
| Synopsis | `dir: "path"` |
| Notes | The directory to hold uploaded files should be outside the site "documents" directory.|

**Example**

```js
dir: "./tmp/uploads"
```

## upload.remove

| Name | upload.remove |
|-|-|
| Description | Defines whether the uploaded files should be preserved after the request completes.|
| Synopsis | `remove: true | false` |
| Notes | The <b>remove</b> property defines whether the uploaded file is removed when the request completes. By default, an action routine that receives the upload file request should process the file before completing. Then Ioto will observe this property to determine if the file should be removed.|
| Security | It is a denial-of-service risk to keep uploaded files in the upload directory after the receiving action routine completes. If the files are not immediately removed, attackers can upload more and more data and exhaust the capacity of the server. |

**Example**

```js
remove: true
```

## webSockets

| Name | websockets |
|-|-|
| Description | Defines configuration for the WebSockets protocol.|
| Synopsis | `websockets: {ping: '60sec', validateUTF: false}` |
| Notes | The <b>ping</b> property defines the frequency of sending `ping` keep alive messages. The protocol property defines the WebSocket sub-protocol to use. The validateUTF property enables or disables validation of UTF messages. |

**Example**

```js
webSockets: {
    ping: 'never',
    protocol: 'chat',
    validateUTF: false,
},
```
# Web Server 

The Ioto web server is a fast, compact web server designed for management web applications and serving device data.

Ioto can be configured to support the web server as an additional component or Ioto can be build to run only the web server and thus be a first-class replacement for any embedded web server. Embedthis has been developing embedded web servers for many years and the Ioto web server contains all that we have learned over this period.

The Ioto web server is unlike other enterprise or embedded web servers. It does not attempt to offer ALL HTTP features and functions. Rather, it aims to implement only the required core of HTTP/1.1 and thus deliver a tiny, fast, secure embedded web server that is exceptionally good at serving single page web applications and device data APIs.

The Ioto web server supports a cohesive feature set including: HTTP/1, HTTP/1.1, TLS/SSL, WebSockets, SSE, Action routines, user authentication, sessions, cookie management, request logging, and security sandboxing. Yet Ioto remains very small from 80K code and will run in as little as 200K RAM. It will serve over 3,000 requests/sec on a modest Raspberry PI.

<img class="fit" src="/images/ioto/web-server.png" alt="web server" />

## Goals

Our target use-cases for the Ioto web server were:

* Support device management applications that use [Single-Page Application](https://en.wikipedia.org/wiki/Single-page_application) techniques.
* Support device APIs using [REST APIs](https://www.redhat.com/en/topics/api/what-is-a-rest-api)

Our goals are:

* Be as compact as possible
* Enhance security by minimizing the code and feature footprint
* Provide a simple, intuitive API for web applications

## Features

The core web services include:

* HTTP/1.1 protocol engine
* TLS 1.3 support
* WebSockets
* Server-Sent Events (SSE)
* Non-blocking socket communications
* Multiple listen endpoints
* Flexible configuration via a web.json5 file
* Request routing with access control
* Binding URLs to C functions for dynamic content rendering
* Serve static files
* Configurable redirections
* Transfer encoding filter
* Session and cookie management
* Authentication and User management
* File upload
* JSON parser and query engine
* Sandbox limits and timeouts

### Core Components

The Ioto web server components are:

|Component|Description|
|-|-|
| Safe Portable Runtime | Cross-platform, multi-threaded portable runtime. Includes services for memory allocation, dynamic module loading, safe string handling, lists, hashing, command execution, socket communications, threads, thread synchronization, thread-pool, events, timers, debug trace and logging.|
| Transport Security Layer (TLS) | TLS protocol stack. This is a virtual interface that can selectively support a variety of TLS providers including: the MbedTLS and OpenSSL stacks. |
| HTTP/1.1 | HTTP/1.1 HTTP protocol with keep-alive support. |
| WebSockets | WebSockets protocol. |
| SSE | Server-Sent Events (SSE) protocol. |
| Request Router | Request routing with user authentication and access control. |
| Redirections | Configurable redirections to TLS or new URL targets. |
| Dynamic Actions | Render dynamic content with Actions that bind URLs to C functions. |
| Static File Handler | The static File handler serves static content such as HTML pages, images and PDF files. |
| Upload Filter | The upload filter supports multipart mime file upload. |
| Authentication and User Management | Configurable user and password management. Control access to specific parts of the site. |
| Cookie and Session Management | Automatic session creation and cookie management. |
| Transfer Encoding Filter | The Chunk applies Transfer Chunk Encoding to outgoing data. Chunk encoding enables the HTTP connection to be reused for subsequent requests without having to establish a new TCP/IP connection. This can significantly improve network and application performance. |
| Logging | Configurable request and response tracing including HTTP headers. |


## Ioto Quick Tour

The web server uses a **web.json5** JSON/5 configuration file that specifies what ports and addresses to listen on, where to find the web pages, and how to route requests. This file is read when Ioto starts.

The Ioto web server is enabled via the ioto.json5 file. Set the **services.web** property to true.

```js
{
    services: {
        web: true
    }
}
```

The web server configuration is controlled via the **web.json5** file. Here is a simple example web configuration file:

```js
{
    web: {
        documents: "./site",
        listen: [
            "http://:80",
            "https://:443",
        ],
        tls: {
            certificate: "server.crt",
            key: "server.key",
        },
        redirect: [
            { status: 302, from: "http://:80", to: "https://:443" }
        ],
        routes: [
            { match: '/' },
            { match: '/index.html' },
            { match: '/public/' },
            { match: '/admin/', role: 'admin' },
            { match: '/upload/', methods: ['DELETE', 'GET', 'POST'] },
            { match: '/status/', stream: true },
            { match: '/unused/', redirect: '/auth/login' },
            { match: '/websockets/', methods: ['GET'], handler: 'action'},
            { redirect: '/auth/login' },
        ],
    }
}
```

The **documents** directory specifies where your web pages are located.  The **listen** property nominates the IP:PORT endpoints on which you wish to listen, and the **tls** property specifies your TLS private key file and certificate file.

The **redirect** property ensures all HTTP traffic is redirected over TLS. And finally, the **routes** property defines a set of processing rules for incoming requests. These rules can specify required roles (capabilities) for a user to be authenticated to access the URL.

See [Web Server Configuration](configuration.md) for details.

### Building Ioto with Web Server

The easiest way to build Ioto and enable the embedded web server is to select the local **Console** app. This will configure and build Ioto enabling the web server and also build the local Console device management VueJS app.

```bash 
$ make APP=console clean build
```

If you only want to build Ioto and don't want the Console app, select the **Empty** app.

```bash 
$ make APP=empty clean build
```

### Starting Ioto

You can manually run ioto via:

```bash
make run
```

This will run Ioto with the **-v** verbose option.  This will emit:

```bash
app: info: Starting Ioto 2.0.0, with "console" app 1.0.0, using "dev" profile
setup: info: Enabling services: db register serialize web
sync: info: Update device
register: info: Device already registered
web: info: Listening http://:9090
web: info: Listening https://:4443
app: info: Ioto ready
```

The **-v** means run in verbose mode where request to the server will be traced to the console. You can also run in debug mode via **-D** which emits more debug trace.

You can request a file from the server now with the `curl` utility:

    curl http://localhost:9090/index.html

or using the supplied **url** command utility:

    url 9090/index.html

## Dynamic Web Content

Dynamic content is generated via the Ioto **Action handler** that binds specific URLs to corresponding C functions. The action handler is ideal for situations when you want to respond with device data or generate a dynamic response.

Previously, earlier web servers used the CGI and web frameworks like PHP or ESP to generate dynamic content. But these solutions are a poor fit for modern management applications that use SPA techniques. They also consume considerable CPU and memory resources and are not the best approach for embedded devices. Further, they expose large attack surfaces due to excess features that are not essential.

Ioto uses a more efficient direct binding from URLs to C functions. This direct binding of HTTP URL requests to C code is extremely efficient and since most device data is manage by C API &mdash; this provides the most direct path to accessing device data.

When coupled with a flexible streaming, WebSockets, SSE, non-blocking API, and a JSON parser and query engine, the result is a dramatically simpler and more efficient device management platform.

```c
static int testAction(Web *web)
{
    char  buf[ME_BUFSIZE];
    ssize nbytes;
    int   i;

    //  Read POST body data. This will block, but other fibers can still run.
    while ((nbytes = webRead(web, buf, sizeof(buf))) > 0) {
        printf("Got body data %.*s\n", (int) nbytes, buf);
    }

    //  Stream a response without buffering and with minimal memory footprint
    for (i = 0; i < 10000000; i++) {
        //  This will block as required, but other fibers can still run.
        webWriteFmt(web, "Hello World, now is: %s\n", rFormatLocalTime(0, 0));
    }
    webFinalize(web);
    return 0;
}
```

## Ioto API 

Ioto provides a flexible, comprehensive API so you can fully tailor dynamic request responses.

For example:

To generate a simple one line response:

    webResponse(web, 200, "Hello World\n");

To set an output HTTP header with the response

    webAddHeader(web, "X-Custom", "%d", 42);

To set the HTTP response status:

    webSetStatus(web, 404);

To respond to a request with an error:

    webError(web, 404, "Cannot serve request");

To write a database item (record) to the response:

    DbItem *item = dbGet(db, "User", DB_PROPS("id", "u23877112"), 0);
    webWriteItem(web, item);

To write an array (grid) of items to the response:

    DbGrid *users = dbFind(db, "User", 0, 0);
    webWriteItems(web, users);

To redirect to a new page:

    webRedirect(web, 302, "/login");

To get the value of a request form field:

    const char *user = webGetVar(web, "username", 0);

To set a variable in the authenticated session store:

    webSetSessionVar(web, "username", username);

To send a WebSockets message:

    webSocketsSend(web->webSockets, "Hello %s", "world");

To send a Server-Sent Events message:

    webWriteEvent(web, id, "event-name", "Hello %s", "world");

### Ioto Background

The Ioto HTTP core is responsible for parsing the incoming HTTP request. A HTTP request is comprised of a request line followed by one or more HTTP headers that provide additional context.

The first line of the HTTP request specifies the HTTP operation method to use, the URI to access and the variant of the HTTP protocol to use. This typically looks like:

```http
<b>GET</b> /index.html HTTP/1.1
```

This example is asking for the /index.html document via the GET method using the HTTP/1.1 protocol.

After the first line follow the headers. These are keyword, value pairs that control how the request will be processed. Typically there are 5-15 headers in most requests.

```
HeaderName: value
```

Some typical headers are:

|Header|Description|
|-|-|
| Authorization | Authorization details including user name, realm, password digest and other authorization parameters to implement Basic and Digest authentication. |
| Connection | Describe how the TCP/IP connection should be managed when the request completes. |
| Content-Length | Length of any addition data with a POST request. |
| Content-Type | Mime types the client prefers to accept in response to this request. |
| Cookie | Cookie associated with the URI in the clients cookie cache. |
| Host | Name to the target host to serve the request. This specifies the host name when using virtual hosting. |
| If-Modified-Since | Only return the content if it has been modified since the date specified. Clients who have cached copies of a document (or graphics) use this header to allow the server to skip copying the document if it has not changed. |
| Keep-Alive | Request the server to keep the connection alive so that subsequent requests can reuse the connection. |

For example:

```
Connection: keep-alive
```

The HTTP core stores the parsed headers and their values for access by the request handlers. When all the headers have been processed Ioto proceeds to do request routing. This will occur before any associated POST data has been read from the client. POST data may be form data submitted by the client or it may be a file upload using the PUT method.

## Request Routing

Ioto has a flexible request routing engine that processes client HTTP requests and validates access using a role-based access control mechanism. The routing engine is configured with a set of routes from the Ioto configuration file. When a request is received, it examines the routes in sequence and selects the first matching route to handle the request.

Handlers are responsible for receiving the request and creating a response. They generate response content based on the HTTP request URI, headers, any associated body data, and potential application session state. The output data flows through the output pipeline before transmission over the network to the client.

Ioto supports two request handlers:

* Static file handler
* Dynamic action handler

The static file handler serves document files from the configured **documents** directory.

The dynamic action handler responds to requests by invoking an associated C function to generate a dynamic response. It is also used for WebSockets and SSE requests.


## Fiber Coroutines

Ioto does not provide a web framework — nor do we believe this is the best approach for remote device management applications. Rather, we provide compellingly simple, streaming primitives to serve data for REST APIs and for single page applications.

To do this, Ioto adopts a unique approach of using fiber coroutines for parallelism and streaming. This yields an exceptionally fast web server that will serve over 3K requests per second on a modest Raspberry PI 4 and yet runs using only 80K of code.

The main benefit of fibers, is a non-blocking straight line procedural programming style.

A fiber coroutine is code that runs with its own stack and cooperatively yields to other fibers when it needs to wait. You can think of a fiber as a thread, but only one fiber runs at a time so there is no thread sync to worry about. For Go programmers, fibers are like Go routines. For JavaScript developers, fibers are similar to async/await.

You can read more in [Fiber Coroutines](../dev/fiber.md), but for now, consider this sample Action routine:


## JSON Parser and Query Engine

Ioto includes an integrated JSON parser, query engine and persistency to enable it to respond to HTTP requests with JSON payloads and remit responses in JSON.

## Ioto Kickstart

Ioto has a fully working sample single page application called [Kickstart](/apps/samples/kickstart/). This is a VueJS application that serves a sample device application from Ioto.

To build the Kickstart app:

```bash
$ make APP=kickstart clean build
```

## WebSockets

The Ioto web server supports WebSockets for bidirectional, full-duplex communications over persistent TCP/IP connections. A WebSocket connection is established over a standard HTTP connection using a GET request and is then upgraded without impacting the original connection. 

Ioto implements WebSockets for both the HTTP web server and for the URL HTTP client. The WebSockets library implements the core WebSockets protocol, handshaking, and provides a C language API. The `web` library accepts incoming HTTP connections and upgrades WebSockets requests via to use the WebSockets protocol. Similarly, the `url` library provides APIs to initiate WebSockets connections via a HTTP client GET request and it then upgrades that connection to use the WebSockets protocol. The `url` client program supports WebSockets for load testing purposes.

## Server-Sent Events (SSE)

The SSE protocol is a simple, lightweight protocol that is supported by most modern browsers. It is a good fit for device management applications that need to push data to the client. The Ioto web server supports Server-Sent Events (SSE) for streaming data to the client.

Ioto implements SSE for both the HTTP web server and for the URL HTTP client. The `web` library accepts incoming HTTP connections and via the `webWriteEvent` can remite SSE responses. Similarly, the `url` library provides APIs to initiate SSE connections via a HTTP client GET request and it then upgrades that connection to use the SSE protocol. 
# Configuration

The Ioto web server is built by default when compiling from source.

After building, the Ioto web server is enabled via the **ioto.json5** file. It is disabled by default.

```js
{
    services: {
        web: true
    }
}
```

If you wish to only run the web server, you can disable all the other services. In this manner, Ioto becomes a dedicated embedded web server.

The web server configuration is controlled via the **web.json5** file.

Here is a minimal sample web.json5 that will listen on port 80 for HTTP requests and port 443 for TLS requests.

```js
{
    web: {
        documents: "./site",
        listen: [
            "http://:80",
            "https://:443",
        ],
        tls: {
            certificate: "server.crt",
            key: "server.key",
        },
    }
}
```

The configuration file defines the following items:

* Public **name** of the server
* The **documents** directory for files to serve
* The ports on which to **listen** for requests
* Request **timeouts**
* Request **limits**
* The **tls** (TLS) certificates
* Instructions to **redirect** requests
* Processing **routes**
* Policy for file **upload**

The configuration properties are defined in the [Configuration Properties](./properties.md).

Here is a more detailed example:

```js
{
    web: {
        documents: "./site",
        headers: {
            'X-Frame-Options': 'SAMEORIGIN',
        },
        index: "index.html",
        limits: {
            body: "100K",
            connections: "100",
            memory: "1MB",
            header: "10K",
            sessions: "20",
            upload: "20MB",
        },
        listen: [
            "http://:80",
            "https://:443",
        ],
        name: "mysite.com",
        redirect: [
            { status: 302, to: "https://" },
            { status: 301, from: "/old", to: "/new.html" },
        ],
        routes: [
            { match: '/public/', role: 'user' },
            { match: '/auth/' },
            { match: '/trace/', methods: ['TRACE'], trim: '/trace' },
            { redirect: '/auth/login' },
        ],
        sessions: {
            cookie: "-web-cookie-",
            enable: true,
            sameSite: "lax",
        },
        timeouts: {
            parse: "10 secs",
            inactivity: "300 secs",
            request: "10 mins",
            session: "30 mins",
            tls: "1 day",
        },
        tls: {
            certificate: "server.crt",
            key: "server.key",
        },
        upload: {
            dir: '/tmp',
            remove: true,
        }
    }
}
```
# Transport Layer Security (TLS) Overview

Ioto supports the Transport Layer Security (TLS) protocol for authenticating systems and encrypting data. Use of this protocol enables secure data transmission to and from clients in a standards-based manner. The Transport Layer Security protocol is a protocol layer which may be placed between a reliable connection-oriented network layer protocol (e.g. TCP/IP) and the application protocol layer (e.g. HTTP). TLS provides for secure communication between client and server by allowing mutual authentication, the use of digital signatures for integrity, and encryption for privacy.

This following document explains TLS. It has heavily borrowed from the Apache Documentation. Many thanks to the fine folks at Apache for this excellent base material and for Frederick Hirsch who authored quite a bit of the original material.

If you have a good understanding of TLS and now you want to configure TLS for Ioto, you may wish to skip the background and read immediately how to setup [TLS for Ioto](tls.md).

<a id="cryptographicTechniques"></a>
## Cryptographic Techniques

Understanding TLS requires an understanding of cryptographic algorithms, message digest functions (aka. one-way or hash functions), and digital signatures. The following section provides a brief introduction to the cryptographic foundations of TLS. If you are already familiar with this material, please skip forward to the <a href="#tlsOverview">TLS Overview</a> section.

### Cryptographic Algorithms

Consider the example of Alice who wants to send a message to her bank to transfer some money. She would like the message to be private, since it will include information such as her account number and transfer amount. One solution is to use a cryptographic algorithm, a technique that would transform her message into an encrypted form, unreadable except by those it is intended for. Once in this form, the message may only be interpreted through the use of a secret key. Without the key, the message is useless: good cryptographic algorithms make it so difficult for intruders to decode the original text that it isn't worth their effort.

There are two categories of cryptographic algorithms: conventional and public key.

<a id="symmetricCryptography"></a>
#### Symmetric Cryptography

Symmetric cryptography, requires the sender and receiver to share a key: a secret piece of information that may be used to encrypt or decrypt a message. If this key is secret, then nobody other than the sender or receiver may read the message. If Alice and the bank know a secret key, then they may send each other private messages. The task of privately choosing a key before communicating, however, can be problematic.

<a id="publicKeyCryptography"></a>
#### Public Key Cryptography

Public key cryptography also known as asymmetric cryptography, solves the key exchange problem by defining an algorithm which uses two keys, each of which may be used to encrypt a message. If one key is used to encrypt a message then the other may be used to decrypt it. This makes it possible to receive secure messages by simply publishing one key (the public key) and keeping the other secret (the private key).

Anyone may encrypt a message using the public key, but only the owner of the private key will be able to read it. In this way, you may send private messages to the owner of a key-pair (the bank), by encrypting it using their public key. Only the bank will be able to decrypt it.

<a id="messageDigests"></a>
### Message Digests

Although Alice may encrypt her message to make it private, there is still a concern that someone might modify her original message or substitute it with a different one, in order to transfer the money to themselves, for instance. One way of guaranteeing the integrity of Alice's message is to create a concise summary of her message and send this to the bank as well. Upon receipt of the message, the bank creates its own summary and compares it with the one Alice sent. If they agree then the message was received intact.

A summary such as this is called a <b>message digest</b>, `one-way function` or `hash function`. Message digests are used to create short, fixed-length representations of longer, variable-length messages. Digest algorithms are designed to produce unique digests for different messages. Message digests are designed to make it too difficult to determine the message from the digest, and also impossible to find two different messages which create the same digest &mdash; thus eliminating the possibility of substituting one message for another while maintaining the same digest.

Another challenge that Alice faces is finding a way to send the digest to the bank securely; when this is achieved, the integrity of the associated message is assured. One way to do this is to include the digest in a digital signature.

<a id="digitalSignatures"></a>
### Digital Signatures

When Alice sends a message to the bank, the bank needs to ensure that the message is really from her, so an intruder does not request a transaction involving her account. A `digital signature`, created by Alice and included with the message, serves this purpose.

Digital signatures are created by encrypting a digest of the message, and other information (such as a sequence number) with the sender's private key. Though anyone may `decrypt` the signature using the public key, only the signer knows the private key. This means that only they may have signed it. Including the digest in the signature means the signature is only good for that message; it also ensures the integrity of the message since no one can change the digest and still sign it.

To guard against interception and reuse of the signature by an intruder at a later date, the signature contains a unique sequence number. This protects the bank from a fraudulent claim from Alice that she did not send the message &mdash; only she could have signed it (non-repudiation).<a id="certificates"></a>

## Certificates

Although Alice could have sent a private message to the bank, signed it, and ensured the integrity of the message, she still needs to be sure that she is really communicating with the bank. This means that she needs to be sure that the public key she is using corresponds to the bank's private key. Similarly, the bank also needs to verify that the message signature really corresponds to Alice's signature.

If each party has a certificate which validates the other's identity, confirms the public key, and is signed by a trusted agency, then they both will be assured that they are communicating with whom they think they are. Such a trusted agency is called a `Certificate Authority`, and certificates are used for authentication.

### Certificate Contents

A certificate associates a public key with the real identity of an individual, server, or other entity, known as the subject. As shown in <a href="#table1">Table 1</a>, information about the subject includes identifying information (the distinguished name), and the public key. It also includes the identification and signature of the Certificate Authority that issued the certificate, and the period of time during which the certificate is valid. It may have additional information (or extensions) as well as administrative information for the Certificate Authority's use, such as a serial number.

<a id="table1"></a>

#### Table 1: Certificate Information

| Item | Description |
|-|-|
| Subject | Distinguished Name, Public Key |
| Issuer | Distinguished Name, Signature |
| Period of Validity | Not Before Date, Not After Date |
| Administrative Information | Version, Serial Number |
| Extended Information | Basic Constraints, Netscape Flags, etc. |

A distinguished name is used to provide an identity in a specific context &mdash; for instance, an individual might have a personal certificate as well as one for their identity as an employee. Distinguished names are defined by the X.509 standard, which defines the fields, field names, and abbreviations used to refer to the fields (see <a href="#table2">Table 2</a>).

<a id="table2"></a>

#### Table 2: Distinguished Name Information

| DN Field | Abbrev. | Description | Example |
|-|-|-|-|
| Common Name | CN | Name being certified | CN=Joe Average |
| Organization or Company | O | Name is associated with this organization | O=Snake Oil, Ltd. |
| Organizational Unit | OU | Name is associated with this organization unit, such as a department | OU=Research Institute |
| City/Locality | L | Name is located in this City | L=Snake City |
| State/Province | ST | Name is located in this State/Province | ST=Desert |
| Country | C | Name is located in this Country (ISO code) | C=XZ |

A Certificate Authority may define a policy specifying which distinguished field names are optional, and which are required. It may also place requirements upon the field contents, as may users of certificates. As an example, a Netscape browser requires that the Common Name for a certificate representing a server has a name which matches a wildcard pattern for the domain name of that server, such as <code>*.snakeoil.com</code>

The binary format of a certificate is defined using the ASN.1 notation. This notation defines how to specify the contents, and encoding rules define how this information is translated into binary form. The binary encoding of the certificate is defined using Distinguished Encoding Rules (DER), which are based on the more general Basic Encoding Rules (BER). For those transmissions which cannot handle binary, the binary form may be translated into an ASCII form by using Base64 encoding. This encoded version is called PEM encoded (the name comes from "Privacy Enhanced Mail"), when placed between begin and end delimiter lines as illustrated in the following example.

### Example of a PEM-encoded certificate (snakeoil.crt)
```
-----BEGIN CERTIFICATE-----
MIIC7jCCAlegAwIBAgIBATANBgkqhkiG9w0BAQQFADCBqTELMAkGA1UEBhMCWFkx
FTATBgNVBAgTDFNuYWtlIERlc2VydDETMBEGA1PEBxMKU25ha2UgVG93bjEXMBUG
A1UEChMOU25ha2UgT2lsLCBMdGQxHjAcBgNVBAsTFUNlcnRpZmljYXRlIEF1dGhv
cml0eTEVMBMGA1UEAxMMU25ha2UgT2lsIENBMR4wHAYJKoZIhvcNAQkBFg9jYUBz
bmFrZW9pbC5kb20wHhcNOTgxMDIxMDg1ODM2WhcNOTkxMDIxMDg1ODM2WjCBpzEL
MAkGA1UEBhMCWFkxFTATBgNVBAgTDFNuYWtlIELlc2VydDETMBEGA1UEBxMKU25h
a2UgVG93bjEXMBAGA1UEChMOU25ha2UgT2lsLCBMdGQxFzAVBgNVBAsTDldlYnNl
cnZlciBUZWFtMRkwFwYDVQQDExB3d3cuc25ha2VvaWwuZG9tMR8wHQYJKoZIhvcN
AQkBFhB3d3dAc25ha2VvaWwuZG9tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB
gQDH9Ge/s2zcH+da+rPTx/DPRp3xGjHZ4GG6pCmvADIEtBtKBFAcZ64n+Dy7Np8b
vKR+yy5DGQiijsH1D/j8HlGE+q4TZ8OFk7BNBFazHxFbYI4OKMiCxdKzdif1yfaa
lWoANFlAzlSdbxeEVHoT0K+gT5w3UxwZKv2DLbETzLZyPwIDAQABoyYwJDAPBgNV
HRMECDAGAQH/AgEAMBEGCWCGSAGG+EIBAQQEAwIAQDANBgkqhkiG9w0BAQQFAAOB
gQAZUIHAL4D09oE6Lv2k56Gp38OBDuILvwLg1v1KL8mQR+KFjghCrtpqaztZqcDt
2q2QoyulCgSzHbEGmi0EsdkPfg6mp0penssIFePYNI+/8u9HT4LuKMJX15hxBam7
dUHzICxBVC1lnHyYGjDuAMhe396lYAn8bCld1/L4NMGBCQ==
-----END CERTIFICATE-----
```

<a id="certificateAuthorities"></a>

### Certificate Authorities

By first verifying the information in a certificate request before granting the certificate, the Certificate Authority assures the identity of the private key owner of a key-pair. For instance, if Alice requests a personal certificate, the Certificate Authority must first make sure that Alice really is the person the certificate request claims.

#### Certificate Chains

A Certificate Authority may also issue a certificate for another Certificate Authority. When examining a certificate, Alice may need to examine the certificate of the issuer, for each parent Certificate Authority, until reaching one which she has confidence in. She may decide to trust only certificates with a limited chain of issuers, to reduce her risk of a "bad" certificate in the chain.

#### Creating a Root-Level CA

As noted earlier, each certificate requires an issuer to assert the validity of the identity of the certificate subject, up to the top-level Certificate Authority (CA). This presents a problem: Since this is who vouches for the certificate of the top-level authority, which has no issuer? In this unique case, the certificate is "self-signed", so the issuer of the certificate is the same as the subject. As a result, one must exercise extra care in trusting a self-signed certificate. The wide publication of a public key by the root authority reduces the risk in trusting this key &mdash; it would be obvious if someone else publicized a key claiming to be the authority. Browsers are preconfigured to trust well-known certificate authorities.

A number of companies, such as <a href="http://www.thawte.com/">Thawte</a> and <a href= "http://www.verisign.com/">VeriSign</a> have established themselves as Certificate Authorities. These companies provide the following services:

* Verifying certificate requests
* Processing certificate requests
* Issuing and managing certificates

It is also possible to create your own Certificate Authority. Although risky in the Internet environment, it may be useful within an Intranet where the organization can easily verify the identities of individuals and servers.

#### Certificate Management

Establishing a Certificate Authority is a responsibility which requires a solid administrative, technical, and management framework. Certificate Authorities not only issue certificates, they also manage them &mdash; that is, they determine how long certificates are valid, they renew them, and they keep lists of certificates that have already been issued but are no longer valid (Certificate Revocation Lists, or CRLs). Say Alice is entitled to a certificate as an employee of a company. Say too, that the certificate needs to be revoked when Alice leaves the company. Since certificates are objects that get passed around, it is impossible to tell from the certificate alone that it has been revoked. When examining certificates for validity, therefore, it is necessary to contact the issuing Certificate Authority to check CRLs &mdash; this is not usually an automated part of the process.

### Notes

If you use a Certificate Authority that is not configured into browsers by default, it is necessary to load the Certificate Authority certificate into the browser, enabling the browser to validate server certificates signed by that Certificate Authority. Doing so may be dangerous, since once loaded, the browser will accept all certificates signed by that Certificate Authority.

<a id="tlsOverview"></a>
## Transport Layer Security (TLS) Overview

The Transport Layer Security protocols designed to support a range of choices for specific algorithms used for cryptography, digests, and signatures. This allows algorithm selection for specific servers to be made based on legal, export or other concerns, and also enables the protocol to take advantage of new algorithms. Choices are negotiated between client and server at the start of establishing a protocol session.

<a id="table4"></a>
### Table 4: Versions of the TLS protocol

<table title="protocols" class="ui table celled segment">
<thead>
    <tr>
        <th>Version</th>
        <th>Source</th>
        <th>Description</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td>TLS v2.0</td>
        <td>Expired</td>
        <td>First TLS protocol for which implementations exists</td>
    </tr>
    <tr>
        <td>TLS v3.0</td>
        <td>Expired</td>
        <td>Revisions to prevent specific security attacks, add non-RSA ciphers,
        and support for certificate chains</td>
    </tr>
    <tr>
        <td>TLS v1.0</td>
        <td>Internet Standard</td>
        <td>TLSv1.0 is a revision of TLS 3.0 to update the MAC layer to HMAC,
        add block padding for block ciphers, message order standardization
        and more alert messages.</td>
    </tr>
    <tr>
        <td>TLS v1.1</td>
        <td>Internet Standard</td>
        <td>TLSv1.1 adds protection against Cipher block chaining attacks.</td>
    </tr>
    <tr>
        <td>TLS v1.2</td>
        <td>Internet Standard</td>
        <td>TLSv1.2 deprecates using MD5 as a hash and deprecates TLSv2.</td>
    </tr>
    <tr>
        <td>TLS v1.3</td>
        <td>Internet Standard</td>
        <td>TLSv1.3 improves performance and fast connection startup.</td>
    </tr>
</tbody>
</table>

There are a number of versions of the TLS protocol, as shown in <a href="#table4">Table 4</a>. As noted there, one of the benefits in TLS 3.0 is that it adds support of certificate chain loading. This feature allows a server to pass a server certificate along with issuer certificates to the browser. Chain loading also permits the browser to validate the server certificate, even if Certificate Authority certificates are not installed for the intermediate issuers, since they are included in the certificate chain. TLS 3.0 is the basis for the Transport Layer Security protocol standard, currently in development by the Internet Engineering Task Force (IETF).

### Session Establishment

The TLS session is established by following a handshake sequence between client and server. This sequence may vary, depending on whether the server is configured to provide a server certificate or request a client certificate. Though cases exist where additional handshake steps are required for management of cipher information, this article summarizes one common scenario: see the TLS specification for the full range of possibilities.

### Note
Once an TLS session has been established it may be reused, thus avoiding the performance penalty of repeating the many steps needed to start a session. For this the server assigns each TLS session a unique session identifier which is cached in the server and which the client can use on forthcoming connections to reduce the handshake (until the session identifier expires in the cache of the server).

<p class="figure">The elements of the handshake sequence, as used by the client and server, are listed below:</p>

1. Negotiate the Cipher Suite to be used during data transfer
2. Establish and share a session key between client and server
3. Optionally authenticate the server to the client
4. Optionally authenticate the client to the server

The first step, Cipher Suite Negotiation, allows the client and server to choose a Cipher Suite supportable by both of them. The TLS3.0 protocol specification defines 31 Cipher Suites. A Cipher Suite is defined by the following components:

* Key Exchange Method
* Cipher for Data Transfer
* Message Digest for creating the Message Authentication Code (MAC)

These three elements are described in the sections that follow.

### Key Exchange Method

The key exchange method defines how the shared secret symmetric cryptography key used for application data transfer will be agreed upon by client and server. TLS 2.0 uses RSA key exchange only, while TLS 3.0 supports a choice of key exchange algorithms including the RSA key exchange when certificates are used, and Diffie-Hellman key exchange for exchanging keys without certificates and without prior communication between client and server.

One variable in the choice of key exchange methods is digital signatures &mdash; whether or not to use them, and if so, what kind of signatures to use. Signing with a private key provides assurance against a man-in-the-middle-attack during the information exchange used in generating the shared key.

### Cipher for Data Transfer

TLS uses the conventional cryptography algorithm (symmetric cryptography) described earlier for encrypting messages in a session. There are nine choices, including the choice to perform no encryption:

* No encryption
* Stream Ciphers
- RC4 with 40-bit keys
- RC4 with 128-bit keys
* CBC Block Ciphers
    - RC2 with 40 bit key
    - DES with 40 bit key
    - DES with 56 bit key
    - Triple-DES with 168 bit key
    - Idea (128 bit key)
    - Fortezza (96 bit key)

Here "CBC" refers to Cipher Block Chaining, which means that a portion of the previously encrypted cipher text is used in the encryption of the current block. "DES" refers to the Data Encryption Standard, which has a number of variants (including DES40 and 3DES_EDE). "Idea" is one of the best and cryptographically strongest available algorithms, and "RC2" is a proprietary algorithm from RSA DSI.

Digest Function
The choice of digest function determines how a digest is created from a record unit. TLS supports the following:
* No digest (Null choice)
* MD5, a 128-bit hash (deprecated in TLS/1.2)
* Secure Hash Algorithm (SHA-1), a 160-bit hash

The message digest is used to create a Message Authentication Code (MAC) which is encrypted with the message to provide integrity and to prevent against replay attacks.

### Handshake Sequence Protocol

The handshake sequence uses three protocols:
* The <dfn>TLS Handshake Protocol</dfn> for performing the client and server TLS session establishment.
* The <dfn>TLS Change Cipher Spec Protocol</dfn> for actually establishing agreement on the Cipher Suite for the session.
* The <dfn>TLS Alert Protocol</dfn> for conveying TLS error messages between client and server.

These protocols, as well as application protocol data, are encapsulated in the <dfn>TLS Record Protocol</dfn>. An encapsulated protocol is transferred as data by the lower layer protocol, which does not examine the data. The encapsulated protocol has no knowledge of the underlying protocol.

The encapsulation of TLS control protocols by the record protocol means that if an active session is renegotiated the control protocols will be transmitted securely. If there were no session before, then the Null cipher suite is used, which means there is no encryption and messages have no integrity digests until the session has been established.

### Data Transfer

The TLS Record Protocol is used to transfer application and TLS Control data between the client and server, possibly fragmenting this data into smaller units, or combining multiple higher level protocol data messages into single units. It may compress, attach digest signatures, and encrypt these units before transmitting them using the underlying reliable transport protocol (Note: currently all major TLS implementations lack support for compression).

### Securing HTTP Communication

One common use of TLS is to secure Web HTTP communication between a browser and a web server. This case does not preclude the use of non-secured HTTP. The secure version is mainly plain HTTP over TLS (named HTTPS), but with one major difference: it uses the URL scheme <code>https</code> rather than <code>http</code> and a different server port (by default 443).
# Listening for Connections

Ioto can listen for HTTP requests on multiple IP addresses and ports. Incoming requests may be served by a single server, or they may be processed by different logical servers often called virtual hosts.

The process of opening TCP/IP ports to listen for requests is called binding. By default, Ioto will listen on all the interface network cards in the system, but the Ioto configuration file allows explicit control over which interfaces, IP addresses and ports are used.

## Listen Directive

The <a href="properties.html#listen">Listen</a> configuration file property specifies the IP endpoints on which Ioto will listen for incoming HTTP requests. It takes the form:

```json
listen: [
    'http:// | https://][IP][:PORT]',
    ...
]
```

The HTTP scheme portion is optional and indicates whether TLS is to be use. If **https://** is used, then TLS will be applied to the connection.

The IP address and port components are optional, but at least one must be present. If the IP address is absent, Ioto will listen on all network interfaces including the loop-back adapter. If the PORT is absent, Ioto will listen on the default port which is typically configured to be port 80.

For example:

```json
listen: [
    "http://:80",
    "https://:443",
]
```

## IPv6

Ioto will listen on both IPv4 and IPv6 endpoints. To specify IPv6 endpoints you need to use IPv6
encoding. IPv6 addresses have eight colon separated segments. For example:

```
2001:0db8:85a3:08d3:1319:8a2e:0370:7348
```

Because IPv6 addresses contain a colon character, you need to enclose the IPv6 address in brackets if
you want to also specify a network port when using the Listen directive.

```json
listen: [
    "http://[2001:0db8:85a3:08d3:1319:8a2e:0370:7348]:7777"
]
```

These two documents are useful IPv6 references:
* [Understanding IPv6 Addresses](http://www.enterprisenetworkingplanet.com/netsp/article.php/3633211)
* [Wikipedia IPv6](http://en.wikipedia.org/wiki/IPv6)
# File Upload

Ioto has an integrated file upload filter that accepts and processes file upload requests.

The Ioto upload filter intercepts uploaded files, saves them to disk and passes details about the
uploaded file to Ioto Action routines for processing.

File upload uses multi-part mime encoding to transport files over HTTP POST requests. This is specified in
the IETF standard <a href="http://www.ietf.org/rfc/rfc2388.txt">RFC 2388</a>.

<a id="overview"></a>

## Overview

Because uploaded files can be very large, Ioto uses specialized handling for the receipt, storage and processing of uploaded files. When an upload request is received, Ioto will accept and store the uploaded file before starting the Action routine to respond to the request. The Action routine does not directly receive the uploaded file. Rather, Ioto passes the name of the temporary file holding the uploaded file. Ioto expects that the Action routine will process, copy or move the temporary file before completing the request. Once complete, Ioto will remove any remaining upload temporary files.

<a id="directives"></a>

## Ioto Upload Configuration

There are two **web.json5** configuration properties that control the upload filter.
* [upload.dir](properties.md#upload.dir) &mdash; This specifies directory to receive uploaded files.
* [upload.remove](properties.md#upload.remove) &mdash; This specifies if the uploaded files should be automatically removed from the upload directory after the action routine has completed processing the request.

<a id="details"></a>
## Upload File Details

Once a file is uploaded, the Action routine responsible for processing the request will receive details about
uploaded files via the request parameters.

Ioto provides direct access to the uploaded files structure. Each uploaded file is described
by a [WebUpload](../ref/api/web.md#group___web_upload) structure.

These structures are stored in an RHash table indexed by their HTML file upload ID.

The [WebUpload](../ref/api/web.md#group___web_upload) structure is defined as:

```c
typedef struct WebUpload {
    char *filename;       /**< Local (temp) name of the file */
    char *clientFilename; /**< Client side name of the file */
    char *contentType;    /**< Content type */
    char *name;           /**< Symbolic name for the upload supplied by the client */
    ssize size;           /**< Uploaded file size */
    int fd;               /**< File descriptor used while writing the upload content */
} WebUpload;
```

You can access uploaded files via:

```c
WebUpload  *file;
cchar      *name;

for (ITERATE_NAME_DATA(web->files, name, file)) {
    webWriteFmt(web, "FILENAME %s\n", file->filename);
    webWriteFmt(web, "CLIENT_NAME %s\n", file->clientFilename);
    webWriteFmt(web, "TYPE %s\n", file->contentType);
    webWriteFmt(web, "SIZE %d\n", file->size);
}
```

<a id="post"></a>
## Alternative Upload Technique

File upload using POST requests is one way to upload files. Another is to use the HTTP PUT method.
This uploads a file without encoding and can offer higher performance. The HTTP DELETE method can then
be used to delete files from the server.
# Security Considerations

Securing applications that are accessible to the Internet is not a trivial task.

When a device enables an embedded web server, the security exposure increases significantly as it is listening for unsolicited incoming connections and requests.

>You should disable the Ioto web server unless you definitely need to provide HTTP web services.

This page outlines some of the issues, and offers best-practices and tips to help you secure your application using the Ioto web server.

## Updates

Even the best or most secure application server can experience some security vulnerabilities that are discovered after being deployed in the field. It is highly recommended that you stay up to date with the latest version of Ioto. [Download Ioto](https://www.embedthis.com/ioto/download.html).

<a href="https://embedthis.com/">Embedthis</a> provides security protection as part of the Ioto commercial license that will proactively notify you of any security flaws and will expedite fixes or workarounds to minimize any vulnerabilities.

## Sandboxing

Sandboxing is the term applied to running the Ioto web server in a confined environment. For device management, the profile of client access is typically well known, and the profile of malicious attacks are well outside this profile. The profile includes the rate of accesses, the type and size of requests.

The Ioto web server has a set of configuration file properties that allow you to define a sandbox which specifies how Ioto must be used for a request to be serviced. By using a well defined sandbox, you can minimize the chance that your application will be compromised by malicious requests. You should customize the sandbox limits to use minimum values and thus provide the most protection.

### Security Limits and Timeouts

The Ioto security limits can be used to effectively block some denial of service attacks. Limits should be set as low as possible while still permitting all valid requests and workloads.

Setting the LimitRequestsPerClient to a low value can restrict the ability of a malicious client to monopolize the server. One attack method for denial of service attacks is to initiate requests, but not conclude the request headers. The server is then forced to wait for the client to complete the request before it can act. However, setting the RequestParseTimeout directive to a low value will abort such requests and prevent such attacks.

Ioto can monitor sandbox limits and trigger defensive responses if access is outside defined norms. See the <a href="#dos">Denial of Service</a> section for more details.

## Sandbox Limits

The additional sandbox [limit](./properties.md#limits) properties are:

| Limit | Description |
|-|-|
| limits.body | Maximum size of the incoming request body for POST and PUT requests. Does not include file upload size. |
| limits.form | Maximum size of request form data (POST request using URL form encoding). |
| limits.header | Maximum size of the request headers |
| limits.upload | Maximum size of a file upload request |

## Timeout Properties

The important Ioto security [timeout](./properties.md#timeouts) properties are:

| Timeout | Description |
|-|-|
| timeouts.inactivity | Maximum request and connection inactivity duration. This can be defined per route, so if you have a long running request, create a dedicated route for that request. |
| timeouts.parse | Maximum duration to parse the request headers. This should be set very short. Typically a browser will send all the request headers in one network packet. Recommended value is 5 secs. |
| timeouts.request | Maximum request duration. Set this to the maximum time a request can take. This can be defined per route, so if you have a long running request, create a dedicated route and RequestTimeout for it. |

See the [Limit Properties](./properties.md#limits) and [Timeout Properties](./properties.md#timeouts) documentation for further details.

## Ioto User Account

It is important that you run Ioto with the lowest system privilege that will get the job done. If any application is compromised, including Ioto, then the system will be safest if the compromised application has as few privileges as possible.

## Unix Account

On Unix, create a dedicated user account and group for Ioto.

## Directory and File Permissions

When Ioto is installed, it is configured for maximum security. This section explains the policy should you need to move or modify files and directories.

To enhance security you need to consider the directory and file permissions for three classes of content:

* Pages served by the HTTP server
* Scripts run by the HTTP server
* Configuration and log files used by the HTTP server.

Pages served by the Ioto server should be owned by root or administrator and should be only readable by the Ioto user account. Directories containing served pages should be readable and executable only.

Scripts run by the Ioto server should always be outside all directories containing served pages. After all, you don't want prying eyes viewing your scripts! Scripts should be owned by the <b>root</b> or <b>administrator</b> and should only be readable and executable by the Ioto user account.

Configuration and log files used by the Ioto server should always be outside all directories containing served pages or scripts. The directory containing the log files must be writable by the Ioto user account.

## Home Directory Permissions

The root directory for Ioto is called the Home directory and is defined by the Home directive in the configuration file. The Home directory, and the logs and lib directory below it, should be owned by <b>root</b> (or admin), and should be in the group <b>root</b> (or administrators). They should only be writable by this specific user and group.

For Linux, these commands will ensure the privileges are correctly set up:

```bash
cd    /etc/ioto
chown root .
chgrp root .
chmod 755  .
cd    /var/www/ioto
chown root .
chgrp root .
chmod 755  .
```

## Chroot Jail

One of the best forms of isolation for the server is to run inside a <a href="http://en.wikipedia.org/wiki/Chroot">chroot</a> jail. A chroot jail is when an application changes its root directory to be isolated from the real file system root directory. Any access then to files outside the jail is protected and impossible. Ioto supports chroot jails via the **chroot** command.

## Securing TLS

It is important to select a sufficiently long key length and strong cipher to protect TLS communications. It is recommended to use the AES cipher and avoid the older RC4 cipher suite. See the section below regarding <a href="#threats">Common Security Threats</a> for threats against the RC4 ciphers.

## TLS Forms

A common practice is to use HTTP for regular communications and to post login forms using TLS. However, this approach is flawed. The web form itself must be served using TLS as well as the URL receiving the login information. This prevents attackers injecting code into the form and hijacking login credentials.

For more information regarding TLS, please read:

* <a href="tlsOverview.html">TLS Overview</a>
* <a href="tls.html">Configuring TLS</a>

## Authentication

It is important to adequately secure all passwords stored at the server. Simply hashing the passwords with MD5 is insufficient as MD5 and other "fast" hashing techniques can be quickly compromised by dedicated password cracking and hashing tools.

Ioto includes the SHA256 and Blowfish/Bcrypt ciphers as an alternative that are more secure than MD5. The <a href="http://en.wikipedia.org/wiki/Blowfish_(cipher)">Blowfish</a> cipher is especially well suited for password hashing partly. Partly because it is slow, it does not easily succumb to brute-force cracking.

If using a web page for users to submit their credentials, it is strongly recommended that you use TLS for both the web form page and for the request validating the user credentials.

Lastly, remember to define routes to restrict access to content that should only be served to certain users. Otherwise those pages will also be visible via the default server.


## Log Files

Ioto will log satisfied requests to the access log (usually logs/access.log) and errors to the error log (usually logs/error.log). It is recommended that you regularly review these logs for suspicious activity.


## Common Security Threats

This section details some common security threats and issues and the steps you can take to mitigate them.

## Server Information Disclosure

HTTP responses often disclose information that an attacker can use to refine their attack. At a minimum, too much information enables the attack to proceed faster. Ioto minimizes these disclosures and does not emit a **Server** HTTP header and strives to minimize unnecessary disclosures in responses. In cases where an illegal request is detected, Ioto will simply disconnect the client without issuing a response.

## Mixed Transports

Is is a bad idea to mix secure and non-secure content in one page. This means a web page should be totally served by HTTP or by HTTPS but not mix transports on one page. The reason is that a page served by HTTP can be compromised and the guarantee of HTTPS and that green-browser https logo is diminished if the form page from which the user enters there data is not 100% trust-worthy.

Ioto can support the "Strict-Transport-Security" HTTP response header. This header instructs the browser that all connections thereafter must only request over HTTPS. The specified age limit is in seconds To enable this, use the following directive:

```js
web: {
    headers: {
        'Strict-Transport-Security': 'max-age="31536000"',
    }
}
```

## Denial of Service

Denial of service attacks can be difficult to detect and defend against. However, Embedded devices typically have a well defined, understood and anticipated work load. Unlike enterprise system, which have highly variable work loads, embedded systems typically serve a specific purpose with known clients that follow a more predictable access pattern. This allows an embedded system to define a range of operation that is considered "normal" and to trigger alerts and defenses if access is outside of this "normal" operation.

## Cross Site Scripting

Cross-site vulnerabilities have ballooned over recent years. Unfortunately, there is no, single complete cure. However, Ioto supports the <a href="http://en.wikipedia.org/wiki/Content_Security_Policy">Content Security Policy (CSP)</a> scheme that can go a long way to reduce the exposure. It does this by exactly specifying and restricting what cross-site access is permitted.

The following Ioto directive enables the Content Security Policy and restricts all access to the origin site. This is a good starting point.

```js
{
    web: {
        headers: {
            "Content-Security-Policy":  "default-src 'self'"
        }
    }
}
```

See <a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/">An introduction to Content Security Policy</a> for more information.

## Cross Site Sharing

Cross origin sharing is often required when using XMLHttp (Ajax) requests to communicate with another server. <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross Origin Resource Sharing (CORS)</a> is a mechanism that allows scripts to make XMLHttp requests to another domain different from that which served the web page. This relaxes the same-origin policy of the browser, but in a controlled manner.

```js
headers: {
    CrossOrigin: "origin=* credentials=yes headers=X-CORS-HEADER age=3000",
}
```


## Hidden Frames

Hidden frames may be inserted by attackers to provide a launch-pad for running malicious scripts. Denying the ability to run frames can close of this attack vector.

The following Ioto directive will prevent frames or iframes from running in the web page.

```http
Header set X-Frame-Options deny
```

```js
headers: {
    "X-Frame-Options": "deny",
}
```

## High Profile Threats

There have been several high profile exploits that pose specific risks and have captured media attention. These are addressed specifically below with details on how to mitigate their effects.

## Crime Exploit

The <a href="http://en.wikipedia.org/wiki/CRIME_(security_exploit)">Crime Security Exploit</a> attacks and exploits leakage of information due to the varying effectiveness of TLS compression.

* Access to intercept and redirect client communications
* Ability to initiate requests from the client
* Encrypted communications TLS/SSL
* TLS level compression

By default, Ioto does not use TLS with TLS compression and is thus not vulnerable to this exploit. If you are using OpenSSL, the OpenSSL SSL_COMP_add_compression_method will enable TLS compression, so it is important not to use this OpenSSL API.

## Breach Exploit

The <a href="http://breachattack.com">Breach</a> exploit is a variant of the Crime exploit. It attacks and discovers private server information, such as CSRF tokens, by observing the compression of HTTP responses over TLS. This exploit requires the following to be effective:

* Access to intercept and redirect client communications
* Ability to initiate requests from the client
* Encrypted communications TLS
* Server-side encryption of dynamic responses
* Unmodified inclusion in the response body of client specified query or form data

Ioto does not dynamically compress response content and so is not vulnerable to this exploit.

## Beast Exploit

The <a href="http://en.wikipedia.org/wiki/BEAST_(computer_security)#BEAST_attack">Beast Security Exploit</a> attacks block ciphers used by TLS to access encrypted packets. This exploit requires the following to be effective:

* Use of TLS 1.0. This exploit has been addressed in TLS 1.1 and later.
* Ability to position attacker as man-in-the-middle between server and client
* Encrypted communications TLS
* Using a block cipher.

Notes:

* OpenSSL 0.9.6d and later are not vulnerable.
* Ioto 3.3 and later have shipped with fixed OpenSSL libraries.
* Using RC4 will mitigate the attack if upgrading OpenSSL is not feasible, however this cipher is vulnerable to the Luck 13 exploit described below.

## Lucky 13 Exploit

The <a href="http://www.isg.rhul.ac.uk/tls/TLStiming.pdf">Lucky 13</a> exploit attacks TLS by using varying padding for block ciphers.

This exploit requires the following to be effective:

* Ability to position attacker as man-in-the-middle between server and client
* Encrypted communications TLS
* Using a block cipher.
* Use of the RC4 cipher.

Notes:

* Mitigate by not using an RC4 cipher
* RC4 was not the default cipher in any Ioto release

## Documented Vulnerabilities

Ioto documents discovered security issues in the Builder product security center.

Go to the [Builder Products List](https://admin.embedthis.com/product) to see the product list and product security center.

Specific issue reports are created for all confirmed or erroneous security reports that receive a CVE classification. 

## Other Security References

Some of these articles may provide good background regarding security web servers.

* <a href="http://www.isg.rhul.ac.uk/tls/TLStiming.pdf">http://www.isg.rhul.ac.uk/tls/TLStiming.pdf</a>
* <a href="http://html5sec.org/">http://html5sec.org/</a>
* <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a>
* <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)</a>
* <a href="https://www.owasp.org/images/b/be/Cracking-into-embedded-devices-and-beyond.pdf">https://www.owasp.org/images/b/be/Cracking-into-embedded-devices-and-beyond.pdf</a>
* <a href="http://media.blackhat.com/bh-ad-11/Sutton/bh-ad-11-Sutton_Embeded_Web_Servers_WP.pdf">http://media.blackhat.com/bh-ad-11/Sutton/bh-ad-11-Sutton_Embeded_Web_Servers_WP.pdf</a>
* <a href="http://www.imperialviolet.org/2012/07/19/hope9talk.html">http://www.imperialviolet.org/2012/07/19/hope9talk.html</a>
* <a href="https://www.owasp.org/images/b/be/Cracking-into-embedded-devices-and-beyond.pdf">https://www.owasp.org/images/b/be/Cracking-into-embedded-devices-and-beyond.pdf</a>


## Ioto Secure By Default

Ioto is designed to be secure by default. This means that the default configuration enables security best-practices to limit cross-site-scripting vulnerabilities. It also implies a fairly restrictive security sandbox. This default configuration may be a little too restrictive for your application. In that case, you can easily remove or override these defaults by the relevant Ioto configuration properties.

Ioto uses the following built-in configuration for the default route.

```js
{
    headers: {
        "X-XSS-Protection": "1; mode=block",
        "X-Frame-Options": "deny",
        "X-Content-Type-Options": "nosniff",
        "Content-Security-Policy": "default-src 'self'",
    }
    timeouts: {
        inactivity: "30 secs",
        parse: "5 secs",
        request: "5 mins",
        session: "5 mins",
    }
    limits: {
        body:               "100K",
        connections:        50,
        form:               "10K",
        header:             "10K",
        sessions:           20,
        upload:             "1MB",
    }
}
```

The default Content Security Policy header is set to only permit content loaded from the server running ioto. It also bans inline scripts as these are vulnerable to inline script injection. See <a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/">An Introduction to Content Security Policy</a> for more information.
# Server WebSockets 

The Ioto web server supports WebSockets for bidirectional, full-duplex communications over persistent TCP/IP connections. A WebSocket connection is established over a standard HTTP connection using a GET request and is then upgraded without impacting the original connection. 

Read the [WebSockets Library](/agent/websockets/) for background first.

## Configuration

To configure WebSockets in the web server, define a request route for web sockets requests. This route ill use a unique URI prefix for WebSocket communications and configure the `action` handler to be invoked upon receipt of a connection requeset.

```
routes: [
    { match: '/upload/', methods: ['DELETE', 'GET', 'PUT'] },
    { match: '/ws/', methods: ['GET'], handler: 'action' },
    { /* Catch all */ },
],
```

WebSockets is configured via several `web.json5` configuration directives.

Path | Default | Description
-|-|-
limits.maxMessage | MAXINT | Define the maximum message size.
limits.maxFrame | 131072 | Define the maximum frame size.
webSockets.ping | none | Define the ping keep-alive message frequency.
webSockets.protocol | chat | Define the application-level sub-protocol.
webSockets.validateUTF | true | Enable validation of UTF8 message.

When WebSockets messages are sent, they may be divided into frames. On receipt, the client will aggregate into a unified message.

## API Quick Tour

This is a quick tour of the WebSockets server API.

When a WebSockets connection request is received by the Ioto web server, the HTTP `upgrade` header will instruct Ioto to upgrade the connection to use WebSockets.

To respond to the connection, you should define an `action` routine to be invoked when the connection is established. To define the action function, specify the request URL and provide the function to invoke. This definition should be placed in your Ioto `ioStart` routine.

```c
webAddAction(host, "/test/websockets", myAction, NULL);
```

When a WebSockets request is received, your `myAction` function will be invoked:

```c
static void myAction(Web *web)
{
    webAsync(web, onRead, web);
    //  Run web sockets until closed and invoke onEvent for each incoming message and event
    if (webWait(web, onEvent) < 0) {
        //  Error
    }
    // Closed
}
```

The `webAsync` routine defines a callback routine to invoke for incoming WebSocket messages, errors and connection events. The `webWait` routine blocks until the WebSocket connection is closed.

If the connection is closed, `webWait` will return a value <= 0. If less than zero, the socket was closed due to an error. If the API returns zero, the connection has been orderly closed.

```c
void onEvent(WebSocket *ws, int event, char *buf, ssize len, void *arg)
{
    switch (event) {
    case WS_EVENT_OPEN:
    case WS_EVENT_CLOSE:
    case WS_EVENT_ERROR:
        break;

    case WS_EVENT_MESSAGE:
    case WS_EVENT_PARTIAL_MESSAGE:
        printf("Received %s\n", buf);
        webSocketSend(ws, "%s", "Response message");
        break;
    }
}
```

To send a message to the peer, use `webSocketSend`:

```c
//  Send a message to the client
webSocketSend(web->webSocket, "WebSocket connected");
```

To close the connection, you can call `webSocketSendBlock` with a close message type.

```c
webSocketSendClose(web->webSocket, status, reason);
```

or alternatively, call `webFinalize` which will close the HTTP connection and the WebSocket connection.

```c
webFinalize(web);
```

## Keep Alive

To keep a communications channel alive, it is sometimes necessary to send regular messages to indicate the channel is still being used. Some servers, browsers, or proxies may close an idle connection. The Ping/Pong WebSockets messages are designed to send non-application-level traffic that will prevent the channel from being prematurely closed.

Automatic ping message can be sent from the web server by setting the `webSockets.ping` directive to the desired frequency. For example:

```json5
webSockets {
    ping: "1min"
}
```

## Timeouts

The standard Ioto request and inactivity timeouts can be used for WebSocket communications by defining the `timeouts.request` and `timeouts.inactivity` web.json5 directives. These are the same request and inactivity timeouts used for ordinary requests. 

You can extend the timeouts by calling `webUpdateDeadline` in your `onRead` callback whenever a message is received or sent.

```
timeouts: {
    inactivity: '5 mins',
    request: '1 hour',
},
```

## API

* [WebSockets API](/agent/ref/api/websockets.md)

## References

- [RFC 6455](http://tools.ietf.org/html/rfc6455) - The WebSockets Protocol
- [WebSocket API](http://dev.w3.org/html5/websockets/) - The Javascript WebSockets API
- [WebSockets Wikipedia](http://en.wikipedia.org/wiki/WebSocket) - WebSockets Wikipedia# Growable hash table

Simple hash table that can store arbitrary objects associated with string names.

## API Quick Tour

To create a hash table:

```c
RHash *table = rAllocHash(size, 0);
```

To free the table:

```c
rFreeHash(table);
```

To add a name and value to the hash:

```c
RName *name = rAddName(table, "some-name", value, flags);
```

To lookup a name, use:

```c
void *value = rLookupName(hash, "some-name");
```

To remove a name, use:
```c
rRemoveName(table, "some-name");
```

To iterate over hashed names:

```c
RName *item;
for (ITERATE_NAMES(table, item)) {
    printf("Item %s has value %s", item->name, item->value);
}
```
# File

Ioto provides some simple helper functions to read and write files.

To read a file in one go:

```c
ssize   size;

char *data = rReadFile("file.txt", &size);
```

To write a file:

ssize length = rWriteFile("file.txt", data, dataLen, 0644);
```c

```

To get the current working directory:

```c
char dir = rGetCwd();
```

To get the base directory containing the application executable:

```c
char dir = rGetAppDir();
```


To join two file paths:

```c
PUBLIC char *rJoinFile(cchar *base, cchar *other);
```

To matach a file against a glob pattern. This tests a filename against a file pattern that list may contain the wildcards: "?" Matches any single character, "*" matches zero or more characters of the file or directory and "**"/ matches zero or more directories

```c
if (rMatchFile("file.text", "*.txt")) {
    //  Matches
}
```

To get a list of files in a directory or subdirectories that match the given wildcard pattern.

```c
RList *list = rGetFiles("/somedir", "*.txt", 0);
```

To walk a directory tree and invoke a callback for each path that matches a given pattern.

```c
rWalkDir("/dir", "*.txt", fn, arg, 0);
```

To get a temporary filename:

```c
char *path = rGetTempFile("/tmp", "TEMP-");
```

This returns a temporary filename in /tmp starting with the "TEMP-" prefix.
# String

The Ioto runtime provides a suite of "safe" string handling routines.

These help guard against buffer overflows and NULL dereferencing errors.

The strings are all NULL tolerant and will not crash when passed NULL arguments. For example, copying a NULL string will return an empty string and searching for a pattern in a NULL string will return false.

The string routines all use a "s" prefix.

## API Tour

There are many (many) runtime string routines. Here is a short sampling:

Search for a character in a string (strchr):

    char *ptr = schr(str, '\n');


Clone (duplicate) a string (strdup):

    char *ptr = sclone(str);

Get the length of a string (strlen):

    ssize length = slen(str);

Check if a string contains a pattern (strstr):

    char *ptr = scontains(str, "abc");

Format a string (sprintf):

    char *str = sfmt("Hello %s", "world");

Join two strings

    char *result = sjoin("one", "two", NULL);

Get a title case string (Leading cap):

    char *str = stitle("pool")

Trim a string of certain characters:

    char *trimed = strim(str, " \t\n\r", R_TRIM_BOTH);


## API Reference

The full API is specified here:

[String API](/agent/ref/api/r.md#rstring)
# Sockets

The Ioto agent provides a cross platform Socket abstraction to make network programming easier and simpler.

The Socket API is fiber aware in that blocking API calls will transparently resume other waiting fibers while waiting for I/O. This enables a simple, straight-line procedural programming style without ugly callbacks or complex threads. See [Fiber Coroutines](../dev/fiber.md) for more details.

All the socket APIs must be called from a fiber.

## API Tour

First you need a socket object. To allocate a socket object:

```c
RSocket *sock = rAllocSocket();

//  and to free

rFreeSocket(sock);
```

### Connecting

To connect to a host or IP address:

```c
int status = rConnectSocket(sock, "www.example.com", 80, 0);
if (status < 0) {
    //  error connecting
}
```

### Listening for Connections
To listen for connections:

```c
rListenSocket(sock, NULL, 80, connectionHandler, data);
```

The second argument is the IP address(s) on which to bind. If NULL, the socket listens on all interfaces.


### Testing the Socket

To test if the socket is closed:

```c
if (rIsSocketClosed(sock)) {
    //  Socket is closed
}
```


To test for end-of-file. i.e. if the peer has closed the other end of the socket:

```c
if (rIsSocketEof(sock)) {
    //  No more data
}
```


To determine if a socket is using TLS. i.e. is secure:

```c
if (rIsSocketSecure(sock)) {
    //  Connection is using TLS
}
```


### Closing the Socket

To close a socket:

```c
rCloseSocket(sock);

//  Still need to free the socket resources
rFreeSocket(sock);
```

### Reading Data

To read from a socket. The read call will return with whatever bytes are available. If none is available, this call will block and yield the current fiber and resume another fiber. When data is available, the call will resume.

```c
ssize count = rReadSocket(sock, buf, sizeof(buf), deadline);

The last argument to rReadSocket (and some other Socket APIs) is a deadline. This is time at which the read request should be aborted. Note: this is not a timeout value, but rather a time value.

Use the following to get a deadline of 30 seconds.

```c
Time deadline = rGetTime() + (30 * 1000);
```

Set the deadline to zero to use the Ioto default deadline timeout which is infinite.

### Writing Data

To write to a socket:

To write a block of data to a socket, use rWriteSocket. If the socket is in non-blocking mode (the default), the write may return having written less than the required bytes. If no data can be written, this call will yield the current fiber and resume another fiber. When data is available, the call will resume.

```c
ssize count = rWriteSocket(sock, buf, bufSize, deadline);
```


### Using TLS
To configure the socket TLS certificates, use rSetSocketCerts:

```c
rSetSocketCerts(socket, privateKey, certificate, authority, revoke);
```

To select the preferred ciphers:

```c
rSetSocketCiphers(sock, cipherList);
```

To control how the Socket will verify peers:

```c
rSetSocketVerify(sock, verifyPeer, verifyIssuer);
```

## API Reference

The full API is specified here:

[Socket API](/agent/ref/api/r.md#rsocket)
# Buf - Dynamic Buffer Module

The RBuf module is a flexible, dynamic growable buffer structure that is ideal as a network and file buffer.

RBuf has start and end pointers to the data buffer which act as read/write pointers. Routines are provided to get and put data into and out of the buffer and automatically advance the appropriate start/end pointer. By definition, the buffer is empty when the start pointer == the end pointer.

Buffers can be created with a fixed size or can grow dynamically as more data is added to the buffer.

For performance, the specification of RBuf is deliberately exposed. All members of RBuf are implicitly public. However, it is still recommended that wherever possible, you use the accessor routines provided.

## Features

* Dynamically growable memory buffer
* Routines to get references to start and end pointers
* Option to null terminate the buffer
* Formatted add to buffer

## RBuf

The RBuf definition is:

```c
typedef struct RBuf {
    char *buf;      /**< Actual buffer for data */
    char *endbuf;   /**< Pointer one past the end of buffer */
    char *start;    /**< Pointer to next data char */
    char *end;      /**< Pointer one past the last data character */
    ssize buflen;   /**< Current size of buffer */
} RBuf;
```

## API Quick Tour

To create a buffer with an initial size. Set the size to zero for a default size of 4K.

```c
#include "r.h"

RBuf *buf = rAllocBuf(initialSize);

// and to free the buffer

rFreeBuf(buf);
```

To add data to the buffer. It will automatically grow as required.
```c
rPutStringToBuf(buf, "Hello World");
rPutFmtToBuf(buf, "My favorite number is %d", 42);
rPutBlockToBuf(buf, data, dataLen);
```

To get the buffer length

```c
ssize length = rGetBufLength(buf);
```

Note: ssize is a typedef from "osdep.h" for ssize_t which is a 64-bit signed quantity.

To add a NULL character to the buffer without moving the end pointer. i.e.

```c
rAddNullToBuf(buf, data, dataLen);
```

To explicitly grow the buffer:

```c
rGrowBuf(buf, 8000);
```

To see how much space is available in the buffer. This is (endbuf - end).

```c
ssize available = rGetBufSpace(buf);
```

To get a reference to the end of the buffer:

```c
cchar *ptr = rGetBufEnd(buf);

//  and to the start
ptr = rGetBufStart(buf);
```

To adjust the start or the end:

```c
rAdjustBufEnd(buf, amount);
rAdjustBufStart(buf, amount);
```

To copy data out of the buffer, reference the start pointer and adjust:

```c
ssize count = rGetBufLength(buf);
memcpy(rGetBufStart(buf), count);
rAdjustBufEnd(buf, count);
```

To empty the buffer:

```c
rFlushBuf(buf);
```

## API Reference

The full API is specified here:

[Buf API](/agent/ref/api/r.md#rbuf)
# List

The RList module is a simple growable list suitable for storing simple primitive data values or pointers to arbitrary objects.

## API Tour

To create a list:

```c
#include "r.h"

RList *list = rAllocList(initialSize, flags);
```

Lists can be created so that when the list is freed, each of the list items will also be freed.
If the `flags` are set to R_DYNAMIC_VALUE, then rFree() will be called on each list item when the list is freed. If the flags are set to R_STATIC_VALUE (the default), then list items will not be freed.

To free a list:

```c
rFreeList(list);
```

To add an item to the end of the list:

```c
rAddItem(list, myObject);
```

To clear the list:

```c
rClearList(list);
```

To get the number of items in the list:

```c
ssize length = rGetListLength(list);
```

To iterate over items in a list:

```c
void *item;
int index;
for (ITERATE_ITEMS(list, item, index)) {
    //  Process item
}
```

ITERATE_ITEMS is defined as:

```c
#define ITERATE_ITEMS(list, item, index) \
    index = 0; \
    list && index < list->length && ((item = list->items[index]) || 1); \
    index++
```

To get an item from the list at a specific index position:

```c
int index = 4;
rGetItem(list, index);
```

To insert an item at a specific position. This will insert myObject at index 4.

```c
rInserItemAt(list, 4, myObject);
```

To remove an item:

```c
rRemoveItem(list, myObject);

//  or remove at an Index
rRemoveItemAt(list, 4);
```

To grow a list:

```c
rGrowList(list, 1000);
```

To push and pop items:

```c
rPushItem(list, item);
item = rPopItem(list);
```

## API Reference

The full API is specified here:

[List API](/agent/ref/api/r.md#rlist)
# Thread

Ioto is single threaded and uses fiber coroutines for parallelism. Ioto is not thread safe and you cannot call Ioto APIs from program threads without ensuring all access to Ioto data structures are serialized via thread locks.

Ioto provides a cross platform thread library so you can create threads and implement appropriate locks.

NOTE: this is not a recommended design pattern. It is simpler, faster and more reliable to use fiber coroutines that to use threaded programming.

# API Tour

## Locking

To create a lock:

    RLock *lock = rAllocLock();

and to free a lock

    rFreeLock(lock);

To assert a lock, use **rLock**. This will block the current thread until resumed.

NOTE: do not use this call in a fiber.

    rlock(lock);

To unlock:

    runlock(lock);

To try for a lock without waiting or blocking:

    if (rTryLock(lock)) {
        //  Got the lock
    }

## Spin Locks

Ioto also provides spin locks which may be faster on some operating systems:

```c
rSpinLock(lock)
rSpinUnlock(lock)
```


## API Reference

The full API is specified here:

[Buf API](/agent/ref/api/r.md#rbuf)
# Logging Trace

If you are using a dedicated device cloud running in your AWS account, Ioto provides a convenience wrapper to make uploading log files to AWS CloudWatch logs easier.

The purpose of the error log is to record essential configuration and error conditions. Per-request log typically is sent to a separate log.

The default log file captures log messages issued throughout the various Ioto modules and writes them to the default log file. Log typically is enabled in both debug and release builds and may be controlled via the build compile define ME_R_LOGGING which is typically set to true.

Log messages should be a single text line to facilitate machine processing of log files.

## API Tour

To write an informational log message to the error log file.

```c
rlog("info", "my-module", "Log message: %s", "Hello World");
```

The Ioto runtime defines four convenience routines for logging:

```c
rDebug("my-module", "Status code at %d is %d", __LINE__, status);
rError("my-module", "Bad error: %d", code);
rFatal("my-module", "Insufficient resources, cannot continue");
rInfo("my-module", "Connected to server");
rTrace("my-module", "Active user count %d", count);
```

The convenience routines wrap rlog() and supply the first argument which is the message type. You can create custom types just by using them with rlog(). These standard types are provided: debug, error, fatal, info and trace.

The debug type is for trace trace that should only be emitted in debug builds. The fatal type will cause Ioto to immediately exit. Trace is for more verbose messages that are not emitted by default in production builds but can be enabled at runtime.


### Changing Levels

To change which messages are emitted by Ioto, you can define the log filters via the Ioto command line and via the **rSetLog** API.

To change the default Ioto log trace settings, customize the **ioto.json5** **trace** property:

```js
trace: {
    path: '/var/log/ioto.log',
    format: '%D %H %A[%P] %T %S %M',
    types: 'error,info',
    sources: 'all',
}
```

See the [Trace Configuration](../user/properties.md#trace) for details.

You can also change trace levels via the command line. This will override the **ioto.json5** trace settings. See the [Ioto Trace Command Line](../user/running.md#logging-and-tracing) for information.

Via the API, you can override log settings:
```c
rSetLog("/tmp/newlog.out:all:all", "%D %H %A[%P] %T %S %M", 1);
```

This will direct log output to newlog.out for all types and all sources.

### Log Handlers

You can also override Ioto's log handling and define your own log handler routine that will be invoked to process log messages.

```c
rSetLogHandler(myLogHandler);
```

This routine will be invoked for all log messages with the type, source and message parameters.


## API Reference

The full API is specified here:

[Log API](/agent/ref/api/r.md#rlog)
# Ioto Safe Runtime (R)

Ioto is built upon a safe portable runtime (R). This layer insulates the rest of Ioto from the underlying platform and allows it to be highly portable to new operating systems or hardware.

![Ioto Architecture](/images/ioto/ioto-agent.png)

The safe runtime provides a suite of services that facilitate the creation of high performance, non-blocking management applications by providing: fiber coroutines, lists, hashing, safe strings, buffering, timers, events, networking, buffer management and JSON parsing.

The safe runtime provides a more secure environment in which to program as it replaces 'C' APIs that are prone to buffer overflows and other similar security exploits. The safe runtime includes a fast, safe string library that supports a secure programming style.

# Ioto Types

The Ioto Agent uses an operating system dependent layer called "osdep".

By including "osdep.h", you gain access to these cross-platform types. Some types are implemented natively on some platforms and others are provided by "osdep".


## Quick Tour

Here are some primitive data types:

```c
bool   b;
int8   i8;
int16  i16;
int32  i32;
int64  i64;
uint8  u8;
uint16 u16;
uint32 u32;
uint64 u64;
schar  c;      //  Signed char
uchar  c;      //  Unsigned char
cchar  c;      //  Const char
cuchar  c;     //  Const unsigned char
```

Other useful types:

```c
ssize   length;     //  64-bit signed length
Time    time;       //  Time in milliseconds since Jan 1, 1970
Ticks   ticks;      //  Elapsed time in system millisecond ticks (never goes backwards)
```

For a full list of the osdep types, see: [OSDEP API](/agent/ref/api/osdep.md)


## Return Values

Many Ioto APIs return an integer value that is zero for success and otherwise set to a negative error code.

Here are the return codes used by the Ioto runtime:

```c
#define R_ERR_OK              0
#define R_ERR_BASE            -1
#define R_ERR                 -2
#define R_ERR_ABORTED         -3
#define R_ERR_ALREADY_EXISTS  -4
#define R_ERR_BAD_ACK         -5
#define R_ERR_BAD_ARGS        -6
#define R_ERR_BAD_DATA        -7
#define R_ERR_BAD_FORMAT      -8
#define R_ERR_BAD_HANDLE      -9
#define R_ERR_BAD_NULL        -10
#define R_ERR_BAD_REQUEST     -11
#define R_ERR_BAD_RESPONSE    -12
#define R_ERR_BAD_SESSION     -13
#define R_ERR_BAD_STATE       -14
#define R_ERR_BAD_SYNTAX      -15
#define R_ERR_BAD_TYPE        -16
#define R_ERR_BAD_VALUE       -17
#define R_ERR_BUSY            -18
#define R_ERR_CANT_ACCESS     -19
#define R_ERR_CANT_ALLOCATE   -20
#define R_ERR_CANT_COMPLETE   -21
#define R_ERR_CANT_CONNECT    -22
#define R_ERR_CANT_CREATE     -23
#define R_ERR_CANT_DELETE     -24
#define R_ERR_CANT_FIND       -25
#define R_ERR_CANT_INITIALIZE -26
#define R_ERR_CANT_LOAD       -27
#define R_ERR_CANT_OPEN       -28
#define R_ERR_CANT_READ       -29
#define R_ERR_CANT_WRITE      -30
#define R_ERR_DELETED         -31
#define R_ERR_MEMORY          -32
#define R_ERR_NETWORK         -33
#define R_ERR_NOT_CONNECTED   -34
#define R_ERR_NOT_INITIALIZED -35
#define R_ERR_NOT_READY       -36
#define R_ERR_READ_ONLY       -37
#define R_ERR_TIMEOUT         -38
#define R_ERR_TOO_MANY        -39
#define R_ERR_WONT_FIT        -40
#define R_ERR_WOULD_BLOCK     -41
#define R_ERR_MAX             -42
```

## NULL Tolerance

Ioto adopts a technique call NULL tolerance where APIs, wherever possible, tolerate NULL arguments and attempt to do something reasonable with their arguments, rather than crashing the applications.

The standard C library is not NULL tolerant. If you pass a NULL pointer to routines such as as free() or strlen() your program will crash.

The Ioto memory allocator is NULL tolerant when calling **rFree**. Similarly, Ioto provides a safe string library that will accept NULL arguments wherever possible. In the case of strlen, Ioto provides **slen()** which will return zero if passed a NULL pointer.
# Time

Ioto provides a suite of time management routines to help format, parse and manage time values.

Ioto stores calendar time in **Time** values that store the date/time as elapsed milliseconds since Jan 1, 1970. Time values may go backwards if the system date clock is adjusted.

Ioto stores system time in **Ticks** values that are a system representation of elapsed time in milliseconds. Ticks will never go backwards even if the system date clock is adjusted.

## API Tour

To get the current time:

    Time time = rGetTime();

To get the current time in ticks:

    Ticks ticks = rGetTicks()

To get a high resolution CPU tick counter on some systems:

    uint64 rGetHiResTicks();

To convert the time to a string local time representation:

    char *str = rFormatLocalTime("%a %b %d %T %Y %Z", time);

To convert to universal time:

    char *str = rFormatUniversalTime("%FT%TZ", time);

To get a local string representation of the current date:

    char *str = rGetDate(NULL);

To get an ISO format date:

    char *str = rGetIsoDate(time);

To get the elapsed time since a prior measurement:

    Ticks elapsed = rGetElapsedTicks(mark);

To get the remaining ticks until a timeout:

    Ticks remaining = rGetRemainingTicks(mark, timeout);

To parse an ISO date string:

    Time time = rParseIsoDate(isoDateString);

## API Reference

The full API is specified here:

[Time API](/agent/ref/api/r.md#rtime)
# Event

R provides a simple eventing mechanism to schedule events to run at some time in the future.

Events are described by REvent objects which are created and queued via #rCreateEvent. Events are scheduled once unless restarted via rRestartEvent.

## API Tour

To create an event to run a function at some delay in the future.

```c
Ticks delay = 1000;
REvent event = rCreateEvent(fn, data, delay);
```

This will run the fn() function in 1 second and pass the reference data as an argument.

```c
void fn(void *data) {
    //  Do something
}
```

The rCreateEvent API will return an event ID that can be used to cancel the event before it is run by calling **rStopEvent**.

```c
rStopEvent(event);
```

You can lookup an event to see if it is scheduled:

```c
if (rLookupEvent(event)) {
    //  scheduled
}
```

## Running Events

The Ioto main program calls the **rServiceEvents()** API to run scheduled events as they come due.

This call will call rRunEvents() to run due events and then wait via **rWait** for any pending I/O.

If you replace the Ioto main program, you must call rServiceEvents in your main.

## Watching for Conditions

You can watch for certain conditions to happen and be notified when they do. For example, it can be useful to be notified when the network connects or disconnects to the cloud.

To watch for a condition:

```c
rWatch("mqtt:connect", fn, data);
```

To then signal a condition, call:

```c
rSignal("mqtt:connect", arg);
```

This will invoke fn() with the watch data and the signal argument.

```c
void fn(void *data, void *arg) {
    //  Do something
}
```

To disable watching, call:

```c
rWatchOff("mqtt:connect", fn, data);
```

This will disable the watch registered with exactly the same arguments.
# Use Cases

The Ioto device agent can be utilized in a variety of use cases:

- [IoT Cloud Agent](#iot-cloud-agent)
- [HTTP Client](#http-client)
- [Local Device Management](#local-device-management)
- [Embedded Web Server](#embedded-web-server)
- [MQTT Client](#mqtt-client)

## IoT Cloud Agent

Device management via the cloud typically requires the MQTT protocol and an understanding of the MQTT topics supported by cloud provider.

The Ioto agent is pre-integrated with the AWS Cloud and is easily configured to enable MQTT communications with AWS IoT Core.

Ioto supports a wide set of AWS services including: DynamoDB, IoT Core rules, IoT Shadows, S3, CloudWatch Logs, and CloudWatch metrics. Using IoT rules, you can also direct messages and data to many other AWS services.

The Ioto agent can:

- Send messages to AWS IoT and other services via MQTT.
- Upload data and files to AWS S3.
- Replicate structured device data to and from AWS DynamoDB.
- Send control-plane data to AWS IoT Shadows.
- Store Ioto, device and O/S logs in AWS CloudWatch logs.
- Create device and operational metrics in AWS CloudWatch Metrics.
- Save audit trails to AWS CloudTrail.

### Replicated Device Data

Ioto can replicate device data from its internal embedded device database to an AWS DynamoDB database in the cloud. This replication can operate in either direction so that data can be either sent to devices or aggregated from devices.

This replication is reliable and transparent and the device developer does not need create any custom code to implement. The replication is configurable and granular on a table-by-table basis, and is resilient in the event of network outages.

## HTTP Client

Ioto includes a streaming HTTP Client so you can make REST and HTTP requests to external web services.

The API provides a simple GET and POST routines and a powerful fully streaming fetch call.

As Ioto uses fiber coroutines, you can process streamed data (in either direction) without ugly callbacks or complex threads. Other fibers in Ioto continue to run transparently while the HTTP client is waiting for I/O.

Ioto uses the HTTP client to communicate with the EmbedThis Builder site and various AWS services. Ioto includes AWS SigV4 signing APIs so you can issue any AWS API using the HTTP client without requiring the significant overhead of the full AWS SDK.

### Example
```c
//  Simple get
data = urlGet("https://www.example.com");

//  Simple post
data = urlPost("https://www.example.com", "POST", body, bodyLen,
    "Authorization: bearer %s\r\n", authToken);

//  Or fully streaming fetch
char  buf[1024];
ssize nbytes;
int   status;

status = urlFetch(up, "https://www.example.com", "POST", body, bodyLen, headers);
do {
    if ((nbytes = urlRead(up, buf, sizeof(buf))) > 0) {
        printf("%s", buf);
    }
} while (nbytes > 0);
```

## Local Device Management

Embedded web servers are useful for a variety of use cases including:

* Local end-user device setup and ongoing management.
* Provide a programatic REST API for device operation, data and metrics.
* Provide a debug web interface for developers creating connected devices.

## Embedded Web Server

The Ioto agent can be used as a stand-alone embedded web server without any cloud management features enabled.

Ioto can be configured and compiled to run only the web server and thus be a first-class replacement for any embedded web server. EmbedThis has been developing embedded web servers for many years and the Ioto web server contains all that we have learned over this period.

>*Ioto is our best embedded web server with performance and security that surpasses other web servers.*

The Ioto web server is unlike other embedded web servers in that it does not try to offer *ALL* HTTP features and functions. Rather, it implements only the essential core of HTTP/1.1 and thus deliver a tiny, fast, secure embedded web server that is exceptionally good at serving single-page device management web applications and device data APIs with a very small security footprint.

The Ioto web server supports: HTTP/1, HTTP/1.1, TLS/SSL, Action routines, user authentication, sessions, cookie management, request logging, and security sandboxing. Best of all, Ioto is tiny using only 80K of code. It will serve over 3,300 requests/sec on a Raspberry PI class of device.

The Ioto web server is fully streaming for receive and transmit data. It can receive live streaming data and dynamically generate responses based on device data.

### Example
```c
//  Bind a URL to a function to generate the response

webAddAction(host, "/test", testAction);

//  Invoked for /test requests
static int testAction(Web *web)
{
    char  buf[ME_BUFSIZE];
    ssize nbytes;
    int   i;

    //  Streaming read of POST body data
    while ((nbytes = webRead(web, buf, sizeof(buf))) > 0) {
        printf("Got body data %.*s\n", (int) nbytes, buf);
    }

    //  Streaming a response without buffering and with minimal memory footprint
    for (i = 0; i < 10000000; i++) {
        //  This will block as required, but other fibers can still run.
        webWriteFmt(web, "Hello World, now is: %s\n", rFormatLocalTime(0, 0));
    }
    //  Finalize
    webWrite(web, NULL, 0);
    return 0;
}
```

![Ioto Web Server](/images/ioto/web-server.png)

For more details, please read the [Ioto Web Server](../web/).

## MQTT Client

Most IoT cloud management services rely on the [MQTT](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html) protocol.

MQTT is a light-weight client/server publish/subscribe messaging transport protocol. It is simple and has very low overhead and this makes it ideal for use in embedded devices and IoT where a small code footprint and minimal network overhead is required.

For a device to be managed by the cloud requires not only MQTT support, but also an understanding of what MQTT topics are required to integrate with the specific cloud provider.

Ioto has a high-performance, flexible MQTT client that can be used to communicate with any cloud service supporting MQTT 3.2.1.

The Ioto MQTT agent is non-blocking, but also supports a blocking mode where you can wait for a message to be acknowledged or receipt of a response. This enables the MQTT protocol to be used for request/response APIs. Because, Ioto uses fiber coroutines, even when an MQTT sequence of operations are blocking, other APIs and services continue to run in other fibers.

```c
PUBLIC int ioStart(void)
{
/*
    Subscribe for incoming notifications.
    This call will block and wait for acknowledgement.
    Note: call blocks, but agent is not.
 */
mqttSubscribe(ioto->mqtt, incoming, MQTT_QOS_2, MQTT_WAIT_ACK, "/myDevice/change");

/*
    Publish an "initialized" message with quality of service (1) which means send at most once.
    Don't wait for sending or acknowledgement.
 */
mqttPublish(ioto->mqtt, "Initialized", 0, MQTT_QOS_1, MQTT_WAIT_NONE, "/myDevice/init");
```
# WebSockets

[WebSockets](http://en.wikipedia.org/wiki/WebSocket) is a technology providing interactive communication between a server and client. It is an IETF standard defined by [RFC 6455](http://tools.ietf.org/html/rfc6455).

Normal HTTP connections follow a request/response paradigm and do not easily support asynchronous communications or unsolicited data pushed from the server to the client. WebSockets solves this by supporting bidirectional, full-duplex communications over persistent TCP/IP connections. A WebSocket connection is established over a standard HTTP connection using a GET request and is then upgraded without impacting the original connection. This means it will work with existing networking infrastructure including firewalls and proxies.

WebSockets is currently supported in the current releases of all major browsers, including Chrome, Brave, Firefox, Edge, Opera, and Safari.

## Ioto Implementation

Ioto implements WebSockets for both the HTTP web server and for the URL HTTP client. The WebSockets library implements the core WebSockets protocol, handshaking, and provides a C language API. The `web` library accepts incoming HTTP connections and upgrades WebSockets requests via to use the WebSockets protocol. Similarly, the `url` library provides APIs to initiate WebSockets connections via a HTTP client GET request and it then upgrades that connection to use the WebSockets protocol.

The `url` client program supports WebSockets for load testing purposes.

## WebSocket Handshake

A WebSocket connection begins life as a normal HTTP request and is upgraded to the WebSocket protocol. For the web server, the WebSockets connection is activated by a set of WebSocket HTTP headers from the client that describes a desired WebSocket connection. Here is a typical client HTTP request requiring a WebSocket upgrade:

```
GET /websock/proto/msg HTTP/1.1
Host: example.com
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Protocol: chat, better-chat
Sec-WebSocket-Key: 50cLrugr7h3yAbe5Kpc52Q==
Sec-WebSocket-Version: 13
Origin: http://example.com
```

WebSockets constructs a handshake response that includes an accepted key and selected protocol. For example:

```
HTTP/1.1 101 Switching Protocols
Server: Embedthis-http
Date: Sat, 06 Oct 2014 05:10:15 GMT
Connection: Upgrade
Upgrade: WebSocket
Sec-WebSocket-Accept: 58ij/Yod1NTjzqcyjkZbZk6V6v0=
Sec-WebSocket-Protocol: chat
X-Inactivity-Timeout: 600
X-Request-Timeout: 600
```

After the handshake message has been sent, the server is free to send messages to the client. Once the client receives the handshake, it can send messages to the server. Either side can send at any time thereafter. Communications are thus full-duplex.

## Message Types

WebSockets supports several message types:

- Text in UTF-8
- Binary
- Close
- Ping/Pong

### Text Messages

Text messages must be valid UTF-8 strings. The receiving peer will validate and reject non-conforming strings. However, Ioto can be configured to accept invalid UTF-8 strings via the `validate` Ioto directive in the web.json5 configuration file.

### Binary Messages

Binary messages allow the transmission of any content. Messages can be an arbitrary length up to the maximum specified by the WS_MAX_MESSAGE constant or the web.json5 `limits.maxMessage` directive.

When messages are transmitted, they may be divided into frames of no more than the length specified by the WS_MAX_FRAME constant or the web.json5 `limits.maxFrame` directive. Incoming message frames are not subject to this limit. WebSockets will aggregate message frames into complete messages before passing to the `onRead` callback.

### Close Message

Ordinarily, WebSocket communications are terminated by sending a *Close* message. The close message includes a status code and an optional *reason* string to explain why the connection is being closed.

### Ping/Pong Messages

To keep a communications channel alive, it is sometimes necessary to send regular messages to indicate the channel is still being used. Some servers, browsers, or proxies may close an idle connection. The Ping/Pong WebSockets messages are designed to send non-application-level traffic that will prevent the channel from being prematurely closed.

Automatic ping message can be sent from the web server by setting the `webSockets.ping` directive to the desired frequency. For example:

```json5
webSockets {
    ping: '1min'
}
```

## Timeouts

The standard Ioto request and inactivity timeouts can be used for WebSocket communications by defining the `timeouts.request` and `timeouts.inactivity` web.json5 directives.


## Web Server Configuration

See [Web Server WebSockets](/agent/web/websockets.md) for details on how to configure WebSockets in the web server.
See [URL Client](/agent/url/websockets.md) for details on how to configure WebSockets in the URL HTTP client.

## Quick Tour

See [URL Client WebSockets](/agent/url/index.html#api-quick-tour) for a quick tour of the WebSockets client API.

See [Web Server WebSockets](/agent/web/websockets.html#api-quick-tour) for a quick tour of the WebSockets client API.

## API

* [WebSockets API](/agent/ref/api/websockets.md)

## References

- [RFC 6455](http://tools.ietf.org/html/rfc6455) - The WebSockets Protocol
- [WebSocket API](http://dev.w3.org/html5/websockets/) - The Javascript WebSockets API
- [WebSockets Wikipedia](http://en.wikipedia.org/wiki/WebSocket) - WebSockets Wikipedia# Device Configuration

The **device.json5** configuration file contains device identification and descriptive properties to uniquely identify a device. It is used during device registration and cloud provisioning.

The device.json5 contains properties for:

* The device unique ID
* A product token indicating which product on which the device is based
* When the device was made
* Identifying description and model strings
* Whether the device is a test device

You can also add any other properties to the device.json5 that may provide useful device context. These properties will be saved in the cloud device database and will be available to device managers.

**Example**

```js
{
    id: "731KPY4BA6",
    product: "01GHTB33NJZXYZ1XA80GY5SZSN",
    name: "Acme Router",
    created: "2022-12-14T03:20:39.347Z",
    description: "Acme Router for Home Office",
    model: "Office-Hub",
    test: false,
    ports: 16,
    memory: "256MB"
}
```

## created

| Name | created |
|-|-|
| Description | An ISO date for when the device was manufactured. |
| Synopsis | `created: 'ISO Date'`.|

**Example**

```js
created: '2022-12-14T03:20:39.347Z'
```

## description

| Name | description |
|-|-|
| Description | A short description of your product. |
| Synopsis | `description: 'Short sentence'`|
| Notes | This should be a one sentence description of your product.|

**Example**

```js
description: 'Acme Router for Home Office'
```

## id

| Name | id |
|-|-|
| Description | The unique device claim ID. |
| Synopsis | `id: "Unique device ID"` |
| Notes | The <b>id</b> property defines a unique per-device ID. This must be a globally unique ID. This should have a minimum of 80-bits of entropy. For more information, see [Device Serialization](/ioto/provisioning/serialize.html).|

**Example**

```js
id: '731KPY4BA6'
```


## model

| Name | model |
|-|-|
| Description | A product model string. |
| Synopsis | `model: 'Short model string'`|
| Notes | This should be a short identifier that describes your device model type.|

**Example**

```js
model: 'Office-Hub-32'
```


## name

| Name | name |
|-|-|
| Description | The name of your product. |
| Synopsis | `name: 'Few words'`|
| Notes | This should be the short, public name of your product.|

**Example**

```js
name: 'Acme Rocket'
```

## product

| Name | product |
|-|-|
| Description | The product ID token is a Builder token that identifies the product on which the device was based. |
| Synopsis | `product: 'product-id'` |
| Notes | To obtain a product token, use the Builder to create a product definition and then get the **ProductID** token from the token list.|

**Example**

```js
product: '01GHTB33NJZXYZ1XA80GY5SZSN'
```


## test

| Name | test |
|-|-|
| Description | Determine if the device is a test device |
| Synopsis | `test: true | false`|
| Notes | This defaults to false.

**Example**

```js
test: true
```
# Supported Hardware

Ioto is highly portable and runs on a wide variety of operating systems, environment and CPU architectures.  

Ioto has been ported to:

* ESP32
* FreeBSD
* FreeRTOS
* Linux
* Mac OS X
* Quadros
* VxWorks
* Windows on WSL

on the following CPU architectures:

* arm
* arm64
* mips
* mips64
* ppc
* ppc64
* riscv
* riscv64
* tidsp
* sh
* x86
* x64 
* xtensa 

Ioto has also been ported by customers to many other environments including:

* QNX
* Quadros

When porting Ioto to a new environment, Ioto generally requires:

* Flash code storage for ~300K
* Flash file system for embedded database and configuration
* 1-2MB RAM on a 32-bit system that is cloud connected
* Network connection 

The code can be compiled to include only the required components. The size of the flash file system is determined by the size of your device data. The configuration files are typically < 25K.

The RAM requirements are dominated by the TLS package. A typically cloud-networked device will utilize TLS for security and will require 1-2MB of RAM.



## Supported CPU Architectures

### ARM Cortex-A7

Raspberry Pi 2 Model B (Rev 1.1)

Manufacturers:  Broadcom BCM2836

32-bit, quad-core Cortex-A7, commonly used in lower-power applications.

### ARM Cortex-A53

Raspberry Pi 3 Model B, Model B+, Raspberry Pi 2 Model B (Rev 1.2)
64-bit, quad-core Cortex-A53, used in the more powerful, power-efficient Pi models.

Manufacturers: Broadcom BCM2837

Raspberry Pi 3 Model A+. 64-bit, quad-core Cortex-A53, similar to the BCM2837 with slight differences in power management and packaging.

Manufacturers: Broadcom BCM2710A1


### ARM Cortex-A72

Raspberry Pi 4 Model B, Raspberry Pi 400
64-bit, quad-core Cortex-A72, providing substantial performance improvements, capable of running full desktop environments.

Manufacturers: Broadcom BCM2711

### ARM Cortex-A76

Raspberry Pi 5. 64-bit, quad-core Cortex-A76 paired with quad Cortex-A55 cores for big.LITTLE architecture, offering even higher performance with modern architecture.

Manufactuers: Broadcom BCM2712

### ARM Cortex-A15

Raspberry Pi 1 Model A, Model A+, Model B, Zero, Zero W
32-bit, single-core ARM11, based on the older ARMv6 architecture, making it compatible with lightweight applications.

Manufacturer: Broadcom BCM2835 (ARM11)

### ARM Cortex-M Series (M0, M0+, M1, M3, M4, M7, M23, M33, M35P)

Manufacturers: STMicroelectronics, NXP, Microchip (Atmel), Texas Instruments, Renesas, Cypress (Infineon), Silicon Labs, Nordic Semiconductor, GigaDevice, Dialog Semiconductor, Maxim Integrated, Particle, Arduino, Adafruit, SparkFun

### ARM Cortex-R Series (R4, R5, R7, R8)

Manufacturers: NXP, TI (Automotive/Industrial applications)

### ARM7 (ARM7TDMI)

Xtensa LX6/LX7 (32-bit)

Manufacturers: Espressif Systems (ESP32 series: ESP32, ESP32-S2, ESP32-S3, ESP-C)

### AVR32 UC3

Manufacturers: Microchip (Atmel)

### ColdFire V2, V3, V4

Manufacturers: NXP (legacy and industrial systems)

### RISC-V 32-bit

Manufacturers: SiFive, GigaDevice, Espressif (ESP32-C3)

### MIPS32 (32-bit)

Manufacturers: Microchip (PIC32 series)

### Renesas RX (RX100, RX200, RX600)

Manufacturers: Renesas Electronics

### Intel x86 (32-bit, 64-bit)

Manufacturers: Various # Downloading Ioto

Ioto releases are available as source code distributions from the [Builder Site](https://admin.embedthis.com). The Builder portal provides an integrated service for creating connected devices, downloading device software, creating and managing device clouds.

To use Builder, you need to register and create an account. This is a simple, one-time task that will take you just a few minutes.

To register, navigate to the Builder site [https://admin.embedthis.com](https://admin.embedthis.com), and enter your email address and desired password and click on the Register tab.  You will be sent an email confirmation code to complete your builder login.

If you have been invited to a Builder account by a co-worker, please click on the link in the invite email. That will ensure you become a member of the account that invited you.

## Downloading Ioto

To download the Ioto device agent, visit the **Products** page and click on the **Download** icon for the **Ioto Evaluation Product**. This will download the complete Ioto evaluatione source code package.

[Download Source Package](https://admin.embedthis.com)

In the future, you can create a product definition for your product, purchase a subscription and download the release software or any historical device agent version.

You can also download the [**Ioto Apps**](/apps/samples/building.md) package which is a suite of full device management apps.

## Extracting the Ioto Source Code

Copy the downloaded `ioto-eval-src.tgz` compressed tar archive to a suitable directory and extract the contents. This will place the ioto source in a `ioto-1.0.0` directory.

The eval source is a recent release and is always set to verion 1.0.0. It may not include all the latest features and patches that are present in the full release -- but it is ideal for evaluating Ioto.

```bash
$ tar xvfz ioto-eval-src.tgz
x ioto-1.0.0/EVAL.md
x ioto-1.0.0/LICENSE.md
x ioto-1.0.0/Makefile
...
```
# Cross-Compiling Ioto

Building Ioto for platform different to that of the local system is called **cross compiling**. Sometimes this compiling is just for a different instruction set (say x64 instead of x86). Other times, it is for a completely different operating system and/or CPU architecture. In such cases, a cross-compiler is typically required to build for the target platform.

To cross compile, you will typically need to install a cross-compiler tool chain for your target architecture. Once installed and before you attempt to build Ioto, it is best to test compiling a simple, stand-alone *HelloWorld* program to ensure the cross compiler is working correctly.

If you are targeting the popular [ESP32 Architecture](https://www.espressif.com/en/products/socs/esp32) please read the dedicated instructions [Building for ESP32](building-esp32.md).

If you are interested in porting Ioto to a new platform, please read [Porting Ioto](../dev/porting.md).

## Invoking Make

To cross-compile Ioto, invoke the relevant project makefile and pass the required CPU architecture as a make variable. For example, to cross compile for VxWorks on ARM:

```bash
$ make -f projects/ioto-vxworks-default.mk ARCH=arm PROFILE=debug
```

When the project makefile is invoked directly, it will place the output products (executables, libraries and objects) in a platform-specific output directory. This is named using the form: OS-ARCH-PROFILE. For example: vxworks-arm-debug. In this manner, make can be invoked multiple times, once for each target platform and the results will be captured in separate platform output directories. Some of the supported architectures for the ARCH field are:

```
arm, arm64, mips, mips64, ppc, ppc64, riscv, riscv64, sh, sparc, x64, x86 and xtensa.
```

The PROFILE variable is a descriptive name chosen by you for your configuration.

If there is not a makefile for your target operating system, copy the closest makefile and edit to suit your target platform. The project makefiles are generated and are thus highly regular and easy to modify.

## Specifying the CPU

The build will use the generic CPU type within the specified architecture. To override the default choice and specify a CPU type within an architecture, use the CPU variable. For example:

```bash
$ make OS=vxworks ARCH=arm CPU=arm7tdmi
```

## Specifying a Tool Chain

You may need to specify where make can locate your cross-compiler and other tools. You can supply these via the make variables: CC, CFLAGS, DFLAGS, IFLAGS, LD and LDFLAGS. For example:

```bash
$ make CC=/opt/bin/ccarm.exe LD=/opt/bin/ccarm.exe ARCH=arm PROFILE=release \
        -f projects/ioto-vxworks-default.mk
```

# Running Ioto

After building Ioto, the Ioto and other binaries and libraries will be in the **bin** directory.

You may want to add this directory to your shell PATH.
```bash
export PATH=`pwd`/build/bin:$PATH
```
Or you can easily run Ioto via **make run**:

```bash
$ make run
app: info: Starting Ioto 2.1.1, with "standard" app 1.0.0, using "dev" profile
setup: info: Enabling services: db provision register sync serialize test web
app: info: Device Claim ID: M72DANY8BZ
register: info: Device registered with https://api.admin.embedthis.com/api
{
    "product": "01H4R15D3478JD26YDYK408XE6",
    "id": "M72DANY8BZ",
    "created": "2024-01-23T02:03:57.062Z"
}
register: info: Device not yet claimed
web: info: Listening http://:9090
web: info: Listening https://:4443
app: info: Ioto 2.4.0 ready, Device firmware 1.3.0
```

When Ioto runs, it listens on any required HTTP ports (if you are running the web server service) and registers with the cloud. If your selected services enable the web server, Ioto will listen for connections on ports 80 for HTTP and 443 for HTTPS and serve documents from the **./site** directory.

To manage your device from the cloud, read [Managing from the Cloud](../clouds/).


## Ioto Command Line

On Linux or Mac OS X, Ioto is installed by default in the directory /usr/local/lib/ioto. The Ioto binary program is installed at /usr/local/bin/ioto, and the Ioto configuration is at /etc/ioto.

The Ioto command line is:

```bash
ioto [options]
```

## Ioto Command Options

Option | Description
-|-
--account ID | Manager account for self-claiming.
--background | Run Ioto in the background detached from the terminal.
--cloud Token | Cloud claim token for self-claiming.
--config dir | Set the directory for config files.
--configFile | Path to the ioto.json5 configuration file.
--debug | Emit very verbose debug tracing.
--exit event or seconds | Exit on event or after 'seconds'.
--home directory | Change to directory to run.
--id Token | Device claim ID. Overrides device.json5.
--ioto path | Set the path for the ioto.json5 config.
--mode mode | Select execution mode from ioto.json5 (dev,prod).
--nolocal | Do not apply local.json5.
--nosave | Run in-memory and do not save state.
--product Token | Product claim ID. Overrides device.json5.
--profile profile | Select execution profile from ioto.json5
--quiet | Don't show web server headers. Alias for --show ''.
--reset | Reset state to factory defaults.
--show [HBhb] | Show request headers/body (HB) and response headers/body (hb).
--state dir | Directory for the state files.
--test Suite | Run test suite from config/test.json5.
--timeouts | Disable timeouts for debugging.
--trace file[:types:from] | Trace to file.
--verbose | Verbose operation. Alias for --show Hhb plus module trace.
--version | Output version information

When Ioto starts, it reads the **ioto.json5** and other configuration files from the Ioto **config** directory. These are copied at build-time from the **apps/NAME/config** directory.  The **ioto.json5** file defines the default logging and tracing configuration. This can be overridden by command line options and environment variables. See below for details.

See [Configuration Files](./) for details.

## Logging and Tracing

Ioto provides detailed log tracing for all operational aspects of Ioto. 

The Ioto tracing is configured via the **log** property collection in the **ioto.json5** file. 

The **log** property specifies the trace destination via the **path** property. This property can be set to **stdout**, **stderr**, or any filename or **cloud** to send log files to AWS cloudwatch.

```js
log: {
    path: 'ioto.log',
    format: '%D %H %A[%P] %T %S %M',
    types: 'error,info',
    sources: 'all',
},
```

The **format** property specifies how the log messages will be formatted. It contains a printf style string with tokens that are expanded at runtime. The supported tokens are: 'A' for the application name, 'D' for the local datetime, 'H' for the system hostname, 'M' for the trace message, 'P' for the process ID , 'S' for the message source, and 'T' for the trace message type.

### Message Types

Ioto classifies trace messages according to types. The supported types are: debug, error, fatal, info, and trace. The **types** property specifies a comma separate list of trace message types to emit.

### Message Sources

Log messages are emitted from "sources". These are the names of the code module that originate the trace messages. The **sources** property is a comma separated list of sources. Some of the Ioto trace message sources are: "runtime", "tls", "json", "url" and "web".

You can use **"all"** for types and sources to match all types/sources. You can also use "!type" and "!source" to negate a type or source.

For example:

```js
types: 'all,!debug,!trace'
```

This will emit messages of all types, except for debug and trace messages.

### Command Line

The logging configuration defined in the **ioto.json5** file can be overridden via via the **--trace**, **--verbose** and **--debug** Ioto command line options. It can also be overridden via the **LOG_FILTER** environment variable.

The **--trace** option specifies the trace file destination and a list of types and sources.

```bash
$ ioto --trace FILENAME[:TYPES[:SOURCES]]
```

The types are a comma separated list of message types. Valid types include: info, debug, error, trace and all. Sources are the code module names originating the trace messages. You can use "!type" and "!source" to negate a type or source.

For example:

```bash
$ ioto --trace trace.log  # Same as path:trace.log   
$ ioto --verbose          # Same as path:stdout, types:raw,error,info, sources:all
$ ioto --debug            # Same as path:stdout, types:raw,error,info,trace,!debug, sources:all
$ ioto --trace file:all:all 
$ ioto --trace file:all,!debug,!trace:all
```

You can also use the **-v** short cut for **--verbose** and **-d** for **--debug**.

### Trace Environment Overrides

Similar to the command line options, you can override the trace configuration via two environment varables.

Command Line Options | Environment Variable | Description
-|-|-
--trace | LOG_FILTER | Override the log filter definition
--verbose | | Override the log filter definition
--debug | | Override the log filter definition

These variables take the same string values as their command line option counterparts. 

The order of precedence of configuration is:

1. Command line --trace, --debug or --verbose options
2. Environment variable LOG_FILTER, LOG_FORMAT values
3. ioto.json5 configuration

## Web Server Tracing

Ioto provides special control for the web server HTTP request and response tracing. You can selectively trace HTTP request and response headers and bodies via the **show** property.

```js
log: {
    show: 'hB',
    path: 'ioto.log',
    format: '%D %H %A[%P] %T %S %M',
    types: 'error,info',
    sources: 'all',
},
```

The **show** property is a string with the following characters:

Character | Description
-|-
b | Show the response body
h | Show the response HTTP headers
B | Show the client request HTTP body
H | Show the client request HTTP headers
empty | Show no HTTP trace

You can override the **ioto.json5** **show** property configuration via the **--show** Ioto command line option.

For example:

```bash
$ ioto --show hH
```

You can also override the configuration via the **WEB_SHOW** environment variable.

Command Line Options | Environment Variable | Description
-|-|-
--show | WEB_SHOW | Override the **show** definition

The order of precedence of configuration is:

1. Command line --show option value
2. Environment variable LOG_FILTER, LOG_FORMAT values
3. ioto.json5 configuration

## HTTP Client Tracing

Similar to the web server HTTP tracing, you can trace client HTTP requests and responses. Tracing HTTP client requests can be enabled via the **URL_SHOW** environment variable.

For example:

```bash
$ URL_SHOW=hH ioto --trace trace.log
```

This will trace any client HTTP requests issued via the URL module. This includes internal Ioto client requests and your own client HTTP requests that use the URL API.

## Other Environment Varialbes

You can override the Ioto **mode** and **profile** settings via environment variables:

Command Line Option | Environment Variable | Description
-|-|-
--mode MODE | IOTO_MODE | Override the execution mode (cloud \| local)
--profile PROFILE | IOTO_PROFILE | Override the execution profile (dev \| prod)


## Test Suites

Ioto provides a test facility via the **Unit** testing app. The **apps/unit/test.json5** configuration file defines the available test suites. 
You can create your own tests in the **unitTest.c** source file and define them in the **test.json5** config file.

The default Ioto source distribution includes a **demo** property collection to run a simple demo test that will increment a counter and post to the device database.

```js
demo: {
    count: 30,
    delay: '30sec',
    enable: true,
    type: 'sync',
},
```

The **count** property defines how many test iterations will be performed. The **delay** property indicates the delay between each test. The **type** property selects the type of test.


## Ioto Manual Pages

This Ioto distribution provides manual pages that can be viewed (on Unix-like systems) using the systems **man** command. Text copies of the pages are included below:

| Topic | Description |
|-|-|
| [ioto](../man/ioto.md) | Ioto device agent |
| [db](../man/db.md) | Database client program |
| [json](../man/json.md) | JSON tool |
| [pass](../man/pass.md) | Password manager |
| [url](../man/url.md) | URL HTTP client test program |
# Building for FreeRTOS 

This document covers building Ioto with FreeRTOS. Please read the [General Building](building.md) for general background first.

## Requirements

Ioto on the FreeRTOS has the following requirements for the target hardware:

* TLS stack
* A flash file system
* 32-bit CPU
* 2MB RAM

The flash file system such as [LittleFS](https://github.com/littlefs-project/littlefs) is required to store database and configuration data. 

The instructions below assume you have your development environment setup with FreeRTOS installed and you have successfully built one of the FreeRTOS demo applications for your target device.

Ioto requires a TLS stack for secure network communications. Ioto support MbedTLS and OpenSSL. See [Building TLS](building.md) for details.

Please read [Supported Hardware](hardware.md) for a complete target hardware list.

## Download Ioto

Navigate to the [Builder](https://admin.embedthis.com/clouds) site and select `Products` in the sidebar menu and click on the download link for the `Ioto Evaluation`.  

Extract the Ioto source code into your FreeRTOS app directory and rename the ioto-VERSION director to **ioto**.

    tar xvfz ioto-VERSION.tgz
    mv ioto-* ioto

## Preparing Ioto Source

Before building your Ioto source code, you need to configure Ioto for your desired set of services. The Ioto distribution build includes several demo apps that define a set of services required for that app. The Ioto services are selected via the **ioto.json5** configuration file. The services are:

Service | Description
-|-
database | Enable the embedded database
keys | Get AWS IAM keys for local AWS API invocation (dedicated clouds only)
logs | Capture log files and send to AWS CloudWatch logs (dedicated clouds only)
mqtt | Enable MQTT protocol
provision | Dynamically provision keys and certificates for cloud based management
register | Register with the Ioto Builder
serialize | Run a serialization service when making the device
shadow | Enable AWS IoT shadow state storage
sync | Enable transparent database synchronization with the cloud
url | Enable client HTTP request support
web | Enable the local embedded web server

The included apps are:

Name | Directory | Description
-|-|-
auth | Simple embedded web server user/group authentication.
blink | Minimal ESP32 blink app to demonstrate linking with Ioto on ESP32 microcontrollers.
demo | Cloud-based management of a device. Demonstrates simple data synchronization and metrics.
eco | Customized cloud-based device management of an **Eco House** demo app.

The default app is the **demo** app which sends device data and metrics to the cloud. The **eco** app emulates a simple Home charging networks and a mobile app.

To select an app, invoke **make config** with your desired APP:

```bash
make APP=demo config
```

This will copy the app's configuration to the **ioto/config** directory. From there, you can copy the config files to your Flash file system.

If you want a complete sample, please see the [Building ESP32](building-esp32.html) for a demo app that uses FreeRTOS on ESP32 hardware micro-controllers.

## Embedding Ioto

To invoke the Ioto library from your main program you will need to include the **ioto.h** header in your source and call Ioto APIs to initialize and run. 

In your main program, use:

```c
#include "ioto.h"

int main() {
    //  Start the Ioto runtime
    ioStartRuntime(1);

    //  Run Ioto services until instructed to exit
    //  You need to call vTaskStartScheduler() before ioRun
    ioRun();

    ioStopRuntime();
}

int iotStart() {
    //  This is invoked by ioRun when Ioto is ready
    //  Put your user code here
}

void iotStop() {
    //  This is invoked by ioRun when Ioto is shutting down
}
```

## Building Ioto and FreeRTOS

The Ioto source files are contained in the **ioto/lib** directory which contains C files and one assembly file. The assembly code contains some high performace stack management code that is used on Arm, Mips, RiscV and X86 platforms.

To build your FreeRTOS application with Ioto, edit the FreeRTOS app Makefile and add the following lines. This will cause the Makefile to build the Ioto source code when compiling FreeRTOS.

```make
// Must be after the OBJ_FILES definition

C_FILES     = $(wildcard ioto/lib/*.c)
A_FILES     = $(wildcard ioto/lib/*.S)
OBJ_FILES   += $(C_FILES:%.c=$(BUILD_DIR)/%.o)
OBJ_FILES   += $(A_FILES:%.S=$(BUILD_DIR)/%.o)
CFLAGS      += -Iioto/include -I/path/to/openssl/include
LDFLAGS     += -L/path/to/openssl/lib -lssl -lcrypto
```

Use the following if you are using MbedTLS

```
CFLAGS  += -I/path/to/mbedtls/include
LDFLAGS += -L/path/to/mbedtls -lmbedtls -lmbedcrypto -lmbedx509
```

Then build with **make**

```bash
$ make
```

## Filesystem

Ioto requires a flash file system with a Posix API to store config and state files. The file system should be defined with the following directories and files:

Directory | Description
-|-
state | Runtime state including database, provisioning data and provisioned certificates

File | Description
-|-
ioto.json5 | Primary Ioto configuration file
web.json5 | Local web server configuration file
schema.json5 | Database schema
device.json5 | Per-device definition
roots.crt | Top-level roots certificate
aws.crt | AWS root certificate

Copy the **state** files to your flash file system.

## Local Management

If the selected app enables the embedded web server, files will be served from the **site** directory. The Ioto embedded web server is configured via the **config/web.json5** configuration file which is then copied to the **config/web.json5** directory.

## Tech Notes

The stack size is configured to be 32K for the main app task and for spawned fiber tasks. Observationally, the minimum stack for the core Ioto is ~14K.

Ioto uses its own optimized printf implementation which uses less stack (<1K) and is more secure, being tolerant of errant NULL arguments.# Installing Ioto

One Linux or MacOS, you can natively install Ioto to the standard system directories by using `make install`

```bash
$ sudo make install
[Run] make --no-print-directory -f projects/ioto-macosx-dev.mk install
[Info] Ioto installed at /usr/local/lib/ioto/1.4.0
[Info] Configuration directory /etc/ioto
[Info] Documents directory /var/www/ioto
[Info] Executables directory /usr/local/lib/ioto/1.4.0/bin
[Info] Use "man ioto" for usage
[Info] Run via 'cd /etc/ioto ; sudo ioto'
[Info] Then browse to http://localhost
[Info] install complete
```

After installing, you can run via:

```bash
$ cd /etc/ioto
$ sudo ioto
```
# Configuration Properties

These are the configuration properties for the primary **ioto.json5** configuration file.

See the following descriptions for other configuration files:


| File | Description |
|-|-|
| [device.json5](device-properties.md) | Device configuration file. |
| [local.json5](local.md) | Local Ioto overrides configuration file. |
| [web.json5](../web/configuration.md) | Web server configuration file. |
| [schema.json5](../database/schemas/) | Database data schema. |


## ai

| Name | ai |
|-|-|
| Description | AI Connection Properties. |
| Synopsis | `ai: { "enable": true, endpoint: "..." }` |
| Notes | The <b>ai</b> property collection defines AI configuration. The api.enable will enable/disable the service at runtime. The `endpoint` property defines the LLM API URL. The api.model defines the default LLM model. The api.key property defines the LLM access key.|

## api

| Name | api |
|-|-|
| Description | Collection of API endpoint URLs. |
| Synopsis | `api: { "builder": "value", serialize: "value" }` |
| Notes | The <b>api</b> property collection defines various API endpoints. The api.builder endpoint is for the Builder public API. The api.serialize endpoint is for your local device serialization service employed during device manufacture.|

**Example**

```js
api: {
    builder: 'https://api.admin.embedthis.com/api',
    serialize: 'http://localhost:4100/ioto/serialize',
}
```

## certs

| Name | certs |
|-|-|
| Description | Ioto Certificates. |
| Synopsis | `certs: { aws: 'path', url: 'path' }` |
| Notes | The <b>certs.aws</b> property defines a filename for the AWS root certificate bundle. The <b>certs.url</b> property defines a root certificate bundle that is used to verify domains used by the URL client.<br><br>Ioto includes default certificates for the AWS root and URL root certificates.|

**Example**

```js
certs: {
    aws: 'certs/aws.crt',
    url: 'certs/roots.crt',
}
```


## conditional

| Name | conditional |
|-|-|
| Description | Conditional configuration properties. |
| Synopsis | `conditional: { "Set-Name": { /* properties */ }` |
| Notes | The <b>conditional</b> property collection is used to define a suite of different configurations for Ioto. For example, it can select a "dev" profile for development and a "prod" profile for productions.<br><br>Selections are made based on a controlling top level property. The **mode** and **profile** properties are used to select relevant configuration sets to apply.

**Example**
```js
conditional: {
    profile: {
        dev: {
            directories: {
                log: '.',
                state: 'state'
            }
        },
        prod: {
            directories: {
                log: '/var/log',
                state: '/var/lib/ioto'
            }
        }
    }
}
```

## database

| Name | database |
|-|-|
| Description | Control the Ioto database. |
| Synopsis | `database: { properties... }` |
| Notes | The <b>database</b> property collection defines the database, schema and operational parameters that govern the Ioto database.The <b>path</b> property defines the filename of the on-disk database store. Ioto will also create a database journal log file that appends a ".jnl" extension to this path.<br><br>The <b>schema</b> property defines the database scheme that defines the database indexes, entities and data types.<br><br>The <b>maxJournalSize</b> defines how big the database journal log should grow before Ioto rewrites the database. The <b>maxJournalAge</b> defines how long data should be preserved in the journal log before the database file is updated. These values should be sufficiently long as writing updated data to the journal is much more efficient that updating the database file.<br><br>. The <b>maxSyncSize</b> property defined how much data should be buffered before synchronizing to the cloud. The path and schema properties can use @db and @config prefixes which will be expanded to "state/db" and "state/config" respectively. <br><br>The <b>service</b> property defines when to run a database maintenance task to remove expired items that define an expiry via the "ttl" schema property. |

**Example**

```js
database: {
    path: '@db/state.db',
    schema: '@config/schema.json5',
    maxJournalSize: '1mb',
    maxJournalAge: '1min',
    maxSyncSize: '10k',
    service: '1hr',
},
```

## directories

| Name | directories |
|-|-|
| Description | Define default Ioto directories. |
| Synopsis | `directories: { "log": ".", state: "./state" }` |
| Notes | The <b>directories</b> property collection defines various directories used by Ioto. The directories.log directory is where log files will be saved. The directories.state directory is where runtime state including databases, certificates, web pages, configuration and shadow state will be stored. These can be overridden via the ioto command line --config, --state and --ioto options. |

**Example**

```js
directories: {
    log: '/var/log',
    state: '/var/lib/ioto',
}
```

## limits

| Name | limits |
|-|-|
| Description | Define execution limits for Ioto. |
| Synopsis | `limits: { "key": "value", ... }` |
| Notes | The **limits** property collection defines various execution limits for Ioto. The **limits.reconnect** property defines the delay after MQTT communications are lost before the agent will reconnect. This is useful to throttle network load in the event of a network disconnection. The **limits.stack** property defines the default size of fiber coroutine stacks. |

**Example**

```js
limits: {
    reconnect: '10 secs',
    stack: '32K',
}
```


## limits.stack

| Name | limits.stack |
|-|-|
| Description | Define the stack size of fiber coroutines for Ioto. |
| Synopsis | `limits: { stack: "Number" }` |
| Notes | The <b>limits.stack</b> property specifies the stack size for Ioto coroutines. This should be set to the maximum anticipated stack size for your executing code. The default stack size is 64K. The core Ioto code requires a stack size of 12K.<br> <br>It is recommended that you minimize your use of big stack buffer variables and your use of deep recursion both of which require much bigger fiber stacks. |

**Example**

```js
limits: {
    stack: '16K',
},
```


## files

| Name | files |
|-|-|
| Description | Define the list of files to ingest and send to CloudWatch logs. |
| Synopsis | `files: { path: "filename", group: "log-group', stream: "log-stream" }` |
| Notes | The <b>files</b> property contains one or more file definitions to ingest and send to CloudWatch logs. The definitions define the log file name, AWS CloudWatch log group and stream names.<br> <br>The <b>path</b> property may contain wild cards and all matching files will be ingested.<br> <br>The <b>group</b> property specifies the AWS log group name which must exist.<br> <br>The <b>stream</b> property specifies the AWS log stream name which must exist.<br> <br>The group and stream properties may contain tokens that are expanded before use. The supported tokens are: "{hostname}" which translates to the system hostname, "{instance}" which expands to the AWS EC2 instance name and "{deviceId}" which expands to the provisioned provision.deviceId property. |
**Example**

```js
files: [ {
    path: '/var/log/sys*log',
    group: 'ioto',
    stream: '{hostname}'
} ],
```


## log

| Name | log |
|-|-|
| Description | Control the Ioto log file output. |
| Synopsis | `log: { path: 'path', format: 'format', types: 'types', sources: 'sources' }` |
| Notes | The <b>log</b> property collection defines how and where Ioto logs execution information.<br><br>The <b>log.path</b> property specifies the destination of the Ioto trace log. Set it to "stdout" or "stderr", "aws" or a filename. If set to "aws", then the <b>log.group</b> property specifies the AWS log group name and the <b>log.stream</b> property specifies the AWS log stream name.<br><br>The <b>format</b> specifies a leading format for the message that contains printf style tokens that are expanded at runtime. The supported tokens are: 'A' for the application name, 'D' for the local datetime, 'H' for the system hostname, 'M' for the message, 'P' for the process ID , 'S' for the message source, and 'T' for the message type.<br><br>The <b>types</b> property specifies the types of messages to emit. It may contain the following types: debug, error, info and trace. It may be set to "all" for all types.<br><br> The <b>sources</b> property specifies a comma separated list of message sources to emit. Sources may be prefixed with "!" to subtract from the list. For example: "all,!json" will emit messages from all sources except "json".|

**Example**

```js
log: {
    path: '/var/log/ioto.log',
    format: '%D %H %A[%P] %T %S %M',
    types: 'error,info',
    sources: 'all'
}
```

## mqtt

| Name | mqtt |
|-|-|
| Description | MQTT configuration. |
| Synopsis | `mqtt: { properties }"` |
| Notes | The <b>mqtt</b> property collection is used to configure MQTT communications to the cloud. The mqtt.cert and mqtt.key properties define filenames to the X.509 certificate and key used to secure MQTT communications. <br><br> The mqtt.client defines the MQTT client ID used to uniquely identify the device. <br><br>The alpn property defines the HTTPS ALPN identification string required when using HTTP port 443 for communications. The mqtt.ca property defines the authority certificate from AWS that is used as the root certificate to verify the MQTT broker endpoint. <br><br>The cert, key, client and endpoint properties can be set to "auto" to have their values dynamically configured from AWS IoT core at runtime.<br><br>The timeout property defines the time period in which to disconnect an idle mqtt connection. The delay property defines how long to wait before reconnecting. The schedule property is a "cron" style specification that defines the time window in which MQTT connections can be established. |

**Example**
```js
mqtt: {
    cert: 'auto',
    key: 'auto',
    client: 'auto',
    endpoint: 'auto',
    port: 443,
    alpn: 'x-amzn-mqtt-ca',
    ca: 'certs/aws.crt',
    timeout: '5 mins',
    delay: '1 min',
    schedule: '* * * * *',
}
```

## optimize

| Name | optimize |
|-|-|
| Description | Build for debug or production release. |
| Synopsis | `optimize: "debug|release"` |
| Notes | If **debug** is selected, Ioto will be built with debug symbols.<br><br>If **release** is selected, Ioto will be built optimized without debug symbols.|

```js
optimize: 'release'
```

## profile

| Name | profile |
|-|-|
| Description | Configuration profile to select. |
| Synopsis | `profile: "dev | qa | prod | ..."` |
| Notes | The <b>profile</b> property is used to select different build and execution configurations for Ioto at runtime. For example, it can select a "dev" profile for development and a "prod" profile for productions.<br> <br>The <b>profile</b> property selects a set of configuration properties from the **conditional.profile** collections. These are copied to the top level and overwrite any existing top-level properties. |

**Example**
```js
profile: "prod"
```

## scripts

| Name | scripts |
|-|-|
| Description | Set of scripts used for various management tasks.|
| Synopsis | `scripts: { update: './scripts/update'}` |
| Notes | The <b>scripts.update</b> property defines a script that is invoked to apply software updates. The script is invoked with the pathname to the update image as the first and only argument.|

```js
scripts: {
    update: './scripts/update'
}
```

## services

| Name | services |
|-|-|
| Description | Configure which Ioto services to enable at runtime.|
| Synopsis | `services: { 'Service-Name': true | false, ... }` |
| Notes | The <b>services</b> property collection defines which Ioto services to enable.<br><br>The supported services are: <ul> <li>ai &mdash; OpenAI LLM connections</li><li>database &mdash; Local embedded database</li> <li>keys &mdash; Generate and rotate IAM access credentials</li> <li>logs &mdash; Send local O/S log files to CloudWatch logs</li> <li>mqtt &mdash; MQTT services</li> <li>provision &mdash; Enable registration and provisioning of device in the cloud</li> <li>serialize &mdash; Invoke manufacturing serialization service at first boot during test.</li> <li>shadow &mdash; AWS IoT device shadows</li> <li>sync &mdash; Send device state to AWS database</li> <li>url &mdash; Client HTTP service</li> <li>web &mdash; Local web server</li> </ul><br>Some services depend on others. Lower-level services will be forcibly enabled if upper level services require them. |


**Example**

```js
services: {
    database: true,
    keys: true,
    logs: true,
    mqtt: true,
    provision: true,
    register: true,
    serialize: 'auto',
    shadow: true,
    sync: true,
    update: true,
    url: true,
    web: true
}
```

## timeouts

Ioto supports timeout properties that improve security by limiting the duration of requests. Additional timeouts are provided from the [web.json5 timeouts](../web/properties.md#timeouts) configuration.

| Name | timeouts |
|-|-|
| Description | Collection of timeout properties. |
| Synopsis | `timeouts: { "Timeout-Property": "Timeout-Value", ...}` |
| Notes | All timeout values are strings, not numbers.<br><br>The string values may take human-readable suffixes which indicate the units for the value. The suffixes can be upper or lower case. The supported units are: infinite, never, sec, secs, seconds, min, mins, minute, minutes, hr, hrs, hour, hours, day, days, week, weeks, month, months, year, years.<br><br>Ioto has sensible defaults for these timeouts if not explicitly specified.|

**Example**
```js
timeouts: {
    api: "30 secs",
    aws: "60 secs",
    checkin: "30 secs",
    download: "5 mins",
}
```

## timeouts.api

| Name | timeouts.api |
|-|-|
| Description | Defines the maximum duration of requests to the Ioto cloud. |
| Synopsis | `api: "duration"` |
| Notes | The api timeout will be used for general calls via the Ioto cloud. The default is 30 seconds.|

**Example**

```js
api: "30 secs"
```


## timeouts.aws

| Name | timeouts.aws |
|-|-|
| Description | Defines the maximum duration of requests to the AWS cloud. |
| Synopsis | `aws: "duration"` |
| Notes | The aws timeout will be used for all calls via the **aws()** API. The default is 60 seconds.|

**Example**

```js
aws: "60 secs"
```


## timeouts.checkin

| Name | timeouts.checkin |
|-|-|
| Description | Defines the frequency of the **checkin** API call to the Ioto cloud. |
| Synopsis | `checkin: "elapsed"` |
| Notes | The checkin API will be called when Ioto starts and thereafter at this frequency. Defaults to 24 hours. |

**Example**

```js
checkin: "24 hours"
```


## timeouts.download

| Name | timeouts.download |
|-|-|
| Description | Defines the maximum duration of a software download from the Ioto cloud. |
| Synopsis | `download: "duration"` |
| Notes | The software download is used to deploy new firmware to devices. The default duration is 5 minutes. |

**Example**

```js
download: "5 mins"
```


## tls

| Name | tls |
|-|-|
| Description | Collection of TLS properties. |
| Synopsis | `tls: { "Tls-Property": "Tls-Value", ... }` |
| Notes | TLS properties apply to web server https connections. They do not apply to Ioto MQTT or Ioto client connections. <br><br>The authority, certificate and key paths may use @certs prefixes to refer to the "state/certs" director. |

**Example**

```js
tls: {
    authority: "@certs/ca.crt",
    certificate: "@certs/server.crt",
    key: "@certs/server.key",
    verify: {
        client: true,
        issuer: true
    }
}
```

## tls.authority

| Name | tls.authority |
|-|-|
| Description | Defines the location of the certificate file for client authentication. |
| Synopsis | `authority: "path"` |
| Notes | The <b>authority</b> property defines the file containing the certificates to use when authenticating client certificates. This property is only necessary if you wish to verify client certificates. If so, you must also define the "verify.client" to be true.<br><br>The certificate file contains the concatenated certificates to use in preference order. The path may be an absolute path or it may be relative to the Home directory. The path can also use the "@certs" prefix which will be expanded to "state/certs". |

**Example**

```js
authority: "/var/ioto/ca.crt"
```

## tls.certificate

| Name | tls.certificate |
|-|-|
| Description | Defines the location of the X.509 file containing the server certificate |
| Synopsis | `certificate: "path"` |
| Notes | The SSLCertificateFile directive defines the file containing the PEM encoded X.509 certificate for the server. The file may also contain the private key for the server in which case you do not need to use the <b>key</b> property. |  

**Example**

```js
certificate: "@certs/server.crt"
```

## tls.key

| Name | tls.key |
|-|-|
| Description | Defines the location of the server's private key. |
| Synopsis | `key: "path/to/key"` |
| Notes | The key property defines the file containing the PEM encoded private key file for the server. This property is not required if the server's private key is combined with the certificate file. The private key should not be encrypted. |
| Security | There is a dilemma here. If you use an encrypted private key, the server will pause until you enter the pass-phrase which makes headless operation impossible. If you do not encrypt the private key, your private key is more vulnerable should the server be compromised. |

**Example**

```js
key: "@certs/server.key.pem"
```

## tls.verify


| Name | tls.verify |
|-|-|
| Description | Collection of TLS verification properties |
| Synopsis | `verify: { "client": "value", "issuer": "value" }`
| Notes | Control the type of certificate verification. |

**Example**

```js
verify: {
    client: true,
    issuer: true,
}
```

## tls.verify.client

| Name | tls.verify.client |
|-|-|
| Description | Control the type of client certificate verification.|
| Synopsis | `client: true|false` |
| Notes | This property controls whether the client must provide a client certificate for the server to verify the identity of the client. If disabled, no certificate is required. If one is supplied, it will be ignored. The certificate and the certificate's issuer will be verified. Use the "verify.issuer" directive to turn off verification of the issuer if you need to use a self-signed test certificate.<br><br>If the property is enabled, the client must provide a valid certificate. The default is disabled. |

**Example**

```js
verify: {
    client: true,
}
```

## tls.verify.issuer

| Name | tls.verify.issuer |
|-|-|
| Description | Defines whether the issuer of the client certificate is verified. |
| Synopsis | `issuer: true|false` |
| Notes | This property controls whether the issuer of the client certificate will be verified. If set to <b>off</b>, the certificate issuer will not be verified. This is useful to accept self-signed test certificates. |

**Example**

```js
verify: {
    issuer: true,
}
```

## update

| Name | update |
|-|-|
| Description | Collection of software update properties. |
| Synopsis | `update: { "Update-Property": "Update-Value", ... }` |
| Notes | The update collection controls the schedule and behavior of requesting, downloading and applying software updates. 

**Example**

```js
update: {
    apply: '* 0 * * *',
    jitter: '1 hr',
    period: '24 hr',
    schedule: '* 18-23 * * *',
    throttle: 100,
}
```

## update.apply

| Name | update.apply |
|-|-|
| Description | Cron-like schedule defining when the Ioto agent will apply a downloaded software updates. |
| Synopsis | `schedule: "cron-spec string"` |
| Notes | See [Cron](https://en.wikipedia.org/wiki/Cron) for details about Cron strings.

**Examples**

```js
update: {
    apply: 'midnight',
}
```

## update.jitter

| Name | update.jitter |
|-|-|
| Description | Random time period to delay the scheduled software update check so that multiple devices will not all hit the service at once.

| Synopsis | `jitter: "1 hr"` |

**Examples**

```js
update: {
    jitter: '2 hrs',
}
```

## update.period

| Name | update.period |
|-|-|
| Description | The minimum delay in seconds before checking for a software update. |
| Synopsis | `period: "number or string numeric with suffix"` |
| Notes | The minimum period will be applied in addition to the defined **schedule**. The supported suffixes are "min", "hr", "day". |

**Examples**

```js
update: {
    period: '6 hr',
}
```


## update.schedule

| Name | update.schedule |
|-|-|
| Description | Cron-like schedule defining when the Ioto agent will check for new sofwtare updates. |
| Synopsis | `schedule: "cron-spec string"` |
| Notes | See [Cron](https://en.wikipedia.org/wiki/Cron) for details about Cron strings.

**Examples**

```js
update: {
    schedule: '* 18-23 * * *',
or
    schedule: 'midnight',
}
```

## update.throttle

| Name | update.throttle |
|-|-|
| Description | The time in milliseconds to pause between reading 4K of a software download update. |
| Synopsis | `throttle: 50` |
| Notes | This delay is useful to lessen the CPU and network impact on the device due to downloading a software update. Set to zero for no delay.

**Examples**

```js
update: {
    throttle: 100,
}
```

## version

| Name | version |
|-|-|
| Description | Set the agent version. |
| Synopsis | `version: "SemVer Version String"` |
| Notes | The version string defines the versions of the embedded agent including your software. It is used when selecting software updates deployed from the Builder. Don't confuse this with the underlying Ioto version. The version string must conform to the [Semantic Versioning 2.0](https://semver.org/) spec.
# Building for ESP32 

This document covers building Ioto for ESP32 using the [ESP IDF](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/index.html).

Please read the [Building](building.md) for general background first.

## Requirements

Ioto on the ESP32 has the following requirements:

* ESP32 device
* At least 2MB PSIRAM

Please read [Supported Hardware](hardware.md) for a complete list.

## Building Ioto for ESP32

This build sequence assumes you have your development environment setup on Linux or MacOS with the ESP-IDF installed. See [ESP-IDF Setup](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/linux-macos-setup.html) for details.

To begin open a terminal and create a directory for your project and the Ioto component. Choose any name you like for the project directory.

    mkdir -p myproject
    cd myproject
    mkdir components

Next, add the [ESP IDF](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/index.html) to your environment.  

    . ~/path-to-esp-idf/export.sh

## Download Ioto

Navigate to the [Builder](https://admin.embedthis.com/clouds) site and select `Products` in the sidebar menu and click on the download link for the `Ioto Evaluation`.  

<img src="https://www.embedthis.com/images/builder/product-list.avif" alt="Product List" class="screen"><br>

Extract the Ioto source code into the components directory. Then rename the **ioto-VERSION* directory to **ioto**.

    cd components
    tar xvfz ioto-VERSION.tgz
    mv ioto-* ioto
    cd ..

## Sample apps

The Ioto source distribution includes several ESP32 sketch example apps. Each example includes the necessary configuration files that are copied from the relevant app directory into build tree.

Name | Directory | Description
-|-|-
blink | apps/blink | Blink a GPIO LED within the Ioto agent framework
demo | apps/demo | Create a demo counter and synchronize with the local and cloud databases

The default app is the **blink** app which is ideal to test if you have ESP and Ioto successfully installed and configured.  You can select an app by providing an **APP=NAME** option to the make command.

To prepare for building the app and Ioto, invoke **make** with your selected app.  The **components/ioto/apps** directory contains master copies of the Ioto demonstration apps. When you select an app, the code and configuration are copied to the **./main** and **./fs** directories.

    make -C components/ioto esp32

or

    make -C components/ioto APP=blink esp32

This command will perform the following steps:

* Create the blink app at main/main.c
* Create the app CMakeLists.txt
* Create the file system partitions.csv
* Create the app sdkconfig.defaults
* Initialize the components/ioto for the blink app 
* Create some test certificates that may be required by the app

## Configuration

Next, ensure your ESP target device is defined. For example, to set the target to **esp32-s3**:

    idf.py set-target esp32-s3

The default build configuration is defined via the **sdkconfig.defaults** file. You can tailor the configuration by running:

    idf.py menuconfig

The Ioto services are enabled via the Ioto menu config option. Navigate to 

    Components config ---> 
    Ioto
    
Then enable the desired services. This will update the **ioto.json5** and regenerate the **sdkconfig** and **include/ioto-config.h** files.

Check your **sdkconfig** that the following settings are defined:

Key | Value | Description 
-|-|-
CONFIG_ESP_MAIN_TASK_STACK_SIZE | 8192 | Main task stack size (in words)
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ | 240 | CPU frequency setting to the fastest setting
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_240 | y | CPU frequence alias
CONFIG_ESPTOOLPY_FLASHSIZE | 8MB | Flash memory size
CONFIG_ESPTOOLPY_FLASHSIZE_8MB | y | Flash size alias

The full list is in components/ioto/apps/NAME/sdkconfig.defaults

## Building with idf.py

Building is done using the ESP-IDF **idf.py** command rather than using the normal Ioto generic Makefiles which are used when building natively on Linux or MacOS.

To build for ESP32, run:

    idf.py build

## Update the Board Flash 

To update your device with the built application:

    idf.py -p PORT flash

Where PORT is set to the USB/TTY serial port connected to your device.

## Monitoring Output

You can view the ESP32 and Ioto trace via the ESP32 monitor:

    idf.py monitor

The app will turn the LED On/Off every 2 seconds and trace the LED status to the monitor.

## Local Management

If the selected app enables the embedded web server, files will be served from the **./site** directory. The Ioto embedded web server is configured via the **web.json5** configuration file which is then copied to the *state** directory.

## Tech Notes

The stack size is configured to be 32K for the main app task and for spawned fiber tasks. Observationally, the minimum stack for the core Ioto is ~14K.

Ioto uses its own optimized printf implementation which uses less stack (<1K) and is more secure, being tolerant of errant NULL arguments.

The PlatformIO and Arduino build frameworks are not (yet) supported.# Configuration

The Ioto Agent is controlled via several [JSON/5](https://json5.org/) configuration files that are that are read at startup by Ioto.

The configuration files are are copied from the select appplication **./app/NAME/config** directory into the top-level **./state** directory. 

| File | Description |
|-|-|
| [device.json5](device-properties.html) | Device registration configuration. |
| [ioto.json5](properties.html) | Primary Ioto configuration file. Configures enabled services, logging and log file ingestion |
| ioto.crt | Allocated Ioto certificate for cloud communications. |
| ioto.key | Allocated Ioto certificate key for cloud communications. |
| [local.json5](local.html) | Local configuration for development. |
| provision.json5 | Device and cloud provisioning configuration. |
| [schema.json5](../database/schemas/) | Database data schema. |
| signature.json5 | REST API signatures. |
| shadow.json5 | Local copy of the AWS IoT shadow state. |
| state.db | Saved database. |
| [web.json5](../web/configuration.md) | Web server configuration file. |

## JSON/5

Ioto uses a human-readable JSON/5 for configuration. JSON/5 an extension of JSON that makes it easier to create, read and maintain configuration files in JSON.

JSON/5 adds the following JavaScript features to JSON.

* Object keys may be JavaScript identifiers without quotes.
* Objects or arrays may have a trailing comma.
* Strings may be single quoted.
* Strings may span multiple lines (single, double or back-tick quotes).
* Numbers may have a leading or trailing decimal point, can be hexadecimal, and may begin with a plus.
* Values may be regular expressions.
* The **undefined** value may be used.
* Single and multiline comments are allowed and preserved.

```js
{
    // single-comment
    /*
        Multi-line comment
    */
    unquotedKey: 42,
    singleQuoteString: 'The "lazy brown fox" jumped...',
    multiLine: "Line one
        line two
    ",
    hex: 0x42,
    trailingComma: {
        one: 1,
        two: 2,
    },
}
```

Some Ioto configuration properties accept numeric values as human-readable string with unit suffixes. In this case, the value must be string. The **limits** and **timeouts** properties in the web.json5 file support the suffixes: unlimited, infinite, kb, k, mb, m, gb, g, byte, bytes, infinite, never, sec, secs, seconds, min, mins, minute, minutes, hr, hrs, hour, hours, day, days, week, weeks, month, months, year and years.

## Profiles

Configuration files can provide multiple property profiles that can be selected at runtime. When Ioto is run, it executes with selected profile. This is typically `prod` for production and `dev` for development. However, you can create your own profiles for any desired execution configuration such as `qa` or `test`.

The Ioto profile is defined via the PROFILE environment variable or via the `--profile` command line option.

Configuration profiles are defined under the **conditional.profile** property in any configuration file. The relevant configuration properties are selected by the current Ioto **profile**. When selected, the relevant set are copied to overwrite properties of the same name at the top level. This allows a single configuration file to apply different settings based on the current values of the profile property.

```js
conditional: {
    profile: {
        dev: {
            limits: {
                //  Override the default stack size
                stack: '64k',
            }
        },
        prod: {
            log: {
                //  Send trace to a specific output file
                path: 'ioto.log',
            }
        }
    }
}
```

## Ioto Configuration

The primary Ioto configuration file is called **ioto.json5**.

Here is a sample ioto.json5:

```js
{
    services: {
        database: true,
        keys: true,
        logs: false,
        mqtt: true,
        provision: true,
        serialize: 'auto',
        shadow: false,
        sync: true,
        update: true,
        url: true,
        web: false,
    },
    files: [
        {path: '/var/log/sys*log', group: 'ioto', stream: '{hostname}' }
    ],
    limits: {
        stack: '16k',
    },
    log: {
        path: 'aws',
        format: '%D %H %A[%P] %T %S %M',
        types: 'error,info',
        sources: 'all',
    }
}
```

The configuration file defines the following items:

* The **services** to enable.
* The **files** files to capture and send to CloudWatch logs.
* The Ioto execution **limits** that defines the default stack size
* The Ioto **log** log configuration.

The configuration properties are defined in the [Configuration Properties](./properties.md).

The ioto.json5 **services** property collection defines which services to build and enable when running Ioto.

The selectable Ioto services are:

* database -- Enable the embedded database
* demo -- Demonstrate sending data to the cloud
* keys -- Get AWS IAM keys for local AWS API invocation (dedicated clouds only)
* logs -- Capture log files and send to AWS CloudWatch logs (dedicated clouds only)
* mqtt -- Enable MQTT protocol
* provision -- Dynamically provision keys and certificates for cloud based management
* register -- Register with the Ioto Builder
* serialize -- Run a serialization service when making the device
* shadow -- Enable AWS IoT shadow state storage
* sync -- Enable transparent database synchronization with the cloud
* url -- Enable client HTTP request support
* web -- Enable the local embedded web server
# Ioto Services

Ioto can be compiled to include or exclude support for various services.

The optional services are:

Name|Description|
-|-
database | Local embedded Database
keys | Local AWS IAM keys for AWS APIs
logs | Log file capture to AWS CloudWatch
mqtt | MQTT protocol used for cloud communications
provision | Provision AWS certificates for cloud management
register | Register device with the Builder
serialize | Serialization during manufacturer
shadow | AWS IoT Shadow state support
sync | Database sync to the cloud
update | Device agent software updates from the cloud
url | Url Http Client
web | HTTP Web server

If a component is compiled, you can also selectively enable or disable support at runtime via the  **services** property in the **ioto.json5** file.

When Ioto starts, it will enable services as defined in the **services** property collection.

```js
{
    services: {
        database: true,
        keys: true,
        logs: true,
        mqtt: true,
        provision: true,
        register: true,
        serialize: 'auto',
        shadow: true,
        sync: true,
        update: true,
        url: true,
        web: true,
    }
}
```

## Startup Order

When Ioto starts, it will configure services (if enabled) in a specific order. If services are not enabled during compilation or are disabled in the **ioto.json5** file, the step will be skipped.

The order is:

1. Serialize the device.
2. Open the database
3. Register with the build service (one time).
4. Start the embedded web server.
5. Provision certificates and keys from the device cloud (one time).
6. Initialize MQTT communications with the cloud.
7. Start database synchronization and retrieve changes while powered off.
8. Start additional cloud services

Please read the [Provisioning for the Cloud](../aws/provisioning.md) for details about the device provisioning process.

## Serialization

For secure device operation it is essential that each device can be uniquely identified. Most devices are created with a serial number that may include the product code, manufacturing batch number and individual serial number. However, while this serial number may be unique, it can be easily guessed because serial numbers typically follow a predictable format. This can present a security vulnerability when claiming device by serial number.

Instead of using the existing serial number, Ioto uses a random, unique claim ID (UCI) that is a random, 80-bit number that is not guessable and does not follow a predictable pattern. When paired with the product ID, it is used as a unique claim ticket for users to claim devices for management. For example:

```bash
JT08FFQXWQ
```

The 10 letter UCI results in over 1 quadrillion possible numbers (32^10).

During manufacturer, each device should be given a UCI that identifies the device to the Ioto service and is used by the user to "claim" the device after purchase or installation.

The UCI should be printed on the device label and be clearly identified as the Claim ID. The Claim ID can also be represented as a QR code if you choose to develop a mobile app for users to claim devices. (See Claiming below).

The UCI should be saved in the **device.json** configuration file in the **claim** property.


```json
{
    "claim": "7423FFA8DT",
    "product": "01GAQD45HGSN90AAF5QFVEBVTS",
    "test": 0
}
```

## Device Registration

Before a device can be managed, it must be registered and then be "claimed" by a user once purchased.

Registration is a one-time step that happens only when the device is first powered on.

When the device boots during system test, the Ioto agent will connect to the EmbedThis Builder service to register. The agent will send the contents of the device.json over an encrypted TLS connection to the EmbedThis Builder service.

The **device.json** file contains the UCI device identifier and the "product" registration token. You can get the ProductID registration token from the Builder Token List.

Once Ioto registers the device, the Ioto agent awaits for a user to claim the device.

## Device Claiming

When a user purchases or installs a device with the Ioto agent, they can "claim" the device to manage from the cloud. While waiting, cloud services are pending, but other Ioto services can run, including the embedded web server for local management (if enabled).

The user claims their device using the unique claim ID (UCI) printed on the device label. This claim request is sent to the Builder service that provisions the necessary X.509 certificates and AWS IoT resources required to support and manage the device. These are then returned to the Ioto Agent who saves them in the **provision.json5** config file.


## Device Connection

When the device is powered on, but unclaimed, the Ioto agent will regularly check with the Ioto service to see if it has been claimed. In this state, it is "unmanaged" by the cloud and awaiting orders.

The Ioto agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay up to a defined limit. If the device is rebooted, the polling process recommences.

Once claimed, when the agent next polls the Ioto service, it will receive management instructions and be redirected to the relevant AWS device cloud for ongoing management and the provisioning process is complete.

## Firewall Ports

If the embedded web server is enabled, Ioto will listen on the interfaces and ports specified in the **listens** property in the **web.json5** config file.

If cloud services are enabled, Ioto will communicate out on port 443 using HTTPS to the EmbedThis Builder cloud at **admin.embedthis.com**. It will also connect over port 443 to **amazonaws.com** using MQTT and HTTP protocols.

# Ioto Overview

The Ioto device agent is a compact management agent and library. It provides local and remote management capabilities including: HTTP web server, MQTT client, HTTP client, embedded database, AWS IoT cloud integration, cloud database sync, state persistency, provisioning and OTA upgrading. It also includes several browser-based management apps for local or cloud-based management.

Ioto is fast and compact, with a tiny memory footprint of less than 200K of code.

![Ioto Agent Architecture](/images/ioto/ioto-agent.png)

## Goals

Embedded agents for managing devices have several competing goals:

* Provide a strong and standard management feature set
* Minimize memory footprint
* Minimize CPU consumption
* Maximize security

To meet all these goals in one agent is difficult, but Ioto utilizes a safe runtime to assist. This maximizes code reuse and security, allowing management services to be coded as simply and efficiently as possible.


## Processing Architecture

Ioto is based on an event-driven, single-threaded fibre coroutine core. It uses a non-blocking, event-driven architecture and is capable of running many inbound and outbound requests simultaneously with minimal CPU and memory resources.

Ioto eliminates the ugliness of event callbacks and the complexity of threads by using fiber coroutines. A fiber coroutine is a segment of code that runs with its own stack and cooperatively yields to other fibers when it needs to wait. You can think of a fiber as a thread, but only one fiber runs at a time. For Go programmers, fibers are like Go routines. For JavaScript developers, fibers are similar to async/await.

Ioto fibers are baked into the I/O system so you can easily support parallelism by overlapping requests without any effort. You can read and write sockets, issue HTTP client requests, send MQTT messages or respond to web server requests using a straight-line procedural programming model.

All Ioto services are "fiber-enabled". This means that your user extension code is simple, easy to debug and maintainable over the long haul.

### Core Components

Ioto has a modular architecture where modules can be conditionally compiled as required to minimize your memory and security footprint.

The key components of Ioto are:

| Component | Description |
|-|-|
| Embedded Web Server | Embedded web server supporting HTTP/1.1, TLS 1.3, C action functions, file upload, transfer-encoding, user management, sessions and cookies, authentication, sandbox limits. |
| Embedded Database | Embedded NoSQL database with JSON documents, red/black indexing, local persistency, triggers and replication to the cloud. |
| MQTT 3.1.1 Client | Supports publish, subscribe, ping and disconnect messages. Includes retained message support and connect over port 443 via ALPN. |
| Cloud-based Management | AWS cloud support with data export to IoT shadows, S3, CloudWatch logs, CloudWatch metrics, Kinesis for streaming and DynamoDB for structured device data. |
| Transport Layer Security (TLS/SSL) | Secure Socket Layer protocol stack. This is a virtual interface that can selectively support a variety of TLS providers including: the MbedTLS and OpenSSL stacks. |
| JSON | JSON and JSON 5/6 parser. This module includes JSON persistency to files and a powerful JSON query engine. |
| Safe Portable Runtime | Cross-platform safe portable runtime. Includes services for memory allocation, buffer management, safe string handling, lists, hashing, sockets, events, timers, logging and fiber coroutines. |
| Suite of Management Applications | Browser-based VueJS management applications |


## Ioto Configuration

Ioto uses a set of JSON configuration files to control execution. These configuration files are read when Ioto starts.

The configuration files use a relaxed JSON format called JSON/5. This format is similar to the JavaScript object literal notation. Specifically, it supports: comments, keys without quotes, trailing commas and multiline strings.

Embeddable files are stored under the **./state** directory.

|File|Description|
|-|-|
| state/config/ | Configuration files. |
| state/db/ | Database files. |
| state/certs/ | Certificates. |
| state/site/ | Web site files. |

|File|Description|
|-|-|
| ioto.json5 | Primary Ioto configuration file. Configures enabled services, logging and log file ingestion |
| device.json5 | Device registration configuration. |
| local.json5 | Local configuration for development. |
| schema.json5 | Database schema. |
| signature.json5 | REST API signatures |
| web.json5 | Web server configuration file. |
| provision.json5 | Cloud provisioning endpoints and keys. |
| shadow.json5 | Local copy of the AWS IoT shadow state. |


See [Agent Configuration](index.md) for more details.

## Applications

When the Ioto agent is built, a selected management application will also be built. 

The management apps are browser-based [VueJS](https://vuejs.org/) apps that communicate with either the local Ioto web server or with the cloud-based Ioto service. The applications are stored under the **./apps** directory.

|Name | Directory | Description|
|-|-|-|
auth | apps/auth | Test web server authentication
demo | apps/demo | Demo app to send data to the cloud
eco | apps/eco | Eco House demo app
unit | apps/unit | Unit tests app

Some extra apps are provided via the **Ioto Samples** package.

|Name | Directory | Description|
-|-|-
console | apps/console | Local developer console for Ioto
cloudkick | apps/cloudkick | Cloud-based version of the Kickstart app
kickstart | apps/kickstart | Local Kickstart sample "router" management app
manager | apps/manager | Cloud-based device manager developer console for Ioto


The build will copy the application's configuration files from **apps/NAME/config** to the **state** directory.

You can use the supplied management applications "as-is" or you can use them as a base for creating your own device-specific management solutions.


## Ioto HTTP Web Server

The Ioto web server is a fast, compact web server designed for local device management and for hosting embedded device management applications. It can also be used for serving device data over the network.

Management applications are best created using [Single Page Application](https://en.wikipedia.org/wiki/Single-page_application) design techniques where the application is rendered locally in the browser and it requests pure-data from the device to populate dynamic content.

Ioto is ideal for this approach. It includes an integrated embedded database, JSON parser and query engine to enable it to receive HTTP requests with JSON payloads and remit responses in JSON.

Ioto does not provide a web framework &mdash; nor do we believe that dynamically generating HTML is the most compact, secure or best approach for performing device management.

A working sample single page application called Kickstart is available for download from the Builder. This is a VueJS application that serves a sample device application for Ioto.

The core web services include:

* HTTP/1.1 protocol engine.
* Non-blocking socket communications.
* TLS (SSL) 1.3 support.
* Multiple listen endpoints.
* Flexible configuration via the web.json file.
* Session and cookie management.
* Authentication and User management.
* Serve static files.
* File upload.
* Transfer chunk encoding in both directions.
* Fully streaming receive and transmit data.
* Dynamic content rendering via binding URLs to C functions.

The Ioto web server module is exceptionally fast and will serve over 3K requests per second on a modest Raspberry PI 4 and yet runs using only 80K of code.

## Cloud-based Management

The Ioto agent can integrated with the AWS IoT back-end to make the job of creating IoT enabled devices dramatically easier.

The AWS integrations are optional and can be enabled or disabled via the application's **ioto.json5** configuration file.

Features:

* Simply provision devices for management by AWS IoT.
* Send messages to AWS IoT and other services via MQTT.
* Easy publish data to the cloud via MQTT.
* Create metric from any data for graphical display.
* Replicate and synchronize structured data to AWS DynamoDB.

For device clouds hosted on your own AWS account, you gain direct access to additional AWS features:

* Generate IAM temporary access credentials to call AWS API services on the device.
* Use the compact AWS SigV4 REST APIs from the device.
* Upload data and files to AWS S3.
* Send control-plane data to AWS IoT Shadows.
* Store the Ioto log file in AWS CloudWatch.
* Capture device O/S logs and upload to AWS CloudWatch.
* Emit metrics to AWS CloudWatch metrics.
* Save an audit trail to AWS CloudTrail.


## Agent Security

Ioto provides a suite of measures designed to increase the security of the Ioto device agent:

* TLS &mdash; Secure Sockets Layer
* Sandbox limits directives
* Authorization directives
* Safe, secure portable runtime
* Simple fiber coroutine programming paradigm

Ioto supports the MbedTLS and OpenSSL stacks. You can configure server and/or client certificate-based authentication.

## Safe Portable Runtime (R)

Ioto is built upon a portable runtime layer called the Safe Portable Runtime or "runtime" for short. This layer insulates the rest of the product from the underlying platform and allows it to be highly portable to new operating systems or hardware.

The runtime provides a suite of services that facilitate the creation of high performance management applications, including: buffer management, networking, safe string handling, events, wait management, logging, lists and hashing.

The runtime permits the rest of the Ioto code to be more secure by using the safe primitives offered by the runtime. It includes many mechanisms to assist in the creation of secure applications. One such facility is a safe string and buffer handling module to help eliminate the buffer overflows that have plagued many products.
# local.json5

Sometimes during development, it is useful to be able to override settings in the **ioto.json5** configuration file for testing purposes.

The **local.json5** configuration file serves this purpose and is blended with and overrides the **ioto.json5** configuration file.

The **local.json5** configuration file has the same properties as the [ioto.json5](properties.html) configuration file.

## Profiles

The **local.json5** configuration can use multiple property profiles that are selected at runtime. 
When Ioto is run, it executes with selected profile. This is typically `prod` for production and `dev` for development. However, you can create your own profiles for any desired execution configuration such as `qa` or `test`.

The Ioto profile is defined via the PROFILE environment variable or via the `--profile` command line option.

Configuration profiles are defined under the **conditional.profile** property in any configuration file. The relevant configuration properties are selected by the current Ioto **profile**.

For example:

```js
conditional: {
    profile: {
        dev: {
            limits: {
                //  Override the default stack size
                stack: '64k',
            }
        },
        prod: {
            log: {
                //  Send trace to a specific output file
                path: 'ioto.log',
            }
        }
    }
}
```

## Overriding the device.json5

A typical use-case for the **local.json5** is to override the device.json5 and specify a test device ID and product. You can also specify a manager account and cloud ID to auto-claim the device.

```json
{
    conditional: {
        profile: {
            dev: {
                device: {
                    id: 'P4CH123456',
                    product: '01HAVJGGHYG7FXXXXXXXXXXXXX',
                    name: 'Acme Router',
                    description: 'Acme Router for Home Office',
                    model: 'Office-Hub',
                    test: true,
                    account: '01HK6J56WN9XXXXXXXXXXXXXXX',
                    cloud: '01HJ7W4YBWXXXXXXXXXXXXXXXX',
                }
            }
        }
    }
}
```# Building Ioto

The Ioto source code has been designed to run on Arduino, ESP32, FreeBSD, FreeRTOS, Linux, Mac OS X, VxWorks and other operating systems. Ioto supports the X86, X64, Riscv, Riscv64, Arm, Arm64, and other CPU architecutres. Ioto can be ported to new platforms, operating systems and CPU architectures. Ask us if you need help doing this.

Several build environments are supported: 

-   **Linux** &mdash; Linux 4 with GNU C/C++
-   **Mac OS X** &mdash; Mac OS X 11 or later
-   **Windows** &mdash; Windows 11 with WSL v2
-   **ESP-32** &mdash; Using the [ESP IDF](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/index.html)

For other environments, you will need to [cross-compile](cross-compiling.md). 


## Build Configuration

You do not need to use a `configure` program when building via **make**. Instead, you select the desired sample app and just run make. 

The Ioto distribution build includes several demo apps for local or cloud-based management. Apps demonstrate device-side logic to implement various management use cases. The default app is the "demo" app which sends device data and metrics to the cloud.

When `make` is invoked, it will copy the selected app's **ioto.json5** file to the **state** directory and generate a **src/ioto-config.h** header that will ensure the required services are compiled.

## Building

If you are building on Windows, or for ESP32 or FreeRTOS, please read the specific instructions for various build environments:

* [Building on Windows](#building-on-windows)
* [Building for the ESP32](building-esp32.md) 
* [Building for FREERTOS](building-freertos.md)

Read below for generic build instructions.

## Building with Make

To build on Linux, MacOS or Windows via WSL, use the system **make** command. The supplied Makefile will build the Ioto library (libioto.a) and the "ioto" main program. If you are embedding Ioto in another program, you should link the Ioto library with your program. See [Linking](#linking-with-ioto) below for details. 

The top level Makefile parses your selected App's **ioto.json5** configuration file, detects your operating system and CPU architecture and then invokes the appropriate project Makefile for your system. It copies the select app configuration from the **apps/NAME/config** directory to the **state** directory.

To build, nominate your selected app via the "APP=NAME" makefile option:

```bash
$ make APP=demo
```

The default build of Ioto is configured to build the Ioto agent and the `demo` management app which saves device data and metrics to the cloud.

## Building on Windows

Building on Windows utilizes the [Windows SubSystem for Linux (WSL)](https://learn.microsoft.com/en-us/windows/wsl/about). Using WSL, you get a tightly integrated Linux environment from which you can build and debug using VS Code.

To build, first [install WSL](https://learn.microsoft.com/en-us/windows/wsl/install) by running the following command as an administrator:

```bash
$ wsl --install
```

Then invoke **wsl** to run a wsl (bash) shell:

```bash
$ wsl
```

To configure WSL for building, install the following packages from the wsl shell.

```bash
$ apt update 
$ apt install make gcc build-essential libc6-dev openssl libssl-dev
```

Then extract the Ioto source distribution:

```bash
$ tar xvfz ioto-VERSION.tgz ioto
```

Finally build via **make**:

```bash
$ cd ioto
$ make
```

To debug with VS Code, add the [WSL extentension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl) to VS Code and then from a WSL terminal, open VS Code from the ioto directory:

```bash
$ cd ioto
$ code .
```

This will open a remote WSL project for the Ioto distribution.

## Building with an IDE

Ioto includes Xcode projects that provide easy access for building and debugging. The generated IDE projects will build Ioto using default settings and are somewhat limited in their configurability.

To build with the Xcode on Mac OS X, run Xcode 12 or later and open the projects/ioto-macosx.xcodeproj project. Then select the Product -> Build menu option to build the software. To debug, you will need to create use Product -> Edit Scheme to set the executable to run under the Info tab, and define the working directory under the Options tab.

## Build Profiles

You can change the build and execution **profile** by editing **ioto.json5**. Two build profiles are supported:

* dev
* prod

The **dev** profile will build Ioto with debug symbols and local state directories suitable for debugging.

The **prod** profile will build Ioto optimized without debug symbols. Database state and logs will be stored in the appropriate O/S locations.

After changing the profile, run:

```bash
$ make clean
$ make
```

## Changing the TLS Stack

Ioto includes support for multiple TLS stacks including:

* [OpenSSL](https://www.openssl.org)
* [MbedTLS](https://tls.mbed.org)

Ioto is built with OpenSSL by default. OpenSSL is a leading open source TLS stack that is faster, but bigger. MbedTLS is a compact TLS implementation. When built for ESP32, the supplied ESP32 MbedTLS will be used.

### Downloading OpenSSL

Most Linux distributions include OpenSSL with their default distribution. We support the latest stable and LTS releases only. If you want to build with a custom OpenSSL build, you will need to supply the Ioto project with the pathname to your OpenSSL source code directory.

### Building with MbedTLS

To build with MbedTLS, install MbedTLS version 3 or later using your O/S package manager. For example:

```bash
# On mac
$ brew install mbeddtls

# On Linux
$ apt-get install libmbedtls-dev
```

Then build via:

```bash
make ME_COM_MBEDTLS=1 ME_COM_OPENSSL=0 SHOW=1
```

To install MbedTLS from source, download and install [MbedTLS](https://github.com/Mbed-TLS/mbedtls.git) from:

```bash
$ git clone https://github.com/Mbed-TLS/mbedtls.git 
```

Then checkout the latest stable release (at least version 3.6)

```bash
$ git tag
$ git checkout PICK-TAG
```

For a debug build:

```bash
cmake -DCMAKE_BUILD_TYPE=Debug .
make VERBOSE=1
```

Then build Ioto:

```bash
$ make ME_COM_MBEDTLS=1 ME_COM_OPENSSL=0 ME_COM_MBEDTLS_PATH=/path/to/mbedtls SHOW=1
```

If you wish to use test certificates, you may need this patch (needed for 3.6.0): [MbedTLS Issue 8509](https://github.com/Mbed-TLS/mbedtls/issues/8509#issuecomment-2076818915)

### OpenSSL via Make

Ioto will build with the system installed OpenSSL libraries by default on Linux.

If you want to use a custom OpenSSL build or you are cross-compiling, run make:

```bash
$ make ME_COM_MBEDTLS=0 ME_COM_OPENSSL=1 ME_COM_OPENSSL_PATH=/path/to/openssl SHOW=1
```

### OpenSSL via Xcode

Open the MacOS project:

```bash
$ open projects/ioto-macosx-default.xcodeproj/project.pbxproj
```

Then click on "Build Settings" in the panel in the center. Scroll down to define the path to your OpenSSL source code directory in the ME_COM_OPENSSL_PATH property.

# URL HTTP Client

The Ioto URL API is a HTTP client for interacting with HTTP servers. It is a full-duplex streaming HTTP client that can retrieve both documents and live streaming data. The URL client supports both HTTP and WebSockets over HTTP.

The URL client uses a fiber coroutines to that you can write natural, blocking, procedural code without ugly callbacks or complex threads. It is a highly efficient HTTP and WebSockets client that uses minimal CPU from only 11K of code.

## URL Features

* HTTP/1.0, HTTP.1.1 client.
* WebSockets client.
* Fully streaming API for dynamic input and output.
* Convenience JSON API for interacting with REST services.
* Single-threaded, fiber coroutine event-based runtime without ugly callbacks or complex threads.
* TLS/SSL 1.3 with certificate verification controls.

## API Quick Tour

The URL API provides a high-level simple API and a lower-level API with more granular control.

The high-level API consists of the routines *urlGet* and *urlPost*.

### Get Request

To get a remote document, use the *urlGet* API:

```c
char *document = urlGet("https://example.com/index.html", headers);
printf("Document %s\n", document);
rFree(document);
```

This call will block the current fiber while other fibers continue to run. When the document has been retrieved, the call will resume and the document will be returned. If the request fails and a non-200 HTTP status is returned, the call returns NULL. When complete, you must free the returned string using *rFree*.

### HTTP Headers

To supply headers with your requests, you can use the headers printf style arguments:

```c
urlGet("https://example.com/data", "Authorization: %s\r\n", password);
```

Each header in the format string must be separated by "\r\n".

### Post Request

To issue a post request, use *urlPost* API

```c
char *document = urlPost("https://my.com/post", data, dataLength, httpHeaders);
```

If the data is a string, you can set the length to be -1 and the length will be calculated from the string. The last NULL argument is for optional HTTP headers.

```
char *document = urlPost("https://my.com/post", "Hello World", -1, NULL);
```

### JSON Responses

If you want to issue a POST request and retrieve a JSON document, you can use the JSON variants *urlPostJson*:

```c
Json *json = urlPostJson("https://my.com/", data, dataLength, NULL);
jsonPrint(json);
```

Use the [JSON](../dev/json.md) APIs to manage the returned JSON in-memory tree result.

### WebSockets

To start a WebSockets session, use the *urlWebSockets* API:

```c
int status = urlWebSocket("https://my.com/post", onRead, NULL, NULL);

// This return zero when closed, otherwise a negative status code.

void onRead(WebSocket *ws, char *buf, ssize len, void *arg)
{
    printf("Received %s\n", buf);
    webSocketSend(ws, "%s", "Response message");
}
```

See [URL WebSockets](websockets.md) for details.

## Low Level API

The URL client also offers a [low-level API](low-level.md) for granular control.


## API

* [URL API](/agent/ref/api/url.html)
* [WebSockets API](/agent/ref/api/websockets.html)# Low-Level API

To use the low-level API, first create a URL instance via *urlAlloc*:

```c
Url *url = urlAlloc();
```

When finished, free the URL with *urlClose*.

The primary low-level API is *urlFetch*. This API supports issuing any HTTP method with body data and headers.

### urlFetch

```c
int status = urlFetch(url, "POST", "https://my.com/data", data, dataLength, NULL);
```

This call returns a HTTP status code. To retrieve the returned data, use *urlGetResponse* or *urlGetJsonResponse*:

### urlGetResponse

```c
char *data = urlGetResponse(url);

// or

Json *json = urlGetJsonResponse(url);
```

### urlFetchJson

You can also use the JSON variant *urlFetchJson* which returns the JSON tree if the HTTP return status is a successful 200 code.

```c
Json *json urlFetchJson(url, "POST", "https://my.com/data", data, dataLength, NULL);
```

In this case, you can call *urlGetStatus* to return the HTTP status code.

### urlGetHeader

To retrieve returned HTTP headers, use *urlGetHeader*:

```c
cchar *length = urlGetHeader(url, "Content-Length");
```

## Streaming

The Ioto URL client fully supports streaming data in both directions.

To start a streaming request, use *urlStart*. Then write data blocks with *urlWrite*.

When complete, write a NULL block to signify the end of the posted data.

```c
urlStart(url, "POST", "https://my.com/data");
urlWriteHeaders(url, "X-Custom: %s\r\n", "custom-header");

urlWrite(url, data, dataLength);
urlWrite(url, moreData, moreDataLength);
//  signify end of data
urlFinalize(url0);
```

To stream the response, use *urlRead*:

```c
char buf[1024];
do {
    if ((nbytes = urlRead(url, buf, sizeof(buf))) == 0) {
        //  End of input
        break;
    } else if (nbytes < 0) {
        //  Error
    }
} while (nbytes > 0);
```

## Timeouts

You can define a timeout limit for URL requests incase the server should hang.

```c
urlSetTimeout(url, timeInMillisconds);

//  or set for all requests
urlSetDefaultTimeout(timeInMillisconds);
```

## API

* [URL API](/agent/ref/api/url.html)
* [WebSockets API](/agent/ref/api/websockets.html)# WebSockets Client

The WebSockets client offers a high-level and a low-level API.

## Starting a Session

To start a WebSockets client session using the high-level API, use the *urlWebSockets* API:

```c
if (urlWebSocket("https://my.com/post", onEvent, arg, headers) < 0) {
    //  Error
}
```

This call return zero when closed, otherwise a negative status code.  You can supply HTTP headers on the call if required. 

## Protocol Selection

To select the WebSocket sub-protocol, add a "Sec-WebSocket-Protocol" header.

```c
if (urlWriteHeaders(up, "Sec-WebSocket-Protocol: real-time\r\n") < 0) {
    //  Connection error
}
```

## Incoming Messages

When incoming messages are received, the `onEvent` callback will be invoked with the argument provided when **urlWebSocket** was called.

```c
void onEvent(WebSocket *ws, int event, char *buf, ssize len, void *arg)
{
    switch (event) {
    case WS_EVENT_OPEN:
    case WS_EVENT_CLOSE:
    case WS_EVENT_ERROR:
        break;

    case WS_EVENT_MESSAGE:
    case WS_EVENT_PARTIAL_MESSAGE:
        printf("Received %s\n", buf);
        webSocketSend(ws, "%s", "Response message");
        break;
    }
}
```

## Sending Data

Use **webSocketSend** to send a printf styled formatted message. To send a literal string, use **webSocketSendString**  and to send binary data, use **webSocketSendBlock**. 

```c
webSocketSend(ws, "Hello %s", "World");
webSocketSendString(ws, "Hello World");
webSocketSendBlock(ws, WS, "Hello World", 11);
```

## Closing Connections

To instruct the peer to do an orderly close, call **webSocketSendClose**.

```c
webSocketSendClose(ws, WS_STATUS_OK, "End of session");
```

## Low-Level API

WebSockets also provides a low-level API for more granular operation:

```c
Url *url = urlAlloc(0);

if (urlStart(url, "GET", "wss://example.com/websockets/test") < 0) {
    // Connection failed
}
if (urlWriteHeaders(up, NULL) < 0 || urlFinalize(up) < 0) {
    //  Connection error
}
urlAsync(up, onEvent, up);

//  Serve events and wait for the connection to close
urlWait(up);
urlFree(url);
```

The `urlAsync` call defines the callback to invoke for incoming messages, errors and connection events.
The `urlWait` call blocks until the connection is closed. This call is optional. You may wish to continue with other operations and call `urlFree` when processing is complete.

## API

* [WebSockets API](/agent/ref/api/websockets.html).
* [URL API](/agent/ref/api/url.html)# Cloud Messaging

### Best Practices 

Implementing an efficient data communication design is crucial for successful IoT solutions. When managing a large pool of devices, excessive cloud communication can result in high costs, poor performance, and scalability issues.

The Ioto cloud solution offers powerful communication mechanisms such as MQTT messaging and transparent database synchronization. However, if used indiscriminately by sending excessive or redundant data to the cloud, it can compromise your solution and lead to throttling.

To protect your devices, customers, and the service, Ioto enforces data limits. If a device or group of devices sends too much data, Ioto will throttle (slow down) incoming data from those devices. Persistent overuse can result in the offending devices being disconnected from the network.

Follow these best practices to ensure a successful IoT strategy:

1. **Only send necessary data to the cloud**: Limit cloud communication to data that is required at the cloud. Don't send data that is never accessed by the cloud.
2. **Send only changed data**: Avoid redundant data transmission by sending updates only when data changes. If a data item has only one changed field, consider splitting into fixed and changing data items.
3. **Separate configuration data from runtime statistics**: Define database entities to differentiate between the two. Configuration data changes infrequently and can be synchronized to the cloud when updated. Statistics can be buffered and can be sent less frequently.
5. **Utilize automatic metric creation**: Take advantage of automated metrics for efficient monitoring. Ioto can transparently create metrics from database data that can be graphically displayed or used for automated actions.
6. **Synchronize database tables in one direction only**: Ensure that synchronized tables are not bidirectional to prevent conflicts. Split tables to be synchronized up to the cloud, or down to the device, not both.
7. **Avoid messaging loops**: Implement safeguards to prevent loops in your messaging system.
7. **Monitor throttle messages**: Listen for Ioto throttle messages and adjust your device behavior accordingly.

When designing your data strategy, it is helpful to categorize your data into domains. The Ioto database supports easy creation of entities that can wrap the various categories or concerns.

A helpful segmentation is:

1. Deivce configuration that must be shared with the cloud (changes infrequently)
2. Local state that does not need to be sent to the cloud (changes frequently)
2. Error conditions and records 
3. Performance statistics

By segmenting data that is local to the device and the data that must be sent to the cloud, you can achieve a higher performing solution.

## Device Modes

It may also be a useful strategy for devices to be moded as:

1. Under focussed management
2. Self-managing

When a device is under focus, it can send more data to the cloud to permit **live** monitoring, issue diagnosis and resolution. When a device is self-managing, it should communicate only essential data with the cloud. This can permit very high-bandwidth device communications when required, but still maintain a low overall message traffic rate.

## Device Cloud Limits

Ioto defines data limits to protect you, your devices, customers and the service. If a device or devices send too much data to the cloud, Ioto protects you and your customers by throttling (slowing) incoming data from offending devices. 

Depending on your Device Cloud plan these limits and enforcement policies may vary. 

### Data Traffic

The amount of data you send to the device cloud is measured as the number of KBytes sent on average per device per hour. This traffic is then compared with the limit for your device cloud.

As you connect more devices, your data limit scales automatically with the number of devices connecting to the cloud. What is measured is the average data traffic over your entire pool of connecting devices.

For example, if you have 100 devices and a limit of 60 messages per device per hour, this means that your pool of devices can send up to 6,000 messages to the cloud per hour. 

Ioto supports short-term burst traffic above the limit, but if your sustained, aggregate traffic exceeds your limit, the offending devices will have their sending rate throttled.

### Data Limits

The data limits vary depending your your device cloud type and plan. 

For Hosted device clouds and the Evaluation device cloud, data limits ensure the cloud infrastructure is not monopolized by any one device, set of devices or users.

The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It has higher limits, as it is typically used with few devices and consequently lower aggregate device pool limits.

For a Dedicated cloud, you are the sole user of the cloud running in your own AWS account. In this case limits are advisory and can be increased if required. Contact support if you need a limit increase.

### Cloud Limits

Device Cloud| Limit
-:|:-
Eval Cloud | 60 messages (1K) per device per hour
Hosted Cloud | 10 messages (1K) per device per hour
Dedicated Cloud | 100 messages (1K) per device per hour# Cloud Management

Cloud based management is enabled via the **ioto.json5** services.

```json
{
    services: {
        database: true,
        demo: true,
        keys: false,
        logs: false,
        mqtt: true,
        provision: true,
        register: true,
        serialize: 'auto',
        shadow: false,
        sync: true,
        update: true,
        url: true,
        web: false,
    },
}
```

The **mqtt** service enables cloud communications. The **provision** service enables devices to be claimed by cloud-based device managers and to be provisioned with TLS certificates for communication with the cloud service. The **sync** service enables transparent synchronization of device data with the cloud.

The easiest way to configure cloud-based management is to select the **Manager** app when building Ioto. The app will supply a configured **ioto.json5** file.

```
make APP=manager clean build
```

The **Manager** app builds and configures Ioto for cloud-based management using the Device Manager.


## Running Ioto

After [Building Ioto](../user/building.md) run Ioto via **make run**:

```bash
$ make run
app: info: Starting Ioto 1.4.0 in "cloud" mode using "dev" profile
setup: info: Enabling services: db provision register sync serialize test web
app: info: Device Claim ID: M72DANY8BZ
register: info: Device registered with https://api.admin.embedthis.com/api
{
    "product": "01H4R15D3478JD26YDYK408XE6",
    "id": "M72DANY8BZ",
    "created": "2024-01-23T02:03:57.062Z"
}
register: info: Device not yet claimed
app: info: Ioto 1.4.0 ready, Device firmware 1.3.0
```

When Ioto starts, it registers with the EmbedThis Ioto cloud service and waits to be claimed by a user for management. 

## Device Association

The process of associating a device with a user is called **"Claiming"** and consists of a user presenting a device claim ID that authorizes the user as the owner of the device. The unique claim ID is typically printed on the manufactured device. When evaluating Ioto, the Ioto agent will display the claim ID to the console. 

An Ioto enabled device can be claimed by any user. Once claimed, the device is associated with the user, a device manager and the underlying device cloud.

During evalution, it is easiest to use the pre-existing Builder **Eval Cloud** and **Eval Device Manager**. The Builder's Eval Cloud is a multi-tenant, shared cloud for evaluating Ioto. The Eval Manager is a developer device manager suitable for examining and managing devices and device data.

To claim the device using the Eval manager, navigate to the builder and select the **Managers** page.

[![Manager List](/images/builder/manager-list.png){class="screen"}](https://admin.embedthis.com/managers)

Then click the **Manage** icon for the **Eval** manager. This will launch the [Device Manager](/apps/).

## Manager Login 

When you log into the Device Manager, you are logging in as a device user. This is a different account to your Builder login account. Device Manager logins are unique for each device cloud.

![Manager Login](/images/manager/developer-login.png){class="screen width-40"}

Enter your desired username and password and click **Register**. You will be sent an email confirmation code to complete your manager login.

# Claiming a Device

After logging in, you will see the device list, which will be initially empty. Click the **Claim Device** button and enter your device claim ID to claim your device for management.

![Manager Login](/images/manager/device-claim.png){class="screen"}

The Claim ID is the unique device ID displayed by Ioto when run. This ID is dynamically allocated when first run, but can be initialized via the **config/device.json5** configuration file. During production, a generated device claim ID is typically printed on the device packaging and device label. 

Read more in the [Builder Claiming Devices](/ioto/provisioning/claiming.html) documentation.

```bash
$ make run
...
app: info: Device Claim ID: M72DANY8BZ
```


While an Ioto-enabled device is waiting to be claimed, Ioto will periodically check with the cloud service to see if it has been claimed. 

Once the device is claimed via the Manager, Ioto will display:

```bash
provision: info: Device claimed
provision: trace: {
    accountId: "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    certificate: "state/ioto.crt",
    endpoint: "xxxxxxxxxxxxx-ats.iot.xxxxxxxxxxxxxx.amazonaws.com",
    id: "M72DANY8BZ",
    key: "state/ioto.key",
    port: 443
}
provision: info: Device provisioned
checkin: info: Device has no pending updates for version: 1.3.0
mqtt: info: Connected to mqtt: xxxxxxxxxxxxx-ats.iot.xxxxxxxxxxxx-1.amazonaws.com:443
demo: info: Running demo cloud counter
demo: info: Send counter update via MQTT -- counter 0
```

When claimed, the Ioto agent will be provisioned with a unique device certificate for secure TLS communications and will connect to the cloud using the MQTT protocol. These will be saved under the **./state** directory as **ioto.crt** and **ioto.key**.

## Cloud Messaging

The default Ioto configuration will run a demo routine to update a counter and send the updated value to the cloud. This counter updates every thirty seconds and can be monitored via the Device Manager.

In the Device Manager, select the claimed device from the device list.

![Manager Login](/images/manager/device-list-1.png){class="screen"}

This will then display the database tables and dashboard for this device.

## Key/Value Store

The default device schema has a key/value table called the **"Store"**. The demo counter, will update a value with the key of **"counter"**. Click on the **Store** table to display the store contents.

This will display all the data items in the store for claimed devices. From here, you can modify an item by clicking the **Edit** icon or you can edit in place by clicking on a teal color cell and updating the value and then clicking **Save**.

![Store Table](/images/manager/store-table.png){class="screen"}

You can reload the table contents by clicking the table reload icon.

## Manager Dashboard

The Device Manager includes the ability to display one or more dashboards with data widgets.

Click the **Dashboard** tab to display the default dashboard, then click the **Add Widget** icon to display the add widget panel.

![Store Widget](/images/manager/store-widget-add.png){class="screen"}

You can display database and metric data using numeric, gauge or graphical widgets.

To display the demo counter as a numberic from the database, enter the following widget configuration:

Field | Value
-|-
Type | Numeric
Namespace | Database
Model | Store
Field | value
Select Item | key=counter

This will select the Store table item that has a key value set to "counter" and display the "value" field.

After the ioto agent has run for a minute, there will be sufficient data points for a "COUNTER" metric to be created. Metrics permit the display of current and historical data using graphical widgets.

To display the demo counter as a graph using metrics, enter the following widget configuration:

Field | Value
-|-
Type | Graph
Namespace | Embedthis/Device
Metric | COUNTER
Statistic | avg
Resource Dimensions | Device=YOUR-CLAIM-ID

That should get you started with Ioto and posting data to the cloud from your device.# Cloud Overview

Device clouds are regional management hubs, from which you can centrally operate and manage a set or fleet of devices. 

A device cloud stores device data and manages communications with your devices. By aggregating critical device data in one place, you can more easily manage your devices and extract important data analytics and intelligence from your device pool. You can create one or more device clouds to segment your products and devices.

![Builder Dashboard](/images/builder/dashboard.png){class="screen"}

When creating device clouds, the Builder will create the necessary AWS resources including a DynamoDB device database and IoT messaging services.


## Device Cloud Services

The Ioto device cloud offers the following:

* Automatically provision Ioto-based devices with X.509 certificates for secure communications.
* Setup MQTT communications between devices and the cloud.
* Create and maintain a cloud-based device database store for centralized management and analytics.
* Transparently create and manage dedicated AWS IAM access keys for each device.

## Data Privacy

The Device Cloud is created in a region of your chosing so you have total control and privacy regarding your device data. Device data goes directly from your devices to your device cloud database. The device data is not sent through other third-party services and is encrypted througout. This is important as governments are increasingly requiring that data only be stored, processed and managed locally.

Unlike other IoT services which transport your device data around the globe, Ioto provides decreased latency by locating device data in an AWS cloud in a nearby region of your choosing. This lowers cost and boosts performance of your cloud-based management solution.
 
## Device Certificates

Devices require X.509 certificates to securely connect and communicate with the cloud. The certificates are used to uniquely identify and authenticated devices and then to encrypt communications to prevent tampering or eavesdropping.

Ioto will automatically create and distribute the required certificates as devices are assigned to a device cloud. This eliminates much of the pain of certificate distribution.

## Device Messaging

During device provisioning, the Ioto service will setup the necessary AWS resources to enable secure efficient messaging via AWS IoT core using the MQTT protocol.

MQTT is a messaging protocol for IoT. It is a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices.

When connected, your management applications can control devices, send commands and retrieve data using the MQTT messaging service.

## Device Data Aggregation

Collecting, aggregating and sending device data to a central management store can be complex and costly. Ioto takes the pain out of exporting device data to the cloud by transparently synchronizing device data with the cloud.

Device data written saved the device to the Ioto database will be transparently exported to the cloud. Similarly, data written to the cloud database will be distributed to appropriate devices as required. No programming is required.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-device and per-table basis.

This is similar to AWS Global Tables, but instead of acting inside AWS between AWS regions, it is between an AWS region and a device.

The Ioto replicated device database is unique to Ioto and dramatically simplifies the creation of IoT solutions.

## Device Access Keys

Ioto can optionally create and manage AWS IAM access keys for your devices. AWS uses IAM access keys to authenticate and authorize actors on AWS resources. The Ioto device cloud can create specific IAM keys to enable devices to issue requests to the device cloud and AWS services.

Ioto generates temporary IAM access keys that have tightly controlled access permissions. The keys are automatically distributed to devices and reissued as required.

## Device Logging

If required, device logs and files can be captured and sent to AWS CloudWatch logs for storage, analysis and governance.

The Ioto agent can be configured without coding, to capture any O/S log or program output and send it to CloudWatch Logs. The Ioto agent log is similarly exportable.

## Device Metrics and Analytics

AWS provides a comprehensive metric service via CloudWatch Metrics. The Ioto agent can emit metrics that will be captured by the device cloud and managed by CloudWatch.

Using these metrics, you can create detailed device analytics and dashboards to focus on any aspect of your device or fleet performance.

## Account Audit

When your device cloud is created, Ioto configures and enables CloudTrail which captures and audit trail of **all** activity on your account and device cloud.  This records a complete record to AWS S3 so you can reliably audit operations and determine root cause of any security incidents.

# Ioto<sup>&reg;</sup> Device Agent

![Agent](/images/ioto/embedded-agent.avif){class="width-30 left"}

The EmbedThis Ioto Agent is an powerhouse embedded device agent for direct or remote device management. It is compact, but blazing **fast** and has an extensive suite of management protocols and capabilities.

The Ioto Agent includes a HTTP web server, MQTT client, HTTP client, embedded database, JSON parsing, AWS IoT cloud integration, easy provisioning, over-the-air software upgrading and the ability to run and invoke AI models.

The agent can be used for local management via its embedded web server or it can be integrated with the cloud via comprehensive AWS IoT integration.

## Cloud Ready

The agent is cloud ready and provides data synchronization with the cloud and integration with a suite of AWS services including: AWS IoT core, rules, shadows, AWS EventBridge and AWS DynamoDB. The agent transparently synchronizes device data into the cloud-side DynamoDB database. Optional support is provided for dedicated clouds to capture logs into CloudWatch Logs, and utilize file and data upload to AWS S3 data lakes.

## Apps Included

The Ioto Agent source distribution includes a few sample management applications that are integrated with Ioto. 

The Ioto Sample **Apps** package, available for download from the [Builder](https://admin.embedthis.com) includes several management apps that communicate with either the local Ioto web server or with the cloud-based Ioto service. These apps are are browser-based [VueJS](https://vuejs.org/) apps that are designed to be used with the Ioto Agent.

Name | Package | Directory | Description
-|-|-|-
auth | Agent | apps/auth | Test user login and authentication app
console | Apps | apps/console | Local developer console for Ioto
cloudkick | Apps | apps/kickstart | Local Kickstart sample "router" management app
eco | Apps | apps/eco | Local Kickstart sample "router" management app
kickstart | Apps | apps/kickstart | Local Kickstart sample "router" management app
empty | Agent | apps/empty | Empty application to resolve application hooks
standard | Agent | apps/standard | Cloud-based device manager developer console for Ioto
unit | Agent | apps/unit | Unit tests app

## Modular and Configurable

If you only want an embedded web server, the agent is easily configured to enable just the modules you need. You can configure the agent to include only the web server, or include the HTTP client or you can enable full cloud management integration.

## Highly Optimized

The agent is optimized for embedded device management via an evolved, high performance management runtime that delivers exceptional throughput and effective memory utilization. Ioto eliminates the ugliness of event callbacks and the complexity of threads by using fiber coroutines. Ioto is compact and is especially effective in reducing per-request CPU and memory overhead.

The agent has a tiny memory footprint of only 200K of code. It is ideal for Linux and FreeRTOS systems and is easily ported to other platforms.

## Deployed Widely

The Ioto agent draws from our code base at EmbedThis, where we have experience in providing the most widely deployed embedded web servers. Our software has been deployed in networking equipment, telephones, mobile devices, and consumer and office equipment worldwide in many hundreds of millions of devices for over 20 years.

## Components

The Ioto agent provides the following components:

* HTTP/1.1 server with dynamic rendering, authentication, cookies, sessions and file upload
* HTTP/1.1 client
* MQTT/3.1.1 client
* WebSockets client and server
* Server-Sent Events (SSE) client and server
* Embedded database
* JSON/5 parser and query engine
* Transport Layer Security (TLS/SSL) with ALPN support
* OpenAI API support for chat, reponses, and real-time streaming
* AWS IoT Integration with IoT Core, Shadows, Events and Rules
* AWS service integration with S3, Lambda, Kinesis and CloudWatch
* Transparent Database synchronization to AWS DynamoDB (like Global Tables)
* Safe, secure runtime core
* Easy provisioning
* Over-the-air software and firmware upgrading
* User authentication
* Complete documentation
* Extensive Samples
* Full Source code

## Want More?

To learn more about Ioto, please read:

* [Ioto Developer Background](user/background.md)
* [Ioto Use Cases](start/uses.md)
* [Ioto Web Site](https://www.embedthis.com/ioto/)
* [Ioto Agent Download](https://admin.embedthis.com)
* [EmbedThis Web Site](https://www.embedthis.com)
# Agents and Tools

The OpenAI Responses API supports the use of tools and agents. Tools are pre-defined functions that can be invoked by the LLM or agent to access information or perform actions. Agents are automated AI entities that can independently accomplish tasks by invoking tools to achieve a goal.

The OpenAI Responses API provides cloud-side tools for web searches, file retrievals, and computer operations. The Ioto Agent framework extends the Responses API to provide an environment for local tools that can be used to augment the pre-trained knowledge of the LLM. Ioto also provides a suite of built-in tools, such as: upgrade-device, reboot-device, and signal-condition.

## API Tour

Here is a simple example of an AI agentic workflow. The example demonstrates a patient monitor that "measures" a patient's body temperature and will call an ambulance if the patient needs urgent care.

The example is triggered by running the `patient.html` web page. The page will ask the cloud LLM to evaluate the patient's state. The LLM will respond and request the device to get the patient's temperature. The device will respond with the temperature and the LLM will evaluate the patient's state again and reccomend treatment. If an emergency ambulance is required, the LLM will respond with a request to call an ambulance via the callEmergency() function.

```c
#include "ioto.h"

void example(void)
{
    Json *request, *response;
    char *text;

    request = jsonAlloc(0);
    jsonSetString(request, 0, "input", "How is the patient doing?");
    jsonSetString(request, 0, "instructions",
        "Your are a doctor. You are given a patient temperature and you need to determine if the patient is in urgent need of medical attention. If so, call emergency response by using the callEmergency() function. In your response, state the patient's temperature in C and the result of your assessment. Do not give any other information.");

    jsonSetJsonFmt(request, 0, "tools", "%s", SDEF([{
        type: 'function',
        name: 'getTemp',
        description: 'Get the patient temperature',
        parameters: { type: 'object', properties: {} },
    }, {
        type: 'function',
        name: 'callEmergency',
        description: 'Call emergency response as the patient is critically ill',
        parameters: { type: 'object', properties: {} },
    }]));

    if ((response = openaiResponses(request, agentCallback, NULL)) == NULL) {
        jsonFree(request);
        return sclone("Cannot determine treatment for patient.");
    }
    printf("Response: %s\n", jsonGet(response, 0, "output_text", 0));

    jsonFree(request);
    jsonFree(response);
}
```

```c
static char *agentCallback(cchar *name, Json *request, Json *response, void *arg)
{
    if (smatch(name, "getTemp")) {
        return getTemp();
    } else if (smatch(name, "callEmergency")) {
        return callEmergency();
    }
    return sclone("Unknown function, cannot comply with request.");
}

static char *getTemp(void)
{
    static cchar *temps[] = { "36", "37", "38", "39", "40", "41", "42" };
    static int   index = 0;

    if (index >= sizeof(temps) / sizeof(temps[0])) {
        index = 0;
    }
    return sclone(temps[index++]);
}

static char *callEmergency(void)
{
    return sclone("Ambulance dispatched");
}
```

The `openaiResponses` API takes a JSON object which represents the Response parameters. The `SDEF` macro is a convenience to make it easier to define JSON objects in C code. The SFMT macro expands `printf` style expressions. The `jsonParse` API parses the supplied string and returns an Ioto Json object which can be passed to the `openaiResponses` API.

The `agentCallback` parameter is invoked when the LLM needs to invoke a local tool. The callback is passed the tool name and the request and response JSON objects. The callback should return a string containing the results of the tool call.

The response object returned by the `openaiResponses` API is a JSON object that can be queried using the Ioto JSON library `jsonGet` API. The `output_text` field contains the complete response output text.

Consult the [Responses API](https://platform.openai.com/docs/api-reference/responses) for parameter details.

See the `ai` app in the Ioto Agent source download for this example. The `patient.html` web page initiates the demo. The **src/apps/ai/aiApp.c** file contains the example code and the web action to invoke the example.

## References

Consult the OpenAI documentation for API details:

* [OpenAI Agents API](https://platform.openai.com/docs/guides/agents)
* [OpenAI Responses API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)---
image: https://www.embedthis.com/images/ioto/embedded-agent.avif
---

# AI at the Edge

![IoT AI](/images/ioto/embedded-agent.avif){class="width-30 left"}

Artificial Intelligence (AI) significantly enhances edge devices by enabling more intelligent, autonomous operations. The recent advances in large language models (LLMs) executing in the cloud is leading to transformative applications in the IoT space.

Developers typically select from three principal AI integration patterns: on-device models, cloud-based models, and hybrid models.

**On-device language models** operate entirely within the local hardware environment. This approach guarantees superior data privacy, reduced latency, and consistent operation regardless of network conditions, making it ideal for real-time applications with intermittent connectivity or stringent privacy requirements. However, the complexity and scale of these models are constrained by the limited computational resources of edge devices.

**Cloud-based language models** offload computationally intensive processing to remote servers, enabling the use of robust, large-scale LLMs that surpass the resource capabilities of edge devices. This design provides advanced features, seamless scalability, and simplified updates. Nevertheless, it relies on continuous internet connectivity and may introduce latency.

**Hybrid approaches** combine on-device processing with cloud-based computing. In this pattern, tasks that are privacy-sensitive or critical are executed locally, while more complex, resource-intensive operations are handled in the cloud. This approach effectively blends the strengths of privacy, responsiveness, and scalability, delivering an optimal balance that significantly improves system performance and user experience.

## Ioto IoT AI

Ioto provides an AI library that simplifies interactions with cloud-based LLMs, facilitating tasks such as data classification, sensor data interpretation, information extraction, and logical reasoning. This capability is particularly beneficial for applications in predictive maintenance within industrial settings, smart agriculture, healthcare, smart homes, and environmental monitoring.

>The Ioto AI library facilitates seamless interaction with **cloud-based language models** through integration with the OpenAI Chat Completion, Response, and Real-Time APIs.

## OpenAI and Foundation Models

The Ioto AI provides IoT AI support for the standard OpenAI Chat Completions, Responses and Real-Time APIs. 
While the core API is targeted at the OpenAI implementation, it is easily adapted for other models that utilize the same APIs as the Chat Completions API is supported by many other foundation models. 

### Ioto IoT AI

Ioto provides support for the following LLM APIs:

* [OpenAI Chat Completions API](chat-completion.md)
* [OpenAI Response API](responses.md)
* [OpenAI Response Streaming API](stream.md)
* [OpenAI Real-Time API](real-time.md)

## Configuration

To enable the IoT AI API, ensure the `services.ai` is set to true. The `services.ai` is a compilation and run-time control to initialize the AI library.

```json5
services: {
    ai: true,
    ...
},
```

Then configure the OpenAI access key for your OpenAI account and define your preferred model.

```json5
ai: {
    enable: true,
    provider: "openai",
    model: "gpt-4o",
    endpoint: "https://api.openai.com/v1",
    key: "sk-proj-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
}
```

The `ai.enable` setting enables run-time control of the AI service.

If you are using another foundation LLM other than OpenAI, you can define the API endpoint for that service via the `endpoint` property.   

## References

Consult the OpenAI documentation for API details:

* [Response API](https://platform.openai.com/docs/api-reference/responses)
* [Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [Realtime API](https://platform.openai.com/docs/api-reference/realtime)# OpenAI Chat Completions

The OpenAI Chat Completions API allows developers to integrate OpenAI's conversational models, such as GPT-4 and GPT-3.5, into their applications to create interactive, natural-language conversations with users. It's designed specifically for building chat-based interactions, from simple Q&A chatbots to sophisticated conversational agents.  

Many other foundation models offer APIs that are compatible with the OpenAI Chat Completions API and for these models, the Ioto support may usable. 

It is expected that the newer Responses API will replace the Chat Completions API over time and so developers should use the Response API for new projects.

## API Tour

Here is an example calling the Chat Completions API to ask a simple question. 

```c
PUBLIC void aiChatCompletionExample(void)
{
    Json  *request, *response;
    cchar *model;
    char  buf[1024];

    request = jsonParse(\
        "{messages: [{"
            "role: \"system\","
            "content: \"You are a helpful assistant.\""
        "},{"
            "role: \"user\","
            "content: \"What is the capital of the moon?\""
        "}]}", 0);
    response = openaiChatCompletion(request);

    // Extract the LLM response text from the json payload
    text = jsonGet(response, "choices[0].message.content", 0);
    printf("Response: %s\n", text);

    jsonFree(request);
    jsonFree(response);
}
```

See the `ai` app in the Ioto Agent source download for an example `completion.html` web page that uses the Chat Completion API.

## References

Consult the OpenAI documentation for API details:

* [OpenAI Response API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)# OpenAI Responses API

​OpenAI's Responses is newly introduced API designed to help developers create advanced AI agents and workflows capable of performing tasks cloud-based tasks like web searches, file retrievals, and computer operations on behalf of users. This API streamlines the integration of OpenAI models with built-in tools, eliminating the need for multiple APIs or external services. ​

## Features of the Responses API:

**Built-in Tools**: The API offers tools such as web search, file search, and computer use, enabling agents to access real-time information, retrieve specific documents, and perform tasks on a user's device. ​
OpenAI Developer Community

**Simplified Development**: By combining the simplicity of Chat Completions with enhanced tool usage and state management, the Responses API facilitates the creation of more dynamic and capable AI experiences. ​

## API Tour

Here is an example calling the Responses API to ask a simple question. This example uses file search (aka [RAG](https://blogs.nvidia.com/blog/what-is-retrieval-augmented-generation/)) to augment the pre-trained knowledge of the LLM.

```c
#include "ioto.h"

void example(void)
{
    cchar *vectorId = "PUT_YOUR_VECTOR_ID_HERE";
    char  buf[1024];

    /*
        SDEF is used to catentate literal strings into a single string.
        SFMT is used to format strings with variables.
        jsonParse converts the string into a json object.
     */
    Json *request = jsonParse(SFMT(buf, SDEF({
        model: 'gpt-4o-mini',
        input: 'What is the capital of the moon?',
        tools: [{
            type: 'file_search',
            vector_store_ids: ['%s'],
        }],
    }), vectorId), 0);

    Json *response = openaiResponses(request);

    // Extract the LLM response text from the json payload
    text = jsonGet(response, "output_text", 0);
    printf("Response: %s\n", text);

    jsonFree(request);
    jsonFree(response);
}
```

The `openaiResponses` API takes a JSON object which represents the Response parameters. The `SDEF` macro is a convenience to make it easier to define JSON objects in C code. The SFMT macro expands `printf` style expressions. The `jsonParse` API parses the supplied string and returns an Ioto Json object which can be passed to the `openaiResponses` API.

If you are using local tools, you can pass an "agent" callback as the 2nd parameter to the `openaiResponses` API. This callback is invoked when the LLM needs to invoke a local tool. The callback is passed the tool name and the request and response JSON objects. The callback should return a string containing the results of the tool call.

The response object returned by the `openaiResponses` API is a JSON object that can be queried using the Ioto JSON library `jsonGet` API. The `output_text` field contains the complete response output text.

Consult the [Responses API](https://platform.openai.com/docs/api-reference/responses) for parameter details.

See the `ai` app in the Ioto Agent source download for an example `response.html` web page that uses the Responses API.


## References

Consult the OpenAI documentation for API details:

* [OpenAI Responses API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)
# OpenAI Real-Time API

The OpenAI Realtime API enables the creation of low-latency, multimodal applications capable of real-time interactions. This API supports both text and audio inputs and outputs, allowing for seamless speech-to-speech conversations and real-time transcription services.

Under the hood, the Realtime API establishes a persistent WebSocket connection, facilitating continuous, bidirectional communication between the application and OpenAI's GPT-4o model. This setup enables applications to handle interruptions gracefully and maintain natural conversational flows, similar to human interactions.

Ioto supports the Real-Time API via its WebSocket protocol support. This results in a high-performance direct connection to the LLM.

## API Tour

The following example demonstrates using the `openaiRealTimeConnect` API to establish a WebSocket connection to the OpenAI Real Time API endpoint.

This example loops calling a `getUserQuestion` API to prompt the user for a question to ask. The text is then sent via the `webSocketSend` API to the LLM. This example does not include error handling for clarity.

```c
static void aiChatRealTime(Web *web)
{
    Url   *up;
    cchar *question;
    char  buf[1024];

    if ((up = openaiRealTimeConnect(NULL)) == NULL) {
        webError(web, 400, "Cannot connect to OpenAI");
        return;
    }
    //  This will cause the onEvent to be invoked for incoming messages
    urlAsync(up, (WebSocketProc) onEvent, up);

    while ((question = getUserQuestion()) != NULL) {
        //  Send the user's input question
        webSocketSend(up->webSocket, SFMT(buf, SDEF({
            type: 'conversation.item.create',
            item: {
                type: 'message',
                role: 'user',
                content: [{
                    type: 'input_text',
                    text: '%s',
                }],
            },
        ), question));

        //  Ask for the model to respond
        webSocketSend(up->webSocket, SDEF({
            type: 'response.create',
            response: {
                modalities: [ 'text' ],
                instructions: 'Please assist the user with their question.',
            },
        ));
        //  Incase not yielding in getUserQuestion, yield here for events to run
        rSleep(0);
    }
    urlFree(up);
}
```

On connection events, errors and for incoming messages, the `onEvent` callback will be invoked. The Real Time API sends progressive output via `response.text.delta` messages. These can be incrementally displayed to the user.

See the [Realtime API](https://platform.openai.com/docs/api-reference/realtime) for details.

```c
/*
    Callback for the OpenAI Real Time API.
    This is called when a message is received from OpenAI.
 */
static void onEvent(WebSocket *ws, int event, cchar *message, ssize len, void *arg)
{
    Json    *json;
    cchar   *delta, *type;

    if (event == WS_EVENT_MESSAGE) {
        json = jsonParse(message);
        type = jsonGet(json, 0, "type", 0);
        if (smatch(type, "response.text.delta")) {
            delta = jsonGet(json, 0, "delta", "");
            //  Display the "delta" text to the user
        }
        jsonFree(json);

    } else if (event == WS_EVENT_CLOSE) {
        //  Set a flag to stop processing
    }
}
```

See the `ai` app in the Ioto Agent source download for an example `real-time.html` web page that uses the Real Time API. This sample proxies a browser WebSocket connection to Ioto with the OpenAI Real Time API WebSocket connection.

## References

Consult the OpenAI documentation for API details:

* [OpenAI Response API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)# OpenAI Responses Streaming API

[​OpenAI's Responses](responses.md) API is also capbable of streaming responses.

See the [OpenAI Documentation](https://platform.openai.com/docs/api-reference/responses) for details.

## API Tour

Here is an example calling the Streaming Responses API to ask a simple question. 

```c
#include "ioto.h"

void example(void)
{
    Url   *up;
    cchar *vectorId = "PUT_YOUR_VECTOR_ID_HERE";
    char  buf[1024];

    /*
        SDEF is used to catentate literal strings into a single string.
        SFMT is used to format strings with variables.
        jsonParse converts the string into a json object.
     */
    Json *request = jsonParse(SFMT(buf, SDEF({
        model: 'gpt-4o-mini',
        input: 'What is the capital of the moon?',
        tools: [{
            type: 'file_search',
            vector_store_ids: ['%s'],
        }],
    }), vectorId), 0);

    up = urlAlloc(0);
    up = openaiStream(request, (UrlSseProc) aiStreamCallback, 0);
    jsonFree(request);
    if (up == NULL) {
        rError("example", "Cannot connect to OpenAI");
        return;
    }
    urlWait(up);
    urlFree(up);
}

static void streamCallback(Url *up, ssize id, cchar *event, cchar *data, void *arg)
{
    printf("id: %ld\nevent: %s\ndata: %s\n", id, event, data);
}
```

The `openaiStream` API takes a JSON object which represents the Responses parameters. The `SDEF` macro is a convenience to make it easier to define JSON objects in C code. The SFMT macro expands `printf` style expressions. The `jsonParse` API parses the supplied string and returns an Ioto Json object which can be passed to the `openaiStream` API.

The API returns a HTTP status of which 200 indicates success. The callback function is called for each event in the stream. The `id` is the event id. The `event` is the event type. The `data` is the event data. The `arg` is the user data passed to the `openaiStream` API.

Consult the [Responses API](https://platform.openai.com/docs/api-reference/responses) for parameter details.

See the `ai` app in the Ioto Agent source download for an example `stream.html` web page that uses the Responses API in streaming mode.


## References

Consult the OpenAI documentation for API details:

* [OpenAI Responses API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)# Ioto Agent Samples

Ioto provides an extensive suite of samples for common design patterns.

| Name | Description |
|-|-|
| [link-agent-main](https://github.com/embedthis/ioto-samples/tree/main/samples/link-agent-main/README.md) | Embed the Ioto library in your application and use the Ioto main(). |
| [own-main](https://github.com/embedthis/ioto-samples/tree/main/samples/own-main/README.md)  | Embed the Ioto library with your own main(). |
| [url-fetch](https://github.com/embedthis/ioto-samples/tree/main/samples/url-fetch/README.md">url-fetch) | Issue client HTTP requests to issue REST API request. |
| [url-get](https://github.com/embedthis/ioto-samples/tree/main/samples/url-get/README.md) | Issue simple client HTTP GET requests. |
| [web-auth](https://github.com/embedthis/ioto-samples/tree/main/samples/web-auth/README.md) | Demonstrate user login for a web application. |
| [web-dynamic](https://github.com/embedthis/ioto-samples/tree/main/samples/web-dynamic/README.md) | Generate dynamic responses for HTTP client requests. |
| [web-static](https://github.com/embedthis/ioto-samples/tree/main/samples/web-static/README.md) | Serve static files for HTTP client requests. |
| [web-upload](https://github.com/embedthis/ioto-samples/tree/main/samples/web-upload/README.md) | Process uploaded file in the web server. |
# JSON

The Ioto JSON parser is a high performance JSON parser, serializer and query engine.

It parses JSON text into an in-memory tree for efficient examination, storage and export.

## Json Features

* JSON and JSON5 parser
* Stores parsed JSON as an in-memory tree
* Fast, flexible query engine mange and navigate the JSON tree
* Simple get/set API to retrieve and update JSON values.
* APIs to walk, iterate and navigate a parsed tree
* Overlay and blend JSON trees
* Supports JSON/5 with extensions
* Serialize in strict or JSON/5 formats
* Persist to flash/disk.

## API Quick Tour

To parse a JSON string, call the *jsonParse* API:

```c
Json *json = jsonParse("{Weather: 'Sunny'}", 0);
```

This parses the given JSON text and returns a Json instance which represents the in-memory parsed JSON tree.

!!!Note
    You can provide data to parse as either JSON or JSON/5 format strings. JSON/5 which permits a more relaxed JSON format where property keys may omit quotes and single quotes can be used on values. Also, values can be multi-line strings and may use back-ticks instead of quotes to delimit the strings. Finally, the last item in an object map may be terminated with a trailing comma.

### Getting Values

To query a value from the JSON tree, use *jsonGet*:

```c
cchar *value = jsonGet(json, 0, "weather", NULL);
```

This will retrieve the weather value (Sunny) as a static string that does not need freeing.

When calling jsonGet, you can provide keys with dots:

```c
cchar *value = jsonGet(json, 0, "address.city", NULL);
```

and you can provide a default value to be returned as the last parameter if the property is not defined in the JSON tree.

```c
cchar *value = jsonGet(json, 0, "weather", "rainy");
```

The second argument (0) in these calls defines the starting point from which to search. This is a numeric node ID. Don't worry about it for now, but you'll appreciate it later when searching deeper in a JSON tree.

You can use the *jsonGetInt* and *jsonGetBool* APIs to return data as an integer or boolean data type.

### Setting Values

To update or set a value, use the *jsonSet* API:

```c
jsonSet(json, 0, "weather", "sunny", 0);
```

This will update the value of the given property in-memory. Again, you can use dotted key properties of any depth.


### Data Types

The last parameter to **jsonSet** can be used to specify a data type for the value. In general, the Ioto JSON API can sleuth the data type for you. But as data values are supplied as strings, you may need to specify a type if you want the value to be stored as a number.

The valid types are: JSON_OBJECT, JSON_ARRAY, JSON_STRING and JSON_PRIMITIVE. The primitives are false, true, null, undefined and numbers.

To remove a property, use *jsonRemove*:

```c
jsonRemove(json, 0, "weather");
```

When you are finished with a JSON tree, remember to free it with *jsonFree* to prevent memory leaks.

```c
jsonFree(json)
```

This will release allocated memory.

## Serialization

To save your in-memory tree as a string, use *jsonToString*:

```c
char *string = jsonToString(json, 0, 0, 0);
```

This will save the in-memory tree as JSON/5.

To save in strict JSON, use:

```c
char *string = jsonToString(json, 0, 0, JSON_STRICT);
```

To save a sub-set of the tree, specify the root node to export:

```c
char *string = jsonToString(json, 0, "address", JSON_STRICT);
```

This will save all properties under the "address" (including address) property.


## Working with Files

You can parse a JSON file with the *jsonParseFile* API:

```c
Json *json = jsonParseFile("./file.json", NULL, 0);
```

and you can save the in-memory JSON tree using *jsonSave*:

```c
jsonSave(json, 0, "data.json", 0644, 0);
```

## Navigating and Iterating

Properties in the JSON tree are stored as nodes. These nodes can be identified by a numeric ID or by node reference. Nodes and node IDs are used to very efficiently traverse and enumerate property values.

To get a node ID, use *jsonGetId*:

```c
int id = jsonGetId(json, 0, "address");
```

You can retrieve a node using another node as a starting point:

```c
int addressId = jsonGetId(json, 0, "address");
int cityId = jsonGetId(json, addressId, "city");
```

In fact, most APIs such as *jsonGet* and *jsonSet* take a node ID as a parameter that specifies a root of the tree to base the operation. For example, these are equivalent:

```c
int addressId = jsonGetId(json, 0, "address");
int cityId = jsonSet(json, addressId, "city", "Seattle", 0);

// and

jsonGetSet(json, 0, "address.city", "Brisbane", 0);
```

Similarly, you can retreive a node reference:

```c
JsonNode *node = jsonGetNode(json, "address", "city");
```

You can iterate over nodes using the ITERATE_JSON macro:

```c
JsonNode *child;
int id;
for (ITERATE_JSON(json, 0, child, id)) {
    printf("Property %s has value %s\n", child->name, child->value);
}
```

## Debugging

Use the *jsonPrint* API to print a JSON tree to the console:

```c
jsonPrint(json);
```

## JSON/5

JSON/5 an extension of JSON that makes it easier to create, read and maintain configuration files in JSON.

JSON/5 adds the following JavaScript features to JSON.

* Object keys may be JavaScript identifiers without quotes
* Objects or arrays may have a trailing comma
* Strings may be single quoted
* Strings may span multiple lines (single, double or back-tick quotes)
* Numbers may have a leading or trailing decimal point, be hexadecimal, may begin with a +.
* Values may be regular expressions
* Undefined is a valid value
* Single and multiline comments are allowed and preserved

```js
{
    // single-comment
    /*
        Multi-line comment
    */
    unquotedKey: 42,
    singleQuoteString: 'The "lazy brown fox" jumped...',
    multiLine: "Line one
        line two
    ",
    hex: 0x42,
    trailingComma: {
        one: 1,
        two: 2,
    },
}
```

## Memory References

The JSON engine returns values as static pointers into the in-memory tree. Values are returned as const char* (cchar*) values and this saves having to duplicate strings. This reduces memory footprint and is much more efficient.

It is important not to cast returned values to (char*) or to modify the referenced strings using "dirty" programming to break the const typing protection.

## Optimizations

When JSON parses text, it tokenizes the original text and uses it for individual property keys and values. This means the Ioto JSON parser does not need to re-allocate the JSON text and greatly reduces the memory footprint.

JSON nodes are allocated in a single block which may need to grow if you insert new properties into a JSON tree. For this reason, JSON node references should not be persistently stored. JSON node IDs will be stable despite growing the node storage, but node reference will be re-based. If you need to store JSON node references, you should save IDs rather than node references. 

## References

[JSON5 Spec](https://json5.org/)
# Parallelism

To implement parallelism in an application, a developer has three choices:

1. Threads
2. Non-blocking APIs with callbacks
3. Fiber coroutines

## Threads

Programming with threads can be appealing at first, however a multithreaded design can be problematic. Subtle programming errors due to timing related issues, multithread lock deadlocks and race conditions can be extraordinarily difficult to detect and diagnose. All too often, they appear in production deployments.

## Callbacks

The second approach of using non-blocking APIs with callbacks is simpler to debug. But code quality suffers with the all too common "callback-hell". Relatively simple algorithms become obscure when scattered over cascading callbacks.

## Fiber Coroutines

A compelling alternative, is to use **Fiber coroutines**. A fiber coroutine is code that runs with its own stack and cooperatively yields to other fibers when it needs to wait.

You can think of a fiber as a thread, but only one fiber runs at a time so there is no need for thread locking or synchronizing. For Go programmers, fibers are like Go routines. For JavaScript developers, fibers are similar to async/await.

Fibers allow programs to overlap waiting for I/O or other events with useful compute tasks. They achieve parallelism without the pain.

Fibers solve the main problem with multi-threaded programming where multiple threads access the same data at the same time and require complex locking to safeguard data integrity. Fibers solve this problem by enabling a procedural straight line coding style.

Fibers are not perfect. They will not let you utilize all the CPU cores of a system within one program. But for the use case of embedded device management, this is not a significant concern. Device management applications are generally secondary in purpose to the primary role of the device and consequently should not be monopolizing the CPU cores of the device.

## Parallelism Compared

Consider a **threaded** example:

```c
int count = 0;
pthread_mutex_t mutex;

void increment() {
    pthread_mutex_lock(&mutex);
    count = count + 1;
    pthread_mutex_unlock(&mutex);
}

void getCount() {
    int c;
    pthread_mutex_lock(&mutex);
    c = count;
    pthread_mutex_unlock(&mutex);
    return c;
}
```

Now consider the **fiber** solution:

```c
int count = 0;

void increment() {
    count = count + 1;
}

void getCount() {
    return ccount;
}
```

Since only one segment of code is executing at any one time, there is no possibility of fiber collisions.

## Eliminating callbacks

When doing I/O, applications can choose to perform blocking or non-blocking I/O. Blocking I/O while being simpler, means the application cannot perform any other functions while waiting for I/O to complete.

Consider an application that needs to perform a REST HTTP request to retrieve some remote data. While this request is waiting several seconds, the application cannot perform any other task as it is blocked waiting for the request to complete.

Non-blocking I/O solves this problem, but creates another: "callback hell".

Consider this pseudo-example:

```c
//  Issue a request and invoke the onData callback on completion
httpFetch("https://www.example.com", onData)
return;

//  First Callback
static void onData(HttpResult *result)
{
    if (!result) {
        //  Invoke another request
        httpFetch("https://www.backup.com/);
    }
}

//  Second Callback
static void onComplete(HttpResult *result)
{
    //  Now we done and can process the result
}
```

You can see that callbacks quickly obscure the code's intent.

The alternative Ioto code using **fiber coroutine** would look like this:

```c
int data = urlGet("https://www.example.com");
if (!data) {
    data = urlGet("https://www.backup.com/");
}
```

The calls to urlGet will yield and other fibers will run while waiting for I/O. When the request completes, this fiber is transparently resumed and execution continues.

Fiber-based code is simpler to code, debug and maintain. When converting Ioto from callbacks to fibers, several of our algorithms reduced in lines of code by over 30%.

## Fibers in Practice

In practice, you typically don't need to explicitly code fiber yielding or resuming. The Ioto socket APIs are fiber-aware and will do the yielding for you. The **rReadSocket** and **rWriteSocket** APIs will block the current fiber as required, but other fibers will continue to run. NOTE: that only one fiber is ever running at a time.

In all Ioto services, including the web server, Url client, MQTT client and AWS services: the async APIs are fiber-aware and will yield and resume automatically.

For example:

```c
char buf[1024];

while ((nbytes = rSocketRead(sock, buf, sizeof(buf))) > 0) {
    printf("Got body data %.*s\n", (int) nbytes, buf);
}
```


## Main Program

When using the Ioto fiber coroutines, your main program typically performs little processing before calling **rInit** to create your first fiber. This fiber can then continue initialization and use the full fiber API.

While you can use many of the Safe Runtime (R) APIs from your main program (outside a fiber coroutine), you cannot call **rReadSocket**, **rWriteSocket** and **rConnectSocket** in your main program. It is best practice to call rInit as soon as possible and complete initialization inside a fiber.

If you must read and write from sockets before calling **rInit**, we provide the [rReadSocketSync](http://127.0.0.1:4000/ref/api/r.md#r_8h_1aa75ed2c407f881549fadace8ec56a3bc) and [rWriteSocketSync](http://127.0.0.1:4000/ref/api/r.md#r_8h_1a4a9bc1513a3f0a6f9ef8cd02a91a7041) APIs for that purpose.

## Stack Size

The size of fiber stacks is defined via the **limits.stack** property in the **ioto.json5** configuration file. Set this value to be sufficient for your application needs. 

In general, it is recommended that you limit the use of large stack-based allocations and use heap allocations instead. It is also advised to limit the use of recursive algorithms.

## Ioto I/O API

Ioto builds fiber support into the lowest layer of the "R" portable runtime. The following APIs support automatic fiber yielding:

* [rReadSocket](../ref/api/r.md#r_8h_1a5e68016e4b9381eb07d94855361e4a6d)
* [rWriteSocket](../ref/api/r.md#r_8h_1a59d42a597c69a42387f41d62f0e8c5b2)
* [rSleep](../ref/api/r.md#r_8h_1a35b19891b3c32f496ee52b157cae938a)

These APIs will automatically yield and resume as required.

Furthermore, if you are using TLS, the **rConnectSocket** API must only be called inside a fiber. This is because the handshaking exchange I/O is performed using fiber read/write primities internally.

## Fiber API

Ioto supports a low level fiber API so you can construct your own fiber-enabled primitives.

* [rYieldFiber](http://127.0.0.1:4000/ref/api/r.md#r_8h_1a531c892493b60bb2088705d7f4e447cb)
* [rResumeFiber](http://127.0.0.1:4000/ref/api/r.md#r_8h_1a059333256cfab39b5037149625e1133b)
* [rSpawnFiber](http://127.0.0.1:4000/ref/api/r.md#r_8h_1a116c72a151fb75665eaef53222bcae37)

Use **rYieldFiber** to yield the CPU and switch to another fiber. You must make alternate arrangements to call **rResumeFiber** when required.

Use **rSpawnFiber** to create a new fiber and immediately switch to it. For example:

```c
void myFiberFunction(void *arg) {
    //  code here runs inside a fiber
}
rSpawnFiber(myFiberFunction, arg);
```

## External Services

But what should you do if you need to invoke an external service that will block?

You have two alternatives:

1. Use Non-Blocking APIs
2. Use threads

### Non-Blocking

Ioto provides a flexible centralized eventing and waiting mechanism that can support any service that provides a select() compatible file descriptor.

If the external service has a non-blocking API and provides a file descriptor that is compatible with select or epoll, you can use the Ioto runtime **wait** APIs to be signaled when the external service is complete.

To wait for I/O on a file descriptor, call **rAllocWait** to create a wait object and **rSetWaitHandler** to nominate an event function to invoke.

For example:

```c
wait = rAllocWait(fd);
rSetWaitHandler(wait, fn, arg, R_READABLE);
```

The nominated function will be run on a fiber coroutine when I/O on the file descriptor (fd) is ready.


### Threads

The other option is to create a thread. However you must take care to properly yield the fiber first. The runtime provides a convenient **rSpawnThread** API that will do this for you. It will create a thread, yield the current fiber and then invoke your threadMain. When your threadMain exits and returns a result, it will automatically resume the fiber and pass the result as the return value from rSpawnThread.

For example:

```c
cchar *data = rSpawnThread(threadMain, arg);

static void threadMain(void *arg)
{
    //  Do not call runtime APIs here in this foreign thread
    data = getFromExternalService();
    return data;
}
```

:::warning
It is not safe to call any runtime API from a foreign (not runtime) thread except for: rStartEvent, rResumeFiber, rStartFiber and the thread locking primitives.
:::

If you need to invoke a runtime API from within a foreign thread, you should call rStartEvent to schedule a function that executes on a runtime fiber.

For example:

```c
rSpawnThread(threadMain, arg);

static void insideRuntime(void *arg)
{
    //  Safe to call runtime APIs here
}

static void threadMain(void *arg)
{
    //  This will schedule the "insideRuntime" function to run safely.
    rStartEvent(insideRuntime, arg, 0);
    //  Do not call runtime APIs here in this foreign thread  
    return 0;
}
```


## Manual Yield and Resume

Though unlikely, you may have a need to manually create fibers and yield and resume explicitly.

The APIs for this are: **rAllocFiber**, **rYieldFiber** and **rResumeFiber**.

See the [Runtime API](/agent/ref/api/r.md) for more details.
# Porting Ioto

While porting Ioto is not too difficult, porting any software is not for the novice. It requires skill to read another person's code and adapt it to a new environment. These instructions are intended for experienced developers who want to port Ioto to a new operating system or processor architecture.

Ioto has been written to maximize the ease of porting to a new environment. The O/S and processor-dependent code have been contained while the bulk of the code is cross-platform. Most of this dependent code is in the src/rLib.c file which represents the Safe Runtime (R).

## Steps in Porting to a New System

### Pick a Name for the O/S

If you are doing a port for a new operating system, you need to pick a symbolic name that will be used in conditional compilation, Makefiles, MakeMe files, and operating system specific directories. Some existing O/S names are: "linux", "windows", "freebsd", "freertos", "macosx" and "vxworks".

These names are used as upper-case pre-processor defines and in some cases as lower-case directory names.

### Select the base O/S to emulate

The easiest way to port to a new O/S is to find the closest existing supported O/S that the Ioto software already supports and use it as a base to modify. For example, if you are porting to QNX, you may want to use the Linux port as a base.

### Create the Makefile

Create the Makefile by copying the makefile for the similar O/S. i.e. in our example, Copy the projects/ioto-linux-default.mk Makefile to projects/ioto-qnx-default.mk. Then edit the appropriate compiler and linker switches. 

```bash
$ cp projects/ioto-linux-default.mk projects/ioto-qnx-default.mk
$ vi projects/ioto-qnx-default.mk
```

### Tailor the cross-platform O/S header.

To insulate most of the Ioto source code from the differences of various operating systems, the include/osdep.h header file wraps all the required O/S headers and publishes a consistent set of types and prototypes. None of the source files include normal O/S headers like <string.h>. While this does slow the build by including more headers than are required — it is barely noticeable on modern CPUs.

When porting the osdep.h, start by copying the sections in osdep.h that pertain to your base copied O/S. These will be protected by "#if BASEOS" defines. In the example of QNX, we would look for, and copy, any sections with "#if LINUX" and create "#if QNX" sections.

DO NOT introduce conditional code in other O/S sections. It is better to copy the entire contents from the base O/S and modify. It is better to isolate the code for each O/S.

### Test the Headers with a Hello World Program.

Don't use the make system yet. Just create an empty C hello world program and include "osdep.h". Compile it and shake out the issues.

### Port the Fiber Context Module

Ioto uses fiber coroutines that swap stacks to provide overlapped I/O and compute. Fibers solve the main problem with multi-threaded programming where multiple threads access the same data at the same time and require complex locking to safeguard data integrity. Fibers solve this problem by enabling a procedural straight line coding style.

The existing fiber code supports the CPU architectures: arm, arm64, itanium, mips, mips64, ppc, ppc64, riscv, riscv64, sparc, tidsp, sh, x86, x64 and xtensa. 

Other architectures are supported by emulating fibers over posix pthreads.

The fiber header **uctx-os.h** detects your CPU architecture by a set of conditional compilation tests and enables the appropriate CPU or PTHREAD fiber management code.

### Port the Safe Runtime Source Code

The Safe Portable Runtime (R) wraps the operating system services and exposes a portable, consistent interface for Ioto to utilize. So now is the time for the real work. You will need to modify the **lib/rLib.c** file to support your new platform. 

In rLib.c, you will see banners marking where the various sub-files have been catenated together. The main sections to modify will be socket.c, thread.c time.c and wait.c. Search for conditional code sections for your base O/S and copy/modify as appropriate.

### Test Compile the rLib

To start out, test compile just the R library.

    make NEWOS-ARCH-default/obj/rLib.o

At this stage of the porting effort, the make command will undoubtedly provoke a stream of errors. Use this to work out the bugs in r.h and rLib.c for your O/S.

### Compile the Rest

After the R library, it is more downhill. The rest of the code under **./lib** should compile and build more easily. It is quite cross-platform.

```bash
$ make
```

After building the library, you can port the **cmds/main.c** which is the default Ioto main program.

### Test Ioto

```bash
$ ioto -v
```

## Working with the Ioto Development Team

Once you have a basic port running, you should send it back for the team to look over. They can provide advice and suggestions. 

If you wish, you can contribute your changes back to EmbedThis to be merged back into the core Ioto code. This will make your task of assimilating new releases much easier. Contributed code must be provided under an MIT license so that changes can be shared with both open source and commercial users.

Good luck and have fun. Please give feedback to the development team at dev@embedthis.com.# Embedding Ioto

The Ioto agent is provided as library with a stand-alone command line program.

The Ioto agent can be embedded two ways:

1. Use your own main and code and link with the Ioto library.
2. Use the Ioto main and provide **ioStart** and **ioStop** functions that link to your code.

If you need to embed Ioto in your own main program, you will chose option (1). If you are running on a generic Linux system, you may find option (2) attractive.

## Embed in Your Main Program

The first way to integrate Ioto with your code is to create your own main program and link with the Ioto library. This method is desirable if you are using an RTOS like FreeRTOS and need to integrate Ioto into your main program.

To embed Ioto into your main program, you need to do the following things:

1. Add **#include "ioto.h"** to the relevant source files.
2. Provide a main().
3. Invoke **ioStartRuntime** and **ioRun** from your main().
4. Build your app and references the **libioto.a** library.
5. Create or edit the Ioto **ioto.json5** configuration file and other Ioto config files to suit your needs.

The following code demonstrates providing your own main().

```c
#include "ioto.h"

int main()
{
    ioStartRuntime();

    //  Service requests until told to stop
    ioRun();

    ioStopRuntime();
    return 0;
}

void ioStart()
{
    rInfo("sample", "Hello World\n");
    //  Your code here
}
void ioStop() {}
```

If this source is contained in a file called main.c, you can build this sample and link with the Ioto library and the OpenSSL library:

```bash
cc -o server -I .../ioto/build/inc main.c .../ioto/build/bin/libioto.a main.c -lssl -lcrypto 
```

## Use the Ioto Command Program 

The second way to integrate Ioto is to use the Ioto main program and provide your own **ioStart** and **ioStop** functions. These functions are invoked by Ioto during startup and shutdown. 

To build with your start/stop functions you need to do the following things:

1. Add **#include "ioto.h"** to the relevant source files.
2. Provide **ioStart** and **ioStop** functions.
3. Add the libioto.a library to the build/link target in your Makefile.
4. Build your application.
4. Create or edit the Ioto **ioto.json5** and other Ioto config files to suit your needs.

### Embedding API

The following code demonstrates the Ioto embedding API.

```c
#include "ioto.h"

PUBLIC void ioStart(void *arg)
{
    rInfo("sample", "Hello World\n");
}
```

If this source is contained in a file called main.c, you can build this sample and link with the Ioto library:

```bash
cc -o server -I .../ioto/build/inc main.c .../ioto/build/bin/libioto.a -lssl -lcrypto 
```

If you are building on Mac OS, you will need to install openssl and provide a **-L /opt/homebrew/lib** library directory option.

```bash
brew install openssl
cc-o server -I .../build/inc main.c .../build/bin/libioto.a -L/opt/homebrew/lib -lssl -lcrypto
```

## Samples

The [link-agent-main](https://github.com/embedthis/ioto-samples/tree/main/samples/link-agent-main/README.md) sample demonstrates linking with the Ioto library.

The [own-main](https://github.com/embedthis/ioto-samples/tree/main/samples/own-main/README.md) sample demonstrates linking with your own main.

### More Details

For more details about the Ioto API, please consult the [Ioto APIs](../ref/api/ioto.md).
# Ioto Memory Allocator

Ioto provides a wrapper over the standard malloc memory allocator. This wrapper performs global memory allocation checking and is tailored to the needs of embedded applications.

## Memory Allocation

It is difficult and error-prone for programmers to check the result of every API call that can possibly fail due to memory allocation errors. Calls such as strdup and asprintf are often assumed to succeed, but they can, and do fail when memory is depleted.

A better approach is to proactively detect and handle memory allocation errors in one place. The Ioto allocator handles memory allocation errors globally. When Ioto detects a memory allocation failure, it invokes the global memory exception handler. This configurable handler can then decide what is the best course of recovery. The default action is to abort Ioto so that it can be cleanly restarted.

## Wrapper Routines

The safe runtime provides three memory allocation routines that wrap the standard libc routines.

* **rAlloc** &mdash; Allocate memory
* **rFree** &mdash; Free memory
* **rAllocType** &mdash; Allocate memory for a given type

The rAlloc routine allocates memory and checks for memory failures and invokes the global exception handler if the memory allocation fails.

The rFree routine frees memory and is NULL tolerant. This routine accepts memory allocated via rAlloc or malloc.

The rAllocType routine is a convenience function to allocate memory for a typed object. For example:

```c
mem = rAllocType(struct shape);
```

## Memory Error Handler

The default memory handler prints a message regarding the memory allocation error and aborts execution. 

In many cases, the best recovery is to log the error and quickly reboot the service to minimize down-time. If a slow memory leak is the culprit in your code, then this approach may be sufficient, though clearly not ideal!

You can replace the default handler to perform custom error recovery. Use the **rSetMemHandler** API to install your own memory handler.

```c
void myHandler(int cause, size_t size)
{
    fprintf(stderr, "Memory allocation error for %zd bytes", size);
    //  Try to recover
}

rSetMemoryHandler(myHandler);
```
# MQTT

MQTT is a messaging protocol for (IoT). It is designed as a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices with a small code footprint and minimal network bandwidth.

The Ioto MQTT support is an efficient MQTT client that is ideal for connecting to the cloud.

## MQTT Features

* MQTT 3.1.1 support
* Connect, publish, subscribe, ping and disconnect messages.
* TLS encryption with ALPN over port 443 to get through firewalls.
* Message quality of service for reliable delivery.
* Retained messages.
* High message throughput with exceptionally low overhead.
* Wait for delivery or acknowledgement options.
* Resilient reconnect on network interruptions.
* Automatic configuration after cloud provisioning.
* Parallelism via fiber coroutines. No ugly callbacks or complex threads.
* Tiny footprint of 8K code.

## MQTT Configuration

The Ioto MQTT connection is opened automatically based on the **ioto.json5** configuration settings:

```js
mqtt: {
    authority: 'certs/root.crt',
    client: 'my-device-client-id',
    endpoint: 'https://example.com',
    alpn: 'x-amzn-mqtt-ca',
    port: 443,
    timeout: '30secs',
},
tls: {
    certificate: 'certs/mqtt.crt',
    key: 'certs/mqtt.key',
}
```

These properties describe the MQTT endpoint, port, certificates and keys to use to establish communications with an MQTT broker.

When using a device cloud, your certificate, key and endpoint are automatically provisioned from the Builder. These are saved in the **config/provision.json5** and override the settings of the **mqtt** property collection.

## API Quick Tour

When using cloud-based management, Ioto will typically connect to the cloud once the device is claimed. The MQTT endpoint will be made available via:

```c
ioto->mqtt
```

This means you do not have to explicitly connect to the AWS IoT Core MQTT broker.

However, you can connect to any MQTT endpoint at any time via *mqttConnect* if you wish.

```c
Mqtt *mq = mqttAlloc("my-client-id", onEvents);

mqttConnect(Mqtt *mq, RSocket *sock, int flags, MqttWaitFlags waitFlags);
```
In this case, you create and connect the Socket "sock" using the Safe runtime socket APIs before connecting with MQTT.

## On-Demand Connections

Ioto will transparently connect and disconnect from the device cloud as required to minimize idle MQTT connections. The **mqtt.timeout** property defines the maximum idle time before Ioto will disconnect the MQTT connection.

If you require a permanent MQTT connection, set the **timeout** to "forever". It is best practice to NOT use permanent connections wherever possible.

## Publishing Messages

Publishing messages is done via the *mqttPublish* API:

Ioto creates a MQTT connection to the device cloud on startup. This connection is referenced via **ioto->mqtt**.

```c
mqttPublish(ioto->mqtt, "Initialized", 0, MQTT_QOS_1, MQTT_WAIT_NONE, "myDevice/init");
```

This will publish an "initialized" message with quality of service (1) which means "send at least once". The message will be published on the "myDevice/init" topic and this API call will not block for sending or acknowledgement of the message. The sending will happen in the background with any required re-transmissions.

## Subscribing for Messages

You can subscribe to receive incoming messages on a topic via the *mqttSubscribe* API:

```c
mqttSubscribe(ioto->mqtt, incoming, MQTT_QOS_1, MQTT_WAIT_NONE, "myDevice/change");
```

When messages are received on the "myDevice/change" topic, the function `incoming` will be invoked with the message.

The incoming callback will be passed the message response packet.

```c
static void incoming(MqttResp *rp)
{
    printf(stdout, "Received from topic %s: %s", rp->topic, rp->data);
}
```

The message topic will be a null terminated string in **rp->topic**.

The message data will be passed in **rp->data** and the size of the data will be defined in **rp->dataSize**. The data will always be null terminated which is useful when passing message strings.

## Unsubscribing

To unsubscribe from a topic, use the *mqttUnsubscribe* API:

```c
mqttUnsubscribe(ioto->mqtt, "myDevice/unsub", MQTT_WAIT_NONE);
```

## Waiting for Completion

The MQTT APIs can take a MQTT_WAIT argument that indicates if the API call should wait or not for completion.

With the MQTT_WAIT_NONE flag value, the API call will not wait and transmission will happen in the background. The MQTT_WAIT_SENT flag will cause the API to wait until the message has been fully sent from the client, i.e. it has been fully transmitted over the network. The MQTT_WAIT_ACK will cause the API to wait until an acknowledgement message has been received from the peer.

!!!Note
    Don't confuse this with MQTT quality of service levels which define whether a message is reliably delivered or not. In contrast, the WAIT flag determines how the API itself should block and wait.

## Parallelism

The MQTT API uses the Ioto underlying Fiber Coroutine support to implement parallelism. When an MQTT call needs to wait for an acknowledgement or for network I/O, it will resume other fibers in the application transparently. Ioto is single threaded, but can run any number of fibers simultaneously without needing any locks. See [Fiber Coroutines](./fiber.md) for more details.

## Responding to Events

When Ioto connects to AWS IoT core, it will issue a "mqtt:connect" event and when disconnected it will issue a "mqtt:disconnect" event.

These events can be monitored by calling the **rWatch** API. For example:

```c
static void disconnected(cvoid *data, cvoid *arg)
{
    printf("MQTT disconnected\n");
}

rWatch("mqtt:disconnect", disconnected, NULL);
```

The `data` argument is the value provided as the last parameter to rWatch. The `arg` argument is the argument provided when rSignal was called by Ioto, which in this case will be set to NUL.

## Ioto Key/Value Store

Many devices maintain simple device settings that can be sent to the cloud and stored in a key/value store.

An Ioto device cloud provides such a key/value store in the device database called the **Store**. Values can easily be written and read to/from the Store using the **ioSet** APIs.

```c
iotSet("model", "Acme Rocket");
iotSetNum("cpu", 55);
```

These values can be displayed in the Device Manager UI and can be retrieved in the device via the **ioGet** APIs.

```c
char *model = iotSet("model");
double cpu = iotSetNum("cpu");
```

These APIs are simple wrappers over the mqttPublish and mqttRequest APIs.

## Creating Metrics

When you publish data to the Store, you can create a metric for the published data. This metric can then be displayed using graphical widgets in the Device Manager.

To enable metrics for your data, define your metrics under the **Store** processing definition in the Device schema and upload that schema to your manager. 

>Note: this is not available when using the `Eval` cloud.

For example:

```js
{
    Store: {
        enable: 'both',
        sync: 'up',
        notify: 'default',
        metrics: [
            {
                namespace: 'Embedthis/Device',
                fields: [{CPU: 'value'}],
                where: 'key == "cpu"',
                dimensions: [{Device: 'deviceId'}],
                buffer: {count: 5, elapsed: 10},
            },
        ],
    },
}
```

See [Database Metrics](../metrics/) for details.

<!--
To publish with metrics, use the lower level **mqttPublish** API.

```c
char msg[160];

SFMT(msg, "{" + 
          "\"key\":\"%s\"," +
          "\"value\":\"%s\"," + 
          "\"type\":\"string\" + 
          "\"metrics\":{\"namespace\" + name, + dimensions,...
          ""}", key, value);
mqttPublish(ioto->mqtt, msg, -1, 1, MQTT_WAIT_NONE,
            "$aws/rules/IotoDevice/ioto/service/%s/value/set", ioto->id);
```
-->

See the [MQTT API](/agent/ref/api/mqtt.md) for more details.

## Other Useful Routines

Use **mqttIsConnected** to test if the MQTT handle is currently connected to the MQTT broker.

## References

[MQTT Configuration Properties](../user/properties.md#mqtt)
[MQTT 3.1.1 spec](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html)
# Ioto Events

Ioto will signal important events and conditions using the Ioto runtime signal mechanism.

You can watch for certain conditions to happen and be notified when they do. For example, it can be useful to be notified when the network connects or disconnects to the cloud.

You can also use the signal mechanism to create your own conditions on which to watch and signal.

To watch for a condition:

```c
rWatch("mqtt:connect", fn, data);
```


This will invoke fn() when the condition occurs and will provide the watch data and the signal argument.

```c
void fn(void *data, void *arg) {
    //  Do something
}
```

## Event List

The list of triggered events:

Name|Description|Arguments
-|-|-
app:ready | When the Ioto app is fully initialized. | None 
cloud:ready | When cloud services are initialized. | None
db:change | When a database table value has changed. | A SyncChange structure with model, item, params and command that caused the change.
db:sync | When the database changes due to receiving a cloud sync update | The update message received from the cloud with the update.
db:sync:done | When a sync to the cloud has been completed and an acknowledgement has been received | None
db:syncup:done | When a syncup on device reboot is complete | None
device:keys | Triggered when AWS access credentials are rotated locally | None
device:registered | When the device has registered with the Builder | None
device:provisioned | When the device is claimed by a device cloud and provisioned for management | None
mqtt:connect | When the MQTT connection to the cloud is established | None
mqtt:disconnect | When the MQTT connection to the cloud is lost | None
mqtt:throttle | When the device is sending to much data to the cloud and further sending is delayed | None


To manually signal a condition, call:

```c
rSignal("mqtt:connect", arg);
```

To disable watching, call:

```c
rWatchOff("mqtt:connect", fn, data);
```

This will disable the watch registered with exactly the same arguments.
# Log File Exports

The Ioto agent can export O/S logs and files from the local device into AWS CloudWatch logs for secure cloud-side storage.

Ioto log capture offers two capabilities:

* Export and save the Ioto Log to CloudWatch
* Capture and export any device O/S log file to CloudWatch

## Enabling Cloud Logs

To enable exporting log files to the device cloud, set the **services.logs** property in the **ioto.json5** file to true.

```js
{
    services: {
        keys: true,
        logs: true
    }
}
```

To export logs, you must have the **keys** property set to true to enable generation of the IAM access keys that grant access to AWS CloudWatch.


## Exporting the Ioto Log

By default, the Ioto trace log is saved to /var/log/ioto.log.

To save this to the cloud, change the **log.path** property in the **ioto.json5** file to be set to "cloud".

```js
    log: {
        path: 'cloud'
        group: 'log-group-name',
        stream: 'log-stream-name',
    }
```

This will cause all messages sent to the Ioto log to be saved to the specified CloudWatch group and stream name. If the group and stream are unset, they default to: "Ioto" and "agent".


## Enabling O/S Log File Export

Ioto can monitor, capture and export any file to S3. Ioto will monitor the length of the file and if new data is written to the log, it will be efficiently captured and written to CloudWatch.

To configure log files for monitoring, define the log files in the **files** property of the **ioto.json5** configuration file. For example:

```js
{
    files: [
        { path: '/var/log/sys*log', group: 'ioto', stream: '${hostname}' }
    ],
}
```

The **files** property contains any number of log definitions. Each definition specifies the local filename and the destination CloudWatch group and stream name.

The file pathname may contain the wild cards "*" and "?". This is useful for log files that have a varying portion such as a date or version component in the name.

The **stream** property can use tokens such as "{hostname}" which is expanded at runtime with the local hostname of the device.
# Calling AWS APIs

If you are using a dedicated device cloud running in your AWS account, Ioto provides a convenience wrapper to make invoking AWS APIs using REST easier.

Without this wrapper, invoking AWS APIs requires using either the bulky AWS C SDK or manually using the AWS SigV4 REST API which is tedious at best.

The Ioto AWS API wrapper uses the SigV4 API but performs the SigV4 signing for you.

## Requirements

To use the AWS SigV4 API, you need to have AWS IAM access keys enabled in the device. See the section on [AWS IAM Access Keys](./keys.md) for details.


## API Quick Tour

To issue an AWS REST API, use the *aws* API:

```c
Url *up = urlAlloc();
int status = aws(up, "us-east-1", "logs", "Logs_20140328.PutLogEvents", data, dataLen, NULL);
```

This will issue a request to the specified AWS service (logs) in a region (us-east-1) and invoke the targeted service (Logs_20140328.PutLogEvents). This call will upload log data to CloudWatch logs.

Under the hood, the *aws* API is calling *awsSign* and *urlFetch*.

```c
char *signedHeaders = awsSign(region, service, target, "POST", "", NULL, body, bodyLen, headers);
char *url = sfmt("https://%s.%s.amazonaws.com/", service, region);
int status = urlFetch(up, "POST", url, body, bodyLen, signedHeaders);
```

The *awsSign* API will perform the required cryptographic signing of a request to be received by AWS.
# Provisioning

Device provisioning is the process of providing devices with the necessary certificates and credentials to securely connect with cloud-based services.

For devices to securely connect to the cloud, they require X.509 certificates so that they can be uniquely identified and authenticated by the cloud service. Once authorized, the certificates are used by the TLS protocol to securely encrypt all communications.

Ioto has an automated provisioning process that takes the pain out of device provisioning and certificate distribution for the user.

There are two primary provisioning patterns:

* User Claimed Devices
* Pre-Claimed Devices

### User Claimed Devices

User claimed devices will register with an Ioto cloud when manufactured and then wait for a user to "claim" the device from the device cloud.

### Pre-Claimed Devices

Pre-claimed devices are those that are configured and claimed by an Ioto device cloud during the device manufacturer. Pre-claimed devices are suitable for proprietary devices or projects where the devices are not distributed generally for resale.

Pre-claimed devices provisioned with certificates when manufactured or first configured.

## Provisioning Lifecycle

Ioto provisioning is accomplished in several phases during the device lifecycle.

* Device Serialization
* Device Registration
* Device Claiming
* Device Connection

![Ioto Provisioning](/images/ioto/provisioning.png){class="screen"}

## Device Serialization

For secure operation it is essential that each device can be uniquely identified. Most devices are created with a serial number that may include the product code, manufacturing batch number and individual serial number. However, while this serial number may be unique, it can be easily guessed because serial numbers typically follow a predictable format.

Instead of using the existing serial number, Ioto uses a random, unique claim ID (UCI) that is a random, 80-bit number that is not guessable and does not follow a predictable pattern. When paired with the product ID it is used as a unique claim ticket for users to claim devices for management.

```
JT08FFQXWQ
```

The 10 letter UCI results in over 1 quadrillion numbers (32^10). Ioto claim IDs can be any length, but we recommend at least 10 letters.

During manufacturer, each device should be given a UCI that identifies the device to the service and is saved in the **device.json5** configuration file on the device.

For User-Claimed devices, the UCI should be printed on the device label and be clearly identified as the **Claim ID**. The Claim ID can also be represented as a QR code if you choose to develop a mobile app for users to claim devices. (See [Claiming](#device-claiming) below).

![Device Label](/images/pics/label.png)

### Creating the UCI

You have two alternatives when creating the UCI depending on how you operate your production process. Regardless of which method you choose, the end result is the Ioto **device.json5** configuration file is updated with the UCI in the **id** property.

```js
{
    "id": "JT08FFQXWQ",
    "product": "01G8YJKKRNTHW213TRZYX3YH0M"
}
```

The **product** property in the device.json5 file is generated by the [Builder Site](https://admin.embedthis.com/) when you define your product.

There are several ways to create the UCI including:

* Manually configure the UCI in the device.json5
* Create unique firmware for each device
* Dynamically provision the UCI in each device

### Manually Creating the UCI

If you have a very small production run of devices, you can manually create the UCI with unique values for each device. You can simply edit the **device.json5** with the required values.

With any significant production volumes, you will want an automated process.

#### Unique Firmware

If you create unique firmware for each device, you can set the UCI in the **device.json5** when you create the firmware.

To create the UCI, you can either run the **ioto** process with the **--gen-id** argument or you can create a simple program that calls the **cryptID** API from the libioto library. See the **./factory/serialize.c** sample for an example.

#### Dynamic UCI

If you are using identical firmware for each device, you can provision the UCI by having the Ioto agent in your device, connect to a serialization service during manufacturer. The serialization service will generate and provide the UCI to the agent that will then persist it to the **device.json5** configuration file.

This generation should be integrated with your label creation process in manufacturer so that the UCI in the device.json5 matches that product label for the device.

The serialization service should listen for client requests on a HTTP endpoint and provide the UCI as the response. The address of the serialization service should be set in the Ioto agent **api.serialize** property in the **ioto.json5** configuration file.

The Ioto agent includes a sample serialization service in the **./factory/serialize.c** file.


## Device Registration

Before leaving the factory, when the device first powers on during system test, the Ioto agent will start and connect to the EmbedThis Ioto cloud service to register itself. This requires that your devices have an opening in the firewall to connect out to https://admin.embedthis.com.

The agent will send the contents of the device.json5 over an encrypted TLS connection to the Ioto cloud service. This registration request includes the device UCI and the product ID. Once received and validated, the Ioto cloud service will save the information in the Ioto device registration database.

If using User-claimed devices, the Ioto agent then awaits for a user to claim the device. If using Pre-claimed devices, the Ioto agent will skip the claiming step and proceed retrieve the required MQTT certificates and securely connect to the cloud.

## Device Claiming

When creating a device cloud, Ioto creates a device manager web site for your cloud. The Ioto Device Manager is a generic (white-label) device manager for your devices. It can be extensively customized with your logo, product name and device specific screens and panels. Use the Builder to customize the Device Manager to suit your needs.

When a user purchases or installs a device with the Ioto agent, they can "claim" the device to manage it.

The user claims their device by logging onto the device cloud manager web site and claims the device using the UCI printed on the device label.

They enter the device claim code into a form on the manager site. The device manager then provisions the necessary X.509 certificates and AWS IoT resources required to support and manage the device.

## Device Connection

When the device is unclaimed, the Ioto agent will regularly check with the Ioto service to see if it has been claimed. In this state, it is "unmanaged" and awaiting orders.

The Ioto device agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay period up to a defined limit. If the device is rebooted, the polling process recommences.

After device claiming, when the device will be provided the X.509 certificate and keys when it next connects or polls the service. The device will save the certificates and keys, then connect to the device cloud. This completes the provisioning process.

## Pre-Claiming Devices

If you are using pre-claimed devices, the process is similar, except you claim the device from the Ioto Manager when the device is made. Otherwise the process is the same.
# Uploading Data to S3

If you are using a dedicated device cloud running in your AWS account, Ioto provides a convenience wrapper to make uploading data or files to S3 easier.

## Features

* Upload files to S3
* Upload dynamically generated data to S3


## API Quick Tour

### Uploading a File

To upload a file, use *awsPutFileTS3*:

```c
status = awsPutFileToS3("us-east-1", "MyBucket", "file.dat", "./file.data");
```

This call will upload the file "./file.data" to the bucket "MyBucket" on S3. The file will be saved in the bucket as "file.dat". The returned status will be a HTTP status code of 200 if successful.


### Uploading a Data Block

To upload a data block to AWS S3, use the *awsPutToS3* API.

```c
char data[1024];
int status = awsPutToS3("us-east-1", "MyBucket", "filename", data, sizeof(data));
```

This will upload the data buffer to the given "filename" in the "MyBucket" on S3. The returned status will be a HTTP status code of 200 if successful.

When executing, this call will block the current fiber, but other fibers continue to run. When complete, the call will return.
# Shadow State

The AWS IoT Device Shadow service stores device state in objects called "shadows".


Shadows are capable of handling intermittently connected devices. When a device is not connected, updates to the shadow state in the cloud are stored until the device is next connected. Then, once connected, the changes are sent to the device for action.

If you are using a dedicated device cloud running in your AWS account, you can utilize the AWS IoT shadow state storage. Ioto makes it easy to use shadow state by automatically connecting to the AWS IoT Shadow service and by providing an easy get/set API.

>Note: using the transparent [database synchronization](../database/replication.md) may be easier and more scalable than AWS Shadows.

## Features

* Local copy of AWS Iot Device Shadow in JSON tree
* Convenience API to get / set shadow state properties
* Controllable state synchronization with AWS IoT Shadows
* Local persistency of shadow state.

## Overview

The Ioto agent automatically initializes an AWS Shadow state connection and subscribes to the required MQTT topics for data synchronization.

When shadows updates are received from the cloud, the agent saves these in a local shadow state file called "shadow.json5". When the agent reboots, the local shadow state is read to be immediately available while the AWS cloud shadows are consulted for any updates.

## API Quick Tour

To get the value of a property from the device shadow state, call *ioGetShadow*.

```c
data = ioGetShadow("temperature", 0);
data = ioGetShadow("temperature", "101");
```

The last argument can be a default value to return if the property is not found

To set the value of a property and pass that update to AWS IoT Shadows, call *ioSetShadow*.

```c
ioSetShadow("temperature", "99", 0);
```

This will update the value and perform a lazy save to persistent store and publish to the cloud.

To force an immediate save and publish, set the last argument to 1.

```c
ioSetShadow("temperature", "99", 1);
```

Alternatively, call *ioSaveShadow*:

```c
ioSaveShadow();
```
# AWS Integration Guide

The Ioto agent is pre-integrated with a suite of AWS services to make the job of creating IoT enabled devices dramatically easier.

All these integrations are optional and can be enabled or disabled via the **ioto.json5** configuration file.

## Features

* Simply provision devices for management by AWS IoT.
* Send messages to AWS IoT and other services via MQTT.
* Easy publish data to the cloud via MQTT.
* Create metric from any data for graphical display.
* Replicate and synchronize structured data to AWS DynamoDB.

For device clouds hosted on your own AWS account, you gain direct access to additional AWS features:

* Generate IAM temporary access credentials to call AWS API services on the device.
* Use the compact AWS SigV4 REST APIs from the device.
* Upload data and files to AWS S3.
* Send control-plane data to AWS IoT Shadows.
* Store the Ioto log file in AWS CloudWatch.
* Capture device O/S logs and upload to AWS CloudWatch.
* Emit metrics to AWS CloudWatch metrics.
* Save an audit trail to AWS CloudTrail.
# Cloud Auditing

If you are using a dedicated device cloud in your own AWS account, it is best practice to enable [AWS CloudTrail](https://aws.amazon.com/cloudtrail/) on your AWS device cloud account to track user and API changes and activity on your account.

From the AWS Bible:

>AWS CloudTrail is an AWS service that helps you enable operational and risk auditing, governance, and compliance of your AWS account. Actions taken by a user, role, or an AWS service are recorded as events in CloudTrail. Events include actions taken in the AWS Management Console, AWS Command Line Interface, and AWS SDKs and APIs.

Visibility into your AWS account activity is a key aspect of security and operational best practices. You can use CloudTrail to view, search, download, archive, analyze, and respond to account activity across your AWS infrastructure. You can identify who or what took which action, what resources were acted upon, when the event occurred, and other details to help you analyze and respond to activity in your AWS account. Optionally, you can enable AWS CloudTrail Insights on a trail to help you identify and respond to unusual activity.

Ioto will automatically enable CloudTrail when creating a device cloud.

## S3 Bucket Name

Ioto will enable CloudTrail to log to an S3 bucket named: **ioto-cloudtrail-logs-UUID**
# CloudWatch Metrics

If you are using a dedicated device cloud running in your AWS account and capturing device logs into AWS CloudWatch, Ioto provides a convenience wrapper to make defining AWS cloudwatch metrics easier.

AWS CloudWatch is a monitoring and management service that provides data and actionable insights to monitor devices and get a unified view of operational health.

AWS CloudWatch offers metrics for monitoring specific aspects of your applications. However, AWS custom metrics can become costly when updated or queried frequently, with each custom metric costing up to **$3.60 per metric per year**, along with additional expenses for querying. If you have a significant number of metrics or high dimensionality in your metrics, this could result in a substantial CloudWatch Metrics bill.

>A better solution is to use the Ioto **CustomMetrics** support that offers a cost-effective alternative that is considerably more budget-friendly and efficient compared to standard CloudWatch metrics.

Read about [Ioto Custom Metrics](/ioto/metrics/).

## API Tour

To emit metrics to AWS CloudWatch, use the **rmetrics** API. This uses the CloudWatch EMF log format.

Note: Ioto provides more cost effective metrics via the [Ioto Metrics](/ioto/metrics/). It is generally preferable to use these metrics unless you have a hard requirements to use AWS CloudWatch.

```c
rmetrics("Fan Temperature", "Acme/Rocket", "Fan", "Temp", "int", 101, "Fan", "string", "fan-0", NULL);
```

This would emit the metric "fan-0" temperature is 101 degrees. After this call, CloudWatch or the EmbedThis builder UI can display the fan temperature graph over time.

### The rmetrics API

The arguments of the rmetrics API are:

```c
PUBLIC void rmetrics(cchar *message, cchar *namespace, cchar *dimensions, cchar *values, ...);
```

The **message** is any identifying message you like to emit. The **namespace** is the CloudWatch custom namespace name for your metrics.

The metric values are expressed as triples comprised of: Name, Type and Value.

The **name** is the metric name. The type can be "int", "int64", "boolean" or "string".

You can write multiple metrics with one call by repeating supplying multiple value triples.

The **dimensions** are vectors that qualify the metric. CloudWatch treats each unique combination of dimensions as a separate metric. Enter the dimensions as a comma separated list of dimensions. For example:

dimensions = "Process,Module"

The values of the dimensions must be added to your value triplets.

```c
rmetrics("Fan Temperature", "Acme/Rocket",
    "InFlowTemp", "int", 101,
    "OutFlowTemp", "int", 143,
    "Process", "int", 42,
    "Module", "string", "input",
    NULL);
```
}
# IAM Access Keys

Ioto can automatically generate and provision IAM access keys so you can interact with any AWS service from your device.

The IAM keys are temporary access keys that expire each hour. Ioto will automatically refresh these keys as required.

## Enabling IAM Keys

To enable generation of temporary IAM keys, set the `keys` property of the `services` property in the **ioto.json5** configuration file to true.

```js
{
    services: {
        keys: true
    }
}
```

When the **keys** property is set to true, Ioto will retrieve from your device cloud a set of temporary IAM credentials that can be used to sign AWS API requests using the Ioto **aws** APIs or to use with the [AWS C API SDK](https://github.com/aws/aws-iot-device-sdk-embedded-C).

Ioto saves these keys for you in the Ioto structure:

```c
struct Ioto {
    cchar *awsRegion;          /**< Default AWS region */
    cchar *awsAccess;          /**< AWS temp creds */
    cchar *awsSecret;          /**< AWS cred secret */
    cchar *awsToken;           /**< AWS cred token */
    Time awsExpires;           /**< AWS cred expiry */
}
```

These will be automatically refreshed 20 minutes before expiring -- so you can always rely on using these keys to be valid for 20 minutes.


## IAM Role

The generated keys are based on the Device Cloud IAM role in the device cloud. This defaults to the IAM role named: `IotoDeviceAccess`. However, you can change this using the [Builder Site](https://admin.embedthis.com) Cloud Edit panel to any custom role you choose.

You should follow the principle of least privilege and ensure you scope all privileges granted to your devices are scoped to specific resources and only granting access to AWS APIs that are absolutely required.


## API Quick Tour

To force a regeneration of the IAM access keys, use **ioGetKeys()**.

```c
ioGetKeys();
```
# Software Updates

It is highly desirable to be able to update and upgrade the software in your devices so you can deploy new features, patch security vulnerabilities and improve performance.

For Ioto devices, via the Builder, you can define software updates that will be managed and delivered Over-The-Air (OTA) to your devices.

Using the Builder OTA update manager, you can selectively deploy updates to any desired subset of your device population.

Updates can be published that will be applied to your devices according to a **distribution policy**. In this way, you can selectively update all your device or specific subsets as you require.

![Software Modify](/images/builder/software-edit.png){class="screen width-100"}

See [Builder Software Updates](/builder/software/) for details on how to configure software updates.

## Cloud-Based or Local-Based

You can use the Software Update facility whether you are managing your devices from the cloud or not. If you are not using cloud-based management, you still create a Device Cloud, but you do not need to create a Device Manager, nor do you need to provision your device with MQTT certificates.

To enable software updates, set the **services.update** to true in the **ioto.json5** configuration file.

## Update Selection

At regular intervals, the Ioto agent will connect to the device cloud for an "update check". During this request, the agent will submit the **device.json** contents to the device cloud to see if an update is available for this device.

The device cloud will retrieve the most recent updates and check the updates in reverse version order and select the first matching update for the device.

The device cloud service will evaluate the distribution policy expression when the device checks-in and if the policy matches for the device, the URL for the update image will be returned to the Ioto agent. The agent will then fetch the update image and verify the integrity of the update image. If verified, the **scripts/update** script is invoked to apply the update. If you are running the Agent on an RTOS, without scripting, you will need to watch and react to the the event **device:update** using the rWatch API.


## Software Version

The current version for your device is defined via the **version** property in the **ioto.json5** configuration file. NOTE: your device is versioned separately to the Ioto agent itself which has its own version string.

The version numbers must be compatible with the [SemVer 2.0](https://semver.org/) version specification.

## Device Cloud

Update images are stored in AWS S3 in your device cloud AWS account. When defining updates, you select the relevant device cloud to store and apply the updates. If you have multiple clouds, you will need to define updates in each cloud.


## Checking for Updates

The Ioto agent will issue an **update** HTTP request to the device cloud to query if there are any relevant updates for the device. This request submits the **device.json5** file and receives back a URL that refers to the update image.

If there is an applicable update, Ioto will download the image, verify the contents and then signal that an update is ready.

Your embedded code can watch for "device:update" events via the **rWatch** API. Alternatively, you can customize the **scripts/update** shell script that will be passed the local filename containing the update.

## Controlling Updates

The **ioto.json5** configuration file has a set of properties that control how the Ioto agent will check, download and apply updates.

Note: these are in addition to the Builder update distribution policies and roll-out limits.

For example:

```js
{
    update: {
        schedule: '* * * * *',
        period: '24 hr',
        jitter: 0,
        throttle: 0,
        apply: '* * * * *',
    }
}
```

The **schedule** property defines the time window when the agent will check and download new updates. This is a [Cron-like](https://en.wikipedia.org/wiki/Cron) schedule string.

The **apply** property defines the time window to apply previously downloaded updates. This is useful to separate the impact of downloading updates vs applying updates. For example, you may wish to download updates during the day and only apply at night after business hours.

The **period** property defines the minimum delay in seconds before checking for a new software update.  The period can be a number of seconds or a string with suffixes like: "min", "hr", "day".  The period will be applied as well as the defined **schedule**. i.e. an update checkin will only happen during the specified schedule and no less then the defined period since the last checkin.

The **jitter** property defines a randomize time period in seconds to delay the scheduled software update check so that multiple devices will not all hit the service at once.

The **throttle** property defines a time in milliseconds to pause between reading 4K of a software download update. This delay is useful to lessen the CPU and network impact on the device due to downloading a software update. Set to zero for no delay.

# EmbedThis Ioto&reg; Agent Features

* HTTP/1.1 server.
* HTTP/1.1 client.
* MQTT/3.1.1 client.
* JSON/5 parser and query engine.
* Embedded database (like local DynamoDB)
* Transparent DynamoDB database cloud synchronization.
* AWS IoT Integration with IoT Core, Shadows, Events and Rules.
* AWS service integration with S3, Lambda, Kinesis and CloudWatch.
* Transport Layer Security (TLS/SSL) with ALPN support.
* Safe, secure runtime core.
* Easy provisioning.
* Over-the-air upgrading.
* Complete documentation.
* Extensive Samples.
* Full Source code.

## Feature Overview

### AWS IoT Integration

* AWS Iot Ready &mdash; Bring your own cloud.
* Capture device data and export to AWS.
* Send control plane data to AWS IoT shadows.
* Transparent database synchronization with AWS DynamoDB.
* Upload data and files to AWS S3 data lake.
* Store device logs, metrics in AWS CloudWatch.
* Generate and rotate IAM temporary access credentials.
* Call any AWS API via AWS SDK or more compact AWS REST SigV4 APIs.
* Keep an audit trail in CloudTrail.

### MQTT Client

* MQTT 3.1.1 support.
* On-demand connection management.
* TLS encryption with ALPN over port 443.
* Supports connect, publish, subscribe, ping and disconnect messages.
* Message quality of service for reliable delivery.
* Retained messages.
* Subscription pooling via master subscription topic.
* High message throughput with exceptionally low overhead.
* Wait for delivery or acknowledgement options.
* Auto reconnect.
* Scheduled connections and configurable timeouts and retries.
* Parallelism via fiber coroutines.


## DynamoDB Local Database

* High performance in-memory NoSQL document database.
* Red/black binary search indexes.
* JSON documents with in-memory query API.
* Controllable persistency locally and to the cloud on a per-table basis.
* Transparent bi-directional data synchronization with DynamoDB in the cloud. (like Global Tables).
* Unified data schema between device and cloud databases.
* Database triggers.
* Based on [DynamoDB OneTable](https://doc.onetable.io/) APIs and Schemas.


### HTTP Server

* HTTP/1.0, HTTP/1.1 support.
* TLS/SSL 1.3 and Alpn support.
* URL actions that bind URLs to C functions.
* Configurable request routes and redirections.
* Supports bi-directional transfer chunk encoding to preserve keep-alive.
* Cookie and session management.
* Authentication and user management.
* Fully streaming API for dynamic input and output.
* Request tracing for HTTP request and response headers.
* Sand-box resource limits.
* Runtime configurable via JSON config files.
* HTML helpers for encoding, decoding and escaping content.
* JSON parser and query engine.
* Single-threaded, parallel fiber coroutine event-based runtime.

### HTTP Client

* HTTP/1.0, HTTP.1.1 client.
* Fully streaming API for dynamic input and output.
* Convenience JSON API for interacting with REST services.
* Single-threaded, parallel fiber coroutine event-based runtime.
* TLS/SSL 1.3 with certificate verification controls.

### JSON Parser and Engine

* JSON and JSON/5 support.
* JSON parser and renderer.
* JSON query engine.


### Safe Runtime

* Fiber coroutines for non-blocking procedural programming model.
* Global memory error handler.
* Networking and TLS support.
* Logging framework —— filter by source and/or message type.
* Safe strings, lists, hashing and buffer management.
* Safe, secure printf that is tolerant of null args.
* Portable, cross-platform O/S abstraction.

### Performance

* Tiny memory footprint. All-up is less than 200K code.
* Single-threaded fiber coroutines provide an elegant, non-blocking, procedural programming paradigm without resorting to ugly callbacks or complex threads.
* Web server request throughput (&gt; 9,300 requests per second on Raspberry PI 4).

### Security

* Sandbox limits.
* Safe portable runtime to protect against memory leaks and buffer overflows.
* Transport Layer Security (TLS/SSL).

### Developer Integration

* Stand-alone Ioto program
* Embeddable Ioto library
* Easy, intuitive programming model
* Extensive C API

### Documentation

* Full C API Documentation
* Cookbook of samples (cut and paste to get going)
* Tutorials

### Platform Support

* Linux (2.6+)
* MAC OS X (10.7+)
* FreeBSD (10.X+)
* FreeRTOS
* ESP32 
* Easily ported to new platforms

Ioto is portable and users may wish to port Ioto to other operating systems.
Support is available to assist in such efforts.

### Embedding Support

* Supports ARM, MIPS, X86, X64, PPC, RiscV, SH, Sparc processors
* Full cross-compilation support. Use Linux or Mac as build system
* Fine-grained control for conditional build and compilation

### Standards

* [MQTT 3.1.1](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html)
* [RFC 2616 HTTP/1.1](https://www.ietf.org/rfc/rfc2616.txt)
* [TLS 1.3](https://datatracker.ietf.org/doc/html/rfc8446)
* [RFC 1867 Multipart-mime upload](https://datatracker.ietf.org/doc/html/rfc1867)
* [OneTable Database Schema Specification](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md)
# HTTP Standards

The Standards guide contains references to the specifications that govern the HTTP protocol.

Topic|Description
-|-
The HTTP communications protocol specification|[HTTP/1.1](http://www.w3.org/Protocols/rfc2616/rfc2616.html)

Form-based file HTML upload specification | [File Upload](http://www.ietf.org/rfc/rfc1867.txt)
# Metrics

Device Metrics refer to data points and measurements that provide insights into the performance, availability, and efficiency of your devices and device cloud. Metrics are essential for monitoring and managing your devices and ensuring the overall health of your device pool. 

The Ioto service provides a set of standard metrics and you can create custom metrics based on your device specific data.

Using device data that is synchronized to the cloud from your devices, you can automatically create custom metrics from the data stream. 

## Metric Timespans

When the Ioto service creates metrics, it keeps the current live value and stores the historical metric values so you can monitor historical trends.  Ioto metrics maintains statistics for the last "5 minutes", "hour", "day", "week" "month", or "year". Each of these ranges contain 10-12 data points. 

When querying metrics, you can provide any data range and the relevant underlying metric data will be returned. You can also specify a date range start time and duration for metrics from any point in time.

These metrics can then be monitored, displayed by the Device Manager as a single metric value or as set of values over time as a graph.

## Metric Statistics

For each timespan, you can query the average, minimum, maximum or sum value for the metric. 

## Metric Naming

Metrics are scoped via a set of naming properties including:

* namespace 
* metric name
* dimensions

The **namespace** is a global name to group related metrics. Currently, this must be set to `Embedthis/Device`.

The **metric** name is the specific metric name. For example: a device's `temperature`.

The **dimensions** select specific instances of a metric. For example, each device may have a `temperature` metric and we may also have an overall device pool average `temperature` metric.
Ioto treats each unique combination of dimensions as a separate metric. Enter the dimensions as a comma separated list of dimensions. For example:

dimensions = "Process,Module"

## Defining Metrics

Metrics are created by defining Builder Automation actions that create metrics based upon database values.

<!--
 via the Database schema definition. In the **process** section for a schema model, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:
```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

This will create a `Temperature` metric in the `Embedthis/Device` namespace based upon the database item's `temp` attribute.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| buffer | `map` | Metric buffering directives. Defaults to null|.
| dimensions | `array` | Array of metric dimensions. Defaults to null|.
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| where | `string` | Conditional expression to select items for which to create metrics. |

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.


The `dimensions` property contains an array of dimensions that scope the metric. The elements of the dimensions array can be either field names or objects that map field names into a dimension name. If the values are quoted, they are used as literal values. If unquoted, they are regarded as database item field names.

For example:

```js
process: {
    Fault:   { 
        sync: 'up' 
        metrics: [{
            namespace: 'Embedthis/Device',
            fields: ['temperature'],
            dimensions: [{}, {Device: 'deviceId'}]
        }]
    }
}
```

## Where Expressions

The `where` property can be used to select matching device database items (rows) from which to create the metric.

The `where` query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

will select those items which have the `error` attribute set to "critical" and the `component` attribute set to "PS1".

The query language supports the operators:
    + - * / ( ) ^ ! % == != < <= > >= ^= ^!= $= $!= << >> && || <> ><

These extension operators have the following meaning
    a ^= b     a starts with the string b
    a ^!= b    a does not start with the string b
    a $= b     a ends with the string b
    a $!= b    a does not end with the string b
    a >< b     a contains the string b
    a <> b     a does not contain the string b

Sub-expressions can be grouped with parenthesis and the boolean operators && and || can group conditional operands.

Regular expressions (delimited by slashes) may be used with the "==" and "!=" operators. The regular expression can be on either side of the operator.

The query language understands the types: Numbers, Boolean, String literals, Regular Expressions and null.

For example:

```js
{
    Store: {
        enable: 'both',
        sync; 'up',
        notify: 'default',
        metrics: [
            {
                namespace: 'Embedthis/Device',
                fields: [{CPU: 'value'}],
                where: 'key == "cpu"',
                dimensions: [{Device: 'deviceId'}],
                buffer: {count: 5, elapsed: 10},
            }
        ]
    }
}
```
-->

## Metric API

Metrics can also be created in the Embedthis/Device namespace by using the Ioto Agent **ioSetMetric** API.

For example:

```c
ioSetMetric("Temperature", 30.5, NULL, 0);
```

Then to read the metric in the agent:

```c
double temp = ioGetMetric("Temperature", NULL, "average", 3660);
```

## Displaying Metrics

The Device Manager can display metric data via graphical widgets

![Manager](/images/manager/home.png){class="screen"}

You can select from the following widget types:

* gauge
* graph
* table
* progress
* number
* leds

When creating or modifying a widget, you can select the data source to be either a database table item or a metric.

When selecting a metric, you enter the metric name, statistic and resource dimensions.

When selecting data directly from the database, you enter the database table model name, the model field (attribute) and a row selection expression.

![Manager Widget Edit](/images/manager/widget-edit.png){class="screen"}

## Standard Metrics

The Ioto service computes standard metrics for each device cloud using the **Embedthis/Ioto** namespace.

Metric | Dimensions | Description
-|-|
DevicesMade | Product:PRODUCT | Number of devices manufactured this month
DevicesClaimed | Product:PRODUCT | Number of devices claimed for cloud-based management this month
DevicesConnected | | Number of devices connecting to the cloud this month
MsgIn | | Number of messages received by the cloud
MsgOut | | Number of messages sent by the cloud
Throttles | | Number of times a device sending too much data was throttled
SyncIn | | Number of database synchronization messages sent to the cloud
SyncOut | | Number of database synchronziation messages sent to devices

## Custom Metrics

Custom metrics created from device data streams are created using the **Embedthis/Device** namespace.# Device Table Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-table basis.

## Databases

The Ioto service creates an AWS DynamoDB database table called **ioto** in each device cloud. The **ioto** database table contains the device data and cloud management data for all connected devices in that cloud.

Similarly, the Ioto device agent creates a local embedded database to hold structured data for the device.

These two databases are connected and Ioto replicates changes between device and cloud to keep them in sync.

## Why Synchronization?

The Ioto Database Synchronization service dramatically eases the task of centralizing the data management of a pool of devices. Each device can store data locally and it will be transparently, efficiently and automatically replicated to the cloud. Once in the cloud, it can be easily interrogated and queried for analytics, operational control and intelligence.

Each side has fast, predictable local access to the data. Coupled with reliable replication semantics you can work locally while Ioto takes care of the replication.

## How It Works

To replicate cloud-side data, the Ioto service uses AWS DynamoDB streams to capture modifications made to the cloud-side table data. The stream is connected to a Lambda function that encodes and sends the updates via MQTT messages to a special message topic that is only known to the specific device.

The Ioto device agent subscribes to this topic and receives MQTT messages containing the changed data. The agent then applies those changes to the local database.

In reverse, the Ioto agent registers a database trigger that is called whenever local changes are made to the device's database. When the trigger is invoked, the agent sends an MQTT message with the changes to the Ioto service that updates the cloud database.

Ioto keeps track of the last update sent and received and will retransmit lost updates.

When a device is rebooted after being offline, it sends a "sync" message to the Ioto service to retrieve all changes made to the cloud database since the last change notification was received from the cloud. In this way, changes made while the device is offline or disconnected are not lost.

## Controlling Replication

The cloud-side Ioto DynamoDB table (ioto) and the Ioto agent database both use a [OneTable](https://doc.onetable.io/) schema that defines application data entities, how items are stored, what indexes are used and how to process table data. For example:

```js
const DeviceSchema = {
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault: {sync: 'up'},
    },
    models: {},
}
```

The **"process"** property of the schema defines how to process table data and how tables are synchronized between the device and cloud.

For each database item type in the schema, you can create an entry in the "process" property that specifies where items of that type should be stored and how they should be synchronized.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for item types that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Requirements

Any model that defines a **sync** direction of "up" or "down" must include the following properties in the model definition:

Property | Definition | Description
-|-|-
updated | {type: 'date', readonly: true} | Timestamp for when the item was last updated
_source | {type: 'string', hidden: true} | The source of the last update

The **updated** timestamp property is used to determine the set of updates that have been made to the database since the device last connected to the device cloud. The **_source** property is used to determine the direction of synchronization for an item.

The **bin/make-schema** script that is used when building the Ioto agent and apps will automatically add these properties for synchronized models.# Database Processing

The **schema.process** is a map of properties that control how data is stored in the database and how the data is processed. 

The `process` definitions define the following attributes:

* Where the database item will be stored: device / cloud / both.
* In what direction the database syncronization will flow: to-device / to-cloud / both.
* What metrics should be created from the data stream.

For each item type, you may define an entry in the **process** collection. For example:

```js
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

Each map entry may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| enable | `string` | Control where the item is stored. Set to 'cloud' for in the cloud, 'device' for on the device and 'both' if in both locations. Defaults to 'both'. |
| sync | `string` | Define the direction of the data synchronization. Set to 'down' for down to the device, 'up' for up to the cloud, or 'both' for bi-directional. Defaults to null. |
| metrics | `Array` | Array of metric definitions. See below for details.|
| notify | `boolean` | Issue an AWS EventBridge notification event for matching data. Defaults to false.|

## Database Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-item basis.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

>To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for items that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Metrics

For data that is synchronized to the cloud, you can create custom metrics from the data stream. These metrics can then be displayed or graphed in the Device Manager.

These metrics can be created by creating a Builder Automation action to trigger when specific data values are encountered.

<!--
In the **process** section for an item, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:
```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

This will create a `temperature` metric from the item's `temp` attribute.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| buffer | `map` | Metric buffering directives. Defaults to null.|
| dimensions | `array` | Array of metric dimensions. Defaults to null.|
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| where | `string` | Conditional expression to select items for which to create metrics. |

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.

The `dimensions` property contains an array of dimensions that scope the metric. The elements of the dimensions array can be either field names or objects that map field names into a dimension name. If the values are quoted, they are used as literal values. If unquoted, they are regarded as database item field names.

For example:

```js
process: {
    Fault:   { 
        sync: 'up' 
        metrics: [{
            namespace: 'Embedthis/Device',
            fields: ['temperature'],
            dimensions: [{}, {Device: 'deviceId'}]
        }]
    }
}
```
#### Where Expressions

The `where` property can be used to select matching items for which to create metrics. `Where` expressions use a query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

See [Database Metrics](/ioto/metrics/) for details.
-->

## Event Notification

For dedicated device clouds, you can issue AWS EventBridge events for matching database items via the **notify** property.  The `notify` property is set to the EventBridge bus name. It can be set to "default" or any custom EventBridge bus name.

The database item will be passed to the EventBridge bus as the event context data using the `Embedthis/Ioto` as the event **Source**.

For example:

```js
{
    Store: {
        enable: 'both',
        sync: 'up',
        notify: 'default',
    }
}
```
# Model Attributes

The database schema supports the following attribute properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| default | `string` | Default value to use when creating model items or when reading items without a value.|
| generate | `string|boolean` | Set to 'ulid' or 'uuid' to automatically create a new ID value for the attribute when creating new items.|
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. If unset, the field will use the table default value for isoDates. Default to the schema params value. |
| nulls | `boolean` | Set to true to store null values or false to remove attributes set to null. Default false. |
| required | `boolean` | Set to true if the attribute is required. |
| schema | `object` | Nested schema. |
| ttl | `boolean` | When set to true for date fields, the date value will define when the item should be transparently removed. |
| type | `Type or string` | Field data type. |
| value | `string` | Template to derive the value of the attribute. These attributes are "hidden" by default. |


If the **default** property defines the default value for an attribute. If no value is provided for the attribute when creating a new item, the **default** value will be used.

If the **isoDates** property is defined and not-null, it will override the table isoDates value. Set to true to store the field date value as an ISO date string. Set to false to store the date as a Unix epoch date number.

The **schema** property permits nested field definitions. The parent property must be an Object as the type of items in arrays are defined using the **items** property.

The **type** properties defines the attribute data type. Valid types include: String, Number, Boolean, Date, Object, Null, Array, Buffer (or Binary) and Set. The object type is mapped to a **map**, the array type is mapped to a **list**. Dates are stored as Unix numeric epoch date stamps unless the **isoDates** parameter is true, in which case the dates are store as ISO date strings. Binary data is supplied via **buffer** types and is stored as base64 strings in DynamoDB.

The **value** property defines a literal string template that is used to compute the attribute value. This is useful for computing key values from other properties, creating compound (composite) sort keys or for packing fields into a single DynamoDB attribute when using GSIs.

String templates are similar to JavaScript string templates. The template string may contain **${name}** references to other fields defined in the entity model. If any of the variable references are undefined when an API is called, the computed field value will be undefined and the attribute will be omitted from the operation.

If you call **find** or any query API and do not provide all the properties needed to resolve the complete value template, such as if some of the ${var} references are unresolved, OneTable will take the resolved leading portion and create a **begins with** key condition for that portion of the value template.
# Database Schemas

Ioto uses database schemas to define what are the database data entities and how these will be stored in the database.

A schema specifies the application item types called models. If you are from a SQL background, think "tables". The schema also defines the item fields, indexes and other data access and replication parameters.

Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) schema format, implementing the [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).

The same schema is used for the cloud side AWS DynamoDB table and for the device side embedded database.

## Schema Definition

Schemas look like this:

```js
const DeviceSchema = {
    format: 'onetable:1.1.0',
    version: '0.0.1',
    indexes: {
        primary: {hash: 'pk', sort: 'sk'},
    },
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault:   { 
            sync: 'up',
            triggers: true,
        },
    },
    //  These are the database tables
    models: {
        Status: {
            pk: {type: 'string', value: 'status#'},
            sk: {type: 'string', value: 'status#'},
            parameters: {type: 'object'},
            version: {type: 'string'},
            updated: {type: 'date'},
        },
        Fault: {
            pk: {type: 'string', value: 'device#${deviceId}'},
            sk: {type: 'string', value: 'fault#${id}'},
            deviceId: {type: 'string', required: true},
            id: {type: 'string', generate: 'ulid'},
            timestamp: {type: 'date', required: true},
            source: {type: 'string', required: true},
            severity: {
                type: 'string',
                required: true,
                enum: ['info', 'warn', 'error', 'critical', 'fatal'],
            },
            subject: {type: 'string', required: true},
            message: {type: 'string', required: true},
        },
    },
    params: {
        isoDates: true,
        timestamps: true,
    },
}
```

## Schema Purpose

AWS DynamoDB can operate most efficiently at scale when using a single table with multiple application entities stored in the one table. To make this design pattern easy to implement, application data schemas such as the one used by [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) provide the mapping between application level entities and raw database items.

Ioto uses the OneTable schema in both the DynamoDB table and in the Ioto agent database.

When coupled with a high-level database API such as that offered by OneTable and by the Ioto Agent Database, accessing and managing device data is both performant and straightforward.

## DynamoDB Schema

In Device Clouds, Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) NodeJS library for all access to the **ioto** DynamoDB table. This library has an extensive suite of features beyond those implemented by the Ioto device agent database.

Please consult the [OneTable](https://github.com/sensedeep/dynamodb-onetable) library and [OneTable Documentation](https://doc.onetable.io/) for background.

## Schema Properties

The valid properties of the **schema** object are:

| Property |  Type  | Description                                                                                  |
| -------- | :----: | -------------------------------------------------------------------------------------------- |
| format   | string | Reserved. Must be set to **onetable:1.1.0**                                                  |
| indexes  | object | Hash of indexes used by the table.                                                           |
| models   | object | Hash of item types describing the item keys, indexes and attributes.                    |
| params   | object | Hash of properties controlling how data is stored in the table.                              |
| process  | object | Hash of items describing where the items should be stored and how they should be replicated. |
| version  | string | A SemVer compatible version string.                                                          |

The **format** property specifies the schema format version and must be set to **onetable:1.1.0**.

The **indexes** property specifies the key structure for the primary, local and secondary indexes.

The **models** property contains one or more database item types with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties.

The **params** property defines additional parameters for table data formats.

The **process** map defines how database items should be processed, stored, replicated and whether metrics should be calculated from the data stream.

The **version** property defines a version for your Database design. It must be a [SemVer](https://semver.org/) compatible version string. The version string is used by tools and consumers of the schema to understand compatibility constraints for the schema and stored data.

## Schema Models

The schema defines the database item types as models. For example, consider a music example:

```js
models: {
    album: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        songs:  { type: 'number' },
    },
    artist: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        address: {
            type: Object, schema: {
                street: { type: 'string' },
                city: { type: 'string' },
                zip: { type: 'string' },
            },
        },
    }
}
```

For each item type, all the entity fields are defined by specifying the field type, validations and other operational characteristics (uniqueness, IDs and templates).

The valid types are: array, binary, boolean, date, number, object, and string.

The database will automatically add an item type property via the **\_type** attribute. This is set to the name of the model. You can modify this via the **params.typeField** setting.

## Value Templates

The value of a field can be computed based on the value of other fields and a formatting "value template". This is useful for decoupling your key structure from your entity fields.

The value template is like a Javascript string literal where the value of fields are expressed in a "${field}" format. At runtime, the field references are expanded with the item's value for the named field.

In the example above, the primary key "pk" is calculated from the entity type **\_type** and the **name** field by using the value template: **${_type}:${name}**.

## Nested Schemas

For object attributes, you can define a nested schema for the object properties, as in the example above (repeated below).

A nested schema uses the **schema** property to define a nested map of attributes. Schemas can be nested to an arbitrary depth.

```js
address: {
    type: Object, schema: {
        street: { type: 'string' },
        city: { type: 'string' },
        zip: { type: 'string' }
    }
}
```

## Database Indexes

Schema indexes are defined using the **schema.indexes** property.

The **indexes** property can contain one or more indexes and must contain the **primary** key. Additional indexes will be treated as secondary Indexes.

!!!Note
    Ioto currently only supports the primary index.

```js
const MySchema = {
    indexes: {
        primary: {
            hash: 'pk',         //  Schema property name of the hash key
            sort: 'sk',         //  Schema property name of the sort key
        },
        //  Zero or more global secondary or local secondary indexes
        gs1: {
            hash: 'gs1pk',
            sort: 'gs1sk',
        }
    }
}
```

## Schema Params

The **schema.params** is a map of properties that control how data is stored in the database. It may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| createdField | `string` | Name of the "created" timestamp attribute. Defaults to "created". |
| hidden | `boolean` | Hides templated (value) attributes in Javascript properties. Default true. |
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. Default false. |
| nulls | `boolean` | Store nulls in database attributes vs remove attributes set to null. Default false. |
| timestamps | `boolean | string` | Make "created" and "updated" timestamps in items. Set to true to create both. Set to 'create' for only "created" timestamp and set to "update" for only an "updated" timestamp. See also: "updatedField" and "createdField" properties. Default false. |
| typeField | `string` | Name of the "type" attribute. Default "_type". |
| updatedField | `string` | Name of the "updated" timestamp attribute. Default "updated". |

For example:

```js
const MySchema = {
    params: {
        isoDates: true,
        timestamps: true,
    }
}
```


## References

- [DynamoDB OneTable Overview](https://www.sensedeep.com/blog/posts/2021/dynamodb-onetable-tour.html)
- [DynamoDB with OneTable Schemas](https://www.sensedeep.com/blog/posts/2021/dynamodb-schemas.html)
- [Data Modeling for DynamoDB](https://www.sensedeep.com/blog/posts/2021/dynamodb-singletable-design.html)
- [SenseDeep DynamoDB Data Browser](https://www.sensedeep.com/blog/posts/series/dynamodb-studio/data-browser.html)
- [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).
# Device Tables Overview

Ioto Device Tables is a global, replicated, multi-active database solution that transparently synchronizes data between devices and the cloud.

Similar to AWS DynamoDB Global Tables for replicating data between AWS regions, Ioto Device Tables connects a cloud-side AWS DynamoDB database to a device-resident Ioto embedded database.

Device Tables take the pain out of replicating data between devices and the cloud. Without additional code, it will automatically and transparently synchronize data and state between your devices and the cloud.

Device Tables delivers fast, predictable local read and write access while offering automatic replication of changes.

## Database Replication Features

* Transparent replication between cloud and devices.
* Bi-directional synchronization.
* Per-table synchronization control.
* Resilient catch-up should the device or cloud go offline.
* Database triggers for notification when state data changes.
* Automatic creation of CustomMetrics from the device data stream.

## Challenge

>Aggregating device data in the cloud is not a simple problem.

To centralize device state typically requires several crucial steps:

* State must be captured in the device.
* State must be sent reliably to the cloud despite network disconnections.
* State must be stored and managed in the cloud.
* Conflicts with simultaneous updates must be resolved.
* State updates from the cloud must be sent to the device reliably despite devices being offline.

These factors combine to make centrally aggregating device data decidedly non-trivial.

>Ioto Device Tables solves these issues for you, so you can focus on your device specific logic and value.

## Ioto Agent Embedded Database

The Ioto agent embedded database is an ultra high performance NoSQL database for embedded applications. It supports fast, in-memory, local data access and optional transparent synchronization of data to and from the cloud. The Ioto agent embedded database is designed to be compatible with AWS DynamoDB so that it can easily replicate structured device data to the cloud. It is modeled after [AWS DynamoDB](https://aws.amazon.com/dynamodb/) and the [OneTable](https://doc.onetable.io/) access library.

The database uses Red/black binary search indexes and has controllable local persistence to disk and to the cloud on a per-table basis.

## JSON documents

The database stores items as JSON documents that are a nested collection of properties to arbitrary depth. As JSON is one of the most prevalent data exchange formats, storing data in JSON greatly reduces data replication and API transmission costs.

Ioto includes a powerful JSON query engine that you can use to query and manipulate JSON documents.

## Database Features

* High performance NoSQL management document database.
* JSON document items with flexible query API.
* Efficient import and export of database items.
* Red/black binary search indexes.
* Simple, non-waiting API.
* Controllable persistence with change triggers.
* Transparent bi-directional data synchronization with the cloud.
* Unified data schema between device and cloud databases.
* Based on AWS DynamoDB and DynamoDB OneTable.

# Authentication

The Ioto service provides different authentication methods for two use cases:

Authentication Method | Source | Roles | Description
-|-|-|-
[CloudAPI Token](#admin-tokens) | Utility | Owner | An device builder's admin service running in the cloud or on-premises 
[Login Access Token](#login-access-tokens) | Browser | User, Admin | A logged in user from a web browser app 

For logged in users, Ioto offers **Login Access Tokens** which are granted when a user logs into the Ioto service. These tokens grant access according to the user's authorized role. All actions using Login Access tokens are limited in scope by the user's role and to resources owned by the logged in user.

For utility service commands, Ioto offers **CloudAPI Tokens** that provide full access to the device cloud and the all resources in the cloud. These tokens offer access to all user accounts utilizing the device cloud.

## CloudAPI Tokens

CloudAPI Tokens are used by utility commands and services for full administrative access to the resources of the device cloud. 

CloudAPI Tokens have flexible lifespans and can be managed to set their lifespan or to suspend, resume, revoke or replace the token. You can have one or more CloudAPI tokens active at a time. This is useful to deploy a new token and then subsequently revoke the old token.

To authorize requests using a CloudAPI Token, you need to obtain a **CloudAPI** token from the [Builder](https://admin.embedthis.com). The **CloudAPI** token grants administrator privilege via the **"owner"** role to the caller when accessing Ioto device cloud APIs.

When using CloudAPI tokens, the request URLs are modified to include a **"/tok"** URL prefix before the URL path.

Tokens can be accessed and managed from the [Builder Token list](https://admin.embedthis.com/tokens) or from the Cloud/Edit panel.



## Login Access Tokens

A Login Access Token may be obtained by logging into the Ioto service with a user email address and password and utilizing the **AccessToken** provided in the response with subsequent Ioto API calls.

The Login request is a single HTTP POST request to the Ioto authentiction endpoint.

### Roles

When device app user accounts are created, each user is authorized with an access role that determines the scope of access for the user. The following two roles are supported:

Role | Capabilties
-|-
user | Ability to view but not modify service depending resources.
admin | Ability to modify all resources and fully administer the account.

The Builder will utilize an **owner** role for the **CloudAPI** authentication token. This gives the ability to manage multiple accounts and devices over all users.

Builder Role | Capabilties
-|-
owner | Ability to close the device app account and delete all users and resources.

### Login Request

The login request authenticates the user's credentials and exchanges them for a time-limited access token. The access token will be valid for a period of 60 minutes and can be refreshed using a **RefreshToken** contained in the response. The RefreshToken is valid for a period of 30 days.

The request endpoint will vary depending on the AWS region used by the device cloud. For example:

```
https://cognito-idp.${REGION}.amazonaws.com/
```

You can obtain the login endpoint for the device cloud from the Builder's Cloud / Edit panel under **API Access**.

**Endpoint** 

```
POST https://cognito-idp.REGION.amazonaws.com/
```

**Request Headers**

```
X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth
Content-Type: application/x-amz-json-1.1
Origin: myapp.ioto.me
```

**Request Body**

```json
{
   "AuthParameters" : {
      "USERNAME" : "yourusername@example.com",
      "PASSWORD" : "yourpassword"
   },
   "AuthFlow" : "USER_PASSWORD_AUTH",
   "ClientId" : "5g3qt5mitfa4q1jlrlibeviedn"
}
```

The **ClientId** can obtain the endpoint from the Builder's Cloud / Edit panel under **API Access**.

**Response**

If the request is successful, you will receive a payload response that contains an AccessToken, RefreshToken and AccessToken duration. 

The AccessToken should be used in an **Authorization** HTTP header with Ioto API calls. The **RefreshToken** can be used to refresh the access token before it expires. The **ExpiresIn** property defines how long (in seconds) the access token will be valid before expiring.

```json
{
    "AuthenticationResult":{
        "AccessToken": "...",
        "IdToken": "....",
        "RefreshToken": "....",
        "TokenType": "Bearer",
        "ExpiresIn": 3600
    }
} 
```

**Example**

The following example uses the Ioto `curl` utility to issue an authentication request based on the authentication credentials in a **./creds.json** file. 

::: code-group
```curl
curl -X POST \
  -H 'X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth' \
  -H 'Content-Type: application/x-amz-json-1.1' \
  --data @creds.json \
  https://cognito-idp.us-east-1.amazonaws.com/
```
```url
$ url https://cognito-idp.us-east-1.amazonaws.com/ \
    'X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth' \
    'Content-Type: application/x-amz-json-1.1' \
    @creds.json
```
:::

## Refreshing Login Tokens

Access tokens expire after 60 minutes. However, you can refresh the access token without requiring the user to re-login by using the **RefreshToken** that was returned when first logging in. Refresh tokens expire after 30 days.

**Endpoint**

```
POST https://cognito-idp.REGION.amazonaws.com/
```

The **REGION** can obtain the endpoint from the Builder's Cloud / Edit panel under **API Access**.

**Request Headers**

```
X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth
Content-Type: application/x-amz-json-1.1
```

**Request Body**

```json
{
   "AuthParameters" : {
      "REFRESH_TOKEN": "...",
   },
   "AuthFlow" : "REFRESH_TOKEN_AUTH",
   "ClientId" : "5g3qt5mitfa4q1jlrlibeviedn"
}
```

The **ClientId** can obtain the endpoint from the Builder's Cloud / Edit panel under **API Access**.

**Response**

If the request is successful, you will receive the following payload response. The AccessToken should be used in an **Authorization** HTTP header with Ioto API calls . The RefreshToken should be used to refresh the access token before it expires. The ExpiresIn property defines how long the token will be valid.

```json
{
    "AuthenticationResult":{
        "AccessToken": "...",
        "IdToken": "....",
        "RefreshToken": "....",
        "TokenType": "Bearer",
        "ExpiresIn": 3600
    }
} 
```

**Example**

::: code-group
```curl
curl -X POST \
  -H 'X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth' \
  -H 'Content-Type: application/x-amz-json-1.1' \
  --data @creds.json \
  https://cognito-idp.us-east-1.amazonaws.com/
```
```url
url https://cognito-idp.us-east-1.amazonaws.com/ \
    'X-Amz-Target:AWSCognitoIdentityProviderService.InitiateAuth' \
    'Content-Type:application/x-amz-json-1.1' \
    @creds.json
```
:::

### Logout

There is not an explicit sesion logout API. To logout, discard and erase the access and refresh tokens from any local storage and remove any browser session state associated with the tokens.
# Dashboard

Manage UI Dashboards.

## Create
**Endpoint**

```HTTP
POST /dashboard/create

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Default |
| - | - | - | - |
| css | array |  |  |
| design | boolean |  |  |
| emulate | string |  |  |
| dashboard | boolean |  |  |
| fixed | boolean |  |  |
| framed | boolean |  |  |
| full | boolean |  |  |
| live | boolean |  |  |
| name | string | yes |  |
| options | object |  |  |
| range | object |  |  |
| refresh | number |  |  |
| snap | boolean |  |  |
| toolbar | boolean |  |  |
| type | string |  |  |
| widgets | array |  | [] |
| widgetCss | array |  |  |

**Widget** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Find
**Endpoint**

```HTTP
POST /dashboard/find

```
**Authorized User Role**

```
user

```
**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Get
**Endpoint**

```HTTP
POST /dashboard/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| name | string |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Remove
**Endpoint**

```HTTP
POST /dashboard/remove

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

## Update
**Endpoint**

```HTTP
POST /dashboard/update

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Default |
| - | - | - | - |
| css | array |  |  |
| design | boolean |  |  |
| emulate | string |  |  |
| fixed | boolean |  |  |
| framed | boolean |  |  |
| full | boolean |  |  |
| id | string |  |  |
| layout | string |  |  |
| live | boolean |  |  |
| name | string | yes |  |
| options | object |  |  |
| range | object |  |  |
| refresh | number |  |  |
| snap | boolean |  |  |
| toolbar | boolean |  |  |
| type | string |  |  |
| widgets | array |  | [] |
| widgetCss | array |  |  |

**Widget** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



# Metric

API to manage metrics including the ability to get and set metrics, and to get a list of available metrics.<br><br>        The Ioto service creates metrics for device and service data. It stores the current live and historical metric values. Metrics are calculated for for the last "5 minutes", hour, day, week, month, and year. Statistics are kept for the average, min, max, count and the sum of metric values.<br>        <br>        Metrics are named and grouped into [Namespaces](/ioto/metrics/#metric-naming) with metric [Dimensions](/ioto/metrics/#metric-naming) selecting instances of a metric for a specific resoure.

**See Also**

* [Metrics](/ioto/metrics/)

## Get
Get an accumulated metric. <br><br>                This API is used by devices to retrieve a metric statistic over the MQTT protocol.<br>                <br>                To get metrics over REST HTTP, use the **fetch** API.

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /metric/get

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Default | Notes |
| - | - | - | - |
| dimensions | object |  | Dimensions for metric. |
| metric | string |  | Metric name. |
| period | number | 300 | Metric timespan period. |
| statistic | string | avg | Metric statistic. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Metric** 

An array of Metric items.

| Field | Type | Notes |
| - | - | - |
| dimensions | object | Dimensions for the metric. |
| metric | string | Metric name. |
| namespace | string | Always set to Embedthis/Device. |
| owner | string | The service owning the metric. |
| period | number | Metric timespan period. |
| points | array | Array of data points. |
| samples | number | Number of data points in the period. |

**Dimensions** 

Dimensions for the metric.

| Field | Type |
| - | - |
| * | any |


**Point** 

An array of Points items.

| Field | Type | Notes |
| - | - | - |
| value | number | Metric value. |
| timestamp | number | Last update to the metric value in seconds since Jan 1, 1970. |
| count | number | Number of data values contributing to the metric value. |


## GetMetricList
Get a list of available metrics.

**Endpoint**

```HTTP
POST /metric/getMetricList

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Role | Notes |
| - | - | - | - | - |
| cloudId | string | yes | owner | Override, device cloud containing the metrics. |
| namespace | string |  |  | Metric namespace. If not provided, the API returns a list of namespaces. |
| metric | string |  |  | If not provided, returns a list of available metrics. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| namespaces | array | Returns the requested namespace. If not provided, returns a list of available namespaces. |
| metrics | array | If a namespace is provided, returns a list of available metrics. |
| dimensions | array | If a namespace and metric are provided, returns a list of available metric dimensions. |

## GetDeviceSchema
**Endpoint**

```HTTP
POST /metric/getDeviceSchema

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| cloudId | string |

**Response** 

A object.


## Fetch
Fetch metric values.<br>                <br>                This API fetches multiple metric values in a single request.

**Endpoint**

```HTTP
POST /metric/fetch

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| items | array | yes | Array of metric requests. |
| deviceId | string | yes | Device ID owning the metrics. |

**Metric Request** 

An array of Items items.

| Field | Type | Notes |
| - | - | - |
| accumulate | boolean | Accumulate result into a single result. |
| cloudId | string | Device Cloud ID. |
| dimensions | object | Dimensions for metric. |
| field | string | Database field name. |
| metric | string | Metric name. |
| model | string | Database model name. |
| namespace | string | Must be set to Embedthis/Device. |
| period | number | Metric timespan period. |
| statistic | string | Metric statistic. Select from: avg, min, max, count, sum. |


**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Metric** 

An array of Metric Array items.

| Field | Type | Notes |
| - | - | - |
| dimensions | object | Dimensions for the metric. |
| metric | string | Metric name. |
| namespace | string | Always set to Embedthis/Device. |
| owner | string | The service owning the metric. |
| period | number | Metric timespan period. |
| points | array | Array of data points (see below). |
| samples | number | Number of data points in the period. |
| * | any |  |

**Dimensions** 

Dimensions for the metric.

| Field | Type |
| - | - |
| * | any |


**Point** 

An array of Points items.

| Field | Type | Notes |
| - | - | - |
| value | number | Metric value. |
| timestamp | number | Last update to the metric value in seconds since Jan 1, 1970. |
| count | number | Number of data values contributing to the metric value. |


## Set
Set a metric value.<br><br>                This API is used by devices to emit a metric value. It is sent over MQTT rather than via REST.

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /metric/set

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Notes |
| - | - | - |
| metric | string | Metric name. |
| value | number | Metric value. |
| dimensions | array | Array of dimensions for metric. |
| buffer | object | Metric buffering options. |

# Provision

Device provisioning and management APIs.<br><br>These APIs provide devices with the necessary provisioning APIs to manage communications with a device cloud.

## GetCerts
Provision a device with MQTT certificates.<br><br>After a device has been claimed for management by a user into a device cloud, the device can call "getCerts" to request provisioning of MQTT certificates to secure communications.<br><br>This call returns the certificate, private key and communications endpoint to use for secure MQTT communications with the device cloud.

**Endpoint**

```HTTP
POST /provision/getCerts

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

MQTT certificate and endpoints for device communications.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Manager Account ID. |
| certificate | string | X.509 certificate. |
| endpoint | string | MQTT host endpoint for communciations. |
| id | string | Device ID. |
| key | string | X.509 certificate key. |
| port | number | MQTT TCP/IP port number. |
| thing | string | AWS IoT Core thing name for the device. |

## GetCreds
**Get IAM credentials**

Get IAM credentials for use in the device that is hosted in a dedicated cloud.<br><br>This will create temprorary IAM credentials based on the configured Cloud.deviceRole (default IotoDeviceRole).<br>These credentials can be used with appropriate AWS SDK or Ioto AWS Sigv4 APIs.

**Endpoint**

```HTTP
POST /provision/getCreds

```
**Authorized User Role**

```
device

```
**Response** 

A set of AWS IAM credentials that can be used with AWS APIs.

| Field | Type | Notes |
| - | - | - |
| accessKeyId | string | AWS access key ID. |
| secretAccessKey | string | AWS secret access key. |
| sessionToken | string | AWS credentials session token. |
| expires | date | When the credentials expire. |
| region | string | AWS region. |

## Update
**Device update**

Check for software updates.

**Endpoint**

```HTTP
POST /provision/update

```
**Authorized User Role**

```
update

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| product | string | yes |
| version | string | yes |
| test | boolean |  |
| * | any |  |

**Response** 

| Field | Type | Notes |
| - | - | - |
| checksum | string | Download checksum. |
| version | string | Version to update to. |
| url | string | Download URL for the software update. |
| update | string | Selected update (quote on report). |

## UpdateReport
**Device update report**

Post update status.

**Endpoint**

```HTTP
POST /provision/updateReport

```
**Authorized User Role**

```
update

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| update | string | yes |
| success | boolean | yes |

# Manager

Manage Manager.

## Get
**Endpoint**

```HTTP
POST /manager/get

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| assets | object |
| certArn | string |
| cloudFront | string |
| cloudId | string |
| distributionId | string |
| domain | string |
| error | string |
| id | string |
| name | string |
| owner | string |
| priorDomain | string |
| provisioned | date |
| region | string |
| title | string |
| type | string |
| version | string |

## GetSignedUrl
**Endpoint**

```HTTP
POST /manager/getSignedUrl

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| clean | boolean |
| command | string |
| filename | string |
| mimeType | string |

**Response** 

A signed URL string.


## Provision
**Endpoint**

```HTTP
POST /manager/provision

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| assets | object |  |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| assets | object |
| certArn | string |
| cloudFront | string |
| cloudId | string |
| distributionId | string |
| domain | string |
| error | string |
| id | string |
| name | string |
| owner | string |
| priorDomain | string |
| provisioned | date |
| region | string |
| title | string |
| type | string |
| version | string |

## Update
**Endpoint**

```HTTP
POST /manager/update

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| assets | object |
| cloudId | string |
| domain | string |
| id | string |
| name | string |
| owner | string |
| priorDomain | string |
| region | string |
| title | string |
| version | string |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| assets | object |
| certArn | string |
| cloudFront | string |
| cloudId | string |
| distributionId | string |
| domain | string |
| error | string |
| id | string |
| name | string |
| owner | string |
| priorDomain | string |
| provisioned | date |
| region | string |
| title | string |
| type | string |
| version | string |

# Alert

Manage Alerts.

## Find
**Endpoint**

```HTTP
POST /alert/find

```
**Authorized User Role**

```
user

```
**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Alert** 

An array of Alert items.

| Field | Type | Notes |
| - | - | - |
| seq | string |  |
| accountId | string |  |
| context | object |  |
| cloudId | string | Owning device cloud ID. |
| count | number |  |
| id | string | Unique alert ID. |
| name | string |  |
| message | string |  |
| severity | string |  |
| subject | string |  |
| resolved | boolean |  |
| timestamp | date |  |

## Get
**Endpoint**

```HTTP
POST /alert/get

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

**Response** 

| Field | Type | Notes |
| - | - | - |
| seq | string |  |
| accountId | string |  |
| context | object |  |
| cloudId | string | Owning device cloud ID. |
| count | number |  |
| id | string | Unique alert ID. |
| name | string |  |
| message | string |  |
| severity | string |  |
| subject | string |  |
| resolved | boolean |  |
| timestamp | date |  |

## Remove
**Endpoint**

```HTTP
POST /alert/remove

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

## Update
**Endpoint**

```HTTP
POST /alert/update

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| resolved | boolean |

**Response** 

| Field | Type | Notes |
| - | - | - |
| seq | string |  |
| accountId | string |  |
| context | object |  |
| cloudId | string | Owning device cloud ID. |
| count | number |  |
| id | string | Unique alert ID. |
| name | string |  |
| message | string |  |
| severity | string |  |
| subject | string |  |
| resolved | boolean |  |
| timestamp | date |  |

# Account

Account Management. <br>        <br>        Account APIs operate on the user account utilized when obtaining the login AccessToken. If using a CloudAPI token, which provides the **owner** role capability, the target account can be provided via the **accountId** request property to most APIs. <br><br>        Note: Accounts are created by the User.login API when a new user first logs in.

## Create
**Create an account**

This API will create the account record and the account's first user. Subsequent users can be added via the User.create API. .

**Endpoint**

```HTTP
POST /account/create

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| email | string | yes | A unique, valid email address to use as the master account email address and the first user's email address. |
| name | string | yes | Account or company name. |

**Response** 

| Field | Type |
| - | - |
| account | Account |
| user | User |

**Account** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |


**User** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |


## Close
**Close account**

Close an account and remove all allocated resources.  This will remove all users, devices, dashboards, and the account itself.  This operation cannot be reversed. <br>                <br>                This API can be invoked by a user closing their device manager account. It can also be invoked to close any user account if caller has the **owner** role via the CloudAPI token. .

**Endpoint**

```HTTP
POST /account/close

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Override account to close. |

## Get
**Get account**

Get an account that match the supplied properties. If no email or id provided, return the logged in account.

**Endpoint**

```HTTP
POST /account/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Query by account ID. |
| email | string | owner | Query by email. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

## Find
**Find accounts**

Find a list of accounts that match the supplied properties. If no email or id provided, return list of accounts (requires "owner" role).

**Endpoint**

```HTTP
POST /account/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Query by account ID. |
| email | string | owner | Query by email address. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Account** 

An array of Account items.

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

## UpdateIdentity
Update the account name and email address.

**Endpoint**

```HTTP
POST /account/updateIdentity

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner |  |
| email | string |  | Account email address. |
| name | string |  | Account or company name. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

# API Access

The EmbedThis Ioto API is a [REST API](https://www.redhat.com/en/topics/api/what-is-a-rest-api)
to allow you to interact with the backend Ioto cloud service.

The Ioto API provides calls to:

* Claim and release devices
* Access device database data
* Create and access metric data
* Provision devices with certificates and credentials
* Manage devices
* Invoke automated actions

The Ioto API can be used from browser-based UI apps or from utility service commands running in the cloud or on-prem.

## Authentication

Requests to the Ioto service are authenticated by checking an authentication token included with the request. Ioto  provides two different authentication methods for two use cases:

Authentication Method | Source | Description
-|-|-
[Login Access Token](authentication.md#login-access-tokens) | Browser | A logged in user from a web browser app 
[CloudAPI Token](authentication.md#admin-tokens) | Utility | An admin service running in the cloud or on-premises 

For logged in users, Ioto offers **Login Access Tokens** which are granted when a user logs into the service.  For utility service commands, Ioto offers **CloudAPI Tokens** which provide administrative access to the device cloud and the resources in the cloud. 

An authentication token must be included in the HTTP headers for Ioto API requests.

## API Endpoint

The Ioto API endpoint is unique per device cloud. You can see the API endpoint in the [Builder Cloud/Edit](https://admin.embedthis.com/clouds/) panel under the API Access section.

![API Access](/images/builder/api-endpoint.png){class="screen width-75"}

The Endpoint is of the form: SITE/PATH

For example:

```
https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/user/find
```

When using **CloudAPI** tokens, the request URLs are modified to insert a **"/tok"** prefix at the front of the URL PATH.

For example:

```
https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/user/find
```

## HTTP Methods

All HTTP API requests use the **POST** method for consistency and simplicity. 

## HTTP Headers

To authorize your request, include the authentication token as an **Authentication** HTTP header with your request. All API requests use a HTTP Content-Type of **application/json** for both requests and responses.

If using login access tokens, you must also include an **Origin** header that is set to the domain name for your device app.

For example:

```
Authorization: 1234567990X0C3B0ABF3CF81DZ....
Content-Type: application/json
```

## Example

Here is an example to issue a request from the command line using `curl` or the Ioto **url** command using a **CloudAPI** token:

::: code-group
```curl
curl -X POST https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/user/find \
     -H 'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
     -H 'Content-Type: application/json' \
     -d '{"deviceId": "ZXXXXXXXXX", "_type": "Store"}'
```
```url
url https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/user/find \
    'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
    '{deviceId: "ZXXXXXXXXX", _type: "Store"}'
```
:::

## Read More

* [API Authentication](authentication.md)

## Ioto APIs

Controller | Description
-|-
[Account](account.md) | Account API
[Action](action.md) | Action API
[Alert](alert.md) | Alert API
[Dashboard](dashboard.md) | Dashboard API
[Device](device.md) | Device API
[Generic](generic.md) | Generic Data Access API
[Metric](metric.md) | Metric API
[Provision](provision.md) | Device Provisioning API
[Store](store.md) | Key/Value Store API
[User](user.md) | User API

<!--
| [Account](builder/account.md) | Account API |
| [Cloud](builder/cloud.md) | Cloud API |
| [Product](builder/product.md) | Product API |
| [User](builder/user.md) | User API |
| [Card](builder/card.md) | Card API |
| [Dashboard](builder/dashboard.md) | Dashboard API |
| [Invoice](builder/invoice.md) | Invoice API |
| [Metrics](builder/metrics.md) | Metrics API |
| [Notice](builder/notice.md) | Notice API |
| [Notification](builder/notification.md) | Notification API |
| [Post](builder/post.md) | Post API |
| [Software](builder/software.md) | Software API |
| [Support](builder/support.md) | Support API |
| [Ticket](builder/ticket.md) | ticket API |
| [Token](builder/token.md) | Token API |
-->
# Store

This API provides MQTT messages to get/set values from the key/value Store.<br>        <br>        If you need a REST API, use the Generic API with the **_type** set to 'Store'.

## Get
**Get data from the store**

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /store/get

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type |
| - | - |
| key | string |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account. |
| deviceId | string | Owning device. |
| key | string | Data item key. |
| value | object | Data item value. |
| type | string | Data type. Set to "number" or "string". |
| updated | date | When data item last updated. |
| expires | date | When data item should be deleted. |

## Set
**Set data in the store**

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /store/set

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Notes |
| - | - | - |
| key | string | Data item unique key. |
| expires | number | Date when to expire. Set to number of milliseconds since Jan 1, 1970. Date.getTime(). |
| value | object | Set to a number or string. |
| type | string | Set to "number" or "string". |

# User

User Management.

## Create
Create a new user and optionally send an email invitation to join the service. When the user follows the invitation and registers, their email address wil be confirmed before they are logged into the service.

**Endpoint**

```HTTP
POST /user/create

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| email | string | yes | User email address. |
| role | string | yes | Authorized role. Select from "user", "admin" or "owner". |
| sendInvite | boolean |  | Send an email invitation. |

**Response** 

A user record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Get
**Endpoint**

```HTTP
POST /user/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role |
| - | - | - |
| email | string | admin |
| id | string | admin |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Find
**Endpoint**

```HTTP
POST /user/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role |
| - | - | - |
| email | string | admin |
| id | string | admin |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**User** 

An array of User items.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Login
**Login the authenticated user**

**Endpoint**

```HTTP
POST /user/login

```
**Authorized User Role**

```
public

```
**Request Body** 

| Field | Type |
| - | - |
| invite | string |
| register | boolean |

**Response** 

Account and user records with useful cached data.

| Field | Type | Notes |
| - | - | - |
| account | object |  |
| user | object |  |

**Account** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |


**User** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |


## Remove
**Endpoint**

```HTTP
POST /user/remove

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| email | string |
| id | string |

## Update
**Update a user identity**

**Endpoint**

```HTTP
POST /user/update

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| email | string |
| first | string |
| id | string |
| last | string |
| preferences | object |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## UpdateRole
**Endpoint**

```HTTP
POST /user/updateRole

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Role |
| - | - | - |
| id | string |  |
| role | string | admin |
| sendInvite | boolean |  |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

# Action

Manage Automated Actions.<br><br>        Actions implement automated responses for specific device and cloud conditions. Actions are invoked by triggers to respond and implement a specific remedy or notification. .

## Find
Find actions by matching properties and query parameters.

**Endpoint**

```HTTP
POST /action/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| cloudId | string | yes | Filter by cloud ID. |
| type | string |  | Filter by action type. Valid types are: alert, builder-alert, builder-metric, database, delay, device, email, eventbridge, http, lambda, metric, mqtt, and sms. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Action** 

An array of Action items.

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string | Action description. |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean | Enable or disable the action. |
| error | string | Error message from last invocation. |
| expression | string | Trigger expression. |
| format | string | Message format. |
| id | string | Unique action ID. |
| name | string | Action name. |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string | Alert severity. |
| trigger | string | Source of action trigger. |
| type | string | Action type. |

## Get
Get an action by ID for a cloud.

**Endpoint**

```HTTP
POST /action/get

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string |  | Action ID. |
| cloudId | string | yes | Filter by cloud ID. |
| type | string | yes | Filter by action type. Valid types are: alert, builder-alert, builder-metric, database, delay, device, email, eventbridge, http, lambda, metric, mqtt, and sms. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string | Action description. |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean | Enable or disable the action. |
| error | string | Error message from last invocation. |
| expression | string | Trigger expression. |
| format | string | Message format. |
| id | string | Unique action ID. |
| name | string | Action name. |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string | Alert severity. |
| trigger | string | Source of action trigger. |
| type | string | Action type. |

## Invoke
Invoke an action by ID or name.

**Endpoint**

```HTTP
POST /action/invoke

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Action ID. |
| name | string | Action name if ID not provided. |
| params | object | Parameters for the action. |
| context | object | Context for the action. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| error | string | Error message if the action failed. |
| name | string | Action name. |
| context | object | Context for the action. |

**Example**

Example action invocation using curl to invoke an action by name.

```curl
curl -X POST \
     https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/action/invoke \
     -H 'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
     -H 'Content-Type: application/json' \
     -d '{"name":"myAction", "params":{"deviceId": "ZXXXXXXXXX"}, "context":{}}'
```
# Test

Test the API interface.

## Ping
**Ping device cloud**

Simple ping request.

**Endpoint**

```HTTP
POST /test/ping

```
**Authorized User Role**

```
public

```
**Response** 

The string "pinged" with a new line appended.


# Device

Device Management API.<br><br>When devices are initialized with the Ioto agent, they will "register" with the Builder service using their device ID (ClaimID) at https://admin.embedthis.com/api. The device registration API is part of the Builder API. See [Device Registration](/ioto/provisioning/registration.md).<br><br>Once registered, the device then remains under the management of the Builder until it is **"claimed"** by a user for management using the "Device Claim" API.  When claimed, the device is redirected to the device cloud when it next invokes the "register" API.

## Get
The Get API will fetch a device by its ID (ClaimID).

**Endpoint**

```HTTP
POST /device/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Role | Notes |
| - | - | - | - | - |
| id | string | yes |  | Device Claim ID. |
| accountId | string |  | owner | Manager account ID. Required if using CloudAPI token. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Claim
Claim a device for management by a device cloud.<br><br>Once a device has registered itself with the builder, a user can claim the device for management.<br>The claim ID would typically be printed on the device label during manufacturer.<br><br>A claim request may specify the device as a test device where it will not be counted towards the subscription device count.

**Endpoint**

```HTTP
POST /device/claim

```
**Authorized User Role**

```
claimDevice

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

The claimed device.

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Find
Find matching devices filtered by matching properties.

**Endpoint**

```HTTP
POST /device/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string |  | Device Claim ID. |
| accountId | string | owner | Manager account ID. Required if using CloudAPI token. |
| productId | string |  | Product registration ID from the Builder product list. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of devices owned by the user. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Device** 

An array of Device items.

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Remove
Release a device from management by a device cloud. Releasing a device returns it to the builder to be available for claiming by another cloud.

**Endpoint**

```HTTP
POST /device/remove

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

# Secure Token Storage

Storing access tokens safely is crucial for maintaining the security of applications, devices and protecting sensitive information. Here are some best practices for storing access tokens:

**Use Secure Storage Mechanisms**: Always store tokens in secure storage mechanisms. 

>Never commit access tokens to source repositories such as GitHub without first encrypting. 

**Log Files and Backups**: Ensure that access tokens are not printed in service log files and are not included in backups (especially dev backups).

**Use Environment Variables for Server-side Applications**: When storing tokens in server-side applications, use environment variables or encrypted configuration files. This approach keeps tokens out of the source code and reduces the risk of accidental exposure.

**Encryption**: Encrypt tokens at rest to add an additional layer of security. This way, even if an attacker gains access to the storage, decrypting the tokens will be another hurdle for them.

**Minimize Token Lifespan**: Use tokens with a short expiration time. This minimizes the potential damage in case a token is compromised. Implement token refresh mechanisms to maintain sessions without requiring the user to log in again.

**Secure Transmission**: Always transmit tokens over secure channels. Use HTTPS to encrypt the data in transit, preventing man-in-the-middle attacks.

**Regular Audits and Rotation**: Regularly audit token usage and have mechanisms in place for token rotation and revocation. This helps in identifying suspicious activities and mitigating potential risks promptly.

**Access Control and Monitoring**: Implement strict access control policies for the storage and handling of tokens. Only allow necessary applications and personnel to access them (Need to know). Additionally, monitor access and usage patterns to detect anomalies.

By following these best practices, you can significantly reduce the risks associated with storing and managing access tokens, helping to protect your applications and users from unauthorized access and potential security breaches.# Generic

Generic Access to Database Data.<br>        <br>        The Generic controller provides "generic" access to database items without requiring specific database models for different database items. By providing the database item "_type" and the required item properties, you can query and modify database items.

## Create
**Endpoint**

```HTTP
POST /generic/create

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. This must be a deviceId claimed by the manager account of the authenticated user. |
| * | any |  | Item attributes to create. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

The created item.

| Field | Type | Notes |
| - | - | - |
| _type | string | Database item type. |
| * | any | Item attributes. |

## Get
Get a data item from a database table.

**Endpoint**

```HTTP
POST /generic/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Optional item attributes to filter the selected item. |

**Response** 

The retrieved item.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

## Find
Find data items from a database table.

**Endpoint**

```HTTP
POST /generic/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Optional item attributes to filter selected items. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of devices owned by the user. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Item** 

An array of Item items.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

## Remove
Remove a data item.

**Endpoint**

```HTTP
POST /generic/remove

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Other item attributes sufficient to identify the item. |

## Update
Update a data item.

**Endpoint**

```HTTP
POST /generic/update

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Other item attributes sufficient to identify the item. |

**Response** 

The updated data item.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

# Device Provisioning

Provisioning is the process of providing devices with the necessary certificates and credentials to securely connect with cloud-based services.

For devices to securely connect to the cloud, they require X.509 certificates so that they can be uniquely identified, authenticated and authorized by the cloud service. Once authorized, the certificates are used by the TLS protocol to securely encrypt all communications.

## Ioto Provisioning

Ioto has an automated provisioning process that takes the pain out of device provisioning and certificate distribution for the user.

There are two primary provisioning patterns:

* User Claimed Devices
* Pre-Claimed Devices

## User Claimed Devices

User claimed devices will register with an Ioto cloud when manufactured and then wait for a user to "claim" the device from the device cloud.

## Pre-Claimed Devices

Pre-claimed devices are those that are configured and claimed by an Ioto device cloud during the device registration when manufactured. Pre-claimed devices are suitable for proprietary devices or projects where the devices are not distributed for resale.

Pre-claimed devices are provisioned with certificates when manufactured or first configured.

## Ioto Provisioning

![Ioto Provisioning](/images/ioto/provisioning.png){class="screen"}

Ioto provisioning is accomplished in several phases during the device lifecycle.


* [Device Serialization](serialize.md)
* [Device Registration](registration.md)
* [Device Claiming](claiming.md)# Device Serialization

For secure operation it is essential that each device can be uniquely identified. Most devices are created with a serial number that may include the product code, manufacturing batch number and individual serial number. However, while this serial number may be unique, it can be easily guessed because serial numbers typically follow a predictable format.

Instead of using the existing serial number, Ioto uses a random, unique claim ID (UCI) that is a random, 80-bit number that is not guessable and does not follow a predictable pattern. When paired with the product ID it is used as a unique claim ticket, allowing users to claim devices for management.

```
JT08FFQXWQ
```

The 10 letter UCI results in over 1 quadrillion possible combinations (32^10).

During manufacturing, each device is given a UCI that identifies the device to the service and is used by the user to "claim" the device after purchase or installation.

For User-Claimed devices, the UCI should be printed on the device label and be clearly identified as the **Claim ID**. The Claim ID can also be represented as a QR code if you choose to develop a mobile app for users to claim devices. (See [Claiming](#device-claiming) below).

![Device Label](/images/pics/label.png)

## Creating the UCI

There are several ways to create the UCI depending on how you operate your production process.

* Manually configure the UCI in the device.json5
* Have the Ioto Agent generate a UCI on startup.
* Create unique firmware for each device.
* Factory allocate the UCI in each device during manufacturing.

Regardless of which method you choose, the end result is the Ioto **device.json5** configuration file is updated with the UCI in the **id** property.

```js
{
    "id": "JT08FFQXWQ",
    "product": "01G8YJKKRNTHW213TRZYX3YH0M"
}
```

The **product** property in the device.json5 is generated by the [Builder Site](https://admin.embedthis.com/) when you define your product.

### Manually Creating the UCI

If you have a very small production run of devices, you can manually create the UCI with unique values for each device. You can simply edit the **device.json5** with the required values.

With any significant production volumes, you will want an automated process.

### Agent Generated UCI

If you set the **services.serialize** property in the **config.json5** to **"auto"**, Ioto will automatically generate a UCI and save it to the **device.json5** file.

```js
{
    services: {
        cloud: {
            serialize: "auto"
        }
    }
}
```

### Unique Firmware

If you create unique firmware for each device, you can set the UCI in the **device.json5** when you create the firmware.

To generate a UCI, you can either run the **ioto** process with the **--id** argument or you can create a simple program that calls the **cryptID** API from the **libioto** library. See the **./factory/serialize.c** sample for an example.

### Factory UCI

If you are using identical firmware for each device, you can allocate the UCI by having the Ioto device agent connect to a factory serialization service during manufacturing. The serialization service will generate and provide the UCI to the agent, which will then persist it to the **device.json5** configuration file.

This generation should be integrated with your label creation process during manufacturing so that the UCI in the device.json5 matches that product label affixed to the device.

The serialization service should listen for client requests on a HTTP endpoint and provide the UCI as the response.

To enable factory UCI generation, set the **services.serialize** property to **"factory"** and define the address of the serialization HTTP endpoint in the **api.serialize** property in the **config.json5** configuration file.


```js
{
    api: {
        serialize: "http://localhost:1234/ioto/serialize"
    },
    services: {
        cloud: {
            serialize: "factory"
        }
    }
}
```


The Ioto agent includes a sample serialization service in the **./factory/serialize.c** file.
# Device Registration

Before leaving the factory, when the device first powers on during system test, the Ioto agent will start and connect to the EmbedThis Ioto cloud service to register itself.

During registration, the Ioto agent will send the **device.json5** contents over an encrypted TLS connection to the Ioto cloud service. This registration request includes the device UCI and the product ID.

Once received and validated, the Ioto cloud service will save the device information in the Ioto cloud registration database.

If using User-claimed devices, the Ioto agent then awaits for a user to claim the device. If using Pre-claimed devices, the Ioto agent will skip the claiming step and proceed retrieve the required MQTT certificates and securely connect to the cloud.


## Firewall

Registration requires that your factory firewall have an outbound port opened to connect out to https://admin.embedthis.com on port 443. This is a single outbound request only.
# Claiming Devices

When creating a device cloud, the Builder creates a device manager site for your cloud. The Ioto Device Manager is a generic (white-label) device manager for your devices. It can be extensively customized with your logo, product name and device specific screens and panels. Use the Builder to customize the Device Manager to suit your needs.

## Agent Registration

When a device with the Ioto agent first powers-up, it will register with the Ioto service. If the device is 
claimed, it will receive management instructions and be redirected to the relevant device cloud for ongoing management and the provisioning process is complete.

If unclaimed, the Ioto agent will wait and regularly check with the Ioto service to see if it has been claimed. The Ioto agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay period up to a defined limit. If the device is rebooted, the polling process recommences.

## User Claiming

When a user purchases or installs a device with the Ioto agent, they can "claim" the device using the Ioto Manager application. The user claims their device using the UCI printed on the device label.

![Device Label](/images/pics/label.png)

The user enters the 10 letter code **Claim ID** code into a claim form on the Ioto Manager site configured when you created your device cloud.

When the Ioto Manager receives that request, it provisions the necessary X.509 certificates and AWS IoT resources required to support and manage the device.

When the device is unclaimed, the Ioto agent in the device will regularly check with the Ioto service to see if it has been claimed. In this state, it is "unmanaged" and awaiting orders.

The Ioto device agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay period up to a defined limit. If the device is rebooted, the polling process recommences.


After device claiming, when the device will be provided the X.509 certificate and keys when it next connects or polls the service. The device will save the certificates and keys, then connect to the device cloud. This completes the provisioning process.

## Pre-Claiming Devices

If you are using pre-claimed devices, the process is similar, except you claim the device from the Ioto Manager when the device is made. Otherwise the process is the same.

## Device Connection

When the device is unclaimed, the Ioto agent in the device will regularly check with the Ioto service to see if it has been claimed. While unclaimed, it is "unmanaged" and awaiting orders.

The Ioto agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay period up to a defined limit. If the device is rebooted, the polling process recommences.

Once claimed, when the agent next polls the Ioto service, it will receive management instructions and will be redirected to the relevant device cloud for ongoing management and the provisioning process is complete.
# Software and Over The Air Updates

It is highly desirable to be able to update and upgrade the software in your devices so you can deploy new features, patch security vulnerabilities and improve performance over time.

Via the Builder, you can define software updates for devices that will be managed and delivered Over-The-Air (OTA) to your devices.

![Software Modify](/images/builder/software-edit.png){class="screen"}

## Configuring Updates 

Using the Builder OTA update manager, you can selectively deploy updates to any desired subset of your device population. Updates can be published that will be applied to your devices according to a **distribution policy**. In this way, you can selectively update all your devices or specific subsets as you require.

To configure a software update, you supply the following parameters:

* Product
* Update version
* Update description
* Distribution policy
* Device Cloud
* Update image
* GitHub commit reference


## Update Selection

Each day, the device or update agent will connect to the device cloud for a "checkin". During this request, the agent will submit its update request to see if an update is available for this device.

The service will retrieve the most recent updates and check the updates in reverse version order and select the first matching update for the device.

The device cloud service will evaluate the distribution policy expression when the device checks-in and determine if the policy matches for the device.

## Update Limits

Implementing a gradual update strategy can help minimize load and risk. Updating a large number of devices simultaneously can impose an excessive burden on your service, so staggering the rollout can distribute the load more evenly.

Despite thorough testing, some updates might still be considered "risky." To minimize this risk, you can update a small subset of your device population first to see if the update causes any issues.

The update service provides update limits and gradual rollout factors that allow you to control the rate of updates.

* **Max device limit** and **device percentage** limits define the maximum number of devices that can be updated. Once either limit is reached, further updates are prevented.

* For gradual rollouts, you can set a **max updates per period**, which limits the number of updates to a specified number over a defined period. For example, you could set a limit of 1000 updates per hour (3600 seconds).

If a device meets the distribution policy and rollout limits, the URL for the update image will be returned to the update agent. The agent will then fetch the update image and verify its integrity. If the image is verified, the **scripts/update** script is invoked to apply the update. If you are running the agent on an RTOS without scripting, you will need to monitor and respond to the **device:update** event using the rWatch API.

## Product

When defining an update, select the product for which the software update applies. A device cloud may be managing many different products and the product selection in conjunction with the distribution policy defines the subset of devices that are eligible to receive the update.

You should define multiple product definitions if the different devices consistently require different firmware.

## Software Version

The version number is your software release version number identifying this software release. The version numbers are compatible with the [SemVer 2.0](https://semver.org/) version specification.

If you are using the Ioto agent, the current version for your device is defined via the **version** property in the config.json5 configuration file. NOTE: your device is versioned separately to the Ioto agent itself which has its own version string.

## Software Release Description

The description is an informative description for your purposes.

## Software Distribution Policy

The distribution policy is a simple Javascript-like expression that is evaluated at runtime to determine if the update is relevant for a specific device. If you leave the policy blank, then all devices whoes version is less than the software release version will be updated.

Here is a sample policy expression:

    major >= 1 && minor >= 1 && patch >= 5 && memory >= 256 && ports == 32

The properties contained in the device.json5 configuration file are made available as variables. In this case, the "memory" and "ports" variables are supplied in the device.json5 file. 

The full device version is accessible as the varible "version" and the software update version is provided via the "newVersion" variable. 

The device version string is also split into SemVer components:

* major
* minor
* patch

The query language supports the operators:

    + - * / ( ) ^ ! % == != < <= > >= ^= ^!= $= $!= << >> && || <> ><

These extension operators have the following meaning:

* a ^= b     means a starts with the string b
* a ^!= b    means a does not start with the string b
* a $= b     means a ends with the string b
* a $!= b    means a does not end with the string b
* a >< b     means a contains the string b
* a <> b     means a does not contain the string b

Sub-expressions can be grouped with parenthesis and the boolean operators && and || can group conditional operands.

Regular expressions (delimited by slashes) may be used with the "==" and "!=" operators. The regular expression can be on either side of the operator.

The policy expression language understands the types: Numbers, Boolean, String literals, Regular Expressions and null.

The policy expression is run-time limited to evaluate up to 20 terms. This is to protect your cloud against denial of service attacks.

## Opt-in Updates

Devices can implement an opt-in update strategy by defining variables in the device context that are passed with the update checkin request. These variables can be examined by the distribution policy expression. If a variable is set only when a device/user opts-in, then the distribution policy can target only those devices.

For example, say a device defined an opt-in field called **try-beta-features** that was set to "1" when users toggled a UI checkbox to signify they wished to receive beta features. The device would then pass this field with the update checkin request and the distribution policy could test that value.

    try-beta-features == 1

## Rollback Updates

You can rollback errant updates by defining an update that has a distribution policy pinned to the errant version. For example, say the update **1.2.3** was bad and you wished to rollback devices to the prior **1.2.2** version. You would first disable the 1.2.3 bad update by deselecting the **Enable** checkbox for that update. Then, you would define an update 1.2.2 that had a distribution policy like this:

    version == '1.2.3'

This would target only the 1.2.3 devices and roll them back to version 1.2.2. 

## Device Cloud

Update images are stored in AWS S3 in your device cloud AWS account. When defining updates, you select the relevant device cloud to store and apply the updates. If you have multiple clouds, you will need to define updates in each cloud.

## Applying Updates

When the update is downloaded to the device and verified, the update agent will save the update in a temporary file. Your device can be notified of an update by one of two means:

* The "./script/update" shell script will be invoked and passed the filename of the update.
* Ioto will indicate an update is available via the "device:update" signal. See rSignal/rWatch for details.

## Enable

You can selectively enable or disable a release at any time via the Builder.# Best Practices in IoT Solutions

Implementing an efficient data communication design is crucial for successful IoT solutions. When managing a large pool of devices, excessive cloud communication can result in high costs, poor performance, and scalability issues.

The Ioto cloud solution offers powerful communication mechanisms such as MQTT messaging and transparent database synchronization. However, if used indiscriminately by sending excessive or redundant data to the cloud, it can compromise your solution and lead to throttling.

To protect your devices, customers, and the service, Ioto enforces data limits. If a device or group of devices sends too much data, Ioto will throttle (slow down) incoming data from those devices. Persistent overuse can result in the offending devices being disconnected from the network.

Follow these best practices to ensure a successful IoT strategy:

1. **Only send necessary data to the cloud**: Limit cloud communication to data that is required at the cloud. Don't send data that is never accessed by the cloud.
2. **Send only changed data**: Avoid redundant data transmission by sending updates only when data changes. If a data item has only one changed field, consider splitting into fixed and changing data items.
3. **Separate configuration data from runtime statistics**: Define database entities to differentiate between the two. Configuration data changes infrequently and can be synchronized to the cloud when updated. Statistics can be buffered and can be sent less frequently.
5. **Utilize automatic metric creation**: Take advantage of automated metrics for efficient monitoring. Ioto can transparently create metrics from database data that can be graphically displayed or used for automated actions.
6. **Synchronize database tables in one direction only**: Ensure that synchronized tables are not bidirectional to prevent conflicts. Split tables to be synchronized up to the cloud, or down to the device, not both.
7. **Avoid messaging loops**: Implement safeguards to prevent loops in your messaging system.
7. **Monitor throttle messages**: Listen for Ioto throttle messages and adjust your device behavior accordingly.# Dedicated Device Clouds

Dedicated device clouds are created in an AWS account that you own and control. As such, you have full access to all AWS services in your account.

The Ioto service provides additional capabilities for dedicated clouds:

* Uploading device log files to AWS CloudWatch
* Storing state in AWS IoT shadows
* Executing server-side processing logic in response to AWS EventBridge events triggered by device data or metrics.
* Use a custom domain to address a Device Manager.
* Unlimited message traffic.
* Ability to invoke AWS services directly from the device.

When you create a dedicated device cloud, the Builder and Ioto will create the following AWS resources in your AWS account:

* An AWS DynamoDB database registry of your devices.
* An AWS DynamoDB database exclusively for your device data.
* AWS DynamoDB streams to replicate device data to and from the cloud.
* An AWS API Gateway to authorize remote API access to device data.
* An AWS Cognito User Pool to authenticate user access.
* An AWS CloudFront and S3 site for the Ioto Device Manager site.
* AWS Route53 domain for the Ioto Device Manager site.
* AWS Lambda functions for cloud-side device management.
* IAM Roles to restrict remote access.
* AWS IoT Core policies and message routing rules.
* AWS IoT Things to model your devices in the cloud.


## Enabling IAM Keys

To interact with AWS services, the Ioto agent must be configured to request IAM access keys. This is enabled by setting the **services.cloud.keys** property in the **device.json5** configuration file.

```js
{
    services: {
        cloud: {
            keys: true
        }
    }
}
```

When the agent starts, it will retrieve from the Ioto service a set of IAM access keys to sign AWS API requests. 

## Data Lake

Amazon S3 is an object storage service offering scalable data storage with strong data availability and security guarantees.

The Ioto agent provides convenience APIs to make uploading data or files to S3 efficient and easy.

To upload a file in the Ioto agent, use **awsPutFileTS3** API:

```c
status = awsPutFileToS3("us-east-1", "MyBucket", "file.dat", "./file.data");
```

This call will upload the file "./file.data" to the bucket "MyBucket" on S3. The file will be saved in the bucket as "file.dat". The returned status will be a HTTP status code of 200 if successful.

## CloudWatch Logs

Ioto can export logs from the local device into CloudWatch Logs for secure cloud-side storage.

Ioto Log capture offers two capabilities:

* Export and save the Ioto Log to CloudWatch
* Capture and export any device O/S log file to CloudWatch

### Enabling Cloud Logs

To enable exporting log files to the device cloud, set the **services.logs** property in the **config.json5** file to true.

```js
{
    services: {
        cloud: {
            keys: true,
            logs: true
        }
    }
}
```

To export logs, you must have the **keys** property set to true to enable generation of the IAM access keys that grant access to AWS CloudWatch.

### Exporting the Ioto Log

By default, the Ioto trace log is saved to /var/log/ioto.log.

To save this to the cloud, change the **trace.path** property in the **config.json5** file to be set to "cloud".

```js
    trace: {
        path: 'cloud'
        group: 'log-group-name',
        stream: 'log-stream-name',
    }
```

This will cause all messages sent to the Ioto log to be saved to the specified CloudWatch group and stream name. If the group and stream are unset, they default to: "Ioto" and "agent".

### Enabling O/S Log File Export

Ioto can monitor, capture and export any file to S3. Ioto will monitor the length of the file and if new data is written to the log, it will be efficiently captured and written to CloudWatch.

To configure log files for monitoring, define the log files in the **logs.files** property of the **config.json5** configuration file. For example:

```js
{
    logs: {
        files: [
            { path: '/var/log/sys*log', group: 'ioto', stream: '{hostname}' }
        ],
    }
}
```

The **files** property contains any number of log definitions. Each definition specifies the local filename and the destination CloudWatch group and stream name.

The file pathname may contain the wild cards "*" and "?". This is useful for log files that have a varying portion such as a date or version component in the name.

The **stream** property can use tokens such as "{hostname}" which is expanded at runtime with the local hostname of the device.

## AWS IoT Shadow State

The AWS IoT Device Shadow service offers convenient storage for small device state (up to 8K). 

Shadows are capable of handling limited state for intermittently connected devices. When a device is not connected, updates to the shadow state in the cloud are stored until the device is next connected. Then, once connected, the changes are sent to the device for action.

Ioto makes it easy to use shadow state by automatically connecting to the AWS IoT Shadow service and by providing an easy get/set API on the device.

The Ioto agent automatically initializes an AWS Shadow state connection and subscribes to the required MQTT topics for data synchronization.

When shadows updates are received from the cloud, the agent saves these in a local shadow state file called **shadow.json5**. When the agent reboots, the local shadow state is read to be immediately available while the AWS cloud shadows are consulted for any updates.

We recommend using synchronized database tables rather than AWS Shadows as they offer increased data storage and more flexibility in accessing device data.

### Features

* Local copy of AWS IoT Device Shadow on device.
* Convenience device API to get / set shadow state properties.
* Controllable state synchronization with AWS IoT Shadows.
* Local persistence of shadow state.


## Cloud Auditing

When using a dedicated device cloud, it is best practice to enable [AWS CloudTrail](https://aws.amazon.com/cloudtrail/) on your AWS device cloud account to track user and API changes and activity on your account.

From the AWS Docs:

>AWS CloudTrail is an AWS service that helps you enable operational and risk auditing, governance, and compliance of your AWS account. Actions taken by a user, role, or an AWS service are recorded as events in CloudTrail. Events include actions taken in the AWS Management Console, AWS Command Line Interface, and AWS SDKs and APIs.

Visibility into your AWS account activity is a key aspect of security and operational best practices. You can use CloudTrail to view, search, download, archive, analyze, and respond to account activity across your AWS infrastructure. You can identify who or what took which action, what resources were acted upon, when the event occurred, and other details to help you analyze and respond to activity in your AWS account. Optionally, you can enable AWS CloudTrail Insights on a trail to help you identify and respond to unusual activity.

<!--
Ioto will automatically enable CloudTrail when creating a device cloud.

## S3 Bucket Name

Ioto will enable CloudTrail to log to an S3 bucket named: **ioto-cloudtrail-logs-UUID**.
-->


# IAM Access Keys

Ioto can automatically generate and distribute IAM access keys to devices so the device can interact with the Device Cloud or AWS services.

The IAM keys are temporary access keys that expire each hour. The Ioto agent will automatically refresh these keys as required.

## Enabling IAM Keys

To enable generation of temporary IAM keys, set the `keys` property of the `services.cloud` property in the Ioto agent **config/ioto.json5** configuration file to true.

```js
{
    services: {
        cloud: {
            keys: true
        }
    }
}
```

When the **keys** property is set to true, the Ioto agent will retrieve from your Device Cloud a set of temporary IAM credentials that can be used to sign AWS API requests using the Ioto agent **aws** APIs or to use with the [AWS C API SDK](https://github.com/aws/aws-iot-device-sdk-embedded-C).

These keys will be automatically refreshed 20 minutes before expiring, so you can rely on using these keys to be valid for 20 minutes.

## IAM Role

The generated keys are based on the Device Cloud IAM role in the device cloud. This defaults to the IAM role named: `IotoDeviceAccess`. However, you can change this using the [Builder Site](https://admin.embedthis.com) to any custom role you choose.

You should follow the principle of least privilege and ensure all privileges granted to your devices are scoped to specific resources. They should only grant access to AWS APIs that are absolutely required.# Device Cloud Limits

Ioto defines data limits to protect you, your devices, customers and the service. If a device or devices send too much data to the cloud, Ioto protects you and your customers by throttling (slowing) incoming data from offending devices. 

Depending on your Device Cloud plan these limits and enforcement policies may vary. 

## Data Traffic

The amount of data you send to the device cloud is measured as the number of KBytes sent on average per device per hour. This traffic is then compared with the limit for your device cloud.

As you connect more devices, your data limit scales automatically with the number of devices connecting to the cloud. What is measured is the average data traffic over your entire pool of connecting devices.

For example, if you have 100 devices and a limit of 60 messages per device per hour, this means that your pool of devices can send up to 6,000 messages to the cloud per hour. 

Ioto supports short-term burst traffic above the limit, but if your sustained, aggregate traffic exceeds your limit, the offending devices will have their sending rate throttled.

## Data Limits

The data limits vary depending your your device cloud type and plan. 

For Hosted device clouds and the Evaluation device cloud, data limits ensure the cloud infrastructure is not monopolized by any one device, set of devices or users.

The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It has higher limits, as it is typically used with few devices and consequently lower aggregate device pool limits.

For a Dedicated cloud, you are the sole user of the cloud running in your own AWS account. In this case limits are advisory and can be increased if required. Contact support if you need a limit increase.

### Cloud Limits

Device Cloud| Limit
-:|:-
Eval Cloud | 60 messages (1K) per device per hour
Hosted Cloud | 10 messages (1K) per device per hour
Dedicated Cloud | 100 messages (1K) per device per hour

## Terms

Please see the [Terms of Use](https://www.embedthis.com/about/terms.html) for acceptable use terms.# Ioto&reg; Cloud Service

The Ioto cloud service enables you to centrally operate and manage one or millions of devices. The Ioto cloud service stores device data, manages communications with your devices and provides a device management application to manage devices. By aggregating critical device data in one place, you can easily manage your devices and extract important data analytics and intelligence from your devices.

![Ioto IoT Framework](/images/ioto/framework.avif){class="screen"}


## Device Cloud Services

The Ioto device cloud service provides:

* Cloud-based device database store for centralized management and analytics.
* Provisioning Ioto-based devices with certificates for secure communications.
* Secure management of device communications with denial-of-service protection.
* Automatic creation of device metrics based on device data.
* Management of over the air device updates.
* Device manager apps for managing a single devices or a large fleet of devices.
* Huge scale supporting 10,000,000+ devices per device cloud.

## Device Cloud Types

Ioto supports three types of device clouds:

* Eval Cloud
* Cloud hosted by EmbedThis 
* Dedicated cloud in your own AWS account

When creating a device cloud, the Builder will create all the necessary resources for IoT management. This process results in a configured, complete, integrated and live IoT cloud capability.

## Eval Cloud

The Eval cloud will probably be your first experience with Ioto device clouds. The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It enables you to connect a device running the Ioto agent to the cloud and to receive device data and manage the device.

The Eval cloud is free to use for a few devices for a short period of time for evaluation purposes.

## Hosted Device Clouds

A hosted device cloud is a device cloud for your devices and customers that is hosted by EmbedThis on secure AWS IoT infrastructure. You do not need to have or manage your own AWS account to use a hosted device cloud.

Device data goes directly from your devices to the device cloud in the region you select when creating the device cloud. Data does not transit other regions or third-party services.  This is important as governments and authorities are increasingly requiring that data only be stored, processed and managed locally.

Unlike other IoT services, Ioto provides decreased latency by locating device data in a region close to you. This lowers cost and boosts performance of your cloud-based management solution.

A hosted device cloud provides:

* An AWS DynamoDB database exclusively for your device data.
* AWS DynamoDB streams to replicate device data to and from the cloud.
* An AWS API Gateway to authorize remote API access to device data.
* An AWS Cognito User Pool to authenticate user access.
* An AWS CloudFront and S3 site for the Ioto Device Manager site.
* AWS Route53 domain for the Ioto Device Manager site.
* AWS Lambda functions for cloud-side device management.
* AWS IoT Core policies and message routing rules.
* AWS IoT Things to model your devices in the cloud.

## Dedicated Device Clouds

A dedicated device cloud is created in your AWS account so you have the ultimate in the control and privacy of your device data. With a dedicated device cloud, device data goes directly from your devices to the device cloud in your AWS account. The device data is not sent through EmbedThis servers. The data is encrypted throughout and you have total control.

Dedicated clouds support an enhanced set of AWS services beyond those available with hosted device clouds. These include:

* Device log file capture and storage in AWS CloudWatch logs
* Audit operations via AWS CloudTrail
* Device AWS keys to initiate AWS API operations from the device

## Device Manager

For each device cloud, you can create one or more apps with which to manage your devices. 

Device management apps are based upon the `DevCore` UI Framework which is a flexible UI framework that can be uniquely configured for your devices. It can be completely customized with your logo, product name, device data and device specific screens and custom logic.

Device apps are hosted by EmbedThis on a domain of your choice that reflects your company or product's brand. 


![Builder Dashboard](/images/manager/dashboard.png){class="screen"}

## Device Certificates

Devices require X.509 certificates to securely connect and communicate with the cloud. The certificates are used to uniquely identify and authenticate devices and then to encrypt communications to prevent tampering or eavesdropping.

Ioto will automatically create and distribute the unique per-device certificates. This eliminates the pain of certificate creation and distribution and effectively isolates the security of each device and prevents the compromise of one device's certificate from impacting other devices.

## Device Messaging

During device provisioning, the Ioto service will setup the necessary AWS resources to enable secure efficient messaging via AWS IoT core using the MQTT protocol.  MQTT is a messaging protocol for IoT. It is a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices.

## Device Data Aggregation

Collecting, aggregating and sending device data to a central management store can be complex and costly. Ioto takes the hassle out of exporting device data to the cloud by synchronizing the Ioto device agent database with an AWS DynamoDB database in your device cloud.

Data written on the device to the management database will be transparently exported to the cloud as required. Similarly, data written to the cloud database will be distributed to the appropriate devices as required. No programming is required.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-device and per-table basis. Performance can be optimized by buffering and aggregating changes to reduce message overhead.

This replication capability is similar to AWS DynamoDB Global Tables, but instead of acting inside AWS between AWS regions, it is between an AWS region and a device.

This replicated device database is unique to Ioto and dramatically simplifies the creation of IoT solutions.

## Device Access Keys

For dedicated device clouds, Ioto can optionally create and manage AWS IAM access keys for your devices. AWS uses IAM access keys to authenticate and authorize actors on AWS resources. The Ioto device cloud can create specific IAM keys to enable devices to directly issue requests to the device cloud and AWS services.

The Ioto generated temporary IAM access keys have tightly controlled access permissions. The keys are automatically reissued as required.

## Device Logging

For dedicated device clouds, device logs and files can be captured and sent to AWS CloudWatch logs for storage, governance and analysis.

The Ioto agent can be configured without coding, to capture any O/S log or program output and send it to CloudWatch Logs. 

## Device Metrics and Analytics

Ioto provides a comprehensive, scalable metric service. Metrics can be transparently created from device data changes. The Ioto metrics are dramatically less expensive and more scalable than AWS CloudWatch metrics.

Using these Ioto metrics, you can create detailed device analytics and dashboards to focus on any aspect of your device or fleet performance.

<!--
## Account Audit

For dedicated device clouds, Ioto configures and enables CloudTrail, which captures an audit trail of **all** activity on your account and device cloud.  This records a complete log to AWS S3 so you can reliably audit operations and determine root cause of any security incidents.
--># MQTT Messaging

The MQTT messaging protocol is a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices with a small code footprint and minimal network bandwidth to the cloud.

MQTT is used by Ioto for general device communications and for transporting the device state to the cloud.

## Configuring

As devices are provisioned by the Builder into a Device Cloud, the Ioto service will create and distribute the necessary device X.509 certificates, keys and resources to configure secure cloud communications over MQTT.

The device-specific certificates and keys are provided to the Ioto device agent as part of the device provisioning, registration/claiming process. The device agent will save these on the device.

## Ioto Key/Value Store

Many devices require simple device settings that can be managed by the cloud. In addition to the general Ioto device database, Ioto provides provides a simple **key/value** store in the device database called the **Store**. This key/value store is ideal for a small set of simple device settings. If you have more elaborate device settings and state, they are best stored directly in the device database.

Values can easily be written and read to/from the Store using the device agent **ioSet** APIs.

```c
iotSet("model", "Acme Rocket");
iotSetNum("cpu", 55);
```

These values can be displayed in the Device Manager UI and can be retrieved in the device via the **ioGet** APIs.

```c
char *model = iotSet("model");
int64 cpu = iotSetNum("cpu");
```

These APIs are simple wrappers over the mqttPublish and mqttRequest APIs.

## Ioto Device Agent

The Ioto device agent provides an efficient MQTT client that is ideal for connecting to the cloud. It supports:

* MQTT 3.1.1
* Connect, publish, subscribe, ping and disconnect messages.
* TLS encryption with ALPN over port 443 to get through firewalls.
* Message quality of service for reliable delivery.
* Retained messages.
* High message throughput with exceptionally low overhead.
* Wait for delivery or acknowledgement options.
* Resilient reconnect on network interruptions.
* Automatic configuration after cloud provisioning.
* Parallelism via fiber coroutines. No ugly callbacks or complex threads.
* Tiny footprint of 8K code.

See the [Ioto MQTT Documentation](/agent/dev/mqtt.html) for details about the Ioto Agent MQTT API with examples.

## MQTT Reconnecting

The Ioto service will reliably maintain an MQTT connection to devices. If the network connection fails, Ioto will automatically reconnect to the cloud service. 

## Throttling

Ioto defines data limits to protect you, your devices, customers and the service. If a device or devices send too much data to the cloud, Ioto protects you and your customers by throttling (slowing) incoming data from offending devices. 

## Data Traffic

The amount of data you send to the device cloud is measured as the number of KBytes sent on average per device per hour. This traffic is then compared with the limit for your device cloud.

As you connect more devices, your data limit scales automatically with the number of devices connecting to the cloud. What is measured is the average data traffic over your entire pool of connecting devices.

For example, if you have 100 devices and a limit of 60 messages per device per hour, this means that your pool of devices can send up to 6,000 messages to the cloud per hour. 

Ioto supports short-term burst traffic above the limit, but if your sustained, aggregate traffic exceeds your limit, the offending devices will have their sending rate throttled.

## Throttling

When devices in a cloud cloud exceed the data limit, the offending devices will receive a throttle message and the device's Ioto agent will automatically slow down the rate of sending to the cloud. 

Upon receiving a throttle message, Ioto will implement an exponential backoff strategy and will slow down the rate of sending. Messages can still be received and Ioto will be fully functional. However, the rate of sending will be reduced until the throttled condition is alleviated. This protects your account and your customer's quality of service. It also protects you against rogue devices that have been compromised.

If a device continues to exceed the limit for a device cloud, the device will be disconnected (released) from the device cloud and its communication certificates will be revoked. The device will then need to be reclaimed to join the device cloud.

Ioto measures your device traffic rate every 30 seconds and will throttle a device that is exceeding your traffic limit over a 1 minute period.

Please see [Device Cloud Limits](../clouds/limits.md) for limit details.

## Terms

Please see the [Terms of Use](https://www.embedthis.com/about/terms.html) for acceptable use terms.---
# https://vitepress.dev/reference/default-theme-home-page
layout: home
hero:
  name: "EmbedThis Ioto"
  text: "Documentation"
  tagline: Build your next smart device here
  actions:
    - theme: brand
      text: Why EmbedThis Ioto?
      link: /builder/what-is-ioto.md
    - theme: alt
      text: Get Started
      link: /builder/
  image:
    src: '/circuit-8.avif'
    alt: 'EmbedThis'

features:
  - icon: 🏗️
    title: Device Builder
    details: One-stop-shop for building smart devices. Download device agents softare, create device clouds, monitor devices and update device firmware.
    link: '/builder/'
  - icon: ☁️
    title: Ioto Cloud
    details: Device cloud service for Ioto devices. Device data capture, storage, metrics and analysis.
    link: '/ioto/'
  - icon: 🥷
    title: Iot Device Agent
    details: Blazing fast, compact device agent with local embedded web server and remote cloud-based management.
    link: '/agent/'
  - icon: 🚀 
    title: Device Management Apps
    details: Create apps to manage your devices using the low-code, visual app designer to create mobile and desktop management apps.
    link: '/apps/'

---

<style>
:root {
  --vp-home-hero-name-color: transparent;
  --vp-home-hero-name-background: linear-gradient(-45deg, #445aff 50%, #6d8ae2c7 50%);
  was: -webkit-linear-gradient(120deg,rgb(189, 52, 254) 30%, #41d1ff);

  --vp-home-hero-image-background-image: linear-gradient(-45deg, #445aff 50%, #6d8ae2c7 50%);
  old: linear-gradient(-45deg, #bd34fe 50%, #47caff 50%);
  --vp-home-hero-image-filter: blur(44px);
}

@media (min-width: 640px) {
  :root {
    __--vp-home-hero-image-filter: blur(56px);
  }
}

@media (min-width: 960px) {
  :root {
    __--vp-home-hero-image-filter: blur(68px);
  }
}

.VPImage.image-src {
  max-width: 300px !important;
  max-height: 300px !important;
}
</style># Creating Dashboards

You can create any number of dashboards from the Builder dashboard list.

![Dashboard List](/images/builder/dash-list.png){class="screen width-100"}

From the Dashboard list you can click the `Add` button to create a new dashboard or click on the `Edit` icon to modify an existing dashboard. When clicked, the dashboard configuration panel will be displayed.

The `Design` icon is used to launch the dashboard designer so you can modify the dashboard, content layout and styling.  While the `Show` icon is used to display the dashboard. 

## Modifying Dashboards

![Dashboard](/images/builder/dash-edit.png){class="screen width-50"}

Using the dashboard configuration panel, you can create, delete and manage dashboards to control dashboard operation, layout, and styling.

When you have finished creating or editing your dashboard, you can `Save` to persist your changes. You can rename a dashboard by entering a new name and clicking Save. 

Click the `Copy` button to copy an existing dashboard to a new dashboard. The `Apply` button saves your changes without dismissing the edit panel. Dashboards can be deleted via the `Delete` button.

## Dashboard Name

Each dashboard is given a unique name that is displayed in the dashboard list.

## Dashboard Layout

Dashboards have the choice of using one of two layout engines:

Name | Description
-|-
Grid | Layout widgets on a grid
Exact | Layout widgets with exact positioning

### Grid Layout

The **Grid** layout will align widgets on a 20 pixel grid and ensure that widgets do not overlap.

### Exact Layout

The **Exact** layout engine will position and size widgets wherever you place and configure them with per-pixel resolution. Widgets can overlap and cover widgets behind them. The exact layout does not use a grid.  The exact layout is useful to create composite pages where widget boundaries are not visible (using frameless widgets).


## Live Data

By default, dashboards will automatically update widget data based on the defined **Refresh Period**. You can disable **Live Data** update which can help you to focus on styling and arranging widgets without any display updates to break your concentration. 

## Framed Widgets

Widgets can be framed with a thin border. If you are creating a dashboard with a grid of data graphs, gauges and metrics, you typically frame the widgets with a consistent border.

![Framed Widgets](/images/builder/framed-widgets.avif){class="screen"}

If you are creating a composite page, you may wish to combine widgets so that the boundaries between widgets are less visible. In this case, disabling widget frames can assist to create a cohesive single page interface. For example, the EcoHouse app combines widgets to create a single page dashboard.

![Eco House](/images/eco/eco-home.avif){class="screen width-50"}

In this case, it is typically helpful to enable frames while you are designing a page and then disable frames when you are complete.

## Full Screen

When full screen mode is enabled, the top-level application navbar is hidden:

![Nav Bar](/images/builder/full-screen.avif){class="screen"}

This is useful for mobile displays and for production desktop dashboards.

## Show Toolbar

If the `Show Toolbar` option is enabled, a toolbar is displayed at the top of the dashboard. The toolbar can be used to select dashboards, change the data date range, refresh data, and modify dashboard and widget configuration. You can also click a `designer` icon to quickly return to the designer for more significant changes to the dashboard.

![Widget Toolbox](/images/builder/dashboard-toolbar.avif){class="screen width-80"}

## Refresh Period

You can define the default refresh rate for metrics and data widgets. Set the refresh rate to your desired update period in seconds. However, do not set needlessly low as this will impose increased load on your service.

## Device Emulation

When designing pages for a mobile app, it can be helpful to perform your design on a desktop PC and emulate the mobile device. Selecting a **mobile** device to be emulated will resize the dashboard to be that of an iPhone 15 Pro Max.

Dashboards are responsive and should scale up and down as browser windows are resized or when run on mobile devices of differing dimensions.

### Time Range

You can define an absolute or relative time period to use for metric data supplied to your widgets.
A relative time range may be set to the most recent number of minutes, hours, days, weeks, months or years. An absolute time range can specify a fixed start and end date.

If the dashboard has a **toolbar** widget, users can change the time range at any time.

### Dashboard CSS Properties

Dashboards can be styled with any valid CSS property. For example, you can set the background to red and foreground color to blue via:

Name | Value
-|-
background | red
color | blue

### Default Widget CSS Properties

Simlarly to Dashboard CSS properties, you can define default widget properties that are applied to all widgets. These can be overridden per-widget in the Widget edit panel. You can display a color picker by clicking the pencil icon in the table.

## Exporting and Importing Dashboards

You can export a dashboard to a JSON file by selecting the dashboard and clicking the `Export` option under `Actions`. You can import a dashboard from a JSON file by clicking the `Import` action.

## Selecting Dashboards

You can create multiple dashboards that focus on different service aspects. For example, you may want a dashboard that features service load graphs and metrics and another dashboard to focus on outages and errors.

You can easily switch between dashboards by clicking on the name of the dashboard in the Dashboard toolbar. You can also create enable a "dashboard switch" action on a button widget that lets you rapidly switch to another dashboard by clicking the button widget in the dashboard.# Dashboards

![Dashboard](/images/builder/dashboard.png){class="screen"}

Builder dashboards provide interactive, graphical interfaces for monitoring and managing your account and IoT clouds. They serve as a real-time window into the state of your service.

Dashboards are composed of interactive widgets, allowing you to create tailored information interfaces focused on specific aspects of your service or operations.

## Key Features

- **Graphical Widgets:** Include graphs, gauges, numeric displays, text displays, and more.
- **No-Code Designer:** A drag-and-drop interface for creating and customizing dashboards and widgets.
- **Flexible Layouts:** Adjustable widget positioning and sizing to fit your requirements.
- **Responsive Design:** Dashboards adapt seamlessly to various screen sizes.
- **Multiple Dashboards:** Support for creating and managing multiple dashboards for different service aspects.
- **Widget and Data Source Gallery:** Access to additional pre-designed widgets and data integrations.
- **Configuration Sharing:** Save and share dashboard setups with team members.

These features enable efficient monitoring and management of device and cloud performance.

## Widgets

Widgets are UI components that display data within a dashboard. They pull data from the Builder service, Ioto service, or your custom device metrics. You can add, remove, style, position, and resize widgets to meet your specific needs.

Builder dashboards support 30 widget types, including gauges, graphs, numeric displays, text displays, images, data tables, and input widgets.

Key capabilities of widgets include:

- **Dynamic Styling:** Customize colors, backgrounds, fonts, and overall presentation.
- **Composite Displays:** Combine multiple widgets to create cohesive, intuitive visualizations of device and cloud states.
- **Interactive Input:** Widgets like buttons and switches can trigger actions, such as device commands (e.g., rebooting) or cloud operations (e.g., updating a database or sending alerts).

By combining flexibility and interactivity, Builder dashboards provide a powerful tool for managing the operational state of your devices and services.

The Builder dashboard is based upon the low-code, visual [App Designer] used for EmbedThis device management. It uses the [Boards](/apps/boards/) component as the foundation for dashboards and widgets.

Please consult the documentation for:

* [Boards](/apps/boards/)
* [Layouts](/apps/boards/layouts.html)
* [Widgets](/apps/boards/widgets/)
* [Toolbar](/apps/boards/toolbar.html)# Product

Manage Products.

---

## Create
**Create a product definition**

**Endpoint**

    POST /product/create

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Role | Notes
- | - | - | -
advance | boolean |  | 
agent | string |  | 
align | boolean |  | 
current | object | support | 
description | string |  | 
end | date |  | 
interest | array |  | 
meter | boolean |  | 
name | string |  | Must be a unique name.
notify | array |  | 
pending | boolean |  | 
period | string |  | 
scope | string |  | 
start | date |  | 
type | string |  | 
units | number |  | 
url | string |  | 

**Response** 

Field | Type
- | -
accountId | string
description | string
id | string
name | string
planId | string
suspended | boolean
url | string

---

## Get
**Get a product definition by ID**

**Endpoint**

    POST /product/get

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

Field | Type
- | -
accountId | string
description | string
id | string
name | string
planId | string
suspended | boolean
url | string

---

## Find
**Endpoint**

    POST /product/find

**Authorized User Role**

    user

**Request Body** 

Field | Type | Role
- | - | -
accountId | string | support

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | An array of metrics each containing an array of metric with the following properties.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Product** 

An array of Product items.

Field | Type
- | -
accountId | string
description | string
id | string
name | string
planId | string
suspended | boolean
url | string

---

## Init
**Endpoint**

    POST /product/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
description | string
id | string
name | string
planId | string
suspended | boolean
url | string

---

## Remove
**Remove a product definition**

**Endpoint**

    POST /product/remove

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
id | string

---

## Update
**Update a product definition**

**Endpoint**

    POST /product/update

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Role | Notes
- | - | - | -
advance | boolean |  | 
align | boolean |  | 
agent | string |  | Set to Ioto, GoAhead or Appweb.
current | object | support | 
description | string |  | 
id | string |  | 
end | date |  | 
interest | array |  | 
meter | boolean |  | Set to true to use automatic volume metering.
name | string |  | 
notify | array |  | 
pending | boolean |  | 
period | string |  | 
planId | string |  | 
scope | string |  | 
start | date |  | 
type | string |  | 
units | number |  | 
url | string |  | 

**Response** 

Field | Type
- | -
accountId | string
description | string
id | string
name | string
planId | string
suspended | boolean
url | string

---

## Download
**Download software**

**Endpoint**

    POST /product/download

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
image | string | yes
planId | string | 

**Response** 

The download URL for the requested image.


# Dashboard

Manage Builder UI Dashboards.

---

## Create
**Endpoint**

    POST /dashboard/create

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required | Default
- | - | - | -
layout | string |  | 
name | string | yes | 
range | object |  | 
responsive | boolean |  | 
widgets | array |  | []

**Widgets** 

An array of Widgets items.

Field | Type
- | -
cloudId | string
dashboard | string
dimensions | object
field | string
height | string
id | string
left | string
limit | number
metric | string
model | string
name | string
namespace | string
presentation | string
region | string
statistic | string
top | string
type | string
units | string
width | string
z | string


**Response** 

Field | Type
- | -
accountId | string
id | string
layout | string
name | string
range | object
responsive | boolean
widgets | array

**Widgets** 

An array of Widgets items.

Field | Type
- | -
cloudId | string
dashboard | string
dimensions | object
field | string
height | string
id | string
left | string
limit | number
metric | string
model | string
name | string
namespace | string
presentation | string
region | string
statistic | string
top | string
type | string
units | string
width | string
z | string


---

## Find
**Endpoint**

    POST /dashboard/find

**Authorized User Role**

    user

**Request Body** 

A object.


**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | A list of cloud records.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Dashboard** 

An array of Dashboard items.

Field | Type
- | -
accountId | string
id | string
layout | string
name | string
range | object
responsive | boolean
widgets | array

**Widgets** 

An array of Widgets items.

Field | Type
- | -
cloudId | string
dashboard | string
dimensions | object
field | string
height | string
id | string
left | string
limit | number
metric | string
model | string
name | string
namespace | string
presentation | string
region | string
statistic | string
top | string
type | string
units | string
width | string
z | string


---

## Get
**Endpoint**

    POST /dashboard/get

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
id | string

**Response** 

Field | Type
- | -
accountId | string
id | string
layout | string
name | string
range | object
responsive | boolean
widgets | array

**Widgets** 

An array of Widgets items.

Field | Type
- | -
cloudId | string
dashboard | string
dimensions | object
field | string
height | string
id | string
left | string
limit | number
metric | string
model | string
name | string
namespace | string
presentation | string
region | string
statistic | string
top | string
type | string
units | string
width | string
z | string


---

## Init
**Endpoint**

    POST /dashboard/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
id | string
layout | string
name | string
range | object
responsive | boolean
widgets | array

**Widgets** 

An array of Widgets items.

Field | Type
- | -
cloudId | string
dashboard | string
dimensions | object
field | string
height | string
id | string
left | string
limit | number
metric | string
model | string
name | string
namespace | string
presentation | string
region | string
statistic | string
top | string
type | string
units | string
width | string
z | string


---

## Remove
**Endpoint**

    POST /dashboard/remove

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
id | string

---

## Update
**Endpoint**

    POST /dashboard/update

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
id | string | 
layout | string | 
name | string | yes
range | object | 
responsive | boolean | 
widgets | array | 

**Response** 

Field | Type
- | -
accountId | string
id | string
layout | string
name | string
range | object
responsive | boolean
widgets | array

**Widgets** 

An array of Widgets items.

Field | Type
- | -
cloudId | string
dashboard | string
dimensions | object
field | string
height | string
id | string
left | string
limit | number
metric | string
model | string
name | string
namespace | string
presentation | string
region | string
statistic | string
top | string
type | string
units | string
width | string
z | string


# Metric

Metric.

---

## Fetch
**Endpoint**

    POST /metric/fetch

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
items | array

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | An array of metrics each containing an array of metric with the following properties.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Metric** 

An array of Metric items.

Field | Type | Notes
- | - | -
dimensions | array | Dimensions for the metric.
metric | string | Metric name.
namespace | string | Always set to Embedthis/Device.
owner | string | The service owning the metric.
period | number | Metric timespan period.
points | array | Array of data points.
samples | number | Number of data points in the period.

**Points** 

An array of Points items.

Field | Type | Notes
- | - | -
value | number | Metric value.
timestamp | number | Last update to the metric value in seconds since Jan 1, 1970.
count | number | Number of data values contributing to the metric value.


---

## GetMetricList
**Endpoint**

    POST /metric/getMetricList

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
cloudId | string
namespace | string
metric | string

**Response** 

Field | Type | Notes
- | - | -
namespaces | array | Returns the requested namespace. If not provided, returns a list of available namespaces.
metrics | array | If a namespace is provided, returns a list of available metrics.
dimensions | array | If a namespace and metric are provided, returns a list of available metric dimensions.

---

## Action
**Endpoint**

    POST /metric/action

**Authorized User Role**

    public

**Request Body** 

A object.


**Query String Options** 

Field | Type
- | -
action | string
keep | string

---

## Visit
**Endpoint**

    POST /metric/visit

**Authorized User Role**

    public

**Request Body** 

A object.


**Query String Options** 

Field | Type
- | -
browser | string
dimensions | string
mode | string
dwell | string
keep | string
metric | string
site | string
url | string
vary | string

# Card

Manage Billing Cards.

---

## Create
**Add a credit card**

**Endpoint**

    POST /card/create

**Authorized User Role**

    owner

**Request Body** 

Field | Type | Required
- | - | -
current | boolean | 
name | string | yes
number | string | yes
month | string | yes
year | string | yes
stripeToken | string | yes

**Response** 

Field | Type
- | -
accountId | string
current | boolean
error | string
failures | number
id | string
name | string
number | string
month | string
submitted | date
year | string

---

## Find
**Get a list of all the cards added**

**Endpoint**

    POST /card/find

**Authorized User Role**

    admin

**Request Body** 

A object.


**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | A list of cards.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Card** 

An array of Card items.

Field | Type
- | -
accountId | string
current | boolean
error | string
failures | number
id | string
name | string
number | string
month | string
submitted | date
year | string

---

## Get
**Get a card by ID**

**Endpoint**

    POST /card/get

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

The requested card.

Field | Type
- | -
accountId | string
current | boolean
error | string
failures | number
id | string
name | string
number | string
month | string
submitted | date
year | string

---

## Init
**Endpoint**

    POST /card/init

**Authorized User Role**

    admin

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
current | boolean
error | string
failures | number
id | string
name | string
number | string
month | string
submitted | date
year | string

---

## Remove
**Endpoint**

    POST /card/remove

**Authorized User Role**

    owner

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

Field | Type
- | -
accountId | string
current | boolean
error | string
failures | number
id | string
name | string
number | string
month | string
submitted | date
year | string

---

## UpdateCurrent
**Endpoint**

    POST /card/updateCurrent

**Authorized User Role**

    owner

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
current | boolean | 

**Response** 

Field | Type
- | -
accountId | string
current | boolean
error | string
failures | number
id | string
name | string
number | string
month | string
submitted | date
year | string

---

## GetStripe
**Endpoint**

    POST /card/getStripe

**Authorized User Role**

    admin

**Request Body** 

A object.


**Response** 

A stripe token.

Field | Type
- | -
0 | any
1 | any
2 | any
3 | any
4 | any
5 | any

# Manager

Device Manager UI.

---

## CheckDomain
**Endpoint**

    POST /manager/checkDomain

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
domain | string | yes

**Response** 

A boolean.


---

## Create
**Create a device manager**

This call created a device manager object. This must be paired with a cloud object using the same ID.

**Endpoint**

    POST /manager/create

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
app | string
cloudId | string
domain | string
logo | string
name | string
region | string
title | string
version | string

**Response** 

A manager object.

Field | Type
- | -
accountId | string
app | string
logo | string
certArn | string
cloudFront | string
cloudId | string
distributionId | string
domain | string
error | string
id | string
name | string
priorDomain | string
provisioned | date
region | string
title | string
type | string
version | string

---

## Find
**Get a list of device managers**

**Endpoint**

    POST /manager/find

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
id | string

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | A list of cloud records.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Manager** 

An array of Manager items.

Field | Type
- | -
accountId | string
app | string
logo | string
certArn | string
cloudFront | string
cloudId | string
distributionId | string
domain | string
error | string
id | string
name | string
priorDomain | string
provisioned | date
region | string
title | string
type | string
version | string

---

## Get
**Get a manager object**

**Endpoint**

    POST /manager/get

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

A manager object.

Field | Type
- | -
accountId | string
app | string
logo | string
certArn | string
cloudFront | string
cloudId | string
distributionId | string
domain | string
error | string
id | string
name | string
priorDomain | string
provisioned | date
region | string
title | string
type | string
version | string

---

## Init
**Endpoint**

    POST /manager/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

A manager object.

Field | Type
- | -
accountId | string
app | string
logo | string
certArn | string
cloudFront | string
cloudId | string
distributionId | string
domain | string
error | string
id | string
name | string
priorDomain | string
provisioned | date
region | string
title | string
type | string
version | string

---

## Provision
**Endpoint**

    POST /manager/provision

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
assets | object | 

**Query String Options** 

Field | Type
- | -
invoke | string

---

## ProvisionAsync
**Endpoint**

    POST /manager/provisionAsync

**Authorized User Role**

    service

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
accountId | string | yes
assets | object | 

---

## Remove
**Endpoint**

    POST /manager/remove

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Query String Options** 

Field | Type
- | -
invoke | string

---

## RemoveAsync
**Endpoint**

    POST /manager/removeAsync

**Authorized User Role**

    service

**Request Body** 

Field | Type | Required
- | - | -
accountId | string | yes
id | string | yes

---

## Update
**Endpoint**

    POST /manager/update

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
app | string
cloudId | string
domain | string
id | string
logo | string
name | string
priorDomain | string
region | string
title | string
version | string

**Response** 

A manager object.

Field | Type
- | -
accountId | string
app | string
logo | string
certArn | string
cloudFront | string
cloudId | string
distributionId | string
domain | string
error | string
id | string
name | string
priorDomain | string
provisioned | date
region | string
title | string
type | string
version | string

---

## GetSignedUrl
**Endpoint**

    POST /manager/getSignedUrl

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
id | string
clean | boolean
filename | string
mimeType | string

**Response** 

A signed URL string.


# Usage

Manage usage metrics.

---

## Get
**Endpoint**

    POST /usage/get

**Authorized User Role**

    support

**Request Body** 

A object.


**Response** 

Field | Type
- | -
* | any

# Invoice

Manage Invoices.

---

## Download
**Endpoint**

    POST /invoice/download

**Authorized User Role**

    owner

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

A PDF binary string.


---

## Get
**Endpoint**

    POST /invoice/get

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

Field | Type
- | -
accountId | string
amount | number
date | date
description | string
due | date
items | array
id | string
memo | string
nextReminder | date
number | string
order | string
paid | number
pdf | string
receipt | string
submitted | date
tax | number
terms | number
total | number

---

## Find
**Endpoint**

    POST /invoice/find

**Authorized User Role**

    admin

**Request Body** 

A object.


**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | A list of cloud records.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Invoice** 

An array of Invoice items.

Field | Type
- | -
accountId | string
amount | number
date | date
description | string
due | date
items | array
id | string
memo | string
nextReminder | date
number | string
order | string
paid | number
pdf | string
receipt | string
submitted | date
tax | number
terms | number
total | number

---

## FindOutstanding
**Endpoint**

    POST /invoice/findOutstanding

**Authorized User Role**

    owner

**Request Body** 

A object.


**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Field | Type
- | -
accountId | string
amount | number
date | date
description | string
due | date
items | array
id | string
memo | string
nextReminder | date
number | string
order | string
paid | number
pdf | string
receipt | string
submitted | date
tax | number
terms | number
total | number

---

## Init
**Endpoint**

    POST /invoice/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
amount | number
date | date
description | string
due | date
items | array
id | string
memo | string
nextReminder | date
number | string
order | string
paid | number
pdf | string
receipt | string
submitted | date
tax | number
terms | number
total | number

---

## Quote
**Endpoint**

    POST /invoice/quote

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
bill | object | yes

**Response** 

A PDF binary string.


---

## Reissue
**Endpoint**

    POST /invoice/reissue

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

A PDF binary string.


---

## UpdateMemo
**Endpoint**

    POST /invoice/updateMemo

**Authorized User Role**

    support

**Request Body** 

Field | Type | Required
- | - | -
accountId | string | yes
id | string | yes
memo | string | 

**Response** 

Field | Type
- | -
accountId | string
amount | number
date | date
description | string
due | date
items | array
id | string
memo | string
nextReminder | date
number | string
order | string
paid | number
pdf | string
receipt | string
submitted | date
tax | number
terms | number
total | number

---

## UpdateReminder
**Endpoint**

    POST /invoice/updateReminder

**Authorized User Role**

    support

**Request Body** 

Field | Type | Required
- | - | -
accountId | string | yes
id | string | yes
nextReminder | date | 

**Response** 

Field | Type
- | -
accountId | string
amount | number
date | date
description | string
due | date
items | array
id | string
memo | string
nextReminder | date
number | string
order | string
paid | number
pdf | string
receipt | string
submitted | date
tax | number
terms | number
total | number

---

## UpdateReceived
**Endpoint**

    POST /invoice/updateReceived

**Authorized User Role**

    support

**Request Body** 

Field | Type | Required
- | - | -
accountId | string | yes
id | string | yes
received | number | 

**Response** 

Field | Type
- | -
accountId | string
amount | number
date | date
description | string
due | date
items | array
id | string
memo | string
nextReminder | date
number | string
order | string
paid | number
pdf | string
receipt | string
submitted | date
tax | number
terms | number
total | number

# Account

Manage Account.

---

## Aaaa
**Endpoint**

    POST /account/aaaa

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
id | string

**Response** 

A string.


---

## Create
**Create an account**

Create an account and initial user.

**Endpoint**

    POST /account/create

**Authorized User Role**

    public

**Request Body** 

Field | Type | Required
- | - | -
email | string | yes
name | string | yes

**Response** 

Field | Type
- | -
account | Account
user | User

**Account** 

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number



**User** 

Field | Type
- | -
accountId | string
activity | date
email | string
first | string
id | string
invite | string
last | string
preferences | object
role | string
state | string


---

## Close
**Close account**

Close an account and remove all allocated resources. This operation cannot be reversed.

**Endpoint**

    POST /account/close

**Authorized User Role**

    owner

**Request Body** 

Field | Type | Role
- | - | -
id | string | support

---

## Get
**Get account**

Get an account given the account ID.

**Endpoint**

    POST /account/get

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
id | string
email | string

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number


---

## GetID
**Endpoint**

    POST /account/getID

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
size | number

**Response** 

A string.


---

## Find
**Endpoint**

    POST /account/find

**Authorized User Role**

    support

**Request Body** 

Field | Type
- | -
id | string
email | string

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | Array of items.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Account** 

An array of Account items.

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number


---

## Init
**Endpoint**

    POST /account/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

An empty account object.

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number


---

## Make
**Endpoint**

    POST /account/make

**Authorized User Role**

    support

**Request Body** 

A object.


**Response** 

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number


---

## Remove
**Endpoint**

    POST /account/remove

**Authorized User Role**

    support

**Request Body** 

Field | Type
- | -
id | string
email | string

---

## Suspend
**Endpoint**

    POST /account/suspend

**Authorized User Role**

    support

**Request Body** 

Field | Type
- | -
id | string
suspended | boolean

**Response** 

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number


---

## UpdateBilling
**Update account billing details**

**Endpoint**

    POST /account/updateBilling

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
address | string | 
company | string | 
country | string | 
invoiceEmail | string | 
order | string | 
subject | string | 

**Response** 

An account object.

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number


---

## UpdateIdentity
**Update account name and email**

**Endpoint**

    POST /account/updateIdentity

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
email | string | 
name | string | 

**Response** 

An account object.

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number


---

## UpdateMetrics
**Update account metrics**

**Endpoint**

    POST /account/updateMetrics

**Authorized User Role**

    support

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
metrics | object | yes

**Response** 

An account object.

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number


---

## UpdatePayment
**Update account payment information**

**Endpoint**

    POST /account/updatePayment

**Authorized User Role**

    support

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
agreement | boolean | 
canWire | boolean | 
credit | number | 
renew | date | 
renewing | boolean | 
terms | number | 
wire | boolean | 

**Response** 

An account object.

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number


# Software

Software update management.

---

## Create
**Endpoint**

    POST /software/create

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required | Default
- | - | - | -
attachment | object | yes | 
cloudId | string | yes | 
description | string | yes | 
enable | boolean |  | true
image | string |  | 
policy | string |  | 
productId | string | yes | 
size | number |  | 
version | string | yes | 
url | string |  | 

**Response** 

Field | Type
- | -
accountId | string
checksum | string
cloudId | string
description | string
id | string
enable | boolean
image | string
productId | string
policy | string
size | number
url | string
version | string

---

## Find
**Endpoint**

    POST /software/find

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
productId | string

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | An array of metrics each containing an array of metric with the following properties.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Software** 

An array of Software items.

Field | Type
- | -
accountId | string
checksum | string
cloudId | string
description | string
id | string
enable | boolean
image | string
productId | string
policy | string
size | number
url | string
version | string

---

## Get
**Endpoint**

    POST /software/get

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

Field | Type
- | -
accountId | string
checksum | string
cloudId | string
description | string
id | string
enable | boolean
image | string
productId | string
policy | string
size | number
url | string
version | string

---

## Init
**Endpoint**

    POST /software/init

**Authorized User Role**

    admin

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
checksum | string
cloudId | string
description | string
id | string
enable | boolean
image | string
productId | string
policy | string
size | number
url | string
version | string

---

## Remove
**Endpoint**

    POST /software/remove

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

---

## Update
**Endpoint**

    POST /software/update

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
attachment | object | 
cloudId | string | 
description | string | 
enable | boolean | 
image | string | 
id | string | yes
productId | string | 
policy | string | 
size | number | 
version | string | 
url | string | 

**Response** 

Field | Type
- | -
accountId | string
checksum | string
cloudId | string
description | string
id | string
enable | boolean
image | string
productId | string
policy | string
size | number
url | string
version | string

# Issue

Manage Issues.

---

## Create
**Endpoint**

    POST /issue/create

**Authorized User Role**

    support

**Request Body** 

Field | Type
- | -
attachments | array
cve | string
date | date
description | string
impacted | string
notify | boolean
priority | string
public | boolean
recommend | string
release | string
status | string
subject | string
tags | array
title | string
type | string

**Response** 

An issue object.

Field | Type
- | -
attachments | array
cve | string
date | date
description | string
id | string
impacted | string
notify | boolean
priority | string
public | boolean
recommend | string
release | string
status | string
subject | string
tags | array
title | string
type | string

---

## Get
**Endpoint**

    POST /issue/get

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
id | string

**Response** 

An issue object.

Field | Type
- | -
attachments | array
cve | string
date | date
description | string
id | string
impacted | string
notify | boolean
priority | string
public | boolean
recommend | string
release | string
status | string
subject | string
tags | array
title | string
type | string

---

## Find
**Endpoint**

    POST /issue/find

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
public | boolean
subject | string

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | A list of cloud records.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Issue** 

An array of Issue items.

Field | Type
- | -
attachments | array
cve | string
date | date
description | string
id | string
impacted | string
notify | boolean
priority | string
public | boolean
recommend | string
release | string
status | string
subject | string
tags | array
title | string
type | string

---

## Init
**Endpoint**

    POST /issue/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

An issue object.

Field | Type
- | -
attachments | array
cve | string
date | date
description | string
id | string
impacted | string
notify | boolean
priority | string
public | boolean
recommend | string
release | string
status | string
subject | string
tags | array
title | string
type | string

---

## NotifyAsync
**Endpoint**

    POST /issue/notifyAsync

**Authorized User Role**

    service

**Request Body** 

Field | Type
- | -
issue | object

---

## Remove
**Endpoint**

    POST /issue/remove

**Authorized User Role**

    support

**Request Body** 

Field | Type
- | -
id | string
subject | string

---

## Update
**Endpoint**

    POST /issue/update

**Authorized User Role**

    support

**Request Body** 

Field | Type
- | -
attachments | array
cve | string
date | date
description | string
id | string
impacted | string
notify | boolean
priority | string
public | boolean
recommend | string
release | string
status | string
subject | string
tags | array
title | string
type | string

**Response** 

Field | Type
- | -
attachments | array
cve | string
date | date
description | string
id | string
impacted | string
notify | boolean
priority | string
public | boolean
recommend | string
release | string
status | string
subject | string
tags | array
title | string
type | string

# Token

Manage Access Tokens.

---

## Action
**Endpoint**

    POST /token/action

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
action | string
ids | array

---

## Create
**Endpoint**

    POST /token/create

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
cloudId | string
description | string
enable | boolean
expires | date
role | string
type | string

**Response** 

Field | Type
- | -
accountId | string
cloudId | string
description | string
enable | boolean
expires | date
id | string
owner | string
role | string
type | string

---

## Get
**Endpoint**

    POST /token/get

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
cloudId | string | 
owner | string | 
type | string | 

**Response** 

Field | Type
- | -
accountId | string
cloudId | string
description | string
enable | boolean
expires | date
id | string
owner | string
role | string
type | string

---

## Find
**Endpoint**

    POST /token/find

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
id | string
cloudId | string
owner | string
type | string

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | A token object.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Token** 

An array of Token items.

Field | Type
- | -
accountId | string
cloudId | string
description | string
enable | boolean
expires | date
id | string
owner | string
role | string
type | string

---

## Init
**Endpoint**

    POST /token/init

**Authorized User Role**

    admin

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
cloudId | string
description | string
enable | boolean
expires | date
id | string
owner | string
role | string
type | string

---

## Remove
**Endpoint**

    POST /token/remove

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
cloudId | string
id | string

---

## Update
**Endpoint**

    POST /token/update

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
cloudId | string
description | string
enable | boolean
expires | date
id | string
role | string
type | string

**Response** 

Field | Type
- | -
accountId | string
cloudId | string
description | string
enable | boolean
expires | date
id | string
owner | string
role | string
type | string

# Cloud

Manage Device Clouds.

---

## Create
**Create a device cloud**

This call created a device cloud object in preparation for running an<br>                              AWS CloudFormation template to create the required device cloud resources<br>                              in the target AWS account.

**Endpoint**

    POST /cloud/create

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
enable | boolean
error | string
external | string
iotPolicy | string
name | string
open | boolean
region | string
schema | object
shadows | boolean
sync | boolean
type | string

**Response** 

A cloud object.

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

---

## Find
**Get a list of device clouds**

**Endpoint**

    POST /cloud/find

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
id | string

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | A list of cloud records.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Cloud** 

An array of Cloud items.

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

---

## Get
**Get a cloud object**

**Endpoint**

    POST /cloud/get

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

A cloud object.

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

---

## GetBrowserKeys
**Get temporary AWS IAM credentials for use in the browser**

**Endpoint**

    POST /cloud/getBrowserKeys

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

Temporary AWS cloud credentials for access to the device cloud AWS account.

Field | Type
- | -
accessKeyId | string
secretAccessKey | string
sessionToken | string
expires | date
region | string

---

## Init
**Endpoint**

    POST /cloud/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

---

## Provision
**Endpoint**

    POST /cloud/provision

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Query String Options** 

Field | Type
- | -
invoke | string

**Response** 

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

---

## ProvisionAsync
**Endpoint**

    POST /cloud/provisionAsync

**Authorized User Role**

    service

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
accountId | string | yes

**Response** 

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

---

## Remove
**Endpoint**

    POST /cloud/remove

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Query String Options** 

Field | Type
- | -
invoke | string

---

## RemoveAsync
**Endpoint**

    POST /cloud/removeAsync

**Authorized User Role**

    service

**Request Body** 

Field | Type | Required
- | - | -
accountId | string | yes
id | string | yes

---

## UpdateStack
**Endpoint**

    POST /cloud/updateStack

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

---

## WaitForTemplate
**Endpoint**

    POST /cloud/waitForTemplate

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes

**Response** 

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

---

## GetHosts
**Endpoint**

    POST /cloud/getHosts

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
open | boolean
region | string

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | A list of cloud records.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Host** 

An array of Host items.

Field | Type
- | -
name | string
region | string

---

## Connect
**Pass IAM Role from device cloud back to the builer when the CFT completes**

**Endpoint**

    POST /cloud/connect

**Authorized User Role**

    cloud

**Request Body** 

Field | Type
- | -
api | string
awsAccount | string
cloud | string
deviceRole | string
connected | boolean
error | string
external | string
roleArn | string
stack | string
token | object
version | string

**Response** 

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

---

## Report
**Report monthly device usage from a device cloud to the builder**

**Endpoint**

    POST /cloud/report

**Authorized User Role**

    cloud

**Request Body** 

Field | Type
- | -
accountId | string
count | number
cloudId | string
load | number
usage | array

**Usage** 

An array of Usage items.

Field | Type
- | -
devices | number
tenants | number
load | number


---

## Update
**Endpoint**

    POST /cloud/update

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
attachments | object
deviceRole | string
enable | boolean
erase | object
error | string
external | string
id | string
iotPolicy | string
name | string
open | boolean
region | string
schema | object
shadows | boolean
sync | boolean
type | string

**Response** 

A cloud object.

Field | Type
- | -
accountId | string
api | string
apiGateway | string
awsAccount | string
connected | boolean
deviceRole | string
devices | number
enable | boolean
error | string
host | string
hubs | number
id | string
iotPolicy | string
load | number
name | string
open | boolean
planId | string
provisioned | date
quota | object
region | string
schema | object
shadows | boolean
stack | string
status | string
suspended | boolean
sync | boolean
tenants | number
trailBucket | string
type | string
version | number
userPoolId | string
userPoolClient | string

# Post

Support case post management.

---

## Create
**Endpoint**

    POST /post/create

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required | Default | Role
- | - | - | - | -
accountId | string |  |  | support
attachments | array |  |  | 
author | string |  |  | 
message | string |  |  | 
ticketId | string | yes |  | 

**Response** 

Field | Type
- | -
accountId | string
attachments | array
author | string
message | string
id | string
ticketId | string

---

## Download
**Endpoint**

    POST /post/download

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required | Role
- | - | - | -
accountId | string |  | support
id | string | yes | 
key | string | yes | 

**Response** 

A download URL.


---

## Find
**Endpoint**

    POST /post/find

**Authorized User Role**

    user

**Request Body** 

Field | Type | Role
- | - | -
accountId | string | support
id | string | 
ticketId | string | 

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | An array of metrics each containing an array of metric with the following properties.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Post** 

An array of Post items.

Field | Type
- | -
accountId | string
attachments | array
author | string
message | string
id | string
ticketId | string

---

## Get
**Endpoint**

    POST /post/get

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
ticketId | string | 

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Field | Type
- | -
accountId | string
attachments | array
author | string
message | string
id | string
ticketId | string

---

## Init
**Endpoint**

    POST /post/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
attachments | array
author | string
message | string
id | string
ticketId | string

---

## Remove
**Endpoint**

    POST /post/remove

**Authorized User Role**

    support

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
accountId | string | yes
ticketId | string | yes

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

# Ticket

Support case management.

---

## Create
**Endpoint**

    POST /ticket/create

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required | Role
- | - | - | -
assigned | string |  | support
cc | string |  | 
productId | string |  | 
subject | string | yes | 
severity | string | yes | 
status | string | yes | 
updated | date | yes | 

**Response** 

Field | Type
- | -
accountId | string
assigned | string
cc | string
hours | number
id | string
productId | string
subject | string
severity | string
status | string
updated | date
work | array

**Work** 

An array of Work items.

Field | Type
- | -
date | date
description | string
hours | number


---

## Get
**Endpoint**

    POST /ticket/get

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
id | string | yes
owner | string | 

**Response** 

Field | Type
- | -
accountId | string
assigned | string
cc | string
hours | number
id | string
productId | string
subject | string
severity | string
status | string
updated | date
work | array

**Work** 

An array of Work items.

Field | Type
- | -
date | date
description | string
hours | number


---

## Fetch
**Endpoint**

    POST /ticket/fetch

**Authorized User Role**

    support

**Request Body** 

Field | Type
- | -
status | string

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Field | Type
- | -
accountId | string
assigned | string
cc | string
hours | number
id | string
productId | string
subject | string
severity | string
status | string
updated | date
work | array

**Work** 

An array of Work items.

Field | Type
- | -
date | date
description | string
hours | number


---

## Find
**Endpoint**

    POST /ticket/find

**Authorized User Role**

    user

**Request Body** 

Field | Type | Role
- | - | -
id | string | 
accountId | string | support

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | An array of metrics each containing an array of metric with the following properties.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Ticket** 

An array of Ticket items.

Field | Type
- | -
accountId | string
assigned | string
cc | string
hours | number
id | string
productId | string
subject | string
severity | string
status | string
updated | date
work | array

**Work** 

An array of Work items.

Field | Type
- | -
date | date
description | string
hours | number


---

## Init
**Endpoint**

    POST /ticket/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
assigned | string
cc | string
hours | number
id | string
productId | string
subject | string
severity | string
status | string
updated | date
work | array

**Work** 

An array of Work items.

Field | Type
- | -
date | date
description | string
hours | number


---

## Remove
**Endpoint**

    POST /ticket/remove

**Authorized User Role**

    support

**Request Body** 

Field | Type | Role
- | - | -
id | string | 
accountId | string | support

---

## Update
**Endpoint**

    POST /ticket/update

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required | Role
- | - | - | -
accountId | string |  | support
assigned | string |  | support
cc | string |  | 
id | string | yes | 
productId | string |  | 
subject | string | yes | 
severity | string | yes | 
status | string | yes | 
updated | date | yes | 

**Response** 

Field | Type
- | -
accountId | string
assigned | string
cc | string
hours | number
id | string
productId | string
subject | string
severity | string
status | string
updated | date
work | array

**Work** 

An array of Work items.

Field | Type
- | -
date | date
description | string
hours | number


---

## UpdateWorked
**Endpoint**

    POST /ticket/updateWorked

**Authorized User Role**

    support

**Request Body** 

Field | Type | Required
- | - | -
accountId | string | yes
id | string | yes
description | string | yes
hours | number | yes

**Response** 

Field | Type
- | -
accountId | string
assigned | string
cc | string
hours | number
id | string
productId | string
subject | string
severity | string
status | string
updated | date
work | array

**Work** 

An array of Work items.

Field | Type
- | -
date | date
description | string
hours | number


# Plan

Subscription plan management.

---

## Create
**Endpoint**

    POST /plan/create

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Role
- | - | -
agent | string | 
current | string | support
end | date | 
interest | array | 
meter | boolean | 
pending | boolean | 
period | string | 
scope | string | 
start | date | 
type | string | 
units | number | 

**Response** 

Field | Type
- | -
accountId | string
id | string
adjustments | array
advance | boolean
agent | string
align | boolean
current | object
discount | number
end | date
fixed | boolean
interest | array
lastBilled | date
meter | boolean
memo | string
nextReminder | date
notify | array
override | object
pending | boolean
period | string
prepay | boolean
purchases | array
start | date
scope | string
sliding | boolean
test | number
type | string
units | number

**Current** 

Field | Type
- | -
end | date
start | date
period | string
price | number
scope | string
units | number
upfront | number


**Purchases** 

An array of Purchases items.

Field | Type
- | -
date | date
units | number
expired | number


---

## Get
**Endpoint**

    POST /plan/get

**Authorized User Role**

    user

**Request Body** 

Field | Type | Role
- | - | -
accountId | string | support
id | string | 
type | string | 

**Response** 

Field | Type
- | -
accountId | string
id | string
adjustments | array
advance | boolean
agent | string
align | boolean
current | object
discount | number
end | date
fixed | boolean
interest | array
lastBilled | date
meter | boolean
memo | string
nextReminder | date
notify | array
override | object
pending | boolean
period | string
prepay | boolean
purchases | array
start | date
scope | string
sliding | boolean
test | number
type | string
units | number

**Current** 

Field | Type
- | -
end | date
start | date
period | string
price | number
scope | string
units | number
upfront | number


**Purchases** 

An array of Purchases items.

Field | Type
- | -
date | date
units | number
expired | number


---

## Init
**Endpoint**

    POST /plan/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
id | string
adjustments | array
advance | boolean
agent | string
align | boolean
current | object
discount | number
end | date
fixed | boolean
interest | array
lastBilled | date
meter | boolean
memo | string
nextReminder | date
notify | array
override | object
pending | boolean
period | string
prepay | boolean
purchases | array
start | date
scope | string
sliding | boolean
test | number
type | string
units | number

**Current** 

Field | Type
- | -
end | date
start | date
period | string
price | number
scope | string
units | number
upfront | number


**Purchases** 

An array of Purchases items.

Field | Type
- | -
date | date
units | number
expired | number


---

## Find
**Endpoint**

    POST /plan/find

**Authorized User Role**

    user

**Request Body** 

Field | Type | Role
- | - | -
accountId | string | support
type | string | 

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | An array of metrics each containing an array of metric with the following properties.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Plan** 

An array of Plan items.

Field | Type
- | -
accountId | string
id | string
adjustments | array
advance | boolean
agent | string
align | boolean
current | object
discount | number
end | date
fixed | boolean
interest | array
lastBilled | date
meter | boolean
memo | string
nextReminder | date
notify | array
override | object
pending | boolean
period | string
prepay | boolean
purchases | array
start | date
scope | string
sliding | boolean
test | number
type | string
units | number

**Current** 

Field | Type
- | -
end | date
start | date
period | string
price | number
scope | string
units | number
upfront | number


**Purchases** 

An array of Purchases items.

Field | Type
- | -
date | date
units | number
expired | number


---

## Remove
**Endpoint**

    POST /plan/remove

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
id | string

**Response** 

Field | Type
- | -
accountId | string
id | string
adjustments | array
advance | boolean
agent | string
align | boolean
current | object
discount | number
end | date
fixed | boolean
interest | array
lastBilled | date
meter | boolean
memo | string
nextReminder | date
notify | array
override | object
pending | boolean
period | string
prepay | boolean
purchases | array
start | date
scope | string
sliding | boolean
test | number
type | string
units | number

**Current** 

Field | Type
- | -
end | date
start | date
period | string
price | number
scope | string
units | number
upfront | number


**Purchases** 

An array of Purchases items.

Field | Type
- | -
date | date
units | number
expired | number


---

## Update
**Endpoint**

    POST /plan/update

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Role
- | - | -
accountId | string | support
align | boolean | 
current | object | support
end | date | 
id | string | 
interest | array | 
hours | number | support
meter | boolean | 
nextReminder | date | 
pending | boolean | 
prepay | boolean | 
period | string | 
scope | string | 
start | date | 
type | string | 
units | number | 

**Response** 

Field | Type
- | -
accountId | string
id | string
adjustments | array
advance | boolean
agent | string
align | boolean
current | object
discount | number
end | date
fixed | boolean
interest | array
lastBilled | date
meter | boolean
memo | string
nextReminder | date
notify | array
override | object
pending | boolean
period | string
prepay | boolean
purchases | array
start | date
scope | string
sliding | boolean
test | number
type | string
units | number

**Current** 

Field | Type
- | -
end | date
start | date
period | string
price | number
scope | string
units | number
upfront | number


**Purchases** 

An array of Purchases items.

Field | Type
- | -
date | date
units | number
expired | number


# User

User management.

---

## Create
**Create a new user**

**Endpoint**

    POST /user/create

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Required
- | - | -
email | string | yes
role | string | yes
sendInvite | boolean | 

**Response** 

Field | Type
- | -
accountId | string
activity | date
email | string
first | string
id | string
invite | string
last | string
preferences | object
role | string
state | string

---

## Comment
**Endpoint**

    POST /user/comment

**Authorized User Role**

    user

**Request Body** 

Field | Type | Required
- | - | -
subject | string | yes
url | string | yes
comments | string | yes
email | string | yes
account | string | yes

---

## Get
**Endpoint**

    POST /user/get

**Authorized User Role**

    user

**Request Body** 

Field | Type | Role
- | - | -
email | string | admin
id | string | admin

**Response** 

Field | Type
- | -
accountId | string
activity | date
email | string
first | string
id | string
invite | string
last | string
preferences | object
role | string
state | string

---

## Find
**Endpoint**

    POST /user/find

**Authorized User Role**

    user

**Request Body** 

Field | Type | Role
- | - | -
email | string | admin
id | string | admin

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | A token object.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**User** 

An array of User items.

Field | Type
- | -
accountId | string
activity | date
email | string
first | string
id | string
invite | string
last | string
preferences | object
role | string
state | string

---

## Init
**Endpoint**

    POST /user/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
activity | date
email | string
first | string
id | string
invite | string
last | string
preferences | object
role | string
state | string

---

## Login
**Login the authenticated user**

**Endpoint**

    POST /user/login

**Authorized User Role**

    public

**Request Body** 

Field | Type
- | -
invite | string

**Response** 

A user object.

Field | Type
- | -
account | object
cache | object
user | object
versions | object

---

## LookupUser
**Endpoint**

    POST /user/lookupUser

**Authorized User Role**

    support

**Request Body** 

Field | Type | Required
- | - | -
email | string | yes

**Response** 

A string.


---

## Jobs
**Endpoint**

    POST /user/jobs

**Authorized User Role**

    public

**Request Body** 

Field | Type | Required
- | - | -
details | object | yes

---

## Prefetch
**Endpoint**

    POST /user/prefetch

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Prefetched account and user objects.

Field | Type
- | -
account | object
user | object
cache | object
local | boolean
versions | object

**Account** 

Field | Type
- | -
activity | date
billing | object
closed | boolean
created | date
email | string
id | string
metrics | object
name | string
suspended | boolean

**Billing** 

Field | Type
- | -
address | string
agreement | boolean
cardId | string
canWire | boolean
company | string
country | string
credit | number
error | string
invoiceEmail | string
memo | string
order | string
renew | date
renewing | boolean
stripeId | string
subject | string
terms | number
wire | boolean


**Metrics** 

Field | Type
- | -
agents | array
balance | number
connected | number
clouds | number
customer | boolean
dashboards | number
devices | number
developer | number
emails | object
interest | array
notifications | number
plans | number
products | number
software | number
support | number
users | number



**User** 

Field | Type
- | -
accountId | string
activity | date
email | string
first | string
id | string
invite | string
last | string
preferences | object
role | string
state | string


---

## Remove
**Endpoint**

    POST /user/remove

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
email | string
id | string

---

## Update
**Update a user identity**

**Endpoint**

    POST /user/update

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
email | string
first | string
id | string
last | string
preferences | object

**Response** 

Field | Type
- | -
accountId | string
activity | date
email | string
first | string
id | string
invite | string
last | string
preferences | object
role | string
state | string

---

## UpdateRole
**Endpoint**

    POST /user/updateRole

**Authorized User Role**

    admin

**Request Body** 

Field | Type | Role
- | - | -
id | string | 
role | string | admin
sendInvite | boolean | 

**Response** 

Field | Type
- | -
accountId | string
activity | date
email | string
first | string
id | string
invite | string
last | string
preferences | object
role | string
state | string

# Test

Create test data.

---

## Data
**Endpoint**

    POST /test/data

**Authorized User Role**

    support

**Request Body** 

A object.


**Response** 

A object.


---

## Find
**Endpoint**

    POST /test/find

**Authorized User Role**

    support

**Request Body** 

A object.


**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

A object.


---

## Exception
**Endpoint**

    POST /test/exception

**Authorized User Role**

    public

**Request Body** 

A object.


**Response** 

A object.


---

## Success
**Endpoint**

    POST /test/success

**Authorized User Role**

    public

**Request Body** 

A object.


**Response** 

A object.


---

## Echo
**Endpoint**

    POST /test/echo

**Authorized User Role**

    public

**Request Body** 

Field | Type
- | -
* | any

**Response** 

A object.


# Notification

Manage User Notification Channels.

---

## Create
**Endpoint**

    POST /notification/create

**Authorized User Role**

    support

**Request Body** 

Field | Type | Required
- | - | -
channel | string | 
data | string | 
destination | string | 
enable | boolean | 
format | string | 
headers | object | 
method | string | 
name | string | yes
region | string | 

**Response** 

Field | Type
- | -
accountId | string
channel | string
data | string
destination | string
enable | boolean
format | string
headers | object
id | string
method | string
name | string
region | string

---

## Find
**Endpoint**

    POST /notification/find

**Authorized User Role**

    user

**Request Body** 

Field | Type
- | -
type | string

**Query String Options** 

Field | Type
- | -
hidden | boolean
filter | string
limit | number
next | object
prev | object
index | string
where | string
log | boolean

**Response** 

Paged response.

Field | Type | Notes
- | - | -
data | array | An array of metrics each containing an array of metric with the following properties.
next | string | Paged cursor to use for the next page of items.
prev | string | Pages cursor to use for the previous page of items.

**Notification** 

An array of Notification items.

Field | Type
- | -
accountId | string
channel | string
data | string
destination | string
enable | boolean
format | string
headers | object
id | string
method | string
name | string
region | string

---

## Get
**Endpoint**

    POST /notification/get

**Authorized User Role**

    admin

**Request Body** 

Field | Type
- | -
id | string

**Response** 

Field | Type
- | -
accountId | string
channel | string
data | string
destination | string
enable | boolean
format | string
headers | object
id | string
method | string
name | string
region | string

---

## Init
**Endpoint**

    POST /notification/init

**Authorized User Role**

    user

**Request Body** 

A object.


**Response** 

Field | Type
- | -
accountId | string
channel | string
data | string
destination | string
enable | boolean
format | string
headers | object
id | string
method | string
name | string
region | string

---

## Remove
**Endpoint**

    POST /notification/remove

**Authorized User Role**

    support

**Request Body** 

Field | Type
- | -
id | string

---

## Update
**Endpoint**

    POST /notification/update

**Authorized User Role**

    support

**Request Body** 

Field | Type
- | -
channel | string
data | string
destination | string
enable | boolean
format | string
headers | object
id | string
method | string
name | string
region | string

**Response** 

Field | Type
- | -
accountId | string
channel | string
data | string
destination | string
enable | boolean
format | string
headers | object
id | string
method | string
name | string
region | string

# Notice

Manage User Notice Bulletins.

---

## Get
**Endpoint**

    POST /notice/get

**Authorized User Role**

    support

**Request Body** 

A object.


**Response** 

Field | Type
- | -
id | string
info | object
maintenance | object
start | date
end | date

# Device

The Device API manages device registation with the Builder.<br><br>When devices are first booted, they will "register" with the builder using their device ID (ClaimID). The device then remains under the management of the Builder until it is "claimed" by a user for management using the "claim" API.<br><br>When claimed, the device is redirected to the device cloud when it next invokes the "register" API.

## Get
The Get API will fetch a device record by its ID (ClaimID).

**Endpoint**

```HTTP
POST /device/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device Claim ID. |

**Response** 

| Field | Type |
| - | - |
| id | string |
| accountId | string |
| managerAccountId | string |
| cloudId | string |
| productId | string |
| test | boolean |

## Find
**Endpoint**

```HTTP
POST /device/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| cloudId | string |
| productId | string |

**Query String Options** 

| Field | Type |
| - | - |
| limit | number |
| next | object |
| prev | object |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Device** 

An array of Device items.

| Field | Type |
| - | - |
| id | string |
| accountId | string |
| managerAccountId | string |
| cloudId | string |
| productId | string |
| test | boolean |

## Register
Register a device when manufactured.<br><br>When devices are first booted during manufacturing test, the Ioto device agent will "register" with the builder using its device ID (ClaimID). If the device has been claimed by a user, the API will return a response containing the API address of the managing device cloud and an access token. If the device has not been claimed, the "registered" field will be set to true in the response (alone).<br><br>To register, supply the device claim ID and the product token ID. If the device is a test device only, set the "test" field to true<br>so that the device will not count toward your Ioto agent subscription count.<br>.

**Endpoint**

```HTTP
POST /device/register

```
**Authorized User Role**

```
public

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device Claim ID. |
| account | string |  | Manager Account ID if auto claiming. |
| cloud | string |  | Cloud ID if auto claiming. |
| product | string | yes | Product ID Token. |
| test | boolean |  | Set to true for test devices. |
| * | any |  |  |

**Response** 

| Field | Type | Notes |
| - | - | - |
| api | string | API endpoint for the device cloud that claimed the device. |
| token | string | Access token for requests to the device cloud. |
| registered | boolean | Set to true when registered. |
| cloudType | string | Type of cloud hosting. |
| cloudName | string | Cloud name. |
| cloudRegion | string | Cloud geographical region. |

## Release
Release a device from management by a device cloud<br><br>Releasing a device returns it to the builder to be available for claiming by another cloud.

**Endpoint**

```HTTP
POST /device/release

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |
| callback | boolean |  |  |
| certArn | string |  |  |

## Remove
Remove a device from the builder.<br><br>If the device has been claimed by a device cloud, it should be released before being removed.

**Endpoint**

```HTTP
POST /device/remove

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |


![Ioto](/images/logos/ioto-reg.png)

# EmbedThis Ioto&reg;

>**The smallest, fastest, most capable device agent**

The Ioto agent is our newest embedded agent for device management. It includes a HTTP web server, AWS IoT cloud integration, embedded database, MQTT client, HTTP client, JSON parsing, easy provisioning and OTA upgrading.

Ioto is cloud ready — just bring your own AWS cloud account. Ioto provides data synchronization to AWS IoT core, rules, and shadows. It exports and synchronizes structured device data with AWS DynamoDB. It also captures logs into CloudWatch Logs, integrates with CloudWatch Metrics, and offers data and file upload to AWS S3.

## Stand-alone Device Management

If you only want an embedded web server, Ioto is easily configured to enable just the modules you need. You can configure Ioto to include only the web server, or just the MQTT protocol or full cloud management integration.

## Highly Optimized

Ioto is blazing fast and yet has a tiny memory footprint of only 200K of code. It is especially effective in reducing per-request CPU and memory overhead.

Ioto is optimized for embedded device management via an evolved, high performance management runtime that delivers exceptional throughput and effective memory utilization.

## Elegant Programming Model

Ioto eliminates the ugliness of event callbacks and the complexity of threads by using fiber coroutines.
This makes programming with Ioto simple and reliable and avoids difficult downstream debugging due to overly complex designs.

## Extensive Features

Ioto has a strong set of features and protocols, including: MQTT, HTTP/1, TLS/SSL, user authentication, embedded database, JSON parser and query engine, JSON config files, sandbox resource limits, flexible logging, request tracing, and extensive conditional configuration and compilation controls.

With these features, Ioto is designed to make remotely managing and controlling embedded devices painless.

It is ideal for Linux and FreeRTOS systems and is easily ported to other platforms. Ioto dramatically cuts the time, cost, and risk of creating manageability for devices.


## Deployed Widely

Ioto draws from our code base at Embedthis, where we have decades of experience in providing the most widely deployed embedded web servers. Our software has been deployed in hundreds of millions of devices in networking equipment, telephones, mobile devices, and consumer and office equipment worldwide.

## Applications

The Ioto Agent source distribution includes several sample management applications that are integrated with Ioto.

The management apps are browser-based [VueJS](https://vuejs.org/) apps that communicate with either the local Ioto web server or with the cloud-based Ioto service.

Name | Directory | Description
-|-|-
manager | apps/manager | Cloud-based device manager developer console for Ioto
console | apps/console | Local developer console for Ioto
kickstart | apps/kickstart | Local Kickstart sample "router" management app
empty | apps/empty | Empty application to resolve application hooks
auth | apps/auth | Test user login and authentication app
unit | apps/unit | Unit tests app

## Components

Ioto provides the following components:

* HTTP/1.1 server with dynamic rendering, authentication, cookies, sessions and file upload
* HTTP/1.1 client
* MQTT/3.1.1 client
* Embedded database
* JSON/5 parser and query engine
* Transport Layer Security (TLS/SSL) with ALPN support
* AWS IoT integration with IoT Core, Shadows, Events, and Rules.
* AWS service integration with S3, Lambda, Kinesis and CloudWatch
* Transparent database syncronization to AWS DynamoDB (like Global Tables)
* Safe, secure runtime core
* Easy provisioning
* OTA upgrading
* User authentication
* Complete documentation
* Extensive Samples
* Full Source code

# Embedthis Ioto&reg; Features

* HTTP/1.1 server with dynamic rendering, authentication, cookies, sessions and file upload.
* HTTP/1.1 client.
* MQTT/3.1.1 client.
* Embedded database (like local DynamoDB).
* Transparent DynamoDB database cloud synchronization.
* JSON/5 parser and query engine.
* AWS IoT integration with IoT Core, Shadows, Events and Rules.
* AWS service integration with S3, Lambda, Kinesis and CloudWatch.
* Transparent database synchronization with DynamoDB.
* Transport Layer Security (TLS/SSL) with ALPN support.
* Safe, secure runtime core.
* State persistence to JSON configuration files.
* Easy provisioning.
* OTA upgrading.
* Complete documentation.
* Extensive Samples.
* Full Source code.


## Feature Overview


### Management Applications

The Ioto Agent source distribution includes several sample management applications that are integrated with Ioto.

The management apps are browser-based [VueJS](https://vuejs.org/) apps that communicate with either the local Ioto web server or with the cloud-based Ioto service.

Name | Directory | Description
-|-|-
manager | apps/manager | Cloud-based device manager developer console for Ioto
console | apps/console | Local developer console for Ioto
kickstart | apps/kickstart | Local Kickstart sample "router" management app
empty | apps/empty | Empty application to resolve application hooks
auth | apps/auth | Test user login and authentication app
unit | apps/unit | Unit tests app


### AWS IoT Integration

* AWS IoT Ready &mdash; Bring your own cloud.
* Capture device data and export to AWS.
* Send control plane data to AWS IoT shadows.
* Transparent database synchronization with AWS DynamoDB.
* Stream bulk device data to AWS S3 data lake or Kinesis.
* Store device logs, metrics in AWS CloudWatch.
* Keep an audit trail in CloudTrail.


### MQTT Client

* MQTT 3.1.1 support.
* TLS encryption with ALPN over port 443.
* Supports connect, publish, subscribe, ping and disconnect messages.
* Message quality of service for reliable delivery.
* Retained messages.
* High message throughput with exceptionally low overhead.
* Wait for delivery or acknowledgement options.
* Auto reconnect.
* Parallelism via fiber coroutines.


## Embedded Database

* High performance in-memory NoSQL management document database (DynamoDB lite).
* Red/black binary search indexes.
* JSON documents with in-memory query API.
* Controllable persistence locally and to the cloud on a per-table basis.
* Transparent bidirectional data synchronization with the cloud. (like Global Tables).
* Unified data schema between device and cloud databases.
* Based on [DynamoDB OneTable](https://doc.onetable.io/) API.


### HTTP Server

* HTTP/1.0, HTTP/1.1 support.
* TLS/SSL 1.3 and ALPN support.
* URL actions that bind URLs to C functions.
* Configurable request routes and redirections.
* Supports transfer chunk encoding to preserve keep-alive.
* Cookie and session management.
* Authentication and user management.
* Request tracing for HTTP request and response headers.
* Sand-box resource limits.
* Runtime configurable via JSON config files.
* HTML helpers for encoding, decoding and escaping content.
* JSON parser and query engine.
* Single-threaded, fiber coroutine event-based runtime.


### Safe Runtime

* JSON parser and renderer.
* JSON query engine.
* Fiber coroutines for non-blocking procedural programming model.
* Global memory error handler.
* Logging framework —— filter by source and/or message type.
* Safe strings, lists, hashing and buffer management.
* Portable, cross-platform O/S abstraction.


### Performance

* Tiny memory footprint. Web server component is 25K code. Total is 96K code.
* Single-threaded fiber coroutines provide an elegant, non-blocking, procedural programming paradigm without resorting to clumsy callbacks or complex threads.
* Web server request throughput (&gt; 9,300 requests per second on Raspberry Pi 4).


### Security

* Sandbox limits.
* Safe portable runtime to protect against memory leaks and buffer overflows.
* Transport Layer Security (TLS/SSL).



### Developer Integration

* Run supplied Ioto program or embed Ioto library.
* Shared and static libraries supported.
* Easy, intuitive programming model.
* Extensive C API.


### Documentation

* Full C API Documentation.
* Cookbook of samples (cut and paste to get going).
* Tutorials.


### Platform Support

* Linux 
* MAC OS X
* FreeBSD
* FreeRTOS (pending)
* RIOT (pending)


### Embedding Support

* Supports ARM, MIPS, X86, X64, PPC, SH, Sparc processors.
* Full cross-compilation support. Use Windows, Linux or Mac as build system.
* Fine-grained control for conditional build and compilation.


### Standards

* [MQTT 3.1.1](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html)
* [RFC 2616 HTTP/1.1](https://www.ietf.org/rfc/rfc2616.txt)
* [TLS 1.3](https://datatracker.ietf.org/doc/html/rfc8446)
* [RFC 1867 Multipart-mime upload](https://datatracker.ietf.org/doc/html/rfc1867)
* [OneTable Database Schema Specification](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md)
# Embedthis Appweb&trade; and GoAhead&trade;

Our Appweb and GoAhead web servers are provided for existing customers who have existing products incorporating these web servers.

!!! Ioto Device Agent
    All new device builders are encouraged to use the Ioto device agent &mdash; even if you only need an embedded web server.

    The Ioto agent includes our most advanced embedded web server. It is a fraction the size of comparable embedded web servers (including our own) and it boast impressive throughput and efficiency scores.

For more information, please consult:

* [Device Agents Compared](https://www.embedthis.com/ioto/comparison.html)
* [Appweb Web Site](https://www.embedthis.com/appweb/)
* [Appweb Documentation](https://www.embedthis.com/appweb/doc/)
* [GoAhead Web Site](https://www.embedthis.com/goahead/)
* [GoAhead Documentation](https://www.embedthis.com/goahead/doc/)
# Creating Products

The first step when creating connected devices with the **Builder** is to define the product (device) that you wish to manage. In this process:

* Specify the product name.
* Provide a description of the product.
* Select the device agent software you wish to embed in your product.
* Choose the scope of the license you wish to purchase.
* Enter email or phone numbers to use for important security alerts.

The Builder will pre-create product definitions for to evaluate Ioto and for the Builder and Device Manager services. These definitions can be selected to display the relevant product security center information for the relevant service.

## Product Definitions

You can create product definitions for each device type that you wish to deploy and manage. The product definition describes your product, the device agent you wish to deploy, and its license scope.

![Product List](/images/builder/product-list.png){class="screen"}

A product definition includes:

* Product name
* Description
* Selected Device Agent
* License Plan
* License Type
* License Scope
* Email or phone for security alerts

![Product Add](/images/builder/product-add.png){class="screen"}

## Multiple Product Definitions

You can create one or more product definitions to best describe the (many) devices you offer.

If you are using the Ioto device agent, you should create a different product definition for each device type that will require different firmware. When you configure over-the-air software updates for your devices, it is helpful to be able to target different products with the appropriate firmware. When using OTA software upgrades, each product can have a unique firmware configuration. So you will want to configure a different Ioto product definition for each device that requires a different firmware image.

For Appweb and GoAhead based devices, you should create a product definition for each product described in your Embedthis license agreement. This may have already been created for you. If you require assistance, please contact [support@embedthis.com](mailto:support@embedthis.com).

## Product Name

The product name is a unique, one-line, descriptive name of your choosing.

## Product Description

This description is for your records and for licensing scopes. Please fully and uniquely describe your product. (Can be multiple sentences).

## Device Agent

When defining your product, you can select to embed one of three device agents:

* Ioto Device Agent
* GoAhead Web Server
* Appweb Web Server

We recommend choosing the Ioto cloud agent for all new devices, even if they are not connected to the cloud, as Ioto has the most efficient and secure embedded web server. Please read the [Web Server Comparison](https://www.embedthis.com/ioto/comparison.html) for details.

The Ioto agent includes our most advanced embedded web server. It is a fraction the size of comparable embedded web servers (including our own) and it boast impressive throughput and efficiency scores.

Our Appweb and GoAhead web servers are provided for existing customers who have embedded these web servers in existing product designs.

## License Plan

Next, you can select your desired product plan from the list:

* Evaluation
* Project Maker
* Commercial Device Builder

Free evaluations are offered for a limited time, commercial evaluation of the software. 

The Project Maker plan is for up for individual and non-commercial projects to utilize the device agent software for free for up to 10 devices. 

A Commercial Device Builder plan allows for the commerical deployment of any number of devices utilizing the software.

## License

If the Project Maker plan is selected, you can then select a commercial license or an open source GPLv2 license for the agent software. Note: The GPL License does not generally permit incorporating this software into non-open source programs. Use this license only for non-commercial, private or full open source firmware projects.

## License Scope

If you select the Commercial Device Builder for your plan, you next select a license scope from the list:

* By Device Volume
* Single Product
* Family of Products
* Business Line

The **By Device Volume** licence is based on the total installed base of devices that embed the device agent.

The **Single Product** license is limited to a single product and its direct product replacements. This license provides unlimited device unit volume. Multiple model numbers are permitted, provided the models vary only in branding, appearance, packaging or scale and not otherwise in functionality.

The **Product Family** license is limited to related products that share the same functional purpose and have the same public product family name.

The **Business Line** license permits multiple Product Families within a single business unit and single market segment.

These licenses are annual subscriptions and include software updates and upgrades through the year. 
While your license subscription is active, you can include the device agent software in your products. You may access and apply security updates and upgrades for new and existing devices.

For these license subscriptions, you are billed either yearly in advance.

## Ioto Products

When using a License Scope of "**By Device Volume**" you must enter the total number of installed devices using the software in the **Total Devices** field.  This is the cumulative number of devices that you have shipped to date using Ioto including those that you will manufacture during the billing period.

The Ioto service can automatically meter devices as they are manufactured. This involves the Ioto device agent sending a single registration request during creation to the Builder service. This is an automated process and it relieves you of the burden of counting and estimating device unit volumes. The current count of registered devices is displayed in the label for the **Total Devices** field.

Ioto is billed monthly at the end of the month based on the number of devices manufactured during the month. Ioto subscriptions are calculated on a sliding scale where the price decreases the more devices you deploy. The price is < $0.30 when making more than 1,000 devices per month.

You can evaluate Ioto without cost by using the Evaluation plan.

## Intended Purpose

You can help us to better understand your intended goals by selecting how you plan to utilize the agent. 

## Product Alert Recipients

You can enter one or more email addresses or phone numbers to be notified in the event of important security updates. When relevant releases or security updates are issued, you can be proactively notified by mail or phone so you can quickly take the appropriate action. 

Separate entries with commas and use fully qualified phone numbers with international dialing prefixes.

## Creating New Products

To configure a new product, select the **Add Product** button from the product list. This will display the slide out product panel.

![Product Add](/images/builder/product-add.png){class="screen"}

Enter a unique product name and accurate product description. Then select the relevant EmbedThis licensed product you wish to embed. Choose from:

* Ioto Cloud Agent
* GoAhead Web Server
* Appweb Web Server

Depending on the licensed product, you will have different subscription options.
# Product Security Center

Below the product list is the product security center that provides product news, relevant articles and product release and security issues.

The product list displays your configured products and also has entries for the Builder portal and Device Manager services.

For each product entry, a list of product issues and events is displayed below the news and information cards.

![Product List](/images/builder/product-list.png){class="screen"}

## Product News and Articles

Recent news items will be displayed with links to the relevant documentation or Blog articles.
For all the news, go to the [Embedthis Blog](https://www.embedthis.com/blog/).

Helpful articles will be listed in the **Learn About** card.

### Product Issues and Events

The product issue list documents product bugs, features, releases and security issues. 

The issue list displays the following table columns:

Field|Description
-|-
Opened | When the issue entry was opened and documented
Type | Type of issue: Bug, Discussion, Feature, or Release 
Title | Issue subject title
Impacted | Versions impacted by the issue
Priority | [CVSS](https://www.balbix.com/insights/understanding-cvss-scores/) priority rating
Action | Recommended action
Status | Issue status: Open, Closed or Fixed
Tags | Categorization tags

Click on an issue to display the Issue panel

## View an Issue

![Product Issue](/images/builder/issue-edit.png){class="screen"}

The issue panel displays the following issue fields:

|Field|Description|
-|-
Type | Type of issue: Bug, Discussion, Feature, or Release 
Date | When the issue entry was opened and documented
Title | Issue subject title
Description | Full issue description and discussion
Subject | The product that is the subject of the issue
Impacted | Versions impacted by the issue
Status | Issue status: Open, Closed or Fixed
Resolved | Release the issue is corrected and resolved
Priority | [CVSS](https://www.balbix.com/insights/understanding-cvss-scores/) priority rating
CVE | Assigned [CVE](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures) if any
Action | Recommended action
Tags | Categorization tags

## Reporting an Issue

If you have an issue or bug to report, use the Builder Support Case tool to report the issue.

With an active support plan, you can use the integrated Builder support center to open support cases and track them to conclusion.

![Support Cases](/images/builder/support-case.png){class="screen"}

When opening a support case, you supply:

* A short case issue subject
* A detailed issue description
* The relevant product experiencing the issue
* Attach relevant files or logs
* The issue severity
* A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and complete description of what the issue is. Please explain in sufficient detail. Most people are too brief in the description and it results in delays addressing issues as support staff go back and forth with questions. Please spend some time writing a complete description.

If you can, please include a link to a gist or repository containing a test case or sample that reproduces your issue. Reproductions should be short, correct, self-contained and should not contain code that isn't relevant to the issue. Please do NOT just paste code from your project. Explaining how to reproduce the issue alone is typically insufficient.

### Issue Severity

You can set the issue severity which helps EmbedThis staff understand the impact of your issue. Set to low, medium, high or critical. Please do not overstate the issue severity. NOTE: the severity does not equate to a priority with which your issue will be addressed.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.
# Downloading the Device Agent

You can download the latest version of the device agent software from the [Builder Product List](https://admin.embedthis.com/product) via the download link.

EmbedThis continually updates the service and regularly publishes upgrades and security updates for the device agent software.

![Product List](/images/builder/product-list.png){class="screen"}


## Evaluation Use

If your product is based on Ioto, you can download the software to evaluate the service on one device. When you are ready, you can create your own device cloud and connect and manage more devices. This requires adding a billing card and purchase.

If your product is based on Appweb or GoAhead, you can download the limited evaluation software for free. This evaluation software can be used on any number of devices. When you are ready to use the full release software, you will need to add a billing card and purchase.

## Downloaded Image

The downloaded device agent is in Gzipped Tar format and includes everything you need to build the software from source.

![Product List](/images/builder/download.png){class="screen"}

Consult the relevant agent documentation for details.

* [Ioto Agent Documentation](/agent/)
* [Appweb Documentation](https://www.embedthis.com/appweb/doc/)
* [GoAhead Documentation](https://www.embedthis.com/goahead/doc/)

## License Terms

Please read the [EmbedThis License Terms](https://www.embedthis.com/about/terms.html).
# Licenses

The EmbedThis Ioto cloud management service is provided under the [EmbedThis Terms of Service](https://www.embedthis.com/about/terms.html).

EmbedThis distributes device agent software under three licenses. You can choose which license you wish to use depending on your other licensing terms.

* [Embedthis Commercial License](https://www.embedthis.com/about/terms.html)
* [Embedthis Evaluation License](eval.md)
* [GPL License](http://www.gnu.org/licenses/gpl-2.0.html)

### Commercial License Overview

The [Commercial License](https://www.embedthis.com/about/terms.html) provides businesses with the flexibility and rights needed to integrate the software into proprietary products and services. Key features of the commercial license include:

- **Right to Create Integrated Products**: The license allows users to compile, modify, and use the device agent software to create Integrated Products and keep their source code private and confidential. 

- **Distribution Rights**: Businesses can distribute, market, and sell Integrated Products, including the ability to provide cloud-based remote access to those products.

- **Support for Contract Manufacturers**: The license permits distributing the agent software in source code form to contract manufacturers.

- **Service Integration**: Users can interact with the EmbedThis cloud-based management service to manage their devices.

- **Developer Support**: Access to dedicated support services for assistance in designing and implementing Integrated Products.

Please read the full [Embedthis Commercial License](https://www.embedthis.com/about/terms.html).

### Eval License Overview

The [EmbedThis Eval License](eval.md) is for short term commercial evaluations. 

### Open Source License Overview

EmbedThis also provides its device agent software, including Ioto, Appweb, and GoAhead, under an alternate GPLv2 license. The GPLv2 license is particularly suitable for individual maker projects and some commercial evaluations. 

However, it is important to note that the GPL license has strict requirements regarding its use. If you use the GPLv2 license, you are still required to abide by the general [EmbedThis Terms of Service](https://www.embedthis.com/about/terms.html).

The [GNU General Public License](http://www.gnu.org/licenses/gpl-2.0.html#SEC1)is a widely recognized open-source license that ensures users have the freedom to run, study, share, and modify software. Key provisions of the GPLv2 license include:

- **Open Source Requirement**: Software distributed under the GPL license must remain open source. This means that any derivative works or modifications to the software must also be released under the GPL license if distributed.
- **Non-Compatible with Proprietary Software**: GPL-licensed software cannot be incorporated into proprietary software unless the entire project is released under the GPL.
- **Obligation to Share Modifications**: If you modify GPL-licensed software and distribute those modifications, you must make the modified source code publicly available and accessible to all others under the same license.
- **Compliance**: By utilizing the GPL-licensed software, you are legally bound to fully comply with all its terms. Failure to do so may result in a violation of the license agreement.


### Choosing the Right License

You can choose the commercial license or the open source GPL license depending on your individual or business needs.

- **Commercial License**: For businesses requiring the flexibility to incorporate EmbedThis software into proprietary or closed-source applications, the commercial license is the best choice. This option provides professional support, customization, and the ability to integrate with non-open source programs.

- **GPL License**: Ideal for open-source enthusiasts, makers, or those evaluating the software for non-commercial purposes. The GPL License does not generally permit incorporating the agent software into non-open source programs.

Your use of the software or access to the cloud service constitutes acceptance of the relevant license terms. 

# Volume-Based Device Agent Pricing

The volume-based subscriptions licenses you to embed the device agent for the total installed base of your devices. It provides the right to update and apply security patches to your existing devices while your subscription is active.

The volume-based subscriptions are billed yearly in advance and offer a lower-cost of entry for smaller device volumes.

See also details about the [Royalty Free Agent Pricing](royalty-free.md).

## Free Evaluation

Your first device is free and you can evaluate device agents for free by using the evaluation agent downloads. The eval software is a recent release, but does not include the latest patches and features. The eval license includes the ability to embed the agent in one device.

## Device Volume

The volume-based subscription fee is based on the total installed base of devices that embed the device agent. The price is calculated via a sliding scale where the per-device price decreases with increased volume. The more you build, the lower the subscription per device.

You enter and maintain the total installed base of devices for your subscription via the Builder site on the Product page. 

## Volume Price Brackets

The following price table shows the device subscription price brackets at increasing volume levels. The first device is free.

The price column shows the subscription per-device price once that number of manufactured devices been reached. Subscription prices are per year.

Volume|Price
-:|-:
1-10 | Free
11-100 | $8.80
101-1000 | $2.20
1001-1000 | $.55
10001-10000 | $.14
100001+ | $.05

## Billing Period

The volume-based subscriptions are billed yearly in advance.

If you discontinue your agent subscription, you need to cease shipping new products that include the device agent. You can continue to use existing devices that contain the device agent or the Ioto cloud service. An active subscription is required to download or apply new software updates or security patches.

## Pricing Example

For example: If you have 1001 devices manufactured, the calculation would be as follows:

* Devices 1 to 10 -- free
* Devices 11 to 100 -- $8.80 each
* Devices 101 to 1000 - $2.20 each
* Device 1001 -- $0.55

So the annual device subscription would be: $8.80 x 90 + $2.20 x 900 + $0.29 * 1

Annual Total: $2,772.29

The monthly subscription would then be: ~$231

See the price calculator at the [Price Calculator](https://www.embedthis.com/pricing.html)# Embedthis Software Evaluation License

This is a License Agreement between Embedthis Software LLC. ("Embedthis") and you ("You"), the Licensee.

PLEASE READ THESE TERMS AND CONDITIONS CAREFULLY BEFORE INSTALLING OR USING THE SOFTWARE. YOUR USE OF THE SOFTWARE INDICATES YOUR FULL ACCEPTANCE AND YOU ARE AGREEING TO BE BOUND BY ALL THE TERMS AND CONDITIONS IN THIS AGREEMENT. FAILURE TO COMPLY WITH THE TERMS OF THIS AGREEMENT VOIDS THE AGREEMENT, DISALLOWS LICENSEE USE OF THE SOFTWARE AND MAY GIVE RISE TO UNSPECIFIED DAMAGES.

### Definitions

**"Integrated Product"** means a single product that incorporate(s) the Software in binary form only, together with other hardware or software of significant value-add.

**"Software"** means the Embedthis Ioto agent software including source code, headers, documentation and data files.

### 1\. License to Use

1.1. You are hereby granted a limited, non-exclusive, non-transferable right to use, compile and modify the evaluation version of the Software for non-commercial purposes when creating Integrated Products.

1.2. You are prohibited from distributing, selling, renting or providing remote access to Integrated Products containing any portion of the Software. You acknowledge that a separate Embedthis license is required for further development after this Agreement has terminated or for the distribution and selling Integrated Products.

### 2\. Copyright and Ownership

2.1. The Software is owned by Embedthis and is protected by international copyright, trademark and any other applicable laws. You must comply with the terms of the copyright notice in the Software and must never remove any notice or product identification from the Software or the accompanying documentation. You acknowledge that the copyright, patent, trade secret and all other intellectual property rights in the Software shall remain the exclusive property of Embedthis. You also acknowledge that Embedthis owns the Embedthis, Appweb, Ioto and Embedthis GoAhead trademarks and logos.

### 3\. Warranties and Limitations

3.1. Embedthis DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, RELATED TO THE Software, ITS USE OR ANY INABILITY TO USE IT, THE RESULTS OF ITS USE AND THIS Agreement. The Software and any accompanying written materials are supplied "AS IS", without warranty of any kind. Embedthis does not warrant, guarantee or make any representations regarding the use of or the results of the use of the Software or as to its correctness, accuracy, reliability, currentness or otherwise. You assume the entire risk as to the results and performance of the Software.

### 4\. Notices

4.1. Embedthis may, at its sole discretion, terminate this Agreement at any time without notice.

### 5\. Applicable Law

5.1. This Agreement will be governed by the laws of the State of Washington, USA and the parties submit to the non-exclusive jurisdiction of the courts of that state.

Last revised Dec 20, 2024.# Billing

The billing center page displays your billing cards and issued invoices and page will be enabled if you are an "owner" of the Builder account. You become an owner by having a member role set to "owner".

![Billing](/images/builder/billing.png){class="screen"}

## Payment Cards

Your billing cards will be displayed and the current card will be shown as the default card to use for payment. Click "Add Card" to enter a new card. Click on an existing card to modify, delete or designate a card as the default card to use for billing.

For your security, only the last 4 digits of the card number are stored for verification purposes.

## Invoices

As you are billed, invoices are created and stored. You will be emailed the invoice PDF and you can download invoiced from the invoice table.

## Invoice Address

To change the company name or billing address on your invoices, click on the **Invoice Address** button and enter the required details.

## Reissue Invoice

If you change the invoice address, you can click **Reissue** to re-generate the invoice with the updated invoice address.
# Support Plans

The EmbedThis Builder Support Center is the place for you to can tailor your support plan and open support issue tickets and track them to resolution.

EmbedThis offers two types of support:

* Basic Support
* Developer Support

## Basic Support

Basic support provides guidance covering installation and operational usage of the product.

The basic support subscription can be paid monthly or yearly in advance.

Basic support is $720 USD per year and is a 10% discount over the monthly price of $67 per month. Basic support is required if you utilize Developer support.

## Developer Support

Developer support assists with design and implementation challenges, encompassing embedded development, cloud-based device management, coding, debugging, and support for legacy software versions.

The service is priced at $250 USD per hour with a mandatory minimum of two hours. Activation of basic support is a prerequisite. Payments for developer support must be made in advance.

Your purchased support hours are consumed by EmbedThis staff as they tackle issues you submit via the Builder support portal. These hours cover activities such as identifying, diagnosing, and debugging problems, as well as providing guidance and collaborative efforts to resolve your issues. The time spent by EmbedThis support staff is meticulously tracked and deducted from your developer support balance.

Given that the EmbedThis device agent software is embedded and tailored within customer devices, support hours are spent regardless of the root cause of the issue—even if it stems from a bug in the device agent software.

## Support Cases

With an active support plan, you can use the integrated Builder support portal to open support cases and track them to conclusion.

![Support Cases](/images/builder/case.png){class="screen"}

When opening a support case, you supply:

* A short case issue subject
* A detailed issue description
* The relevant product experiencing the issue
* Attach relevant files or logs
* The issue severity
* A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and complete description of what the issue is. Please explain in sufficient detail. Most people are too brief in the description and it results in delays addressing issues as support staff go back and forth with questions. Please spend some time writing a complete description.

If you can, please include a link to a gist or repository containing a test case or sample that reproduces your issue. Reproductions should be short, correct, self-contained and should not contain code that isn't relevant to the issue. Please do NOT just paste code from your project. Explaining how to reproduce the issue alone is typically insufficient.

### Issue Severity

You can set the issue severity which helps EmbedThis staff understand the impact of your issue. Set to low, medium, high or critical. Please do not overstate the issue severity. NOTE: the severity does not equate to a priority with which your issue will be addressed.
center

### Upload Attachments

You can upload log files, screen shots or other assets that can assist EmbedThis to understand and diagnose your support issues. Each asset must be less than 10 MB in size.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.

## Close Case

When an issue is closed to your satisfaction, click the close case button.
# Device Cloud Pricing

Device Cloud pricing is a subscription fee for connecting a device to a device cloud. 

Subscriptions are based on the total number of devices that connect to the device cloud and you only pay for the devices that actually connect to the cloud. The permits you or your users to decide on a per-device basis whether cloud-based management is required.

Billing is performed either monthly or per year. For the first billing period, the price will be calculated pro rata.

Dedicated device clouds have a base fee in addition to the per-device fee. See below.

The device cloud subscription is in addition to the [Device Agent Pricing](index.md).

## Free Ioto Evaluation

Your first device is free, so you can evaluate Ioto without charge.  This includes the ability to embed Ioto in one device, create and connect to a device cloud and create a device manager from which you can manage your device.

You can also test Ioto for free using the pre-created Eval cloud. 

## Volume Scale

Device clouds have a per-device subscription fee. This is calculated according to a sliding scale where the per-device price decreases with increasing numbers of devices connecting to the cloud. The first device is free.

The following price table shows the device subscription price brackets at increasing device volume levels.

The indicated price is the subscription price is the price per device per year once that volume level has been reached for the month.

Volume|Price
-:|-:
1-10 | Free
11-100 | $8.80
101-1000 | $2.20
1001-1000 | $.55
10001-10000 | $.14
100001+ | $.05

## Dedicated Clouds

Dedicated device clouds run the device cloud in your own AWS account. 
Dedicate clouds offer the ultimate in security and control and provide a suite of additional AWS services and customization together with the highest tier support.

If you expect to create more than 1,000 devices over the lifetime of your product, you should use a dedicated device cloud for your production deployment as hosted device clouds are limited to 1,000 devices.

Dedicated clouds have a flat $1,000/month fee in addition to the per-device fee.

## Pricing Example

For example: If you have 1001 devices connecting to the cloud in a month, the calculation for a hosted cloud would be as follows:

* Devices 1 to 10 -- free
* Devices 11 to 100 -- $8.80 each
* Devices 101 to 1000 - $2.20 each
* Device 1001 -- $0.55

So the annual cloud subscription would be: $8.80 x 90 + $2.20 x 900 + $0.29 * 1

Annual Total: $2,772.29

The monthly subscription would then be: ~$231

See the price calculator at:

[Price Calculator](https://www.embedthis.com/pricing.html)# Device Cloud Data Limits

Based on your Device Cloud plan, Ioto sets data limits to safeguard you, your customers, and the service.

If a device or multiple devices exceed these limits, Ioto ensures protection by throttling the incoming data from the devices responsible.

## Data Traffic

The amount of data you send to the device cloud is measured as the average number of KBytes transferred per device per hour. This traffic is then compared with the limit for your device cloud.

As you connect more devices, your data limit scales automatically with the number of devices connecting to the cloud. What is measured is the average data traffic over your entire pool of connecting devices. For example, if you have 100 devices and a limit of 60 messages per device per hour, this means that your pool of devices can send up to 6,000 messages to the device cloud per hour. 

Ioto supports short-term burst traffic above the limit, but if your sustained, aggregate traffic exceeds your limit, the offending devices will have their sending rate throttled. Which means their sending rate will be reduced until the aggregate traffic is below the limit.

## Throttling

When devices in a cloud cloud exceed the data limit, the offending devices will receive a throttle message and the device's Ioto agent will automatically slow down the rate of sending to the cloud. 

Upon receiving a throttle message, Ioto will implement an exponential backoff strategy and will slow down the rate of sending. Messages can still be received and Ioto will be fully functional. However, the rate of sending will be reduced until the throttled condition is alleviated. This protects your account and your customer's quality of service. It also protects you against rogue devices that have been compromised.

Ioto measures your device traffic rate every 30 seconds and will throttle a device that is exceeding 4 times your traffic limit over a 1 minute period. If your traffic load over the prior 5 minutes is light (< 50% of your limit) a device can burst up to 8 times the limit.

If the burst limit is exceeded for the past minute, the device will be throttled.

If a device continues to exceed the limit for a device cloud, the device will be disconnected (released) from the device cloud and its communication certificates will be revoked. The device will then need to be reclaimed to join the device cloud.

## Data Limits

The data limits vary depending your your device cloud type. 

For Hosted device clouds and the Evaluation device cloud, data limits ensure the cloud infrastructure is not monopolized by any device, set of devices or users.

The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It has higher limits, as it is typically used with few devices and consequently lower aggregate device pool limits.

For a Dedicated cloud, you are the sole user of the cloud running in your own AWS account. In this case limits are advisory and can be increased if required.

For hosted clouds, you can purchase increased data limits. If you require this, please contact sales@embedthis.com.

### Cloud Limits

Device Cloud| Limit
-:|:-
Eval Cloud | 60 messages (1K) per device per hour
Hosted Cloud | 1 message (1K) per device per hour
Dedicated Cloud | 1K message per device per hour

## Terms

Please see the [Terms of Use](https://www.embedthis.com/about/terms.html) for acceptable use terms.
# EmbedThis Builder Plans

EmbedThis provides subscription plans for device agents, cloud-based management services and support and services.

* **[Maker Projects](#maker-project-subscriptions)**
* **[Royalty-free Device Agents](#royalty-free-subscriptions)**
* **[Volume-based Device Agents](#volume-based-device-agents)**
* **[Cloud-based Management](#cloud-based-management)**

Device Agent subscription plans provide the agent source code, license to embed, documentation, samples and ongoing upgrades and security updates.

## Maker Project Subscriptions

For individual device makers, builders and commercial evaluations we offer a free subscription for up to 10 devices. This includes the ability to embed the Ioto agent in your device and create device clouds to manage your devices. This subscription is ideal for individual project maketers or commercial evaluations to easily prototype a device management solution with Ioto.

## Royalty-free Device Agents

Royalty-free subscriptions offer an annual renewable license to embed the device agent in new devices and to update existing devices.

Royalty-free subscriptions are based on a license scope that defines the scale and number of products that utilize the device agent software. The supported scopes allow unlimited device volume shipments within that scope.

The **Single Product** scope is limited to a single product model and its direct successor product replacements with unlimited device unit volume. Multiple model numbers are permitted, provided the models vary only in branding, appearance, packaging or scale and **not otherwise in functionality**.

The **Product Family** scope is limited to related Single Products that share the same functional purpose and have the same public product family name.

The **Business Line** scope permits multiple Product Families within a single business unit and single market segment.

The royalty-free subscriptions are paid yearly in advance.

For more details, please see: [Royalty-free Pricing](royalty-free.md).

## Volume-Based Device Agents

The volume-based subscriptions calculate a fee based on the total number of devices that have been manufactured. i.e. on your total installed base of devices. The fee is calculated on a sliding scale where the per-device price decreases the more devices you create. The price is < $0.30 per device with more than 1,000 devices made per month.

The volume-based subscriptions offer a lower-cost of entry for smaller device volumes than the scope based licenses.

The volume-based subscriptions are billed yearly in advance. 

For more details, see: [Volume-Based Pricing](volume.md).

## Cloud-Based Management

If using cloud-based management, the subscription plans are based on two components:

* Ioto Device agent subscription (either volume-based or royalty-free)
* Cloud management subscription

The cloud management subscription is a per-connecting device fee. It is based on the number of devices that connect to the cloud for management and is paid monthly in arrears. You only pay for the devices that actually use the cloud-management service.

Cloud subscriptions are calculated on a sliding scale where the price decreases the more devices you connect and manage. The price is < $0.20 with more than 1,000 devices connecting each month.

For more details, see: [Cloud Pricing](cloud.md).

## Upgrading and Downgrading

If you are downgrading or upgrading a device agent from one plan to another, where possible, the Builder will credit the existing plan toward the cost of a new plan. 

## Support Plans

Embedthis offers two levels of support:

* Basic Support
* Developer Support

Support programs are paid for immediately upon enabling the program.

### Basic support

Basic support provides advice and guidance covering basic usage of the service and the device agent that does not require engineering support. Basic support is $775 USD per year or $71 per month.

### Developer Support

Developer support provides support for design and implementation issues that require engineering support staff. This covers embedded development, cloud-based device management, developer coding and debugging issues with the software including support for legacy software versions.

Developer support is priced at $275 USD per hour. Developer support requires a minimum of two hours and that basic support be also enabled.

## Terms

Please see the [Terms of Use](https://www.embedthis.com/about/terms.html) for terms.
# Royalty Free Device Agent Pricing

Royalty-free subscriptions offer an annual renewable license to embed the device agent in new devices without a device volume limit. It also provides the right to update and apply security patches to all your existing devices while your subscription is active.

## License Scopes

Royalty free subscriptions are based on a license scope:

* Evaluation
* Single Product
* Family of Products
* Business Line

The **Evaluation** scope provides a limited version of the software for you to complete your evaluation. This software is not suitable for production and will not contain the latest upgrades and security fixes. But is it ideal for evaluating Embedthis device agents.

The **Single Product** license is limited to a single product model and its direct successor product replacements with unlimited device unit volume. Multiple model numbers are permitted, provided the models vary only in branding, appearance, packaging or scale and **not otherwise in functionality**.

The **Product Family** license is limited to related products that share the same functional purpose and have the same public product family name.

The **Business Line** license permits multiple Product Families within a single business unit and single market segment.

## Pricing

The following price table shows the annual subscription price for each license scope. This price includes the right to embed the software, ship products that include the software and apply any software upgrades and security updates to new or existing licensed products.

Volume|Price
-:|-:
Product | $7,280
Family | $12,095
Business Line | $34,995

## Billing Period

The royalty free subscriptions are billed yearly in advance.

If you discontinue your subscription, you need to cease using the software or shipping new products that include the software.

## Legacy Agreement Licenses

If you have an existing agreement license, your yearly subscription will be for annual Maintenance that provides for upgrades and security updates.
# Managing Subscriptions

The Builder Account / Subscription page displays your current and pending subscriptions including your products, clouds and support plans and will be enabled if you are an "owner" of the Admin account. You become an owner by having an account membership role of "owner".

![Subscription](/images/builder/subscription.png){class="screen"}

The subscription page displays two panels:

* Active Subscriptions
* Cart Purchases

## Current Subscriptions

This Active subscriptions panel displays your existing subscriptions that are active.

## Cart Purchases

The Cart panel shows the pending subscriptions that require your approval and purchase before billing and activation.

## Subscription Panels

Each panel displays a table of your products, support programs and device clouds.

The Active Subscriptions table includes columns for the following items:

* Date &mdash; When the subscription is due.
* Type &mdash; The type of the subscription.
* Description &mdash; Details about the subscription.
* Quantity &mdash; The number of devices, clouds or support hours.
* Period &mdash; The activation period for the subscription.
* Status &mdash; If the subscription is active or expired.

## Approval

Subscriptions must be approved by you before purchase.  Once approved, subscriptions will automatically renew until you cancel them (except Developer support hours). If you are on a legacy Agreement plan, you may need to approve renewals each year.

Note that some subscriptions are billed in arrears, whereas others are paid upfront.

## Cart Actions

Once you select one or more cart items, you can choose one of the Action buttons:

* Add Card &mdash; click to define an online card for billing.
* Purchase &mdash; approve and immediately purchase the selected items.
* Download Quote &mdash; if you are setup for invoicing, you can download a quote for the selected items.
* Remove Items &mdash; remove the subscription for the selected items. This does not impact current (active) subscriptions.
* Order Details &mdash; enter your order details including a purchase order.

You can click the **Purchase** button to immediately purchase the selected items.

If you are authorized to pay via Bank Transfer, you can click on the **Download Quote** button to generate a PDF quotation for the selected items. To define your Invoice company name, billing address and purchase order number, click on the **Order Details** button. You can also enter an email address and email subject that will be used to email the Invoice to a destination of your choice. Once a purchase order number is entered, you can click on **Purchase** to complete your purchase.
# Glossary of Terms

Here is a list of terms used by the Device Build documentation

Term | Description | Link
-|-|-
AWS IAM Device Role | IAM role used by the Device Cloud when creating IAM keys for use inside the device. | [/builder/clouds/creating.html#device-keys-iam-role](https://www.embedthis.com/doc/builder/clouds/creating.html#iam-role)
AWS IAM Role | An AWS IAM identity that enable specific permissions for the owner. | [/builder/clouds/creating.html#device-keys-iam-role](https://www.embedthis.com/doc/builder/clouds/creating.html#device-keys-iam-role)
Builder | The EmbedThis Device Builder Site. | https://admin.embedthis.com/
Claim Device | When an end-user purchases a device and claims it for them to manage. | [/ioto/provisioning/claiming/](https://www.embedthis.com/doc/ioto/provisioning/claiming.html)
Device Agent | The embedded agent providing device management services. | [https://admin.embedthis.com/products/](https://admin.embedthis.com/products/)
Device Cloud | A management hub from which to centrally operate and manage a set of devices | [/builder/products/](https://www.embedthis.com/doc/builder/products/)
Device Manager | A browser-based device management application. | [/apps/](https://www.embedthis.com/doc/apps/)
Device Provisioning | The process of providing devices with X.509 certificates and credentials to securely connect with cloud-based services. | [/ioto/provisioning/](https://www.embedthis.com/doc/ioto/provisioning/)
Device Tables | Ioto Device Tables is a global, replicated database that transparently synchronizes data between devices and the cloud. | [/ioto/database/](https://www.embedthis.com/doc/ioto/database/)
IoT Policy | An AWS IoT policy used to configure the permissions granted to incoming MQTT messages from the device. | [/builder/clouds/creating.html#iot-policy](https://www.embedthis.com/doc/builder/clouds/creating.html#iot-policy)
Ioto Service | The cloud-side AWS application providing the EmbedThis Ioto cloud-based management service. | [/ioto/](https://www.embedthis.com/doc/ioto/)
MQTT | A lightweight, publish/subscribe messaging protocol primarily used by IoT. | https://en.wikipedia.org/wiki/MQTT
Register Device | The process of connecting the device to the Builder during manufacturing, creating a record that the device was produced. | [/ioto/provisioning/registration/](https://www.embedthis.com/doc/ioto/provisioning/registration.html)
X.509 Certificate | A public key certificate used by TLS to verify the identity of a provider and to use as the basis for encrypted communications. | https://en.wikipedia.org/wiki/X.509
# What is EmbedThis<sup>&reg;</sup> Ioto?

At EmbedThis, we're on a mission to dramatically simplify device connectivity and management, enabling makers and equipment builders to swiftly develop exceptional products that are easy to manage and accessible from anywhere.

[EmbedThis Ioto®](https://www.embedthis.com/ioto/) (pronounced "eye-oh-toe") is a comprehensive, end-to-end [IoT Meta-Platform](https://www.embedthis.com/blog/iot/what-is-an-iot-meta-platform.html) for managing devices, whether via the cloud or directly on the device. Ioto is a complete solution and not just a set of building blocks. Ioto includes a device builder portal, on-device agent, cloud-based device management, and a low-code app designer. It provides all the necessary tools to rapidly create, configure, and deploy secure IoT environments and applications.

## What is a Meta-Platform?

![What is a Meta Platform](/images/blog/t-what-is-an-iot-meta-platform.avif){class="screen width-50 left"} 

Instead of introducing another [IoT platform](https://www.embedthis.com/blog/iot/what-is-an-iot-platform.html), we have focused on delivering a complete solution that fully leverages and extends the existing and leading [AWS IoT platform](https://aws.amazon.com/iot-core/). 

An [IoT Meta-Platform](https://www.embedthis.com/blog/iot/what-is-an-iot-meta-platform.html) is a software layer that extends a foundational IoT platform to deliver a complete, end-to-end IoT solution. It adds missing services such as device cloud creation, streamlined provisioning, data modeling, automation workflows, and low-code builders for rapidly developing IoT device apps.

The AWS IoT platform offers a robust set of building blocks that include device provisioning, connectivity, messaging, data routing and storage. **Ioto** builds upon these AWS IoT capabilities by providing a Device Builder Studio, compact embedded device agent, transparent device data synchronization, analytics, OTA updates and a low-code device app designer. This comprehensive approach accelerates and enhances the underlying AWS platform's functionalities, allowing you to create, configure, and deploy secure IoT environments and applications in minutes rather than months.

:::info
**Ioto dramatically lowers IoT project cost and accelerates the time to completion while lowering project risk.**
:::

## Components of Ioto

![Ioto Solution](/images/ioto/framework.png){.screen}

**EmbedThis Ioto** is comprised of the following components:

- **Device Builder Portal** - Create and configure devices in minutes.
- **Device Agent** - Management agent to embed in devices to control communications with the cloud.
- **Based Device Management** - IoT services to manage device provisioning, messaging, and data storage.
- **Device Apps** - Low-code app designer to create and configure device apps in minutes.

## Key Features of Ioto

- Device builder portal to create, configure and manage devices
- Regional device clouds to manage devices in different locations
- Embedded device agent for local and remote management
- Automated actions and device commands including support for offline devices
- Low-code app designer to create mobile and desktop device apps
- Over-the-air updates
- Device data storage
- Transparent device data synchronization with the cloud
- Device data analytics and metrics
- Device data visualization with dashboards and graphical widgets
- Device data security, privacy, and compliance
- User access control
- Leverage and integrate with AWS IoT services
- Online support portal and extensive documentation# Account Settings

The account settings page displays and manages your account name and billing email address.

The settings page will be enabled if you are an "owner" of the Builder account. You become an owner by having a member role of "owner".

## Name

Your account name was defined when you created your Builder account. You can change your account name here if you require.

You can also change your corporate name and billing address that will be used for invoices on the Invoice Address option on the Account Billing Page.

## Billing Email

Each Builder account has an email address that is designated as the primary contact for the account. This email address will be used for billing and critical account communications. It will not be used for other notifications.

The billing email is by default the email address of the user who created the account. You can change this email address to the valid email address of any admin user.

## Account ID

Your Builder account ID is shown on the settings page and this may be requested by support staff should you need assistance in resolving an issue.
# Account Users

You can invite and add team members to your account and designate their role in your EmbedThis Builder account.

Administrative users can add, remove or modify organization members.

![Invite User](/images/builder/invite-member.png){class="screen"}

## Inviting Users

To add a user to a Builder account, invite them via the "Add Member" button on the Member List page.

When invited, the user is sent an invitation email with instructions. When clicking or entering the link provided, the user can register and login to your account.

## User Role

When inviting a user or later when modifying the user's configuration, a user can be assigned a role. This role may be:

* user
* admin
* owner

User role members can view information but not change product, subscription or organization configuration. Users can view and open support issues and download software.

In addition to user roles capabilities, admin members can perform constructive or destructive operations on the organization. Admin users can create product definitions, configure subscriptions and confirm purchases.

In addition to the admin role, owners can control the entire account. They can add and modify billing cards and close the account.

## Remove User

Clicking this button will remove the user from your Builder account and from all your organizations. The user will lose all access to Builder and your assets.
# Personal Profile

The personal profile displays your login information including your login information and personal preferences.

![Profile](/images/builder/profile.avif){class="screen"}

## Changing Name

If you have logged in using an email address and password, you can change your personal profile including your first and last name.

## Social Media Login

If you have logged on via a social media account such as Google, Amazon or Facebook, and you wish to change your profile, you need to do that via your social media account.

## Account ID

Your Builder account ID is shown on the profile page and this may be requested by support staff should you need assistance in resolving an issue.

## Guide Hints

The Guide hint toggle controls the display of UI sign-posts that guide your use of the Builder site. While you can dismiss the guide posts individually on their respective pages, you can also turn off the Guide Hints toggle to turn off all sign-posts. If you decide to enable again in the future, you can select **Re-Enable** which will redisplay all posts including those you have individually dismissed.

## Dark Mode

You can change your default dark mode setting here. Set to **auto** to have your dark mode change automatically with the time of day.# For Cloud Engineers

> Head in the clouds and feet on the ground. A cloud engineer has to connect the devices of yesterday with the cloud of tomorrow using what is available today.

The work flow for creating cloud-managed devices with the Builder includes:

-   Selecting the device agent for your product.
-   Gaining access to device software.
-   Creating device clouds.
-   Registering and claiming devices.
-   Gaining access to support programs and communicating with EmbedThis support.
-   Monitoring and analyzing device performance.

## EmbedThis Ioto

EmbedThis Ioto is a cloud-based management service for embedded devices connected to the Internet.

It is comprised of five components:

-   Device Builder
-   Ioto Service
-   Ioto Device Clouds
-   Ioto Device Agent
-   Ioto Device Manager

The **EmbedThis Device Builder** web site helps you to:

-   Define, configure, and control your products.
-   Manage your device clouds.
-   Tailor software upgrades to your needs.
-   Manage your subscription and billing for EmbedThis products and services.

The **Ioto Service** is a cloud application. It provides services for the EmbedThis Builder and manages the provision of devices into Device Clouds.

**Ioto Device Clouds** are cloud-based hubs that run in a region of your chosing. They manage routine communications and management for your devices.

The **Ioto Device Agent** is a cloud-ready embedded agent for remote device management. It includes an embedded web server, embedded database, HTTP client, MQTT client and extensive AWS IoT cloud integration. The agent communicates with the Ioto Service and Device Clouds for management. See [Ioto Agent Documentation](/agent/) for in-depth details about the Ioto Agent.

The **Ioto Device Manager** is a white-label, device management web app that you can customize to suit your exact management needs. It can be extensively customized to manage your devices with your logo, product name, color and font theme, device data and device specific screens and interfaces.


## Work Flow

The work flow for creating cloud managed devices is outlined below.

### Creating a Product Definition

For each product type that you wish to manage from the cloud, you need to create a product definition that describes your device and nominates the device agent you wish to utilize.

### Downloading the Ioto Device Agent

Next, download the Ioto device agent from the Builder product list by clicking the **download** icon in the product list.

When building the Ioto device agent, you can select to also build the cloud-based device management application. This is included with the Ioto agent and can serve as the basis for a bespoke management user interface.

To help you evaluate Ioto, your first device is free. Thereafter, a subscription is required.

### Customizing Device Specific Logic

Embed the Ioto agent into your device hardware and add your device specific logic. There is extensive documentation available:

-   [Ioto Agent Doc](/agent/).

### Creating a Device Cloud

When your device has Ioto embedded and is ready to communicate with the cloud, you need to create a **Device Cloud** that will be the central hub for managing your devices.

A Device Cloud is created in an AWS account with a region of your choice. You can have multiple device clouds if you require, though most users will require only one cloud for their devices.

### Device Cloud Privacy

The Device Cloud is created in your AWS account so you have total control and privacy regarding your device data. Your device data goes directly from your devices to the device cloud in your account. The device data is not sent through EmbedThis servers or other AWS accounts. This is important as jurisdictions are increasingly requiring that data only be stored, processed and managed locally.

When creating device clouds, the builder will create the necessary resources, including a DynamoDB device database and service Lambda function in your AWS account.

### Registering Devices

Once a device cloud is created, you can register a device with the Builder service.

See [Ioto Provisioning](/ioto/provisioning/) for more details.

### Claiming Devices

When registered, you can "claim" the device for a user.

During development, you can claim devices from the Builder cloud list.

See [Device Claiming](/ioto/provisioning/claiming.md) for more details.

Once registered and claimed, the device is under management by the Ioto service. Management commands can be sent from the cloud to the device and device data can be sent upstream from the device to the cloud.

In production, users will claim devices using a bespoke management application that best implements an effective operational interface for your product and devices.

### Creating Device Apps

After creating a device cloud, you can create one or more device apps to manage your devices. These apps are created by the build and are hosted by EmbedThis on a sub-domain of your choosing.

Device apps can be uniquely configured using the low-code app designer. The app can be extensively customized to manage your devices with your logo, product name, color and font theme, device data and device specific screens and interface including browser-based and cloud-side custom logic.

You can customize device apps by changing:

- The device manager name and title
- The manager logo with your company logo
- A Device data schema
- A Manager UI Skin definition

You can also use the low-code app designer to create custom pages and navigation for your app.

Device apps leverage the DevCore UI framework which is a responsive, [Single Page](https://en.wikipedia.org/wiki/Single-page_application) web framework authored using [VueJS](https://vuejs.org). Device apps consumes data from the Ioto cloud APIs and sends device commands to your devices as required.

Alternatively, you can create your own device app using a framework of your choosing and the Ioto APIs.  

### Ioto APIs

Ioto provides a comprehensive suite of API interfaces for you to create your device management application. These APIs cover the following areas:

-   Builder HTTP REST API &mdash; for managing products, device clouds and software upgrades.
-   DynamoDB schema &mdash; for querying structured device data.
-   Event API &mdash; for receiving event notifications over AWS EventBridge.
-   MQTT Topic API &mdash; for sending and receiving device commands, data and notifications.

## Support

As you progress with your design and development, you will probably require support.

EmbedThis offers two types of support:

-   Basic Support
-   Developer Support

Basic support provides basic guidance covering installation and operational usage of the product.

Developer support provides comprehensive developer help for design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues, and support for legacy software versions.

You can purchase support via the Builder interface under the Support menu option. You can also raise and track support issues with the EmbedThis support staff.

## Support Issues

With an active support plan, you can use the integrated Builder support center to open support cases and track them to conclusion.

![Support Cases](/images/builder/support-case.png){class="screen"}

When opening a support case, you supply:

-   A short case issue subject
-   A detailed issue description
-   The relevant product experiencing the issue
-   Attach relevant files or logs
-   The issue severity
-   A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and thorough description of what the issue is. Please explain in sufficient detail. If your description is too brief, support staff cannot resolve the issue as quickly and will have to contact you to obtain any missing information. Please spend some time writing a complete description.

If you can, please include a link to a repository containing a test case that reproduces your issue. Reproductions should be short, correct, self-contained. They should not contain code that isn't relevant to the issue, so do NOT simply paste code from your project. Explaining how to reproduce the issue without including a test case is typically insufficient and will result in delays resolving your support issue.

### Issue Severity

Selecting an option for severity informs EmbedThis staff of the level of urgency of your issue. You may categorise an issue as low, medium, high, or critical severity. Please do not overstate the issue severity. NOTE: the severity does not equate to a priority with which your issue will be addressed.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.

## Close Case

When an issue is closed to your satisfaction, click the close case button.

### Product Issues

The Builder is used to track issues and security notices.

Go to the [Builder Products List](https://admin.embedthis.com/product) to see the product list and product security center.

To open a bug report, use the [Builder Support Center](https://admin.embedthis.com/support) to open
a case ticket.

## Feedback

If you have suggestions for how the Builder could make your role easier, please let us know at: [feedback@embedthis.com](mailto:feedback@embedthis.com).
# For Product Managers

>As a product manager, you identify customer needs and business objectives that your product will fulfill. You define product success criteria and rally your team to turn that vision into reality.

The EmbedThisDevice builder supports these requirements by helping you manage EmbedThis device agents, subscriptions, and support services.

The work flow for managing products with the Builder includes:

* Selecting the device agent for your product.
* Providing access to device software and patches.
* Creating and configuring device clouds.
* Managing software and service subscriptions.
* Gaining access to support programs and communication with EmbedThis support.
* Organizing your team.

## Creating a Product Definition

For each device that you wish to manage, you need to create a product definition that describes your device and nominates the device agent you wish to utilize.

The product definition includes the product name, description, and web page URL.

## Subscriptions

Depending on the device agent, there are varying subscription plans.

If you select the Ioto cloud agent, you can choose to automatically meter device volume as you manufacture.

For Appweb and GoAhead device agents, you select a license scope based on the volume and number of products you wish to support. You also select your payment frequency. 

For more detail, please see the [Builder Plans](../plans/) page.

## Download the Software

Once subscribed, you can download the device agent software from the Builder product list. Click on the download icon from the product table.

If you are evaluating the platform, you will be able to download an evaluation version of the software. If you have a paid subscription, you can download any current or prior version of the software.

## Device Specific Logic

Once downloaded, your engineers can begin embedding the device agent in your device hardware and adding your device specific logic. There is extensive documentation for the device agents:

* [Ioto Agent Doc](/agent/)
* [Appweb Doc](https://www.embedthis.com/appweb/doc/)
* [GoAhead Doc](https://www.embedthis.com/goahead/doc/)

## Support

As your team progresses with design and development, they may require support.

EmbedThis offers two support programs:

* Basic Support
* Developer Support

**Basic support** provides basic guidance covering installation and operational usage of the product.

**Developer support** provides comprehensive support with design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues, and support for legacy software versions.

Support can be purchased via the Builder interface. Payment can be made in advance, or each time support is needed. With a support subscription, your team can raise and track support issues with the EmbedThis support staff.

## Billing

You can complete payment for subscriptions via online card. Enter your online card from the Account/Billing page.

If you are authorized to pay by bank transfer, you can download PDF quotations from the Account/Subscription page and then enter your purchase order number in the **Order Details** panel.

After purchasing, you will be emailed an invoice. You can download past invoices from the Billing page.

## Renewals

Subscription plans renew automatically. If you are on an Agreement plan, you will need to confirm the renewal each year. Don't worry, we'll remind you via email when it is due.

To subscribe for additional products, device clouds, or more support, go to the Account/Subscription page. Review your subscription, then click Confirm to purchase.

## Organizing Your Team

You can invite any number of team members to register and login to your Builder account. This is useful so that team members can utilize the Builder directly and:

* Open and track support issues
* Download software
* Download software patches
* Create and configure device clouds
* Claim and test devices
* Monitor device cloud performance

When inviting a user or later when modifying the user's configuration, a user can be assigned a role. This role may be:

* user
* admin
* owner

**User** members can view information but not change product, subscription or organization configuration. Users can view and open support issues and download software.

In addition to user capabilities, **admin** members can perform constructive or destructive operations on the organization. Admin users can create product definitions, configure subscriptions and confirm purchases.

In addition to the admin role, **owners** can control the entire account. They can add and modify billing cards and close the account.

## Feedback

If you have suggestions for how the Builder could make your role easier, please let us know at: [feedback@embedthis.com](mailto:feedback@embedthis.com).
# Create an Account

To use the EmbedThis Builder site, you need to register and create an account. This is a simple, one-time task that will take you just a few minutes.

If you have been invited to an account by a co-worker, please click on the link in the invite email. That will ensure you become a member of the account that invited you.

To register, navigate to the Builder site at [https://admin.embedthis.com](https://admin.embedthis.com) and click on the Register tab.

All use of the EmbedThis Builder service and the device agent software is governed by the [Embedthis Terms of Use](https://www.embedthis.com/about/terms.html).

## Register

When you navigate to the admin site, you will see the login / registration dialog.

![Register](/images/builder/login.png){class="screen width-50"}

You may register using an email address and password or you may use a social media account from Amazon, Facebook, or Google. If you register by email and password, you will be sent a confirmation code to validate your email address. This code will come from the domain sender: no-reply@verificationemail.com.

If this is a new account, you will also be asked to enter an account name to identify your account.

Once registered, you will be automatically logged in to the Builder site.
Later, you can invite team members to join you on your account.
# Stand-Alone Devices

To create stand-alone managed devices, you typically integrate an embedded web server and create an embedded device management application that resides on the device.

The **EmbedThis Ioto Device Agent** includes a first-class embedded web server. We also offer two legacy embedded web servers for historical reasons.

* [Ioto](https://www.embedthis.com/ioto/)
* [Appweb](https://www.embedthis.com/appweb/)
* [GoAhead](https://www.embedthis.com/goahead/)

>Our legacy Appweb and GoAhead web servers are provided for existing customers who have embedded these web servers in existing product designs. We recommend that all customers transition to Ioto for new designs and devices.

The **Ioto Device Agent** can be used as a stand-alone embedded web server without any cloud management features enabled.

Ioto includes our most advanced embedded web server and is a fraction the size of comparable embedded web servers (including our own). It boasts impressive throughput and efficiency scores.

We recommend choosing the Ioto device agent for all new devices, even if they are not connected to the cloud, as Ioto has the most efficient and secure embedded web server. Please read the [Device Agent Comparison](https://www.embedthis.com/ioto/comparison.html) for details.


**GoAhead** is a simple, secure embedded web server that is perhaps the world's most popular embedded web server. Originally designed in 1998, GoAhead was present at the foundation of the Internet of Things. It is compact, secure and simple to use. GoAhead is deployed in hundreds of millions of devices.

**Appweb** is a high-end, secure embedded web server for hosting complex embedded web management applications. Appweb offers HTTP/2, HTTP proxy, extensive security controls, sandboxing and defensive counter-measures.

The work flow for creating stand-alone managed devices is outlined below. The entire process can take a significant amount of time due to the need to customize device-specific logic and adapt to the specific capabilities of each device.

## Create a Product Definition

For each product or product family, you need to:

* Create a product definition that describes your device. This definition should nominate the device agent you wish to utilize.

* Select your subscription options. Depending on your licensed agent, you will have different subscription options.

## Download the device agent

Next, download the device agent from the Builder product list.

If you have purchased a subscription, you can download the full software. Otherwise, you will be able to download an evaluation version.

## Customize device specific logic

Once downloaded, you can begin the task of embedding the agent in your device hardware and adding your device-specific logic.

## Create the Embedded Web App

Creating the embedded web management application can be very time consuming. It is often one of the most challenging tasks when creating device management software.

To accelerate your development cycle, the Ioto solution provides a suite of pre-built apps for local and cloud-based device management. 

For example, the [Kickstart App](/apps/samples/kickstart/) sample device management application emulates a simple smart switch. Kickstart can act as the starting point for your device user interface. It employs best practices for dynamic, responsive device management. 

The Ioto apps are part of the Ioto agent software and can be downloaded from the Builder by clicking **download** on an Ioto product entry. 

Read more at [Kickstart](https://www.embedthis.com/ioto/kickstart.html).

## Support

As you progress with your design and development, you will probably require support.

EmbedThis offers two types of support:

* Basic Support
* Developer Support

Basic support provides basic guidance covering installation and operational usage of the product.

Developer support provides in-depth developer help for design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues, and support for legacy software versions.

You can purchase support via the Builder interface under the Support menu option. You can also raise and track support issues with the EmbedThis support staff.

## Subscribe

To Subscribe for additional devices, create device clouds, or purchase support, go to the Account/Subscription menu option. Review your subscription, then click Confirm to purchase. You can enter a billing card on the Account/Billing page.

You can read more about subscriptions at: [Subscriptions](../plans/).
# Creating Cloud Managed Devices

EmbedThis Ioto is a cloud-based management service for embedded devices connected to the Internet.

It is comprised of five components:

* Device Builder
* Ioto Service
* Ioto Device Clouds
* Ioto Device Manager
* Ioto Device Agent

The **EmbedThis Device Builder** web site helps you to:

* Define, configure, and control your products.
* Manage your device clouds.
* Tailor software upgrades to your needs.
* Manage your subscription and billing for EmbedThis products and services.

The **Ioto Service** is a cloud application. It provides services for the EmbedThis Builder and manages the assignment of devices into Device Clouds.

**Ioto Device Clouds** are cloud-based hubs that run in a region of your chosing. They manage routine communications and management for your devices.

**Ioto Device Manager** is a custom device manager site created for your device cloud. From it, you and your customers can claim and manage individual devices and fleets of devices.

The **Ioto Device Agent** is a cloud-ready embedded agent for remote device management. It includes an embedded web server, embedded database, HTTP client, MQTT client and extensive AWS IoT cloud integration. The agent communicates with the Ioto Service and Device Clouds for management. See [Ioto Agent Documentation](/agent/) for in-depth details about the Ioto Agent.

The work flow for creating cloud managed devices begins with the Builder. The Builder is used to define and configure your products and device clouds.

## Creating a Product Definition

For each product type that you wish to manage from the cloud, you need to create a product definition that describes your device and nominates the device agent you wish to utilize.

## Downloading the Ioto Device Agent

Next, you download the Ioto device agent from the Builder product list.

To help you evaluate Ioto, your first device is free. Thereafter, a subscription is required.

## Customizing Device Specific Logic

Embed the Ioto agent in your device hardware and add your device specific logic. There is extensive documentation available: [Ioto Agent Doc](/agent/).

## Connecting to the Eval Cloud

If you are evaluating Ioto, you can connect to the eval cloud at **eval.ioto.me**. To connect to the eval cloud, define the **product** property in the Ioto device.json5 configuration file. Set it to the value the Builder evaluation product ID from the product list. 

## Creating a Device Cloud

When you are ready, you can create your own **Device Cloud** for your own private use.

A Device Cloud is created in an AWS region of your choice. This is important as jurisdictions are increasingly requiring that data only be stored, processed and managed locally.

When you create a device cloud, the Builder creates a private device database for your devices. Your data is always private and is never shared with any other third-parties.

You can have multiple device clouds if you require, though most users will need only one cloud for their devices.

## Device Cloud Privacy

For the ultimate in privacy and security, you can create a dedicated device cloud in your AWS account. With a dedicated device cloud, your device data goes directly from your devices to the device cloud in your AWS account. The device data is not sent through the EmbedThis cloud. 

## Registering Devices

Once a device cloud is created, you can register a device with the Builder service using the Builder Product ID and a per-device ID.

See [Device Registration](/ioto/provisioning/registration.md) in the [Ioto Agent Documentation](/agent/) for more details. When registered, you can "claim" the device for a user. See [Device Claiming](/ioto/provisioning/claiming.md) for details.

Once registered and claimed, the device is under management by the Ioto service. Management commands can be sent from the cloud to the device and device data can be sent upstream from the device to the cloud.

## Device Manager

> Perhaps the largest task in creating cloud-based managed products is creating this device management application. The size of this task as it is probably the largest single task and expense when creating IoT managed devices.

For this reason, when a device cloud is created, Ioto creates and configures a device manager site for your devices called the **Ioto Manager**.

The Ioto Manager is a generic (white-label) device manager that can be extensively customized with your logo, product name and device specific data, screens and panels.

Using the Builder, you can configure the Ioto Manager by defining device specific components, including:

* Logo
* display.json5
* schema.json5
* Extension VueJS Components (for dedicated clouds)

The schema describes your device entities and their data properties and data types. From this, the Ioto Manager is able to dynamically construct a user interface when guided by the Display.json file.

## Management App

The Ioto Manager is extremely flexible, however, there are limits, and you may want to create your own manager application that uses the Ioto APIs to provide a bespoke management experience for your devices.

Such a management app should ideally be a [Single Page](https://en.wikipedia.org/wiki/Single-page_application) web application authored using [VueJS](https://vuejs.org) or [React](https://https://reactjs.org/). This app will consume data from the Ioto cloud APIs and send device commands to Ioto for relaying to the relevant devices.


## Ioto APIs

Ioto provides a comprehensive suite of API interfaces for you to create your device management application. These APIs cover the following areas:

* Builder HTTP REST API &mdash; for managing products, device clouds and software upgrades.
* DynamoDB schema &mdash; for querying structured device data.
* Event API &mdash; for receiving event notifications over AWS EventBridge.
* MQTT Topic API &mdash; for sending and receiving device commands, data and notifications.

## Support

As you progress with your design and development, you will probably require support.

EmbedThis offers two types of support:

* Basic Support
* Developer Support

Basic support provides basic guidance covering installation and operational usage of the product.

Developer support provides in-depth developer help for design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues and support for legacy software versions.

You can purchase support via the Builder interface under the Support menu option. You can also raise and track support issues with the Embedthis support staff.

## Subscribe

To Subscribe for additional devices, create device clouds or purchase support, go to the Account/Subscription menu option and review your subscription, then click Confirm to purchase. You can enter a billing card on the Account/Billing page.
# For Embedded Engineers

>An embedded software engineer has to bridge the divide between hardware reality and business vision using software alone.

The work flow for creating connected devices with the Builder includes:

* Selecting the device agent for your product.
* Gaining access to device software.
* Gaining access to support programs and communication with EmbedThis support.
* Monitoring security vulnerabilities and security patches.

## Selecting the Device Agent

To create stand-alone managed devices, you typically integrate an embedded web server and create an embedded device management application that resides on the device.

The **Ioto Device Agent** is a cloud-enabled device agent, but it also includes a first-class embedded web server. Ioto can also be used as a stand-alone embedded web server without any cloud management features enabled.

Ioto includes our most advanced embedded web server and is a fraction the size of comparable embedded web servers (including our own). It boasts impressive throughput and efficiency scores.

We recommend choosing the Ioto device agent for all new devices, even if they are not connected to the cloud, as Ioto has the most efficient and secure embedded web server. Please read the [Device Agent Comparison](https://www.embedthis.com/ioto/comparison.html) for details.

We also offer two legacy embedded web servers:

* [Appweb](https://www.embedthis.com/appweb/)
* [GoAhead](https://www.embedthis.com/goahead/)

>Our legacy Appweb and GoAhead web servers are provided for existing customers who have embedded these web servers in existing product designs. We recommend that all customers transition to Ioto for new designs and devices.


**GoAhead** is a simple, secure embedded web server that is perhaps the world's most popular embedded web server. Originally designed in 1998, GoAhead was present at the foundation of the Internet of Things. It is compact, secure and simple to use. GoAhead is deployed in hundreds of millions of devices.

**Appweb** is a high-end, secure embedded web server for hosting sophisticated embedded web management applications. Appweb offers HTTP/2, HTTP proxy, extensive security controls, sandboxing and defensive counter-measures.


## Creating a Product Definition

For each product or product family, you need to create a Builder product definition that describes your device and selects the device agent you wish to utilize.

Depending on your licensed agent, you will have different subscription options.

![Product Edit](/images/builder/product-add.png){class="screen"}

## Downloading the Device Agent

Next, download the device agent from the Builder product list.

If you have purchased a subscription, you can download the full software or any historical version. You may download an evaluation version without purchasing a subscription.

![Download Software](/images/builder/product-list.png){class="screen"}

## Adding Device Specific Logic

Once downloaded, you can begin embedding the device agent into device hardware and adding device specific logic. There is extensive documentation for the device agents:

* [Ioto Agent Doc](/agent/)
* [Appweb Doc](https://www.embedthis.com/appweb/doc/)
* [GoAhead Doc](https://www.embedthis.com/goahead/doc/)


## Creating the Embedded Web App

Creating the embedded web management application can be very time consuming. It is often one of the most challenging tasks when creating device management software.

To accelerate your development cycle, the Ioto solution provides a suite of pre-built apps for local and cloud-based device management. 

For example, the [Kickstart App](/apps/samples/kickstart/) sample device management application emulates a simple smart switch. Kickstart can act as the starting point for your device user interface. It employs best practices for dynamic, responsive device management. 

The Ioto apps are part of the Ioto agent software and can be downloaded from the Builder by clicking **download** on an Ioto product entry. 

Read more at [Kickstart](https://www.embedthis.com/ioto/kickstart.html).

## Accessing Support

As you progress with your design and development, you will probably require support.

EmbedThis offers two types of support:

* Basic Support
* Developer Support

Basic support provides basic guidance covering installation and operational usage of the product.

Developer support provides comprehensive help with design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues, and support for legacy software versions.

You can purchase support via the Builder interface under the Support menu option. You can also raise and track support issues with the EmbedThis support staff.

## Support Issues

With an active support plan, you can use the integrated Builder support center to open support cases and track them to conclusion.

![Support Cases](/images/builder/support-case.png){class="screen"}

When opening a support case, you supply:

* A short case issue subject
* A detailed issue description
* The relevant product experiencing the issue
* Relevant files or logs
* The issue severity
* A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and thorough description of what the issue is. Please explain in sufficient detail. If your description is too brief, support staff cannot resolve the issue as quickly and will have to contact you to obtain any missing information. Please spend some time writing a complete description.

If you can, please include a link to a repository containing a test case that reproduces your issue. Reproductions should be short, correct, self-contained. They should not contain code that isn't relevant to the issue, so do **not** simply paste code from your project. Explaining how to reproduce the issue without including a test case is typically insufficient and will result in delays resolving your support issue.

### Issue Severity

Selecting an option for severity informs EmbedThis staff of the level of urgency of your issue. You may categorize an issue as low, medium, high, or critical severity. Please do not overstate the issue severity.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.

## Close Case

When an issue is resolved to your satisfaction, click the close case button.

### Product Issues

The Builder is used to track issues and security notices.

Go to the [Builder Products List](https://admin.embedthis.com/product) to see the product list and product security center.

To open a bug report, use the [Builder Support Center](https://admin.embedthis.com/support) to open
a case ticket.

## Feedback

If you have suggestions for how the Builder could make your role easier, please let us know at: [feedback@embedthis.com](mailto:feedback@embedthis.com).
# For Purchasing

>Purchasing must identify business requirements for goods and services, and find reliable suppliers to meet those requirements. Nothing is concluded without purchasing connecting the dots.

The Builder provides an intuitive subscription and billing system. It offers:

* Subscription management and configuration.
* Payment by online card.
* Optional payment by bank transfer.
* Generation of quotation PDF orders.
* Generation of subscription PDF invoices.
* Configurable invoice addressing and details.
* Automatic mailing of invoices to accounts payable.

## Managing Subscriptions

Once the desired product and support subscriptions have been defined, your subscription information is collected and presented from the Account/Subscription page.

![Subscription](/images/builder/subscription.png){class="screen"}


To review your subscription, login to [Builder Subscription](https://admin.embedthis.com/account/subscription) and click on the Account/Subscription menu option.

The subscription page displays your current, pending, and due subscriptions. It includes your products, clouds, and support plans. It provides an overview of your EmbedThis subscriptions and future renewals.


## Existing Agreement Customers

If you have an existing agreement, your licensed product definitions and support plans will already be entered. These will have been setup to continue your previously renewed subscription items. However, you can review and tailor the software maintenance options and support plan to suit your current needs.

## Current Subscriptions

Your current subscriptions are those that you have purchased previously and are still active.

The table will display products, clouds, and support subscriptions including the period for which the subscription is active.

## Confirming Subscriptions

Your subscriptions to confirm are those items that are due for renewal but you have not yet confirmed the purchase.

The table will display the products, clouds, and support subscriptions along with the price for each item.

Click the **Confirm** button to confirm the renewal and authorize the transaction. If you are authorized to pay by bank transfer, you will need to first enter a purchase order number via the **Order Details** panel.

## Upcoming Subscriptions

Your upcoming subscriptions are those you have created but are not yet due. For example, Ioto subscriptions are due at the end of each month. Before the end of the month has been reached, the subscription will appear in this section.

The table will display the products, clouds and support subscriptions and the estimated price for each item.


## Download a Quote

If your business processes require a quote PDF, you can click **Download Quote** to generate and download a quotation for the displayed items.

When you are ready, click the Confirm button to purchase. You can enter a billing card on the Account/Billing page.

## Billing

The billing center page displays your billing cards and issued invoices.

![Billing](/images/builder/billing.png){class="screen"}

## Payment Cards

Your billing cards will be displayed and the current card will be shown as the default card to use for payment. Click **Add Card** to enter a new card. Click on an existing card to modify, delete or designate a card as the default card to use for billing.

For your security, only the last 4 digits of the card number are stored for verification purposes.

## Invoices

As you are billed, invoices are created and stored. You will be emailed the invoice PDF and you can download past invoices from the invoices table.

## Invoice Details

To change the company name or billing address on your invoices, click on the **Invoice Address** button and enter the required details.

If you change the invoice address, you can click **Reissue** to re-generate the invoice with the updated invoice address.

## Renewal Reminders

The account owner will be automatically emailed renewal reminders before your subscriptions expires.

## Feedback

If you have suggestions for how the Builder could make your role easier, please let us know at: [feedback@embedthis.com](mailto:feedback@embedthis.com).
# Software Updates

Today, it's essential to regularly **update and upgrade** the software on your devices to fix security vulnerabilities, introduce new features, and enhance overall performance.

With the [EmbedThis Builder](https://www.embedthis.com/builder/), you can create, deploy, manage and monitor software updates that are delivered Over-The-Air (OTA) to keep your devices secure and up-to-date.

Using the Builder OTA update manager, you can selectively deploy updates to any desired subset of your device population. Updates can be published that will be applied to your devices according to a **distribution policy**. In this way, you can selectively update all your device or specific subsets as you require.

## Device Agent Support 

Using the Builder, you can deploy updates to any device, regardless of the device agent you utilize. The Ioto, GoAhead, Appweb device agents pre-integrate software update capability. If your device does not have one of these device agents, you can incorporate update capability device using the stand-alone [Embedthis Updater](https://github.com/embedthis.updater).

## Configuring Updates

![Software Modify](/images/builder/software-edit.png){class="screen"}

To configure a software update, you supply the following parameters:

* Product
* Update version
* Update description
* Distribution policy
* Device Cloud
* Update image


## Update Selection

Each day, the updater agent will typically connect to the device cloud for a "checkin". During this request, the agent will submit the update request to the device cloud to see if an update is available for this device.

The device cloud will retrieve the most recent updates and check the updates in reverse version order and select the first matching update for the device.

The device cloud service will evaluate the distribution policy expression when the device checks-in and if the policy matches for the device, the URL for the update image will be returned to the device agent. The agent will then fetch the update image and verify the integrity of the update image. If verified, the **scripts/update** script is invoked to apply the update. 

If you are running the Ioto agent on an RTOS, without scripting, you will need to watch and react to the the event **device:update** using the rWatch API.

## Update Limits

Implementing a gradual update strategy can help minimize load and risk. Updating a large number of devices simultaneously can impose an excessive burden on your service, so staggering the rollout can distribute the load more evenly.

Despite thorough testing, some updates might still be considered "risky." To minimize this risk, you can update a small subset of your device population first to see if the update causes any issues.

The update service provides update limits and gradual rollout factors that allow you to control the rate of updates.

* **Max device limit** and **device percentage** limits define the maximum number of devices that can be updated. Once either limit is reached, further updates are prevented.

* For gradual rollouts, you can set a **max updates per period**, which limits the number of updates to a specified number over a defined period. For example, you could set a limit of 1000 updates per hour (3600 seconds).

If a device meets the distribution policy and rollout limits, the URL for the update image will be returned to the update agent. The agent will then fetch the update image and verify its integrity. If the image is verified, the **scripts/update** script is invoked to apply the update. If you are running the agent on an RTOS without scripting, you will need to monitor and respond to the **device:update** event using the rWatch API.

## Product

When defining an update, select the product for which the software update applies. A device cloud may be managing many different products and the product selection in conjunction with the distribution policy defines the subset of devices that are eligible to receive the update.

You should define multiple product definitions if the different devices consistently require different firmware.

## Software Version

The version number is your software release version number identifying this software release. The version numbers are compatible with the [SemVer 2.0](https://semver.org/) version specification.

If you are using the Ioto agent, the current version for your device is defined via the **version** property in the **ioto.json5** configuration file. NOTE: your device is versioned separately to the Ioto agent itself which has its own version string.

## Software Release Description

The description is an informative description for your purposes.

## Software Distribution Policy

The distribution policy is a simple Javascript-like expression that is evaluated at runtime to determine if the update is relevant for a specific device. If you leave the policy blank, then all devices whoes version is less than the software release version will be updated.

Here is a sample policy expression:

    major >= 1 && minor >= 1 && patch >= 5 && memory >= 256 && ports == 32

The properties contained in the device.json5 configuration file are made available as variables. In this case, the "memory" and "ports" variables are supplied in the device.json5 file. 

The full device version is accessible as the varible "version" and the software update version is provided via the "newVersion" variable. 

The default policy is uses the inbuilt function **semver** which compares two version strings. This default policy compares if the current version is earlier than the new update version.

    semver(version, "<", newVersion)

The device version string is also split into SemVer components:

* major
* minor
* patch

The query language supports the operators:

    + - * / ( ) ^ ! % == != < <= > >= ^= ^!= $= $!= << >> && || <> ><

These extension operators have the following meaning:

* a ^= b     means a starts with the string b
* a ^!= b    means a does not start with the string b
* a $= b     means a ends with the string b
* a $!= b    means a does not end with the string b
* a >< b     means a contains the string b
* a <> b     means a does not contain the string b

Sub-expressions can be grouped with parenthesis and the boolean operators && and || can group conditional operands.

Regular expressions (delimited by slashes) may be used with the "==" and "!=" operators. The regular expression can be on either side of the operator.

The policy expression language understands the types: Numbers, Boolean, String literals, Regular Expressions and null.

The policy expression is run-time limited to evaluate up to 20 terms. This is to protect your cloud against denial of service attacks.

## Opt-in Updates

Devices can implement an opt-in update strategy by defining variables in the device context that are passed with the update checkin request. These variables can be examined by the distribution policy expression. If a variable is set only when a device/user opts-in, then the distribution policy can target only those devices.

For example, say a device defined an opt-in field called **try-beta-features** that was set to "1" when users toggled a UI checkbox to signify they wished to receive beta features. The device would then pass this field with the update checkin request and the distribution policy could test that value.

    try-beta-features == 1

## Rollback Updates

You can rollback errant updates by defining an update that has a distribution policy pinned to the errant version. For example, say the update **1.2.3** was bad and you wished to rollback devices to the prior **1.2.2** version. You would first disable the 1.2.3 bad update by deselecting the **Enable** checkbox for that update. Then, you would define an update 1.2.2 that had a distribution policy like this:

    version == '1.2.3'

This would target only the 1.2.3 devices and roll them back to version 1.2.2. 

## Device Cloud

Update images are stored in AWS S3 and distributed globally using the AWS CDN. When defining updates, you select the relevant device cloud to store and apply the updates. If you have multiple clouds, you will need to define updates in each cloud.

## Applying Updates

When the update is downloaded to the device and verified, the update agent will save the image in a temporary file. Your device can be notified of an update by one of two means:

* The "./script/update" shell script will be invoked and passed the update image filename.
* Ioto will indicate an update is available via the "device:update" signal. See rSignal/rWatch for details.

## Enable

You can selectively enable or disable a release at any time via the Builder.# Creating Device Clouds

To create a device cloud, navigate to the Cloud list from the side nav bar and click the **Add Cloud*  button. This will display the "Add Cloud" panel.

![Cloud Configure](/images/builder/cloud-add.png){class="screen width-60"}

A device cloud is created in a specific region so you have control and privacy over your device data. 

## Evaluating Ioto

If you are evaluating Ioto, you can skip this step and connect to the pre-built Eval cloud at **eval.ioto.me**. The evaluation cloud is perfect for quickly connecting Ioto devices to the cloud to test the platform.

To connect to the eval cloud, define the **product** property in the Ioto **device.json5** configuration file. Set it to the value the Builder evaluation product ID from the product list. The default Ioto source code download has this property already defined in the device.json5 file. 

## Data Privacy

When you are ready, you can create one or more device clouds to segment your products and devices.  A single device cloud can be created for all your devices or you can segment your devices into fleets, each with their own device cloud.

For privacy and governance, you may need to separate the device data for specific users into separate fleets. These can have a dedicated device cloud to ensure total data isolation for those users.

## Creating a Device Cloud

When creating a device cloud, you specify a cloud name and select an AWS region to locate your device data.

## Cloud Name

Choose a unique name to identify the cloud configuration within your account.

Enter the appropriate AWS cloud region that is closest to the location of your devices. For example, if your devices are on the US east coast, consider using the US East region and enter: "us-east-1".


## Device Clouds

You can create two types of device clouds:

* Hosted by EmbedThis
* Dedicated in your own AWS account

A hosted device cloud is a device cloud for your devices and customers that is hosted by EmbedThis on secure AWS IoT infrastructure. You do not need to have or manage your own AWS account to use a hosted device cloud.

A dedicated device cloud is created in your AWS account so you have the ultimate in the control and privacy of your device data. With a dedicated device cloud, device data goes directly from your devices to the device cloud in your AWS account. The device data is not sent through EmbedThis servers. 

A dedicated cloud has additional capabilities including:

* Full access to AWS services
* No data storage or I/O limits
* Enhanced security
* Custom cloud-side logic
* Fully bespoke device manager with custom components

## Dedicated Device Clouds

A dedicated device cloud requires that you have your own AWS account. We recommend you use a fresh account without any other applications or AWS resources.

When creating a dedicated device cloud, you can optionally control the permissions used in your AWS account via the following AWS roles and policies:

* AWS IAM Role
* Device IAM Role
* IoT Policy

# App Data Schema

Device clouds use a database schema to define what device specific data should be stored in the cloud and what are the device entities to manage.

The schema describes the device entities (components) and their data properties and types. From this, apps are able to dynamically construct a user interface when guided by the display.json5 file.

The Builder defines a default schema when you create the device cloud. This schema supports a generic key/value store, and a device command queue. Initially, you can use the default schema, but as you progress, you may wish to define your own data entities to store device specific data.

The device schema is fixed per device cloud and is common across all apps for that device cloud. You can modify the device schema via the **Cloud Modify** panel.

![Cloud Modify](/images/builder/cloud-modify-schema.avif){class="screen width-60"}

For more information about the device schema, See the Ioto service documentation:

* [Device Tables / Database Schemas](/ioto/database/schemas/)
* [Database Replication](/ioto/database/replication.html)


## IAM Role

EmbedThis controls access to your AWS account via an AWS IAM role. This role grants limited access to your account for EmbedThis Builder.

The IAM role is created in your account via an AWS CloudFormation template. The template creates the necessary IAM role and resources to enable Builder services in your account.

Once your cloud account is connected, Builder will create the necessary cloud resources in your account, including a device DynamoDB database and service Lambda.

## Device Keys IAM Role

The device cloud can create and manage AWS IAM access keys for your devices that can be used to enable devices to issue requests to the device cloud and directly to AWS services.

When creating the cloud, you can specify the name of a custom IAM role that defines the permissions for the access keys given to devices.

The device cloud will generate temporary IAM access keys based on this role.

## IoT Policy

Most device communications with the cloud are performed using the MQTT protocol. When Ioto provisions the device, it initializes the MQTT channel using an IoT policy that controls what resources the device can access and what commands the device can initiate.

You can specify the name of a custom IoT policy to precisely control what capabilities the device will have via MQTT.# Cloud Account

When you create a device cloud, the Builder will create the required cloud resources in an AWS account.

If you are creating a **hosted** device cloud, Ioto will create the cloud in an AWS account owned and operated by EmbedThis for you in a region of your chosing, close to your location.

If you are creating a **dedicated** device cloud, Ioto will create the cloud in your existing AWS account. It is best practice to create a dedicated AWS account for each device cloud you create and not use a pre-existing AWS account that is used for other purposes.  This helps isolate problems and errors and can make issues much simpler.

>If you expect to create more than 1,000 devices over the lifetime of your product, you should use a dedicated device cloud for your production deployment as hosted device clouds are limited to 1,000 devices.

## Cloud Regions

The Ioto Device Cloud is created in the geographical region that you select. For efficiency, you should select a region that is closest to the majority of your devices. Another consideration is where do you want the device data to be stored.

Ioto stores device data in the region you nominate so you have total control and privacy regarding your device data. Device data goes directly from your devices to your device database in the device cloud in your region. The device data does not transit other third-parties services.

## Dedicated Device Clouds

When you create a dedicated device cloud in your AWS account, the Builder and Ioto will create the following cloud resources:

* An AWS DynamoDB database registry of your devices.
* An AWS DynamoDB database exclusively for your device data.
* AWS DynamoDB streams to replicate device data to and from the cloud.
* An AWS API Gateway to authorize remote API access to device data.
* An AWS Cognito User Pool to authenticate user access.
* An AWS CloudFront and S3 site for the Ioto Device Manager site.
* AWS Route53 domain for the Ioto Device Manager site.
* AWS Lambda functions for cloud-side device management.
* IAM Roles to restrict remote access.
* AWS IoT Core policies and message routing rules.
* AWS IoT Things to model your devices in the cloud.

## AWS Pre-requisites

When you create an AWS account, AWS may not immediately grant you permission to create some resources that are required to support a device cloud. It is best to be proactive and immediately after creating the AWS account, ask AWS to increase the following limits:

* Ability to create an AWS CloudFront web site
* Ability to send emails from AWS SES

Ioto requires these abilities to complete creation of the device cloud and to create device managers.  These approvals may take up to a few days. 

When asking to increase your AWS SES limit, AWS will ask you several questions. The following FAQ will help you answer their form questions.

Q: Tell us how often you send email,

A: Emails will be sent by the Ioto manager when a user registers to create a new account or has account issues. The estimated rate will be per customer 1-2 times per month.

Q: How you maintain your recipient lists,

A: Customer sign up for our service and the customer gets a record in Cognito. The user list is managed in Cognito.

Q: How you manage bounces, complaints, and unsubscribe requests.

A: Customers must maintain a valid email address in their account as part of the TOS. CloudWatch metrics are used to track SES bound metrics.

Q: Provide examples of the email you plan to send so we can ensure that you are sending high-quality content.

```
PRODUCT NAME Welcome</h1>
Your NAME user account has been setup.

Please follow this link now and set your password:

LINK

This link will expire in 24 hours.

You recieved this message because ${email} was listed as the contact address
       when requesting the Embedthis Builder invite.
```
# Device Clouds

Device clouds are management hubs from which you can centrally operate and manage one more more devices.

A device cloud stores device data, manages communications with your devices and provides a device management application to manage devices. By aggregating critical device data in the cloud, you can easily manage your devices and extract important data analytics and intelligence from your devices.

You can create one or more device clouds to segment the management of your products and devices.


![Builder Dashboard](/images/builder/dashboard.png){class="screen"}

## Device Cloud Services

The Ioto device cloud performs the following services:

* Create and configure the necessary cloud resources for device management.
* Automatically provision Ioto-based devices with certificates for secure communications.
* Setup MQTT communications between devices and the cloud.
* Create and maintain a cloud-based device database store for centralized management and analytics.
* Create a secure device manager application for managing single devices or fleets of devices.

## Device Cloud Types

Ioto supports three types of device clouds:

Type | Description
-|-
eval | Cloud for evaluating Ioto 
hosted | Cloud hosted in an EmbedThis AWS account
dedicated | Cloud hosted in your own AWS account

When creating a device cloud, the Builder will create all the necessary resources for IoT management. This process results in a configured, complete, integrated and live IoT cloud capability.

## Eval Cloud

The Eval cloud will probably be your first experience with Ioto device clouds.

The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It enables you to connect a device running the Ioto agent to the cloud and to receive device data and manage the device.

The Eval cloud is free to use for a few devices for a short period of time for evaluation purposes.

## Hosted Device Clouds

A hosted device cloud is a device cloud for your devices and customers that is hosted by EmbedThis on secure AWS IoT infrastructure. You do not need to have or manage your own AWS account to use a hosted device cloud.

Device data goes directly from your devices to the device cloud in the region you select when creating the device cloud. Data does not transit other regions or third-party services.  This is important as jurisdictions are increasingly requiring that data only be stored, processed and managed locally.

Unlike other IoT services, Ioto provides decreased latency by locating device data in a region close to you. This lowers cost and boosts performance of your cloud-based management solution.

Hosted device clouds are limited to a maximum of 1,000 devices. If you expect to exceed this number of devices over the lifetime of your product, you should use a dedicated device cloud for your production deployment.

A hosted device cloud provides:

* AWS DynamoDB database exclusively for your device data.
* AWS DynamoDB streams to replicate device data to and from the cloud.
* AWS API Gateway to authorize remote API access to device data.
* AWS Cognito User Pool to authenticate user access.
* AWS CloudFront and S3 site for the Ioto Device Manager site.
* AWS Route53 domain for the Ioto Device Manager site.
* AWS Lambda functions for cloud-side device management.
* AWS IoT Core policies and message routing rules.
* AWS IoT Things to model your devices in the cloud.

## Dedicated Device Clouds

A dedicated device cloud is created in your AWS account so you have the ultimate in the control and privacy of your device data. With a dedicated device cloud, device data goes directly from your devices to the device cloud in your AWS account. The device data is not sent through EmbedThis servers. The data is encrypted throughout and you have total control.

Dedicated clouds support an enhanced set of AWS services beyond those available with hosted device clouds. These include:

* Device log file capture and storage in AWS CloudWatch logs
* Audit operations via AWS CloudTrail
* Device AWS keys to initiate AWS API operations from the device
* Ability to have server-side custom logic responding to device events

If you expect to create more than 1,000 devices over the lifetime of your product, you should use a dedicated device cloud for your production deployment as hosted device clouds are limited to 1,000 devices.

## Device Manager

For each device cloud you can create one or more Device Manager apps from which to manage your devices. The Ioto Device Manager is a generic, white-labeled device manager that is uniquely configured for your devices. It can extensively customized with your logo, product name, device data and device specific screens and interface including custom logic.

The Ioto Device Manager apps are hosted by EmbedThis on a sub-domain of your choosing under the ioto.me domain. You can select a unique sub-domain that reflects your company or product's brand. Alternately, you can choose and associate a custom domain name.

## Device Certificates

Devices require X.509 certificates to securely connect and communicate with the cloud. The certificates are used to uniquely identify and authenticate devices and then to encrypt communications to prevent tampering or eavesdropping.

Ioto will automatically create and distribute the required certificates as devices are assigned to a device cloud. This eliminates the pain of certificate distribution.

## Device Communications

During device provisioning, the Ioto service will setup the necessary AWS resources to enable secure efficient messaging via AWS IoT core using the MQTT protocol.

MQTT is a messaging protocol for IoT. It is a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices.

When connected, your management applications can control devices, send commands and retrieve data using the MQTT messaging service.

## Device Data Aggregation

Collecting, aggregating and sending device data to a central management store can be complex and costly. Ioto takes the hassle out of exporting device data to the cloud by synchronizing the Ioto device agent database with an AWS DynamoDB database in your device cloud.

Data written on the device to the management database will be transparently exported to the cloud. Similarly, data written to the cloud database will be distributed to the appropriate devices as required. No programming is required.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-device and per-table basis.

This is similar to AWS Global Tables, but instead of acting inside AWS between AWS regions, it is between an AWS region and a device.

This replicated device database is unique to Ioto and dramatically simplifies the creation of IoT solutions.

## Device Metrics and Analytics

AWS provides a comprehensive metric service via CloudWatch Metrics. The Ioto agent can emit metrics that will be captured by the device cloud and managed by CloudWatch.

Using these metrics, you can create detailed device analytics and dashboards to focus on any aspect of your device or fleet performance.

## Device Access Keys

For dedicated device clouds, Ioto can optionally create and manage AWS IAM access keys for your devices. AWS uses IAM access keys to authenticate and authorize actors on AWS resources. The Ioto device cloud can create specific IAM keys to enable devices to issue requests to the device cloud and AWS services.

The Ioto generated temporary IAM access keys have tightly controlled access permissions. The keys are automatically reissued as required and can be centrally controlled.


## Device Logging

For dedicated device clouds, device logs and files can be captured and sent to AWS CloudWatch logs for storage, governance and analysis.

The Ioto agent can be configured without coding, to capture any O/S log or program output and send it to CloudWatch Logs. The Ioto agent log is similarly exportable.


<!--
## Account Audit

For dedicated device clouds, Ioto configures and enables CloudTrail, which captures an audit trail of **all** activity on your account and device cloud.  This records a complete log to AWS S3 so you can reliably audit operations and determine root cause of any security incidents.

--># Support


EmbedThis offers three types of support:

* Community Support
* Basic Commercial Support
* Developer Commercial Support

Community support is provided by the community via the public [Ioto Github Site](https://github.com/embedthis/ioto/discussions). 

Basic commercial support provides guidance covering installation and operational usage of the product.

Developer commercial support provides developer help for design and implementation issues. This covers embedded development, cloud-based device management, developer coding and debugging issues. Developer support requires that basic support also be enabled.

If you are interested in commercial paid support programs, please sign up via the Builder portal at: [https://admin.embedthis.com](https://admin.embedthis.com).

## Security Center

The Builder portal has a comprehensive product security center that is used to track issues and security notices. To display product issues, go to the [Builder Products List](https://admin.embedthis.com/product) and define or select your product. This will display the product security center below the product list.

## Community Support

The public [Ioto Github Site](https://github.com/embedthis/ioto/discussions) provides an avenue for you to ask questions, share your ideas and engage with other community members. Support here is a community-based and not offered directly by EmbedThis.

## Commerical Support

With a paid support program, you can open a new support case via the Builder by clicking on Create Case. 

When you open a support case, please make sure you do the following:

* Fully describe any issue &mdash; don't be too brief
* The exact sequence of operations to provoke the issue
* Specify the software version and how you built it
* Describe your system platform: O/S and hardware
* Provide a stand-alone test case that reproduces the issue
* If relevant, upload edited log files and command line trace

It is easy to be too brief in describing issues. To solve quickly, please provide as much detail as you can when describing issues.

### Product Issues

The Builder online site is used to track issues and security notices.

Go to the [Builder Products List](https://admin.embedthis.com/product) to see the product list and product security center.

To open a bug report, use the [Builder Support Center](https://admin.embedthis.com/support) to open
a case ticket.


# Support Cases

With an active support plan, you can use the integrated Builder support center to open support cases and track them to conclusion.

![Support Cases](/images/builder/support-case.png){class="screen"}

When opening a support case, you supply:

* A short case issue subject
* A detailed issue description
* The relevant product experiencing the issue
* Attach relevant files or logs
* The issue severity
* A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and complete description of what the issue is. Please explain in sufficient detail. Most people are too brief in the description and it results in delays addressing issues as support staff go back and forth with questions. Please spend some time writing a complete description.

If you can, please include a link to a gist or repository containing a test case or sample that reproduces your issue. Reproductions should be short, correct, self-contained and should not contain code that isn't relevant to the issue. Please do NOT just paste code from your project. Explaining how to reproduce the issue alone is typically insufficient.

### Issue Severity

You can set the issue severity which helps EmbedThis staff understand the impact of your issue. Set to low, medium, high or critical. Please do not overstate the issue severity. NOTE: the severity does not equate to a priority with which your issue will be addressed.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.

## Close Case

When an issue is closed to your satisfaction, click the close case button.
# EmbedThis<sup>&reg;</sup> Builder

The Builder is a site and service that helps you create and manage your internet connected devices. It is used to define your connected device products, download device agent software, and configure, control and manage cloud-based services. It is also the portal to purchase subscriptions, receive support, and resolve issues with the guidance of EmbedThis staff. 

To get started with the Builder, you need to create an account.

![Builder Site](/images/builder/home.png){class="screen"}

## Builder Overview

Using the Builder you can perform the following tasks:

* Create product definitions for your connected devices.
* Select, license, and purchase embedded device agents.
* Create and deploy device clouds from which to manage your devices.
* Upload device data models for synchronizing device data in the cloud.
* Configure and manage Over-The-Air software upgrades for your devices.
* Access support documentation and samples.
* Connect with Embedthis support to raise and track support issues.
* Purchase and pay online for your EmbedThis subscriptions.

## Getting Started

Depending on your use case, your process flow with the Builder will vary.

We've created guided walk-throughs depending on your role:

* [For Product Managers](start/for-product-managers.md)
* [For Cloud Engineers](start/for-cloud-engineers.md)
* [For Embedded Engineers](start/for-embedded-engineers.md)
* [For Purchasing and Procurement Roles](start/for-purchasing.md)

And your use case:

* [Cloud-Managed Devices](start/cloud-managed.md)
* [Device-Managed Devices](start/device-managed.md)
* [Managing Subscriptions](plans/subscriptions.md)
# Action Triggers

An Action Trigger will monitor a data source and evaluate device and service data to see if a predefined condition is true and if so, invoke the associated action.

Three varieties of action triggers are supported:

* Direct
* Streamed
* Polled

**Direct** triggers respond to user actions or HTTP requests to the device cloud endpoints.

**Streamed** triggers monitor data as it is received by the device cloud from devices.

**Polled** triggers run at a per-trigger frequency. This can be set to any number of minutes, hours, or days.  While event triggers are run whenever the designated event is received by the Ioto device cloud.

Source | Type | Description
-|-|-
Database Value | Polled | Read a device database item value.
Database Sync | Event | Monitor synchronized device data that matches trigger expressions in the device schema.
HTTP | Event | Respond to an incoming HTTP request.
Metric | Polled | Monitor device and service metrics.
User | Event | Respond to a user action from a device manager interface.

## Matching Triggers

When a trigger event is received or polled, the associated trigger data is evaluated and compared with a **trigger expression**. If the expression evaluates to true, the trigger action is automatically invoked.  For example, if you were polling a **temperature** field for a device, you could define a trigger expression to activate when the temperature exceeds 100 degrees.

When a trigger is activatated, it will pass parameters to the action to customize its behavior based on the specific trigger conditions.

## Trigger Expressions

The trigger expression is a JavaScript like expression that is evaluated to yield a true or false result.
If true, the Trigger action is invoked.

The trigger expression is provided with a context of variables that can be accessed by the expression. The context is a blend of user provided variables and internal state. The fields for a database item are provided as named variables. For metric data sources, the metric result is provided as a **value** variable. For example, you can test a metric value via:

```
value > 0
```

The query language supports the operators:

    + - * / ( ) ^ ! % == != < <= > >= ^= ^!= $= $!= << >> && || <> ><

These extension operators have the following meaning:

* a ^= b     means a starts with the string b
* a ^!= b    means a does not start with the string b
* a $= b     means a ends with the string b
* a $!= b    means a does not end with the string b
* a >< b     means a contains the string b
* a <> b     means a does not contain the string b

Sub-expressions can be grouped with parenthesis and the boolean operators && and || can group conditional operands.

Regular expressions (delimited by slashes) may be used with the "==" and "!=" operators. The regular expression can be on either side of the operator.

The expression language understands the types: Numbers, Boolean, String literals, Regular Expressions and null.

The expression is run-time limited to evaluate up to 100 terms. This is to protect your cloud against denial of service attacks.

## Database Value

Database values can be queried according to a polling schedule. To specify the database item to query, you must specify the:

* Table name
* Item keys
* Item filter properties

The Builder and Device Cloud provides data modeling and storage of application data. Data items can be retrieved by specifying the appropriate item key. Other properties can be provided to further filter the data to be queried.

## Polled Metric Value 

Metric values can also be queried according to a polling schedule. To specify the metric item to query, you must specify the:

* Metric namespace
* Metric name
* Metric dimensions
* Metric statistic
* Metric period

Metrics are grouped into namespaces and have a unique metric name. Metrics can also have dimensions where a set of resources may have unique metric values for each resource.

The metric statistics supported are: min, max, avg, sum, count and current. Sum is the sum of values over the request period. Count is the number of values sampled over the period. Current is the most recent updated value.

The metric period should be set to the last 5 minutes, hour, day, week, month or year.

The Builder console provides pulldown lists for each of these fields based on the available metrics on your system.

For more information on metrics, please see [Metrics](/agent/metrics/#metric-naming).

## Streamed Device Data

As device data is sent to the device cloud, data can be used to activate an automation trigger.

## REST API requests

You can issue REST API requests to invoke an automation.

```bash
https://DEVICE_CLOUD/tok/trigger/invoke
```

The POST request accepts a JSON body with the following parameters:

* name
* context

Where **name** is the name of the trigger to invoke. The **context** contains data that will be made available to your automation trigger and action request message/body. These context values can be expanded by using a **${data}** token in the message/body. You can add any context variables you wish to the context.

For example:

```bash
curl -X POST \
    https://xxxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com/tok/action/invoke \
    -H 'Authorization: xxxxxxxxxxxxxxxxxxxxxxxxxx' \
    -H 'Content-Type: application/json' \
    -d '{"name":"AutomationTest", "context":{"data":42}}'
```

When you edit your automation in the Builder, the sample curl command will be displayed.

See [Authentication](/ioto/ref/authentication.html) for how to authenticate HTTP requests.

## UI Triggers

The UI triggers is an alias for the REST API trigger. The DevCore device manager will invoke the REST API when a user clicks on a widget with the associated action defined.# Automations Overview

When developing an IoT solution, it's ideal to implement **automatic**, pre-programmed responses for when your devices or fleet encounter important conditions. Constantly monitoring every aspect of device status around the clock is **impractical**. By defining automated actions, you can enhance your device fleet's intelligence, responsiveness, and availability.

Automated actions can transform your device cloud from a passive data repository into an intelligent, active and adaptive service. For example, automated actions can be used for the following scenarios:

* **Display device errors** in an alert list in the manager device UI.
* **Aggregate fault metrics** for devices and create dashboards for fleet health.
* **Send alert email** notifications to field staff for servicing.
* **Integrate with systems** and services from 3rd parties. 
* **Invoke device actions** in response to user input or measured device state.
* **Compute device state** to be reflected in the device manager UI.

The Builder provides Automated Actions that can detect a wide variety of conditions and automatically initiate configured actions to alert or respond accordingly.

## Ioto Automations

The Builder enables automation via Actions and Alerts. Automation Actions monitor device and cloud states to evaluate data and determine if a predefined trigger condition is met. Automated Actions are invoked by condition triggers to respond and implement a specific remedy or notification. Alerts are a type of action that create human readable messages for display by the Builder console or Device Manager UI.

The EmbedThis Builder is used to create Actions that are deployed to the relevant device cloud and device apps. To create an Action, navigate to the Automations sidebar menu option and click Add Action.

![Action List](/images/builder/action-list.avif){class="screen"}

When creating an Action, you define the **Trigger** that monitors device or cloud state for specific conditions. **Condition Triggers** can be defined for various sources, including device data, device metrics, cloud state, HTTP endpoints, or device app actions.

To learn more, read about: 

* [Condition Triggers](triggers.md)
* [Actions](actions.md)
* [Alerts](alerts.md)
# Alerts

The Builder provides special actions to create Alert message notices.

Alert notices can be created in either the Builder or Device Manager consoles via the the **Alert** and **Builder Alert** actions. When combined with triggers, Alert notices provide log of device error and other important conditions and state.

Alerts log messages are saved in the Builder and Device Cloud databases. Alert notices are uniquely fingerprinted by the trigger context at the time of activation. Repeat alerts for the same fingerprint are aggregated and a count of repeats is displayed in the console.

![Alert View](/images/builder/alert-view.png){class="screen"}
# Actions

When triggered, automation actions run to implement an appropriate notification or response action. Examples of automation actions include creating alerts, defining metrics, performing device operations, updating the device database and sending email notifications.

Automation actions respond to initiation by triggers and utilize the trigger context as parameters to tailor the action's execution.

### Action Types

Type | Description
-|-
Builder Alert | Create an alert in the Builder account
Builder Metric | Create a metric in the Builder account
Database | Create, update or remove an item in the device database
Device | Perform a device operation: release or reboot
Manager Alert | Create an alert in the device manager account
Manager Metric | Define a device metric
HTTP | Invoke a HTTP REST API
Email* | Send an email message
Lambda* | Invoke a Lambda 
MQTT Message* | Send an MQTT message
EventBridge* | Send an EventBridge event

The Email, Lambda, MQTT and EventBridge actions require a dedicated device cloud.

Some actions are configured with specific parameters. For example, an email action defines the email recipients, whereas an HTTP action defines the HTTP method, URL and HTTP headers. The action parameters are combined with the trigger parameters when the action is run.

## Message Context

Most actions have a message or request body textarea. This message can contain context variables that are expanded at runtime. For example, an email action could take a email message:

    The metric value is ${value}

When the action is invoked, the `${value}` reference is replaced with the metric value. The context of variables is a blend of variables provided to the trigger (such as via a HTTP POST body), the result of the trigger (metric or database value) and internal state.

## Rearming Delay

After a trigger has been activated and an associated action has been run, it can be useful to suppress further actions for a period of time. The rearm delay can be one or more minutes to suppress further triggers from activating.

## Enable

Actions can be enabled or disabled at any time.

![Action List](/images/builder/action-list.png){class="screen"}# Creating Apps

You can create one or more device apps using the Builder's app list.

![App List](/images/builder/app-list.png){class="screen"}

From the App list, click on the `Add` button to create a new app or click on the `Edit` icon for an existing app. This will display the App configuration panel from which you can customize the: App domain, name, title, logo, code base, and UI display definition.

![App Modify](/images/builder/app-modify.png){class="screen width-70"}

### App Domain Name

Apps are hosted by EmbedThis on a sub-domain of your choosing under the **ioto.me** domain. You can select a unique sub-domain that reflects your company or product's brand. The sub-domain name you choose must be globally unique. Alternatively, you can register your own domain name and point that to the underlying app site.

To use an Ioto sub-domain, enter the sub-domain name of your choosing. To use a self-hosted domain, check the "Self Hosted Domain" checkbox and enter your full domain name.

### App Code Base

By default, apps are created using the EmbedThis [DevCore](/apps/) UI framework which provides the core app functionality needed by device management apps.

You can rebuild the DevCore and upload either a custom build or your own bespoke app using the Ioto cloud APIs.

### App Title

The App title can be modified to display an alternate name in the user interface navigation frame at the top of the browser window. Set this to your desired product name. Alternately, this title can be defined in the display.json5 definition file described below.

### Upload CSS Stylesheet

You can optionally upload a CSS stylesheeet to be used by the app. You can reference CSS styles when using the Dashboard and Widget property editors.

To upload, click on the **Upload CSS** checkbox and click on the CSS file selection box to select a stylesheet file to upload.

To clear a previously uploaded stylesheet, click on "Clear CSS".

### Upload Logo

Apps may be customized by uploading your own corporate or product logo. This logo will be used on the App's login screen and in the top navigation bar of the app.  Your logo should be a small, square, transparent logo in a format supported by most browsers.

To upload, check the `Upload Logo` and click on the Logo Image file selection box to select a logo file to upload. To clear a previously uploaded logo, click on `Clear Logo`.

### Upload Display

For apps based on the DevCore, the app UI including navigation structure and UI pages are defined using a **display.json5** configuration file. This file also defines the app's features, themes, pages and panels. You can upload a custom display.json5 which will be used by your app. 

The display.json5 file defines the following items:

* Displayed Name
* Display color theme including dark and light modes
* Menu items and options
* UI pages
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

To upload, check the `Upload Display` and click on the Display file selection box to select a `display.json5` file to upload. To clear a previously uploaded display, click on `Clear Display`.

## Next Steps

Now that your app is configured, you can launch your app from the app list by clicking on the `Launch` link for your app on the Builder App list. This will  open the app in a new browser tab. Once launched, you can run the App Designer in the app itself to further configure the UI. # Device Apps

The Builder enables the creation of device management apps tailored to your devices and services. It supports app configurations for both local management through the agent’s embedded web server and remote management via the cloud.

With the flexibility to create multiple apps, the Builder can cater to diverse user groups such as end-users, developers, and support teams. For cloud-based management, the Builder seamlessly hosts and globally distributes these applications through device clouds, ensuring efficient deployment and accessibility at scale.

![Home Page](/images/eco/eco-home.avif){class="screen width-50 center"}

<div class="clear" />

## DevCore UI Framework

Device management apps can be developed using the EmbedThis `DevCore` UI framework or implemented as custom solutions leveraging the Ioto APIs. The `DevCore` framework is a flexible and robust UI library designed for managing devices across mobile, tablet, and desktop platforms. It provides core features such as authentication, state management, request handling, navigation and routing, as well as tools for device configuration and data visualization.

## Default Management App

Device applications are defined from the Builder's App list after specifying key parameters, such as the app name, title, logo, serving domain, code base, and the app UI display.

The UI of an app based upon the `DevCore` is defined via a `display.json5` configuration file. This defines the UI navigation and page order. The display config file permits quick and easy modification of the app to add and remove UI pages. 

### Developer App

When you first define an app, the Builder creates a default management app based upon on the DevCore framework. This app has generic `Developer` UI definition suitable for testing your devices as you develop your IoT solution. This app can be progressively customized or extended to meet custom UI requirements.

![Ioto Device Manager](/images/manager/standard.avif){class="screen"}

## Low-Code App Designer

Once the app is created, you can launch the app from the Builer's app list and then you can modify the app UI and pages using the integrated low-code `App Designer`. This tool offers a visual interface for designing app UI pages efficiently greatly reducing development time.

![App Designer](/images/builder/flow-layout.avif){class="screen width-100"}

For scenarios requiring deeper customization, EmbedThis provides full control over the app's user interface via the `display.json5` UI definition file. Custom UI components can be developed and added to the display definition to address unique requirements. Additionally, with access to the app's source code, engineers can fine-tune both functionality and appearance to meet specific use cases.

### Custom Apps

If you have specific requirements that mean you cannot use the App Designer and the DevCore, you can utilize the Builder and Ioto service APIs directly and create your device app using any app framework you require.

## Sample Desktop App

![Home Page](/images/manager/home.png){class="screen"}
# Authentication Tokens

The EmbedThis Builder and the Ioto service use tokens to securely authenticate and authorize access to the builder and device clouds.

Each token can be used for a purpose that is specified via the token's **type**. When used for this purpose, the token bearer can assume the tokens **role** to act upon the system.

![Token List](/images/builder/token-list.png){class="screen"}

The Token List is segmented into three groups

* Service Tokens &mdash; Tokens for access to the Builder service and Product ID tokens for registration.
* Cloud Tokens &mdash; Tokens for access to Device Clouds.
* Device Tokens &mdash; Device tokens for access by devices to a Device Cloud.

Tokens have the follow properties:

* Type &mdash; the token purpose
* Description &mdash; human readable token description
* Enable &mdash; whether the token is currently enabled or disabled
* Expires &mdash; the date upon which the token expires and cannot be used
* Role &mdash; the authorized role the token bearer will assume
* ID &mdash; the token ID to present when using the token for access
* Cloud &mdash; the device cloud ID if the token is created by the device cloud


## Token Type

The following token types are currently used by the Builder and Ioto

* BuilderAPI &mdash; Used for general API access to the Builder API as an administrator.
* ProductID &mdash; Used when registering devices in the device.json5 file.
* CloudID &mdash; Used when claiming devices for management for a device cloud.
* CloudToBuilder &mdash; Used by device clouds to issue requests to the builder.
* BuilderToCloud &mdash;  Used by the builder to issue requests to a device cloud.

![Token Modify](/images/builder/token-edit.png){class="screen"}


## Token Description

The token description may be modified to help you document the purpose of a specific token.

## Token Enable

A token can be temporarily disabled by **suspending** a token. Should you experience a cyber attack or breach, you can immediately suspend tokens to minimize the damage while you investigate. When all is clear, you can **resume**, **replace** or **delete** the offending tokens.

## Token Expiry

Each token will expire on a specified date. You can modify tokens to change the expiry date.

## Token Role

When a token is presented, it grants the access to the relevant resources using the token's role.

The following roles are supported:

* public &mdash; Grants minimum privilege appropriate for unauthenticated users.
* user &mdash; Grants read-only access at the "user" level.
* admin &mdash; Grants administrator access which provides general read/write access.
* owner &mdash; Grants administrator and owner access which provides access to billing.
* device &mdash; Grants access suitable for a device.
* builder &mdash; Grants access suitable for the builder to act upon a device cloud.

## Token Actions

* New &mdash; Create a new token. If you selected an existing token, the new token will clone the properties of the original token. The original token is not impacted.
* Replace &mdash; An original token is expired and a new active token is created with the same type, description and role.
* Resume &mdash; Resume a suspended token.
* Suspend &mdash; Suspend a token. The expiry date is not changed.
* Delete &mdash; Delete a token.

## Using Tokens

When using REST APIs, you can present the token ID in the X-Token or Authorization HTTP headers. The format should be like:

```
X-Token: 01GEXXXXXXXXXXXXXXXXXXXXXX
```

From the token list, you can select the **clipboard** icon in the token's ID column to copy the ID to your PC's clipboard.

Embedthis has deep and broad experience creating embedded device, management interfaces and web applications that have been deployed in hundreds of millions of devices world-wide.

>We specialize in doing *tough, critical* technology and applications. Our clients usually have stringent requirements and high expectations. We pride ourselves in exceeding these expectations.

## Service Models

We can work with your team in a variety of ways:

**Outsourced development**. Give us the whole or a piece of your project and we will deliver back to you complete, reliable, secure and documented solutions. Our work is clean, proven and easy to assimilate back into your organization. We'll even train you.

**Consultant**. Use us to help, validate and confirm your designs and directions. We can help spare you critical mistakes.

**Team member**. Regard us as one of your team. We can do the hard parts and participate in your development process and deliver critical pieces on time and under budget. Some companies keep us on retainer as an ongoing part of their team.

Embedthis can work on a time and materials basis or fixed price quotation after the provision of detailed requirements.

## Capabilities

Embedthis has extensive experience with many platforms and technologies including:

* IoT and cloud-based device management especially AWS and AWS IoT.
* Linux, Windows, VxWorks, FreeRTOS and other embedded operating systems.
* X86, Arm, Mips and other embedded CPUs.
* TCP/IP, TLS, MQTT and other networking.
* AWS Cloud including: IoT, DynamoDB, Lambda, IAM, CloudFront, EC2, ECS, ...
* Javascript, HTML, VueJS and single page web applications.
* Embedded Device security.

Please contact us at [sales@embedthis.com](mailto:sales@embedthis.com) to discuss your project needs or sign up and pay-as-you-go at the [Builder Support Center](https://admin.embedthis.com/support).

## Consulting Help

Whether you have a new device project or an existing product, a review of your embedded management design can spot and fix potential issues. We can review your design, security and code to ensure you are on the right path.

### Cloud Management

Managing devices from the cloud is non-trivial. It requires familiarity with both embedded design and cloud environments. Embedthis can guide you through the process of moving to the cloud. We can assist with:

* Setting up your EmbedThis Ioto account
* Configuring your AWS IoT account
* Building and integrating the Ioto agent
* Creating a connected embedded device
* Connecting to the cloud and device communications
* Creating cloud-based management applications

### Data Modeling and Mapping

It is critical when designing your device data schema to ensure that you can support all your desired analytics and operational management requirements. We can assist in creating and reviewing your device data model so that it can meet your needs of today and tomorrow.

## Billing

Consulting services hours can be purchased as needed via the [Builder Support Center](https://admin.embedthis.com/support).

There is a minimum commitment of 2 hours and you can purchase developer services as you require.


## Contact

To discuss your project, please contact us at [Embedthis Services](mailto:services@embedthis.com).

## Customer Quotes

> "Embedthis are hands down the best embedded engineering team I have ever worked with. Their code is exceptionally clean, elegant, and an inspiration to avid software developers. Embedthis knows how to hit a deadline and provide extraordinary transparency in the development process. If you're doing embedded work, I can't think of anyone that would be better to have on your team. They are really pushing the edge of what tiny processors can do, putting the web platform on the head of a pin. Literally." *Scott Penberthy, Gilt Group.*

>"Embedthis are great to work with and they played a critical role in designing and building our embedded web management application. They were well organized, knew how to cleanly walk through the process; guiding us each step of the way. They provided excellent support as we worked through the final details to modify the code before delivery to our customer." *Greg Hoepfner, Colmek.*

>"Embedthis was an integral part of our development and they did outstanding work for us. They consistently exceeded our expectations while delivering complex pieces of technology. They enabled us to launch to market much sooner than expected and their code was clean, compact and very high quality." *Roy Satterthwaite, Bling Software.*
# Devices

The Builder maintains a list of all devices for each device cloud in your account.
From this list you can `release` and `remove` devices. Most device management tasks are done from the Device app.

![Devices](/images/builder/device-list.avif){.screen}

For each device, the device list shows the device name, the device cloud, and the device state. The state is whether the device is claimed or not by a user for management.

From the list you can release a device from being managed by a user. This is useful when a device is transferred to a new user.

You can also remove a device from the device cloud. This is useful when a device is no longer in use and you want to remove it from the device cloud.

![Devices](/images/builder/release-device.avif){.screen}
# Device Table Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-table basis.

## Databases

The Ioto service creates an AWS DynamoDB database table called **ioto** in each device cloud. The **ioto** database table contains the device data and cloud management data for all connected devices in that cloud.

Similarly, the Ioto device agent creates a local embedded database to hold structured data for the device.

These two databases are connected and Ioto replicates changes between device and cloud to keep them in sync.

## Why Synchronization?

The Ioto Database Synchronization service dramatically eases the task of centralizing the data management of a pool of devices. Each device can store data locally and it will be transparently, efficiently and automatically replicated to the cloud. Once in the cloud, it can be easily interrogated and queried for analytics, operational control and intelligence.

Each side has fast, predictable local access to the data. Coupled with reliable replication semantics you can work locally while Ioto takes care of the replication.

## How It Works

To replicate cloud-side data, the Ioto service uses AWS DynamoDB streams to capture modifications made to the cloud-side table data. The stream is connected to a Lambda function that encodes and sends the updates via MQTT messages to a special message topic that is only known to the specific device.

The Ioto device agent subscribes to this topic and receives MQTT messages containing the changed data. The agent then applies those changes to the local database.

In reverse, the Ioto agent registers a database trigger that is called whenever local changes are made to the device's database. When the trigger is invoked, the agent sends an MQTT message with the changes to the Ioto service that updates the cloud database.

Ioto keeps track of the last update sent and received and will retransmit lost updates.

When a device is rebooted after being offline, it sends a "sync" message to the Ioto service to retrieve all changes made to the cloud database since the last change notification was received from the cloud. In this way, changes made while the device is offline or disconnected are not lost.

## Controlling Replication

The cloud-side Ioto DynamoDB table (ioto) and the Ioto agent database both use a [OneTable](https://doc.onetable.io/) schema that defines application data entities, how items are stored, what indexes are used and how to process table data. For example:

```js
const DeviceSchema = {
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault: {sync: 'up'},
    },
    models: {},
}
```

The **"process"** property of the schema defines how to process table data and how tables are synchronized between the device and cloud.

For each database item type in the schema, you can create an entry in the "process" property that specifies where items of that type should be stored and how they should be synchronized.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for item types that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Requirements

Any model that defines a **sync** direction of "up" or "down" must include the following properties in the model definition:

Property | Definition | Description
-|-|-
updated | {type: 'date', readonly: true} | Timestamp for when the item was last updated
_source | {type: 'string', hidden: true} | The source of the last update

The **updated** timestamp property is used to determine the set of updates that have been made to the database since the device last connected to the device cloud. The **_source** property is used to determine the direction of synchronization for an item.

The **bin/make-schema** script that is used when building the Ioto agent and apps will automatically add these properties for synchronized models.# Database Processing

The **schema.process** is a map of properties that control how data is stored in the database and how the data is processed. 

The `process` definitions define the following attributes:

* Where the database item will be stored: device / cloud / both.
* In what direction the database syncronization will flow: to-device / to-cloud / both.
* What metrics should be created from the data stream.

For each item type, you may define an entry in the **process** collection. For example:

```js
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

Each map entry may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| enable | `string` | Control where the item is stored. Set to 'cloud' for in the cloud, 'device' for on the device and 'both' if in both locations. Defaults to 'both'. |
| sync | `string` | Define the direction of the data synchronization. Set to 'down' for down to the device, 'up' for up to the cloud, or 'both' for bi-directional. Defaults to null. |
| metrics | `Array` | Array of metric definitions. See below for details.|
| notify | `boolean` | Issue an AWS EventBridge notification event for matching data. Defaults to false.|

## Database Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-item basis.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

>To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for items that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Metrics

For data that is synchronized to the cloud, you can create custom metrics from the data stream. These metrics can then be displayed or graphed in the Device Manager.

These metrics can be created by creating a Builder Automation action to trigger when specific data values are encountered.

<!--
In the **process** section for an item, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:
```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

This will create a `temperature` metric from the item's `temp` attribute.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| buffer | `map` | Metric buffering directives. Defaults to null.|
| dimensions | `array` | Array of metric dimensions. Defaults to null.|
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| where | `string` | Conditional expression to select items for which to create metrics. |

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.

The `dimensions` property contains an array of dimensions that scope the metric. The elements of the dimensions array can be either field names or objects that map field names into a dimension name. If the values are quoted, they are used as literal values. If unquoted, they are regarded as database item field names.

For example:

```js
process: {
    Fault:   { 
        sync: 'up' 
        metrics: [{
            namespace: 'Embedthis/Device',
            fields: ['temperature'],
            dimensions: [{}, {Device: 'deviceId'}]
        }]
    }
}
```
#### Where Expressions

The `where` property can be used to select matching items for which to create metrics. `Where` expressions use a query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

See [Database Metrics](/agent/metrics/) for details.
-->

## Event Notification

For dedicated device clouds, you can issue AWS EventBridge events for matching database items via the **notify** property.  The `notify` property is set to the EventBridge bus name. It can be set to "default" or any custom EventBridge bus name.

The database item will be passed to the EventBridge bus as the event context data using the `Embedthis/Ioto` as the event **Source**.

For example:

```js
{
    Store: {
        enable: 'both',
        sync: 'up',
        notify: 'default',
    }
}
```
# Model Attributes

The database schema supports the following attribute properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| default | `string` | Default value to use when creating model items or when reading items without a value.|
| generate | `string|boolean` | Set to 'ulid' or 'uuid' to automatically create a new ID value for the attribute when creating new items.|
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. If unset, the field will use the table default value for isoDates. Default to the schema params value. |
| nulls | `boolean` | Set to true to store null values or false to remove attributes set to null. Default false. |
| required | `boolean` | Set to true if the attribute is required. |
| schema | `object` | Nested schema. |
| ttl | `boolean` | When set to true for date fields, the date value will define when the item should be transparently removed. |
| type | `Type or string` | Field data type. |
| value | `string` | Template to derive the value of the attribute. These attributes are "hidden" by default. |


If the **default** property defines the default value for an attribute. If no value is provided for the attribute when creating a new item, the **default** value will be used.

If the **isoDates** property is defined and not-null, it will override the table isoDates value. Set to true to store the field date value as an ISO date string. Set to false to store the date as a Unix epoch date number.

The **schema** property permits nested field definitions. The parent property must be an Object as the type of items in arrays are defined using the **items** property.

The **type** properties defines the attribute data type. Valid types include: String, Number, Boolean, Date, Object, Null, Array, Buffer (or Binary) and Set. The object type is mapped to a **map**, the array type is mapped to a **list**. Dates are stored as Unix numeric epoch date stamps unless the **isoDates** parameter is true, in which case the dates are store as ISO date strings. Binary data is supplied via **buffer** types and is stored as base64 strings in DynamoDB.

The **value** property defines a literal string template that is used to compute the attribute value. This is useful for computing key values from other properties, creating compound (composite) sort keys or for packing fields into a single DynamoDB attribute when using GSIs.

String templates are similar to JavaScript string templates. The template string may contain **${name}** references to other fields defined in the entity model. If any of the variable references are undefined when an API is called, the computed field value will be undefined and the attribute will be omitted from the operation.

If you call **find** or any query API and do not provide all the properties needed to resolve the complete value template, such as if some of the ${var} references are unresolved, OneTable will take the resolved leading portion and create a **begins with** key condition for that portion of the value template.
# Database Schemas

Ioto uses database schemas to define what are the database data entities and how these will be stored in the database.

A schema specifies the application item types called models. If you are from a SQL background, think "tables". The schema also defines the item fields, indexes and other data access and replication parameters.

Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) schema format, implementing the [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).

The same schema is used for the cloud side AWS DynamoDB table and for the device side embedded database.

## Schema Definition

Schemas look like this:

```js
const DeviceSchema = {
    format: 'onetable:1.1.0',
    version: '0.0.1',
    indexes: {
        primary: {hash: 'pk', sort: 'sk'},
    },
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault:   { 
            sync: 'up',
            triggers: true,
        },
    },
    //  These are the database tables
    models: {
        Status: {
            pk: {type: 'string', value: 'status#'},
            sk: {type: 'string', value: 'status#'},
            parameters: {type: 'object'},
            version: {type: 'string'},
            updated: {type: 'date'},
        },
        Fault: {
            pk: {type: 'string', value: 'device#${deviceId}'},
            sk: {type: 'string', value: 'fault#${id}'},
            deviceId: {type: 'string', required: true},
            id: {type: 'string', generate: 'ulid'},
            timestamp: {type: 'date', required: true},
            source: {type: 'string', required: true},
            severity: {
                type: 'string',
                required: true,
                enum: ['info', 'warn', 'error', 'critical', 'fatal'],
            },
            subject: {type: 'string', required: true},
            message: {type: 'string', required: true},
        },
    },
    params: {
        isoDates: true,
        timestamps: true,
    },
}
```

## Schema Purpose

AWS DynamoDB can operate most efficiently at scale when using a single table with multiple application entities stored in the one table. To make this design pattern easy to implement, application data schemas such as the one used by [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) provide the mapping between application level entities and raw database items.

Ioto uses the OneTable schema in both the DynamoDB table and in the Ioto agent database.

When coupled with a high-level database API such as that offered by OneTable and by the Ioto Agent Database, accessing and managing device data is both performant and straightforward.

## DynamoDB Schema

In Device Clouds, Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) NodeJS library for all access to the **ioto** DynamoDB table. This library has an extensive suite of features beyond those implemented by the Ioto device agent database.

Please consult the [OneTable](https://github.com/sensedeep/dynamodb-onetable) library and [OneTable Documentation](https://doc.onetable.io/) for background.

## Schema Properties

The valid properties of the **schema** object are:

| Property |  Type  | Description                                                                                  |
| -------- | :----: | -------------------------------------------------------------------------------------------- |
| format   | string | Reserved. Must be set to **onetable:1.1.0**                                                  |
| indexes  | object | Hash of indexes used by the table.                                                           |
| models   | object | Hash of item types describing the item keys, indexes and attributes.                    |
| params   | object | Hash of properties controlling how data is stored in the table.                              |
| process  | object | Hash of items describing where the items should be stored and how they should be replicated. |
| version  | string | A SemVer compatible version string.                                                          |

The **format** property specifies the schema format version and must be set to **onetable:1.1.0**.

The **indexes** property specifies the key structure for the primary, local and secondary indexes.

The **models** property contains one or more database item types with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties.

The **params** property defines additional parameters for table data formats.

The **process** map defines how database items should be processed, stored, replicated and whether metrics should be calculated from the data stream.

The **version** property defines a version for your Database design. It must be a [SemVer](https://semver.org/) compatible version string. The version string is used by tools and consumers of the schema to understand compatibility constraints for the schema and stored data.

## Schema Models

The schema defines the database item types as models. For example, consider a music example:

```js
models: {
    album: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        songs:  { type: 'number' },
    },
    artist: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        address: {
            type: Object, schema: {
                street: { type: 'string' },
                city: { type: 'string' },
                zip: { type: 'string' },
            },
        },
    }
}
```

For each item type, all the entity fields are defined by specifying the field type, validations and other operational characteristics (uniqueness, IDs and templates).

The valid types are: array, binary, boolean, date, number, object, and string.

The database will automatically add an item type property via the **\_type** attribute. This is set to the name of the model. You can modify this via the **params.typeField** setting.

## Value Templates

The value of a field can be computed based on the value of other fields and a formatting "value template". This is useful for decoupling your key structure from your entity fields.

The value template is like a Javascript string literal where the value of fields are expressed in a "${field}" format. At runtime, the field references are expanded with the item's value for the named field.

In the example above, the primary key "pk" is calculated from the entity type **\_type** and the **name** field by using the value template: **${_type}:${name}**.

## Nested Schemas

For object attributes, you can define a nested schema for the object properties, as in the example above (repeated below).

A nested schema uses the **schema** property to define a nested map of attributes. Schemas can be nested to an arbitrary depth.

```js
address: {
    type: Object, schema: {
        street: { type: 'string' },
        city: { type: 'string' },
        zip: { type: 'string' }
    }
}
```

## Database Indexes

Schema indexes are defined using the **schema.indexes** property.

The **indexes** property can contain one or more indexes and must contain the **primary** key. Additional indexes will be treated as secondary Indexes.

!!!Note
    Ioto currently only supports the primary index.

```js
const MySchema = {
    indexes: {
        primary: {
            hash: 'pk',         //  Schema property name of the hash key
            sort: 'sk',         //  Schema property name of the sort key
        },
        //  Zero or more global secondary or local secondary indexes
        gs1: {
            hash: 'gs1pk',
            sort: 'gs1sk',
        }
    }
}
```

## Schema Params

The **schema.params** is a map of properties that control how data is stored in the database. It may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| createdField | `string` | Name of the "created" timestamp attribute. Defaults to "created". |
| hidden | `boolean` | Hides templated (value) attributes in Javascript properties. Default true. |
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. Default false. |
| nulls | `boolean` | Store nulls in database attributes vs remove attributes set to null. Default false. |
| timestamps | `boolean | string` | Make "created" and "updated" timestamps in items. Set to true to create both. Set to 'create' for only "created" timestamp and set to "update" for only an "updated" timestamp. See also: "updatedField" and "createdField" properties. Default false. |
| typeField | `string` | Name of the "type" attribute. Default "_type". |
| updatedField | `string` | Name of the "updated" timestamp attribute. Default "updated". |

For example:

```js
const MySchema = {
    params: {
        isoDates: true,
        timestamps: true,
    }
}
```


## References

- [DynamoDB OneTable Overview](https://www.sensedeep.com/blog/posts/2021/dynamodb-onetable-tour.html)
- [DynamoDB with OneTable Schemas](https://www.sensedeep.com/blog/posts/2021/dynamodb-schemas.html)
- [Data Modeling for DynamoDB](https://www.sensedeep.com/blog/posts/2021/dynamodb-singletable-design.html)
- [SenseDeep DynamoDB Data Browser](https://www.sensedeep.com/blog/posts/series/dynamodb-studio/data-browser.html)
- [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).
# Device Tables Overview

Ioto Device Tables is a global, replicated, multi-active database solution that transparently synchronizes data between devices and the cloud.

Similar to AWS DynamoDB Global Tables for replicating data between AWS regions, Ioto Device Tables connects a cloud-side AWS DynamoDB database to a device-resident Ioto embedded database.

Device Tables take the pain out of replicating data between devices and the cloud. Without additional code, it will automatically and transparently synchronize data and state between your devices and the cloud.

Device Tables delivers fast, predictable local read and write access while offering automatic replication of changes.

## Database Replication Features

* Transparent replication between cloud and devices.
* Bi-directional synchronization.
* Per-table synchronization control.
* Resilient catch-up should the device or cloud go offline.
* Database triggers for notification when state data changes.
* Automatic creation of CustomMetrics from the device data stream.

## Challenge

>Aggregating device data in the cloud is not a simple problem.

To centralize device state typically requires several crucial steps:

* State must be captured in the device.
* State must be sent reliably to the cloud despite network disconnections.
* State must be stored and managed in the cloud.
* Conflicts with simultaneous updates must be resolved.
* State updates from the cloud must be sent to the device reliably despite devices being offline.

These factors combine to make centrally aggregating device data decidedly non-trivial.

>Ioto Device Tables solves these issues for you, so you can focus on your device specific logic and value.

## Ioto Agent Embedded Database

The Ioto agent embedded database is an ultra high performance NoSQL database for embedded applications. It supports fast, in-memory, local data access and optional transparent synchronization of data to and from the cloud. The Ioto agent embedded database is designed to be compatible with AWS DynamoDB so that it can easily replicate structured device data to the cloud. It is modeled after [AWS DynamoDB](https://aws.amazon.com/dynamodb/) and the [OneTable](https://doc.onetable.io/) access library.

The database uses Red/black binary search indexes and has controllable local persistence to disk and to the cloud on a per-table basis.

## JSON documents

The database stores items as JSON documents that are a nested collection of properties to arbitrary depth. As JSON is one of the most prevalent data exchange formats, storing data in JSON greatly reduces data replication and API transmission costs.

Ioto includes a powerful JSON query engine that you can use to query and manipulate JSON documents.

## Database Features

* High performance NoSQL management document database.
* JSON document items with flexible query API.
* Efficient import and export of database items.
* Red/black binary search indexes.
* Simple, non-waiting API.
* Controllable persistence with change triggers.
* Transparent bi-directional data synchronization with the cloud.
* Unified data schema between device and cloud databases.
* Based on AWS DynamoDB and DynamoDB OneTable.

# Dashboard

Manage UI Dashboards.

## Create
**Endpoint**

```HTTP
POST /dashboard/create

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Default |
| - | - | - | - |
| css | array |  |  |
| design | boolean |  |  |
| emulate | string |  |  |
| dashboard | boolean |  |  |
| fixed | boolean |  |  |
| framed | boolean |  |  |
| full | boolean |  |  |
| live | boolean |  |  |
| name | string | yes |  |
| options | object |  |  |
| range | object |  |  |
| refresh | number |  |  |
| snap | boolean |  |  |
| toolbar | boolean |  |  |
| type | string |  |  |
| widgets | array |  | [] |
| widgetCss | array |  |  |

**Widget** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Find
**Endpoint**

```HTTP
POST /dashboard/find

```
**Authorized User Role**

```
user

```
**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Get
**Endpoint**

```HTTP
POST /dashboard/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| name | string |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Remove
**Endpoint**

```HTTP
POST /dashboard/remove

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

## Update
**Endpoint**

```HTTP
POST /dashboard/update

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Default |
| - | - | - | - |
| css | array |  |  |
| design | boolean |  |  |
| emulate | string |  |  |
| fixed | boolean |  |  |
| framed | boolean |  |  |
| full | boolean |  |  |
| id | string |  |  |
| layout | string |  |  |
| live | boolean |  |  |
| name | string | yes |  |
| options | object |  |  |
| range | object |  |  |
| refresh | number |  |  |
| snap | boolean |  |  |
| toolbar | boolean |  |  |
| type | string |  |  |
| widgets | array |  | [] |
| widgetCss | array |  |  |

**Widget** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



# Metric

API to manage metrics including the ability to get and set metrics, and to get a list of available metrics.<br><br>        The Ioto service creates metrics for device and service data. It stores the current live and historical metric values. Metrics are calculated for for the last "5 minutes", hour, day, week, month, and year. Statistics are kept for the average, min, max, count and the sum of metric values.<br>        <br>        Metrics are named and grouped into [Namespaces](/ioto/metrics/#metric-naming) with metric [Dimensions](/ioto/metrics/#metric-naming) selecting instances of a metric for a specific resoure.

**See Also**

* [Metrics](/ioto/metrics/)

## Get
Get an accumulated metric. <br><br>                This API is used by devices to retrieve a metric statistic over the MQTT protocol.<br>                <br>                To get metrics over REST HTTP, use the **fetch** API.

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /metric/get

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Default | Notes |
| - | - | - | - |
| dimensions | object |  | Dimensions for metric. |
| metric | string |  | Metric name. |
| period | number | 300 | Metric timespan period. |
| statistic | string | avg | Metric statistic. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Metric** 

An array of Metric items.

| Field | Type | Notes |
| - | - | - |
| dimensions | object | Dimensions for the metric. |
| metric | string | Metric name. |
| namespace | string | Always set to Embedthis/Device. |
| owner | string | The service owning the metric. |
| period | number | Metric timespan period. |
| points | array | Array of data points. |
| samples | number | Number of data points in the period. |

**Dimensions** 

Dimensions for the metric.

| Field | Type |
| - | - |
| * | any |


**Point** 

An array of Points items.

| Field | Type | Notes |
| - | - | - |
| value | number | Metric value. |
| timestamp | number | Last update to the metric value in seconds since Jan 1, 1970. |
| count | number | Number of data values contributing to the metric value. |


## GetMetricList
Get a list of available metrics.

**Endpoint**

```HTTP
POST /metric/getMetricList

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Role | Notes |
| - | - | - | - | - |
| cloudId | string | yes | owner | Override, device cloud containing the metrics. |
| namespace | string |  |  | Metric namespace. If not provided, the API returns a list of namespaces. |
| metric | string |  |  | If not provided, returns a list of available metrics. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| namespaces | array | Returns the requested namespace. If not provided, returns a list of available namespaces. |
| metrics | array | If a namespace is provided, returns a list of available metrics. |
| dimensions | array | If a namespace and metric are provided, returns a list of available metric dimensions. |

## GetDeviceSchema
**Endpoint**

```HTTP
POST /metric/getDeviceSchema

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| cloudId | string |

**Response** 

A object.


## Fetch
Fetch metric values.<br>                <br>                This API fetches multiple metric values in a single request.

**Endpoint**

```HTTP
POST /metric/fetch

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| items | array | yes | Array of metric requests. |
| deviceId | string | yes | Device ID owning the metrics. |

**Metric Request** 

An array of Items items.

| Field | Type | Notes |
| - | - | - |
| accumulate | boolean | Accumulate result into a single result. |
| cloudId | string | Device Cloud ID. |
| dimensions | object | Dimensions for metric. |
| field | string | Database field name. |
| metric | string | Metric name. |
| model | string | Database model name. |
| namespace | string | Must be set to Embedthis/Device. |
| period | number | Metric timespan period. |
| statistic | string | Metric statistic. Select from: avg, min, max, count, sum. |


**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Metric** 

An array of Metric Array items.

| Field | Type | Notes |
| - | - | - |
| dimensions | object | Dimensions for the metric. |
| metric | string | Metric name. |
| namespace | string | Always set to Embedthis/Device. |
| owner | string | The service owning the metric. |
| period | number | Metric timespan period. |
| points | array | Array of data points (see below). |
| samples | number | Number of data points in the period. |
| * | any |  |

**Dimensions** 

Dimensions for the metric.

| Field | Type |
| - | - |
| * | any |


**Point** 

An array of Points items.

| Field | Type | Notes |
| - | - | - |
| value | number | Metric value. |
| timestamp | number | Last update to the metric value in seconds since Jan 1, 1970. |
| count | number | Number of data values contributing to the metric value. |


## Set
Set a metric value.<br><br>                This API is used by devices to emit a metric value. It is sent over MQTT rather than via REST.

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /metric/set

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Notes |
| - | - | - |
| metric | string | Metric name. |
| value | number | Metric value. |
| dimensions | array | Array of dimensions for metric. |
| buffer | object | Metric buffering options. |

# Provision

Device provisioning and management APIs.<br><br>These APIs provide devices with the necessary provisioning APIs to manage communications with a device cloud.

## GetCerts
Provision a device with MQTT certificates.<br><br>After a device has been claimed for management by a user into a device cloud, the device can call "getCerts" to request provisioning of MQTT certificates to secure communications.<br><br>This call returns the certificate, private key and communications endpoint to use for secure MQTT communications with the device cloud.

**Endpoint**

```HTTP
POST /provision/getCerts

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

MQTT certificate and endpoints for device communications.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Manager Account ID. |
| certificate | string | X.509 certificate. |
| endpoint | string | MQTT host endpoint for communciations. |
| id | string | Device ID. |
| key | string | X.509 certificate key. |
| port | number | MQTT TCP/IP port number. |
| thing | string | AWS IoT Core thing name for the device. |

## GetCreds
**Get IAM credentials**

Get IAM credentials for use in the device that is hosted in a dedicated cloud.<br><br>This will create temprorary IAM credentials based on the configured Cloud.deviceRole (default IotoDeviceRole).<br>These credentials can be used with appropriate AWS SDK or Ioto AWS Sigv4 APIs.

**Endpoint**

```HTTP
POST /provision/getCreds

```
**Authorized User Role**

```
device

```
**Response** 

A set of AWS IAM credentials that can be used with AWS APIs.

| Field | Type | Notes |
| - | - | - |
| accessKeyId | string | AWS access key ID. |
| secretAccessKey | string | AWS secret access key. |
| sessionToken | string | AWS credentials session token. |
| expires | date | When the credentials expire. |
| region | string | AWS region. |

## Update
**Device update**

Check for software updates.

**Endpoint**

```HTTP
POST /provision/update

```
**Authorized User Role**

```
update

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| product | string | yes |
| version | string | yes |
| test | boolean |  |
| * | any |  |

**Response** 

| Field | Type | Notes |
| - | - | - |
| checksum | string | Download checksum. |
| version | string | Version to update to. |
| url | string | Download URL for the software update. |
| update | string | Selected update (quote on report). |

## UpdateReport
**Device update report**

Post update status.

**Endpoint**

```HTTP
POST /provision/updateReport

```
**Authorized User Role**

```
update

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| update | string | yes |
| success | boolean | yes |

# Manager

Manage Manager.

## Get
**Endpoint**

```HTTP
POST /manager/get

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| app | string |
| certArn | string |
| cloudFront | string |
| cloudId | string |
| css | string |
| distributionId | string |
| display | string |
| domain | string |
| error | string |
| id | string |
| logo | string |
| name | string |
| owner | string |
| priorDomain | string |
| provisioned | date |
| region | string |
| title | string |
| type | string |
| version | string |

## GetSignedUrl
**Endpoint**

```HTTP
POST /manager/getSignedUrl

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| clean | boolean |
| command | string |
| filename | string |
| mimeType | string |

**Response** 

A signed URL string.


## Provision
**Endpoint**

```HTTP
POST /manager/provision

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| assets | object |  |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| app | string |
| certArn | string |
| cloudFront | string |
| cloudId | string |
| css | string |
| distributionId | string |
| display | string |
| domain | string |
| error | string |
| id | string |
| logo | string |
| name | string |
| owner | string |
| priorDomain | string |
| provisioned | date |
| region | string |
| title | string |
| type | string |
| version | string |

## Update
**Endpoint**

```HTTP
POST /manager/update

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| app | string |
| cloudId | string |
| css | string |
| display | string |
| domain | string |
| id | string |
| logo | string |
| name | string |
| owner | string |
| priorDomain | string |
| region | string |
| title | string |
| version | string |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| app | string |
| certArn | string |
| cloudFront | string |
| cloudId | string |
| css | string |
| distributionId | string |
| display | string |
| domain | string |
| error | string |
| id | string |
| logo | string |
| name | string |
| owner | string |
| priorDomain | string |
| provisioned | date |
| region | string |
| title | string |
| type | string |
| version | string |

# Alert

Manage Alerts.

## Find
**Endpoint**

```HTTP
POST /alert/find

```
**Authorized User Role**

```
user

```
**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Alert** 

An array of Alert items.

| Field | Type | Notes |
| - | - | - |
| seq | string |  |
| accountId | string |  |
| context | object |  |
| cloudId | string | Owning device cloud ID. |
| count | number |  |
| id | string | Unique alert ID. |
| name | string |  |
| message | string |  |
| severity | string |  |
| subject | string |  |
| resolved | boolean |  |
| timestamp | date |  |

## Get
**Endpoint**

```HTTP
POST /alert/get

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

**Response** 

| Field | Type | Notes |
| - | - | - |
| seq | string |  |
| accountId | string |  |
| context | object |  |
| cloudId | string | Owning device cloud ID. |
| count | number |  |
| id | string | Unique alert ID. |
| name | string |  |
| message | string |  |
| severity | string |  |
| subject | string |  |
| resolved | boolean |  |
| timestamp | date |  |

## Remove
**Endpoint**

```HTTP
POST /alert/remove

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

## Update
**Endpoint**

```HTTP
POST /alert/update

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| resolved | boolean |

**Response** 

| Field | Type | Notes |
| - | - | - |
| seq | string |  |
| accountId | string |  |
| context | object |  |
| cloudId | string | Owning device cloud ID. |
| count | number |  |
| id | string | Unique alert ID. |
| name | string |  |
| message | string |  |
| severity | string |  |
| subject | string |  |
| resolved | boolean |  |
| timestamp | date |  |

# Account

Account Management. <br>        <br>        Account APIs operate on the user account utilized when obtaining the login AccessToken. If using a CloudAPI token, which provides the **owner** role capability, the target account can be provided via the **accountId** request property to most APIs. <br><br>        Note: Accounts are created by the User.login API when a new user first logs in.

## Create
**Create an account**

This API will create the account record and the account's first user. Subsequent users can be added via the User.create API. .

**Endpoint**

```HTTP
POST /account/create

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| email | string | yes | A unique, valid email address to use as the master account email address and the first user's email address. |
| name | string | yes | Account or company name. |

**Response** 

| Field | Type |
| - | - |
| account | Account |
| user | User |

**Account** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |


**User** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |


## Close
**Close account**

Close an account and remove all allocated resources.  This will remove all users, devices, dashboards, and the account itself.  This operation cannot be reversed. <br>                <br>                This API can be invoked by a user closing their device manager account. It can also be invoked to close any user account if caller has the **owner** role via the CloudAPI token. .

**Endpoint**

```HTTP
POST /account/close

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Override account to close. |

## Get
**Get account**

Get an account that match the supplied properties. If no email or id provided, return the logged in account.

**Endpoint**

```HTTP
POST /account/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Query by account ID. |
| email | string | owner | Query by email. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

## Find
**Find accounts**

Find a list of accounts that match the supplied properties. If no email or id provided, return list of accounts (requires "owner" role).

**Endpoint**

```HTTP
POST /account/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Query by account ID. |
| email | string | owner | Query by email address. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Account** 

An array of Account items.

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

## UpdateIdentity
Update the account name and email address.

**Endpoint**

```HTTP
POST /account/updateIdentity

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner |  |
| email | string |  | Account email address. |
| name | string |  | Account or company name. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

# Store

This API provides MQTT messages to get/set values from the key/value Store.<br>        <br>        If you need a REST API, use the Generic API with the **_type** set to 'Store'.

## Get
**Get data from the store**

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /store/get

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type |
| - | - |
| key | string |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account. |
| deviceId | string | Owning device. |
| key | string | Data item key. |
| value | object | Data item value. |
| type | string | Data type. Set to "number" or "string". |
| updated | date | When data item last updated. |
| expires | date | When data item should be deleted. |

## Set
**Set data in the store**

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /store/set

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Notes |
| - | - | - |
| key | string | Data item unique key. |
| expires | number | Date when to expire. Set to number of milliseconds since Jan 1, 1970. Date.getTime(). |
| value | object | Set to a number or string. |
| type | string | Set to "number" or "string". |

# User

User Management.

## Create
Create a new user and optionally send an email invitation to join the service. When the user follows the invitation and registers, their email address wil be confirmed before they are logged into the service.

**Endpoint**

```HTTP
POST /user/create

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| email | string | yes | User email address. |
| role | string | yes | Authorized role. Select from "user", "admin" or "owner". |
| sendInvite | boolean |  | Send an email invitation. |

**Response** 

A user record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Get
**Endpoint**

```HTTP
POST /user/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role |
| - | - | - |
| email | string | admin |
| id | string | admin |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Find
**Endpoint**

```HTTP
POST /user/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role |
| - | - | - |
| email | string | admin |
| id | string | admin |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**User** 

An array of User items.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Login
**Login the authenticated user**

**Endpoint**

```HTTP
POST /user/login

```
**Authorized User Role**

```
public

```
**Request Body** 

| Field | Type |
| - | - |
| invite | string |
| register | boolean |

**Response** 

Account and user records with useful cached data.

| Field | Type | Notes |
| - | - | - |
| account | object |  |
| user | object |  |

**Account** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |


**User** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |


## Remove
**Endpoint**

```HTTP
POST /user/remove

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| email | string |
| id | string |

## Update
**Update a user identity**

**Endpoint**

```HTTP
POST /user/update

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| email | string |
| first | string |
| id | string |
| last | string |
| preferences | object |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## UpdateRole
**Endpoint**

```HTTP
POST /user/updateRole

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Role |
| - | - | - |
| id | string |  |
| role | string | admin |
| sendInvite | boolean |  |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

# Action

Manage Automated Actions.<br><br>        Actions implement automated responses for specific device and cloud conditions. Actions are invoked by triggers to respond and implement a specific remedy or notification. .

## Find
Find actions by matching properties.

**Endpoint**

```HTTP
POST /action/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| cloudId | string | yes |
| type | string |  |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Action** 

An array of Action items.

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string |  |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean |  |
| error | string |  |
| expression | string |  |
| format | string |  |
| id | string |  |
| message | string | Message template/properties. |
| name | string |  |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string |  |
| trigger | string | Source of action trigger. |
| type | string |  |

## Get
Get an action by ID for a cloud.

**Endpoint**

```HTTP
POST /action/get

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string |  | Action ID. |
| cloudId | string | yes |  |
| type | string | yes |  |

**Response** 

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string |  |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean |  |
| error | string |  |
| expression | string |  |
| format | string |  |
| id | string |  |
| message | string | Message template/properties. |
| name | string |  |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string |  |
| trigger | string | Source of action trigger. |
| type | string |  |

## Invoke
Invoke an action by ID or name.

**Endpoint**

```HTTP
POST /action/invoke

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Action ID. |
| name | string | Action name if ID not provided. |
| params | object | Parameters for the action. |
| context | object | Context for the action. |

**Response** 

A string.


# Test

Test the API interface.

## Ping
**Ping device cloud**

Simple ping request.

**Endpoint**

```HTTP
POST /test/ping

```
**Authorized User Role**

```
public

```
**Response** 

The string "pinged" with a new line appended.


# Device

Device Management API.<br><br>When devices are initialized with the Ioto agent, they will "register" with the Builder service using their device ID (ClaimID) at https://admin.embedthis.com/api. The device registration API is part of the Builder API. See [Device Registration](/ioto/provisioning/registration.md).<br><br>Once registered, the device then remains under the management of the Builder until it is **"claimed"** by a user for management using the "Device Claim" API.  When claimed, the device is redirected to the device cloud when it next invokes the "register" API.

## Get
The Get API will fetch a device by its ID (ClaimID).

**Endpoint**

```HTTP
POST /device/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Role | Notes |
| - | - | - | - | - |
| id | string | yes |  | Device Claim ID. |
| accountId | string |  | owner | Manager account ID. Required if using CloudAPI token. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Claim
Claim a device for management by a device cloud.<br><br>Once a device has registered itself with the builder, a user can claim the device for management.<br>The claim ID would typically be printed on the device label during manufacturer.<br><br>A claim request may specify the device as a test device where it will not be counted towards the subscription device count.

**Endpoint**

```HTTP
POST /device/claim

```
**Authorized User Role**

```
claimDevice

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

The claimed device.

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Find
Find matching devices filtered by matching properties.

**Endpoint**

```HTTP
POST /device/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string |  | Device Claim ID. |
| accountId | string | owner | Manager account ID. Required if using CloudAPI token. |
| productId | string |  | Product registration ID from the Builder product list. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of devices owned by the user. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Device** 

An array of Device items.

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Remove
Release a device from management by a device cloud. Releasing a device returns it to the builder to be available for claiming by another cloud.

**Endpoint**

```HTTP
POST /device/remove

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

# Generic

Generic Access to Database Data.<br>        <br>        The Generic controller provides "generic" access to database items without requiring specific database models for different database items. By providing the database item "_type" and the required item properties, you can query and modify database items.

## Create
**Endpoint**

```HTTP
POST /generic/create

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. This must be a deviceId claimed by the manager account of the authenticated user. |
| * | any |  | Item attributes to create. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

The created item.

| Field | Type | Notes |
| - | - | - |
| _type | string | Database item type. |
| * | any | Item attributes. |

## Get
Get a data item from a database table.

**Endpoint**

```HTTP
POST /generic/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Optional item attributes to filter the selected item. |

**Response** 

The retrieved item.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

## Find
Find data items from a database table.

**Endpoint**

```HTTP
POST /generic/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Optional item attributes to filter selected items. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of devices owned by the user. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Item** 

An array of Item items.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

## Remove
Remove a data item.

**Endpoint**

```HTTP
POST /generic/remove

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Other item attributes sufficient to identify the item. |

## Update
Update a data item.

**Endpoint**

```HTTP
POST /generic/update

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Other item attributes sufficient to identify the item. |

**Response** 

The updated data item.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

# Desktop Device Manager Screen Shots

The following screenshots show some of the functionality of the Device manager app when using the desktop skin.

## Home Screen

![Home Page](/images/manager/dashboard.avif){class="screen"}

## Forms

![Form](/images/manager/cloudkick.avif){class="screen"}

## Dashboard Widgets Screen

![Home Page](/images/manager/dashboard.avif){class="screen"}

## Metrics

![Metrics](/images/manager/custom-metrics.avif){class="screen"}

## Login

![Login](/images/manager/developer-login.avif){class="screen"}

## Table Inline Edit

![Store Table](/images/manager/store-table.avif){class="screen"}




# Mobile Screen Shots

The following screenshots show some of the functionality of the Device manager app when using the mobile skin.

## Home Screens

![Eco Page](/images/eco/eco-home.avif){class="screen"}

![Home Page](/images/mobile/home.avif){class="screen"}

## Dark Mode

![Dark Mode Home Page](/images/mobile/home-dark.avif){class="screen"}

## Login

![Login](/images/eco/eco-login.avif){class="screen"}

## Alert Details

![Alert](/images/mobile/alert.avif){class="screen"}

## Metric Range

![Range](/images/mobile/range-pick-dark.avif){class="screen"}

## Confirmations

![Confirm](/images/mobile/confirm-dark.avif){class="screen"}

## Home Menu

![Menu](/images/mobile/menu-dark.avif){class="screen"}

## Device List

![Menu](/images/mobile/device-list-dark.avif){class="screen"}

## Claim Device

![Claim](/images/eco/eco-claim.avif){class="screen"}

![Menu](/images/mobile/device-list-dark.avif){class="screen"}# Replaced Device Manager

The `Standard` device manager is an ideal basis for creating device management apps. It provides the necessary components for a secure, performant and usable device management applications. However, you may have a need to replace the manager with your own bespoke manager using the Ioto cloud service APIs to access device data and state.

For example, you may have a hard requirement to use the [React](https://reactjs.org) UI framework or have a need to create a native IOS app. In these cases, you can use the Ioto REST APIs to build your own app.

For details about the Ioto Cloud service APIs, please read:

* [Ioto Cloud APIs](/ioto/ref/)
* [Ioto Cloud Service](/ioto/)

### Requirements

When creating your device manager app, there are two requirements:

* The app must use the Ioto REST APIs.
* The application must be packaged as a ZIP file.
* The ZIP file must have a top level index.html.

### Deploying

Once your app is built, package as a zip file and login to the [Builder](https://admin.embedthis.com) site to create and configure an App. Then, from the Builder app list, click on the `Add` button or the `Edit` icon to modify an existing app. Select the `Custom App` option and upload your `app.zip` archive and click `Save`.

The Builder will then deploy the image to the associated Ioto device cloud, which will take a few minutes.

Read more about the Ioto APIs:

* [Ioto Cloud Service](/ioto/)
* [Ioto Cloud APIs](/ioto/ref/)# Customized Pattern

The `Standard` device manager app can be extensively customized using the app's the in-built low-code app designer. The designer can modify the app's `name`, `logo`, `themes`, `features`, `UI pages` and app navigation. The end result is a highly appealing bespoke app that can be created with little or no code required.

![Eco Page](/images/eco/eco-home.avif){class="screen width-60 center"}

The app designer can help create highly bespoke pages using graphical widgets and can support user interactions to manage and control devices. By arranging input and output widgets in dashboard, you can create composite pages that are highly usable, interfaces for your devices.

A customized app typically adds one or more UI pages and incorporate cloud-side automated actions that respond to user and device input. 

Cloud-side actions can respond to user and device inputs to implement automated actions such as updating the database, implementing device actions and commands and notifying users.

## App Designer

You can run the App designer by selecting `Designer` from the app's sidebar. The designer menu option will be visible only for users that have the `role` of `owner` that is specified in the Builder's `App Settings`.

![Ioto Device Manager](/images/manager/page-designer.avif){class="screen"}

Using the designer, you can:

* Set the App name
* Set the App logo
* Customize themes including colors, borders and light/dark modes
* Create and modify pages
* Define the app's navigation structure

## Device Data Schema

The device data schema defines the entities, their properties, and corresponding data types for your device. This schema enables your app to dynamically generate and customize the user interface based on your specific requirements.

You can configure the schema using the Builder's cloud settings. To modify it, navigate to `Clouds` in the Builder, select your device cloud, and open the Cloud Modify configuration panel.

![Cloud Modify](/images/builder/cloud-modify.avif){class="screen width-60"}

By default, the schema is set up as a generic key-value store. While this works for initial use, you'll likely want to define custom data entities as your project evolves to better manage and represent device-specific data. 

For more information about the device schema, See:

* [Device Tables / Database Schemas](../database/schemas/)
* [Database Replication](..//database/replication.html# Design Patterns

EmbedThis embraces progressive design patterns when creating device management apps, enabling you to rapidly deploy an app built on the `DevCore` framework with a default developer UI. Once your app is created and launched, you can progressively customize it to meet your specific device management needs. This approach lets you quickly prototype your IoT solution while still achieving your ultimate goal of a fully bespoke application for mobile or desktop.

The Builder supports multiple apps for each product definition, providing flexibility for different user segments. For instance, you can create a mass-market app for general users, a "professional" version for premium customers, and a "developer" app for your support team.

The Builder offers five levels of customization for your device management app, each progressively increasing in flexibility and control:

| **Level** | **Name** | **Description** |
|-|-|-|
| 1 | [Standard](standard.md) | Deploy the standard (default) manager app created by the Builder **without modifications**. Ideal for development prototyping and in-house data-centric devices.|
| 2 | [Customized](customized.md) | Customize by via the app's builtin, low-code visual app Designer to create your own UI pages and define your product name, logo, and device data schema. Perfect to quickly launch appealing small to medium scale apps.|
| 3 | [Rebuilt](rebuilt.md)   | Rebuild the app code to include your own UI components and logic, uploading the customized code via the Builder. Then use the App Designer to create your own UI pages that leverage your components and logic. Ideal for larger scale apps with specific interface needs.|
| 4 | [Replaced](replaced.md) | Fully replace the app code with your own custom application using Ioto cloud service APIs. Suitable for unique requirements or specific UI frameworks and languages.|
# Rebuilt Pattern

The `DevCore` framework build is capable of handling most device management display and modification tasks. However, you may have specific device management needs that require custom UI components and logic. To meet this need, you can extend or modify the DevCore with a bespoke build of your own.

The Ioto-Apps download includes the source code for the `DevCore` that is used to build the `Standard` device manager app. You can customize, modify, extend and rebuild the DevCore and upload to the Builder to use for your apps. 

### Copying the Manager

The Ioto-apps download includes a `manager` app under the `./apps/manager` directory. In its pristine state, this app is used by EmbedThis to build the `Standard` device manager that is used when apps are first created. You can copy the manager directory and then extend or modify to suit your needs.

To get started, copy the entire apps/manager directory to a new directory:

```bash
$ cp -r apps/manager apps/mymanager
```

### Rebuilding

To rebuild the manager, select your app via the **make** command line.

```bash
$ make APP=mymanager clean build
```

The build will create:

* A new build of a manager app including the modified `DevCore`
* The Ioto agent with required services

The built application will be located under the **apps/mymanager/ui/dist** directory and will contain the individual application files and a **app.zip** ZIP file that is ready for uploading via the Builder to the Builder for hosting the UI.

### Uploading your build

To upload your build, login to the [Builder](https://admin.embedthis.com) site to create and configure an app. Then, from the Builder apps list, click on the `Add` button or the `Edit` icon to modify an existing app.

Select the **Custom App** option and upload your **app.zip** archive and click **Save**.

The Builder will then deploy the image to the associated Ioto device cloud, which will take a few minutes.

See the [Manager App](/apps/samples/manager/) in the Ioto Agent documentation for full details.

# Standard Pattern

The `Standard` device management app enables you to quickly start your project by connecting and managing your devices right away. The standard app is built on the `DevCore` framework and comes preloaded with a `developer` UI skin.

This app provides essential features like authentication, routing, data management, and visualization services, optimized for both mobile and desktop applications. 

Using the standard app without modification is an excellent choice for developers aiming to rapidly prototype IoT solutions. It's also well-suited for skilled end-users working on small, data-centric projects, such as scientific applications.

![Ioto Device Manager](/images/manager/standard.avif){class="screen"}

Key Features of the Standard App:

- **User Management:** Authentication, login, and access control.
- **Application Structure:** Includes navigation bars, data display panels, dashboards, widgets, and data editing forms.
- **Navigation and Routing:** User-friendly navigation and request routing.
- **Dynamic Dashboards:** Real-time updating dashboards and data/graphical widgets.
- **Data Property Editor:** View and modify device data seamlessly.
- **Device Management:** Claim, release, and manage one or more devices.
- **Connectivity:** Integrates with local HTTP device agents or cloud services.
- **Framework Setup:** Pre-configured for VueJS and Vuetify frameworks.

:::info 
Using the `DevCore` framework and the standard management app as a foundation can save you countless months of development time in creating your IoT solution.
:::
# DevCore Manager Package

The foundation of the DevCore Framework is the `devcore` package. This package provides essential services necessary for mobile or desktop device management applications.

The DevCore is a VueJS/Vuetify extension that provides structure for your device management application. It provide the essential authentication, routing and data management services to manage one or more devices.

The DevCore provides the following features:

- Setup and configuration of VueJS and Vuetify frameworks
- Application structure with navigation bars, data display panels, dashboards and widgets and  data editing forms
- User authentication, login and access control
- Dashboards and data and graphical widgets with dynamic live updating
- Data property editor to view and modify device data
- User navigation and request routing
- Collection of core VueJS UI components for management applications
- Device claim, release and management
- Ability to connect to local HTTP device agents or cloud services

Using the DevCore as a foundation, you can elimiate countless months of developer time in creating a device management solution.

## Using the DevCore

The DevCore package is imported in the app's main routine. To initialize the framework, import the **createManager** API. For example:

```js
import {createManager} from 'devcore'

async function main() {
    const manager = await createManager({
        display: Display,               //  UI Display definition
        schema: Schema,                 //  Database schema
        widgets: {graph: GraphWidget},  //  Additional dashboard widgets
        router,                         //  VueJS router
        vue,                            //  Vue instance
        vuetify,                        //  Vuetify instance
    }, {
        api: '/api',                    //  Backend URL prefix
        profile: Ioto.profile,          //  Execution profile
        name: Display.name,             //  App name
        title: Display.title,           //  App display title
        version: Display.version,       //  App version (x.y.z)
    })
main()
```

The **createManager** API accepts configured [VueJS](https://vuejs.org), [Vuetify](https://vuetifyjs.com/en/) and [Vue Router](https://router.vuejs.org/) instances. You can configure these as you wish, but a typical setup would look like:

```js
import * as components from 'vuetify/components'
import * as directives from 'vuetify/directives'
import Display from 'display.json5'

async main() {
    let vue = createApp(Main)
    let router = createRouter({
        history: createWebHashHistory(),
        routes: [],
    })
    let vuetify = createVuetify(
        vuetifyProps({
            components: components,
            directives: directives,
            themes: Display.theme.themes,
        })
    )
    vue.use(vuetify)
```

A Manager instance is created with arguments that define the UI display, VueJS components and other configuration options. Here is a table of the createManager first parameter arguments.

Property | Description
-|-
components | A map of VueJS components
display | The [display.json5](../config/display.md) UI route definition file
schema | The device database [schema](../config/schema.md)
models | A map of [REST data models](../config/models.md)
widgets | A map of additional [dashboard widgets](../config/display-properties.md#viewwidgets)
router | A configured [VueJS](https://router.vuejs.org/) router instance
vue | A configured [VueJS](https://vuejs.org/) instance
vuetify | A configured [Vuetify](https://vuetifyjs.com/en/) instance

The Manager constructor also takes an **"options"** argument that supplies essential app configuration information. 

The following properties should be provided via the **options**:

Property | Description
-|-
api | Backend API URL prefix. Use "/api" for local and Connect.js when cloud-based.
name | App name. Short one word product name.
title | App display title. Short multi-word display product title.
profile | Operational profile (dev, prod)
version | App version (x.y.z)
build | Build version number. Single number build version.


### API Endpoint

When a device app is hosted by the cloud, the Ioto service adds a **Connect.js** configuration file to the app site that can be imported from the top level of your app. The **Connect.js** script provides the **api** endpoint address and the AWS Cognito user authentication endpoint configuration. Both are required for cloud-based device managers.

Here is a sample Connect.js:

```js
{
    "api": "https://xxxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com",
    "builder": "https://api.admin.embedthis.com",
    "cognito": {
        "userPoolId": "ap-southeast-2_xxxxxxxxx",
        "clientId": "xxxxxxxxxxxxxxxxxxxxxxxxxx"
    }
}
```

This file should be imported and the **"api"** and **"cognito"** properties used in the Manager options. For example:

```js
import Connect from 'Connect.js'
await createManager({
    ...
}, {
    ...
    api: Connect.api,                   //  Backend cloud service API
    cognito: Connect.cognito,           //  Cognito config
})
```

## DevCore Exports

The DevCore package exports a suite of configured service objects and support functions.

### Service Objects

Name | Description
-|-
Auth | Primary authentication service
Feedback | User UI informational feedback service
Progress | User activity progress bar service
Rest | REST HTTP service
Routes | Navigational routes service
Rules | Input valiation rules
State | Global application state service


### Support Functions

Name | Signature | Description
-|-|-
can | can(role) | Can the logged in user perform the given role
createManager | createManager(params, options) | Create and initialiate a manager instance
getVue | getVue() | Return the initialized Vue instance
getModel | getModel(model) | Return the schema data model definition
getModels | getModels() | Return a list of the schema data models
getRoute | getRoute() | Return the Vue Router object for the current UI page
getRoutePath | getRoutePath() | Return the current Vue router URL
getRouter | getRouter() | Return the Vue router instance
navigate | navigate(url, query) | Navigate the UI to the given URL
vuetifyProps | vuetifyProps(params) | Convert the given params to Vuetify constructor args

<!--
## UI Components

The DevCore class provides a suite of UI components, including:

Component | Description
-|-
- Form validation rules
- Debug logging
- App state store
- Browser session storage
- Themes with light and dark modes
- SVG Icons
- Date and calendar UI component
- Vue cards
- Date  
- Drag and drop support
- User activity feedback and operation progress
- High level form input management
- Data table
- Application, sidebar and tabbed navigation
- User access control
- User signposts


- Background
- List of services
- Display, Schema

vu-form
    props
    CSS
    validation
    loading
    feedback
    save/pre/post
    progress
    confirm
    clickaway
app.feedback
app.progress

vu-input
    props
vu-table
    props
    fields
    events
    selection
    filtering
Panels
    events
icon aliases

Display -- review display tour

## Manager API

- App context
--># Vue Components

The DevCore uses the [Vue.js](https://vuejs.org) framework for building the user interface.

[Vue.js](https://vuejs.org) is a progressive JavaScript framework that is ideal for building user interfaces and single-page device management applications. 

One of the core features of Vue.js is its reactive data binding system, which ensures that the user interface updates automatically and efficiently in response to data changes. This reactivity makes it easier to develop dynamic device management applications where the content changes based on device state, user interactions or other factors without requiring manual DOM updates.

Vue.js also emphasizes a component-based architecture, where the application is built using small, reusable components. Each component in Vue has its own HTML, CSS, and JavaScript, allowing for more organized and maintainable codebases. This component-based approach facilitates the development of complex applications by breaking them down into smaller, manageable pieces.

Moreover, Vue.js offers a variety of tools and supporting libraries for advanced application needs, including Vue Router for page routing, and Vite build tool for project tooling. These tools are designed to work seamlessly with Vue, enabling developers to build robust, high-performance web applications.

Overall, Vue.js stands out for its ease of use, flexibility, and efficient data handling capabilities, making it a favorite among web developers for both small and large projects.

[VueJS Documentation](https://vuejs.org/guide/introduction.html)

## Vue Router

The DevCore uses the [Vue Router](https://router.vuejs.org/) for UI navigation.

Vue Router is the official router for Vue.js. It integrates closely with Vue.js to enable the building of single-page applications (SPAs) with ease. Vue Router allows for the creation of complex navigational structures within Vue applications, managing the synchronization between the browser's URL and your application's Vue components.

Here are some key features and capabilities of Vue Router:

* Dynamic Route Matching: You can design routes to match dynamic paths, allowing for parameterized URLs. This is particularly useful for creating user or item-specific pages based on IDs or other unique identifiers from the URL.

* Nested Routes: Vue Router supports nested routes, enabling the development of nested component structures that reflect nested URLs. This is useful for applications that have a hierarchical structure requiring a UI that reflects this complexity.

* Programmatic Navigation: Besides linking to specific routes with `<router-link>`, Vue Router allows for programmatic navigation. This means you can navigate to different pages programmatically using JavaScript, which is useful for actions like redirecting a user after a form submission.

* Navigation Guards: Vue Router provides navigation guards that allow you to hook into the routing process for operations like authentication checks before entering a route, or fetching data before a component is rendered.

* Lazy Loading: To improve performance, Vue Router supports lazy loading of route components. This means components are only loaded when they are needed for the current route, reducing the initial load time of the application.

* History Mode: Vue Router supports HTML5 history mode, which uses the history.pushState API to achieve URL navigation without a page reload. This creates a better user experience, with URL paths that look "normal" (without the hash # symbol) and are SEO-friendly.

Integrating Vue Router into a Vue.js application involves defining a set of routes, each associated with a component. When the application's URL changes, Vue Router matches the URL to the defined routes and renders the corresponding component, making it a vital part of creating SPA experiences with Vue.js.

The DevCore uses a **Display.json5** configuration file that is automatically translated into route tables for the Vue Router.


## Vuetify

The DevCore uses the [Vuetify.js](https://vuetifyjs.com/en/) design framework for UI components that is ideal for creating consistent, usable device management web applications.

Vuetify is a popular [Material Design](https://m3.material.io/) Framework for [Vue.js](https://vuejs.org). It provides a comprehensive suite of pre-made Vue components that are ready to use and fully customizable, adhering to Google's Material Design principles. Vuetify is designed to help developers create beautiful, responsive layouts and applications quickly and efficiently, without needing to spend a lot of time on CSS and design.

The framework offers a wide array of UI components, including buttons, dialogs, cards, data tables, and many more, all designed to work out of the box with Vue.js applications. These components are built to be accessible and internationalization-friendly, making it easier to create web applications that are accessible to a wide audience.

Vuetify is built on top of Vue.js, meaning it inherits Vue’s reactivity and component-oriented architecture, allowing for a seamless integration into Vue projects. This makes it an excellent choice for developers looking to leverage Vue.js’s capabilities while also maintaining a consistent, attractive design across their application with minimal effort.

Additionally, Vuetify includes support a range of pre-designed themes, and comprehensive documentation, making it a powerful tool for developers building Vue.js applications that need to be both functional and aesthetically pleasing. 

For device management applications, Vuetify can significantly speed up development time and ensure your application follows the best practices of Material Design.# App State

The DevCore includes a state management service that serves as a centralized state store for all the components in the application. 

The state service allows arbitrary data to be centrally stored and shared between app components. One or more State stores can be created for different state. 

The primary advantages of using a centralized state store is the predictable ordering of state changes and the uncoupling of components that need to share state.

## State Stores

The DevCore provides the following state stores:

Name|Description
-|-
app | State data regarding the app in general
config | Configuration data from the ioto.json5 and other config files
auth | User authentication data

## Accessing State

```js
import {State} from 'devcore'

let darkMode = State.app.dark
```

## Creating a State Store

To create a new state store, create a state class and use the **Store.add** to add the store to the centralized state service.

State stores are available as properties on the **State** object.

```js
import {Store, State} from 'devcore'
class MyState {
    temp = 0
    speed: 42
    increment() {
        temp++
    }
    get speed() { return this.speed }
    set speed(v) { this.speed = v }
    async stop() {
        await database.stop()
    }
}
Store.add('my', new MyState())

console.log(State.my.temp)
State.my.stop()
console.log(State.my.speed)
```

## Config State

The **Config** store holds general config state including:

Property | Description
-|-
api | Backend cloud service API
cognito | Cognito config
build | App build number
profile | Execution profile (prod | dev)
name | App name
title | App display title
version | App version (x.y.z)

## Auth State

The **Auth** state store holds authentication state including:

Property | Description
-|-
account | Account object
accountName | Account name
accountId | Account ID
auth | Authentication tokens
authenticated | Boolean set to true when the user credentials are authenticated
authorized | Boolean set to true when the user is fully logged in
email | User's login email address
ready | Set to true when the user is logged in and the app is ready to start
role | User's authenticated role
user | User object
username | User login name
userId | User ID

## Alternatives

If you are building your own custom build of the DevCore, you can also use other state stores such as [Pinia](https://pinia.vuejs.org/).# DevCore Framework

Device Apps that utilize the **DevCore** save **months** if not **years** of development time compared to creating your own device management app from scratch.

Device apps generally need to perform the following core functions as a minimum:

* Login and authenticate users
* Claim devices for management
* Configure device settings
* Display device information and statistics
* Allow user control of the device device

The DevCore Framework provides the following essential features:

Feature | Description
-|-
Framework | Application structure with navigation bars, data display panels, dashboards and widgets and data editing forms
Authentication | User authentication, login and access control
Navigation | User navigation and request routing
Dashboards | Dashboards and graphical widgets with dynamic live updating
Interaction | Connect user interactions with device and cloud commands and operations
Property Editor | Editor to view and modify device data
Provisioning | Device claim, release and management
Integration | Ability to connect to local HTTP device agents or cloud services

The DevCore Framework is **responsive** and supports mobile, tablet or desktop interfaces. It will seamlessly scale to the appropriate screen size and intelligently switches between **dark** and light modes of operation.

The DevCore can also be rebuilt using the source code that is included with the Ioto agent distribution. With this approach, you can completely customize the manager for your app.
Alternatively, you can create your own bespoke device manager using the Ioto APIs for ultimate control.
# Display Page Routing

Apps based on the Ioto Device Manager are configured using a **display.json5** configuration file that defines the app's features, themes, pages and panels. You can upload a custom display.json5 which will be used by your app. 

The display.json5 file defines the following items:

* Displayed Name
* Display color theme including dark and light modes
* Menu items and options
* UI pages
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

The initial display.json5 configuration file defines a "developer" skin for the app.

To upload, check the **Upload Display** and click on the Display file selection box to select a **display.json5** file to upload.

To clear a previously uploaded display, click on "Clear Display".

For more information about the Display file, See the manager documentation:

* [Ioto Device Manager](/apps/)
* [Display](display.html)
* [Display Properties](display-properties.html)
# Database Schemas

Ioto uses database schemas to define how items will be stored in the database.

A schema specifies the database item types, entity fields, indexes and other data access and replication parameters.

Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) schema format, implementing the [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).

The same schema is used for the cloud side AWS DynamoDB table and for the device side embedded database.

## Schema Definition

Schemas look like this:

```js
const DeviceSchema = {
    format: 'onetable:1.1.0',
    version: '0.0.1',
    indexes: {
        primary: {hash: 'pk', sort: 'sk'},
    },
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        },
    },
    models: {
        Status: {
            pk: {type: 'string', value: 'status#'},
            sk: {type: 'string', value: 'status#'},
            parameters: {type: 'object'},
            version: {type: 'string'},
            updated: {type: 'date'},
        },
        Fault: {
            pk: {type: 'string', value: 'device#${deviceId}'},
            sk: {type: 'string', value: 'fault#${id}'},
            deviceId: {type: 'string', required: true},
            id: {type: 'string', generate: 'ulid'},
            timestamp: {type: 'date', required: true},
            source: {type: 'string', required: true},
            severity: {
                type: 'string',
                required: true,
                enum: ['info', 'warn', 'error', 'critical', 'fatal'],
            },
            subject: {type: 'string', required: true},
            message: {type: 'string', required: true},
        },
    },
    params: {
        isoDates: true,
        timestamps: true,
    },
}
```

## Schema Purpose

AWS DynamoDB can operate most efficiently at scale when using a single table with multiple application entities stored in the one table. To make this design pattern easy to implement, application data schemas such as the one used by [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) provide the mapping between application level entities and raw database items.

Ioto uses the OneTable schema in both the DynamoDB table and in the Ioto agent database.

When coupled with a high-level database API such as that offered by OneTable and by the Ioto Agent Database, accessing and managing device data is much easier.

## DynamoDB Schema

Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) NodeJS library for all database access to the Ioto DynamoDB database. 

Please consult the [OneTable](https://github.com/sensedeep/dynamodb-onetable) library and [OneTable Documentation](https://doc.onetable.io/) for full details.

## Updating the Schema

![Updating the Schema](/images/builder/cloud-modify.png){class="screen"}

## Schema Properties

The valid properties of the **schema** object are:

| Property |  Type  | Description                                                                                  |
| -------- | :----: | -------------------------------------------------------------------------------------------- |
| format   | string | Reserved. Must be set to **onetable:1.1.0**                                                  |
| indexes  | object | Hash of indexes used by the table.                                                           |
| models   | object | Hash of model entities describing the model keys, indexes and attributes.                    |
| params   | object | Hash of properties controlling how data is stored in the table.                              |
| process  | object | Hash of model entities describing where the model should be and how it should be replicated. |
| version  | string | A SemVer compatible version string.                                                          |

The **format** property specifies the schema format version and must be set to **onetable:1.1.0**.

The **indexes** property specifies the key structure for the primary, local and secondary indexes.

The **models** property contains one or more item definitions with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties.

The **params** property defines additional parameters for table data formats.

The **process** map defines how database items should be processed, stored, replicated and whether metrics should be calculated from the data stream.

The **version** property defines a version for your database. It must be a [SemVer](https://semver.org/) compatible version string. The version string is used by tools and consumers of the schema to understand compatibility constraints for the schema and stored data.

## Schema Models

The schema defines a model for each item type. For example, consider a music example:

```js
{
    album: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        songs:  { type: 'number' },
    },
    artist: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        address: {
            type: Object, schema: {
                street: { type: 'string' },
                city: { type: 'string' },
                zip: { type: 'string' },
            },
        },
    }
}
```

For each item type, all the entity fields are defined by specifying the field type, validations and other operational characteristics (uniqueness, IDs and templates).

The valid types are: array, binary, boolean, date, number, object, and string.

The database will automatically add an item type via the **\_type** attribute to each model. This is set to the name of the type. You can modify this via the **params.typeField** setting.

## Value Templates

The value of a field can be computed based on the value of other fields and a formatting "value template". This is useful for decoupling your key structure from your entity fields.

The value template is like a Javascript string literal where the value of fields are expressed in a "${field}" format. At runtime, the field references are expanded with the item's value for the named field.

In the example above, the primary key "pk" is calculated from the entity type **\_type** and the **name** field by using the value template: **${_type}:${name}**.

## Nested Schemas

For object attributes, you can define a nested schema for the object properties, as in the example above (repeated below).

A nested schema uses the **schema** property to define a nested map of attributes. Schemas can be nested to an arbitrary depth.

```js
address: {
    type: Object, schema: {
        street: { type: 'string' },
        city: { type: 'string' },
        zip: { type: 'string' }
    }
}
```

## References

-   [DynamoDB OneTable Overview](https://www.sensedeep.com/blog/posts/2021/dynamodb-onetable-tour.html)
-   [DynamoDB with OneTable Schemas](https://www.sensedeep.com/blog/posts/2021/dynamodb-schemas.html)
-   [Data Modeling for DynamoDB](https://www.sensedeep.com/blog/posts/2021/dynamodb-singletable-design.html)
-   [SenseDeep DynamoDB Data Browser](https://www.sensedeep.com/blog/posts/series/dynamodb-studio/data-browser.html)
-   [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).
# Display Properties

## Example

Here is a subset example of a display.json5 file:

```js
{
    version: '1.0.0',
    name: 'Kickstart',
    description: 'Display for Kickstart',
    theme: {
        title: 'Device Manager',
        logo: '/images/ioto-logo.png',
        themes: {
            dark: { ... },
            light: { ... },
        }
    },
    views: [
        { path: '/', name: 'home' },
        { name: 'Login', path: '/auth', component: 'Login' },
        {
            name: 'devices',
            path: '/devices',
            icon: '$devices',
            menu: 'Device',
            component: 'GenericList',
            table: {
                model: 'Device',
                subtitle: 'Click on a device to explore',
                fields: [
                    {name: 'product'},
                    {name: 'description'},
                    {name: 'model'},
                    {name: 'id', title: 'Device ID'},
                    {name: '*', launch: '/devices/:id/overview'}
                ],
                actions: {
                    add: { count: 0, launch: 'claim' },
                    release: { 
                        count: 2,
                        invoke: 'DeviceRelease', 
                        confirm: true 
                    }
                }
            },
            panels: [
                {
                    name: 'claim',
                    component: 'DeviceClaim',
                    button: 'Claim Device'
                }
            ]
        },
    ]
}
```

Here is an example view that uses the dashboard component and informational widgets:

```js
{
    name: 'fleet',
    title: 'Fleet Overview',
    path: '/fleet',
    icon: '$gauge',
    role: 'user',
    menu: 'Fleet'
    component: 'Dashboard',
    widgets: [
        {
            type: 'graph',
            title: 'CPU Metric over 5 mins',
            data: {
                owner: 'account',
                namespace: 'Embedthis/Device',
                metric: 'cpu',
                span: 'min5',
                dimensions: [{Device: 'deviceId'}],
            },
            axes: {y: 'CPU', x: 'Time'},
            width: '25%',
        },
    ],
}
```

## description

| Name | description |
|-|-|
| Description | Textual description of the device. |
| Synopsis | `description: "Short, one sentence description"` |

**Example**

```js
description: 'Display for the Acme Rocket device'
```

## features

| Name | features |
|-|-|
| Description | Enable features for the display UI |
| Synopsis | `features: { "debug": true | false }` |

**Example**

```js
features: {
    debug: false
}
```

## features.auth

| Name | features |
|-|-|
| Description | Authentication features for the display UI |
| Synopsis | `auth: { "social": true | false }` |

**Example**

```js
features: {
    auth: {
        forgot: true,
        login: true,
        social: true,
    }
}
```

Property | Description
-|-
forgot | Support forgot my password recovery
login | Display and require user login
social | Support login via Google, Facebook or Amazon. (Requires cloud-based managemement).



## features.cloud
| Name | features |
|-|-|
| Description | Control cloud features |
| Synopsis | `cloud: { multiple: true | false }` |

This is useful to support apps that can connect to multiple device clouds.

The following properties are supported

Property | Type | Description
-|-|-
enable | Boolean | Enable cloud connectivity
multiple | Boolean | App supports multiple clouds

**Example**

```js
features: {
    cloud: {
        enable: true,
        multiple: false,
    }
}
```

## features.dash
| Name | features |
|-|-|
| Description | Control dashboard features |
| Synopsis | `dash: { edit: true | false }` |

This property collection controls the dashboard.

The following properties are supported

Property | Type | Description
-|-|-
actions | Boolean | Enable editing widget actions
database | Boolean | Enable widgets to access database fields
edit | Boolean | Enable the widget editing panel
metrics | Boolean | Enable widgets to access metrics
multiple | Boolean | Enable support for multiple dashboards per user
name | String | Name of the dashboard to load by default. Set to "auto" to load "Mobile" on phones and "Desktop" otherwise.
responsive | Boolean | Enable widget maximizing on mobile devices


## features.demo

| Name | features |
|-|-|
| Description | Enable demonstration mode |
| Synopsis | `demo: { enable: true | false } ` |

**Example**

```js
features: {
    demo: {
        enable: true,
    }
}
```

## features.debug

| Name | features |
|-|-|
| Description | Enable debug mode |
| Synopsis | `debug: true | false` |

This is useful to enable or disable debug code while developing new features.



## features.nav
| Name | features |
|-|-|
| Description | Control app navigation features |
| Synopsis | `nav: { sidebar: true }` |

This property collection controls the app's navigation features. The following properties are supported:

Property | Type | Description
-|-|-
alerts | Boolean | Display automation alerts icon in the navbar
cookies | String | Reserved
doc | String | URL link to app documentation site
fleet | Boolean\|String | Support multiple claimed devices in the one UI. Can be set to 'smart' to dynamically determine based on the number of claimed devices.
help | Boolean | Reserved
profile | Boolean | Display user profile in top navbar menu
settings | Boolean | Display account settings in top navbar menu
sidebar | Boolean | Display navigation sidebar
navbar | Boolean | Enable top of application navbar


## redirect

| Name | redirect |
|-|-|
| Description | Redirect the browser to a new location
| Synopsis | `redirect: "URL"`
| Notes | If set to a URL, you can use **:token** segments that will be expanded at runtime from the application route context.

**Example**

The :deviceId will be replaced with the selected device ID from the device list.

```js
redirect: '/devices/:deviceId/overview'
```

## theme

| Name | theme |
|-|-|
| Description | Define the display theme configuration |
| Synopsis | `theme: { properties ... }` |

**Example**

```js
theme: {
    title: 'Acme Rocket',
    logo: '/images/acme-logo.png',
    themes: { ... }
}
```

## theme.logo

| Name | theme.logo |
|-|-|
| Description | The logo displayed in the navigation bar and login screen.|
| Synopsis | `logo: "/images/NAME.png"` |
| Notes | The logo should be small, square and have a transparent background.|

```js
{
theme: {
    logo: '/images/acme.png'
}
```

## theme.title

| Name | theme.title |
|-|-|
| Description | The device title displayed in the navigation bar.|
| Synopsis | `title: "Few word title"` |

```js
theme: {
    title: 'Acme Rocket'
}
```


## theme.themes

| Name | theme.themes |
|-|-|
| Description | Set of colors to use for the dark and light UI themes.|
| Synopsis | `themes: { dark: {...}, light: {...}}
| Notes | The themes collection should provide a "dark" and "light" mode set of colors.|

```js
theme: {
    themes: {
        dark: {
            primary: '#3F51B5',
            secondary: '#707070',
            accent: '#82B1FF',    
            error: '#fb6d6d',
            info: '#2196F3',
            success: '#4CAF50',
            warning: '#FB8C00',
            extra: '#00cdcd',
            anchor: '#1976D2',
            nav: '#3f51b5'
        },
        light: { ...}
    }
}
```

## timeouts

| Name | timeouts |
|-|-|
| Description | Define timeout periods for various manager refresh tasks. |
| Synopsis | `timeouts: { dashboard: seconds }`|
| Note | The dashboard time governs how frequently dashboard widgets are updated. You can provide a numeric value in seconds or a textual value such as "3secs".

**Example**

```js
timeouts: {
    dashboard: '10secs'
}
```

## version

| Name | version |
|-|-|
| Description | The version number of your display.json5 file (SemVer). |
| Synopsis | `version: "SemVer compatible version"` |

**Example**

```js
version: '1.2.3'
```

## views

| Name | views |
|-|-|
| Description | Array of UI pages to define
| Synopsis | `views: [ { view }, ...]` |
| Note | Views may also be nested under a view. Such nested views are presented as tabbed views under a common parent view.

**Example**

```js
{
    name: 'fleet',
    title: 'Fleet Overview',
    path: '/fleet',
    icon: '$gauge',
    component: 'Fleet',
    role: 'user',
    menu: 'Fleet',
    period: 10
    views: [
        { /* Tabbed sub-views */ },
    ]
}
```


## view.component

| Name | view.component |
|-|-|
| Description | VueJS component to display for the view
| Synopsis | `component: "ComponentName"`
| Note | The component can be an inbuilt Ioto Manager component or it can be a component provided by the extension components defined via the **modules** property.<br><br>The inbuilt components are listed below.

**Example**

```js
{
    component: 'Generic',
},
```

**Inbuilt VueJS Components**

These components can be referenced in the display.json5 file.

* AccountSettings
* Dashboard
* GenericList
* GenericEdit
* DeviceClaim
* DeviceClaimModal
* DeviceRelease
* Forgot
* Login
* UserPassword
* UserList
* UserProfile


## view.enable

| Name | view.enble |
|-|-|
| Description | Enable or disable the view
| Synopsis | `enable: true | false | array | object`

May be set to true or false to statically enable or disable a view.

May be set to an array or map of properties for dynamic control based on the app context.

If set to an array, each array map element must evaluate to true. If set to a map of properties, any one
of the properties must be true to enable the view.

Map property values can be literal strings, numbers, booleans or regular expressions. Regular expressions are defined as strings delimited by slash characters. For example: "/Some Regular Expression/". Strings can also be prefixed with an operation: < <= > >= == !=.

Property values are derrived by using the property name as an index into the app context. i.e.:

```js
value = state.app.context[PropertyName]
```

Currently, the app context contains the device ID as the **"deviceId** property. Additional properties can be added to the context via the API:

    state.app.setContext(key, value)

**Example**

```js
{
    enable: false
    // or any one of these expressions must be true
    enable: {
        someProperty: 'Required-Value',
        someNumber: '> 100',
        deviceId: '!= ',                    // Must be not equal to empty
        someString: '/Regular Expression/',
    },
    // or All of these expressions must be true
    enable: [
        { someProperty: 'value' },
        { otherProperty: 'value' },
    ]
},
```

## view.height

| Name | view.height |
|-|-|
| Description | Default view widget height
| Synopsis | `height: Pixels`
| Note | This defines the default height for the view's widgets

**Example**

```js
{
    height: 300
}
```

## view.icon

| Name | view.icon |
|-|-|
| Description | Icon to display in menus
| Synopsis | `icon: "mdi-NAME"`
| Note | The icon name is the name of an icon alias. You should use the icon alias name with an "$" prefix.

**Example**

```js
{
    icon: '$edit'
},
```

The Manager class provides a subset of the [Material Design Icons](https://materialdesignicons.com/). Applications can import and add additional aliases when initializing the Manager class.

The following icon aliases are provided as standard:

Icon Alias | Icon Name
-|-
account| account
alert| alert
auto| brightnessauto
aws| aws
bell| bell
bookmark| bookmarkmultiple
bookshelf| bookshelf
bridge | bridge
calendar | calendar
cancel | close-circle
checkboxindeterminate | minus-box
checkboxoff | checkbox-blank-outline
checkboxon | checkbox-marked
clear | close-circle
cart | cart
click | cursordefaultclick
clipboard | clipboardtext
clock | clockoutline
cloud | cloud
close | close
cog | cog
cogoutline | cogoutline
collapse | chevron-up
complete | check
copy | contentcopy
critical | flash
cube | cubesend
dark | brightness3
dashboard | monitordashboard
delete | close-circle
delimiter | circle
devices | devices
down | chevrondown
download | download
dropdown | menu-down
edit | pencil
error | close-circle
expand | chevron-down
email | email
error | alertcircleoutline
eye | eye
eyedropper | eyedropper
eyeoff | eyeoff
facebook | facebook
function | function
file | paperclip
first | page-first
gauge | gauge
grid | viewgridoutline
google | google
info | information
last | page-last
lan | lan
launch | launch
leftarrow | arrowleftbold
light | brightness5
login | login
loading | cached
menu | menu
minus | minus
next | chevron-right
plus | plus
magnify | magnify
medical | medicalbag
monitor | monitor
offline | flashoutline
online | checkcircleoutline
open | lockopen
phone | phone
play | play
plusboxoutline | plusboxoutline
prev | chevron-left
radiooff | radiobox-blank
radioon | radiobox-marked
ratingempty | star-outline
ratingfull | star
ratinghalf | star-half-full
rightarrow | arrowrightbold
reload | reload
redo | redo
resize | resizebottomright
rss | rss
run | run
sortasc | arrow-up
sortdesc | arrow-down
security | security
send | send
start | raystartarrow
stop | stop
support | hospitalbox
swap | swapverticalbold
subgroup | menu-down
success | check-circle
tap | gesturetapbutton
up | chevronup
unfold | unfold-more-horizontal
warning | alert-circlewarn | alertcircleoutline
wizard | autofix
wrench | wrench

To add icons when initializing the Manager, import the icons and add to the **vuetifyProps** when calling **createVuetify**.

```js
import {mdiFormatListBulletedSquare} from '@mdi/js'

const Icons = {
    events: mdiFormatListBulletedSquare,
}

async function main() {
    let vue = createApp(Main)
    let router = createRouter({
        history: createWebHashHistory(),
        routes: [],
    })
    let vuetify = createVuetify(
        vuetifyProps({
            components: components,
            directives: directives,
            icons: Icons,
            themes: Display.theme.themes,
        })
    )
}
```

And then supply the icons when calling 

```js
```


## view.menu

| Name | view.menu |
|-|-|
| Description | Display the view in the sidebar menu with the given text
| Synopsis | `menu: 'MenuTitle`

**Example**

```js
{
    menu: 'MyMenuItem'
},
```


## view.name

| Name | view.name |
|-|-|
| Description | Name of the view
| Synopsis | `name: "One-word-name"`
| Note | This name is used in several places including as a page title and VueJS route name.

**Example**

```js
{
    name: 'fleet'
},
```


## view.panels

| Name | view.panels |
|-|-|
| Description | Array of slide in panels that overlay the view.
| Synopsis | `panels: [ { panel }, ...]`
| Note | Panels are defined inside a parent view. Panels are invoked via buttons defined in the panel properties that are displayed in the parent view. A typical use case is a parent view list of device components and a panel to edit a selected component. For example: from a parent view of device fans, a fan could be selected and an edit panel could modify the fan's operational properties.

**Example**

```js
panels: [
    {
        name: 'claim',
        component: 'DeviceClaim',
        role: 'admin',
        button: 'Claim Device',
        width: '500px'
    }
]
```


## view.panel.button

| Name | view.panel.button |
|-|-|
| Description | Button text to display in the parent view's table.
| Synopsis | `role: "User-role"`
| Notes | The button will be automatically displayed by panel view parents that use the **GenericList** component. If you are using a custom view parent component, you will need to manage the buttons display in that component.

**Example**

```js
{
    button: 'admin',
},
```


## view.panel.component

| Name | view.panel.component |
|-|-|
| Description | VueJS component to display for the panel
| Synopsis | `component: "ComponentName"`
| Note | The component can be an inbuilt Ioto Manager component or it can be a component provided by the extension components defined via the **modules** property.<br><br>The inbuilt components are listed below.

**Example**

```js
{
    component: 'TempPanel',
},
```

## view.panel.fields

| Name | view.panel.fields |
|-|-|
| Description | Array of fields to edit
| Synopsis | `fields: [ {field definition}, ...]`
| Note | This defines an array of fields to edit when using the GenericEdit component. Input fields have a defined "type" which determines the HTML component used to edit the field value. Supported field types include: checkbox, combo, date, label, password, radio, select, slider, switch, text and textarea.

**Example**

```js
{
    panels: [
        {
            name: 'edit',
            component: 'GenericEdit',
            role: 'admin',
            fields: [
                {
                    name: 'name',
                    type: 'label',
                    role: 'user',
                    props: {'max': 100},
                    width: 6,
                }
            ]
        }
    ]
},
```

## view.panel.fields.label

| Name | view.panel.fields.label |
|-|-|
| Description | Field displayed label
| Synopsis | `label: "fieldLabel"`
| Note | The field label is displayed before the input field. If not provided, the field name is converted to PascalCase and used by default.

**Example**

```js
{
    label: 'Speed'
}
```


## view.panel.fields.name

| Name | view.panel.fields.name |
|-|-|
| Description | Field name
| Synopsis | `name: "oneWordName"`
| Note | If a field title is not provided, the field name is converted to PascalCase and is used as the input field title.

**Example**

```js
{
    name: 'speed'
}
```


## view.panel.fields.role

| Name | view.panel.fields.role |
|-|-|
| Description | Required user role to display the field
| Synopsis | `role: "User-role"`
| Notes | The user role may be selected from "public", "user", "admin", "support" or "owner". The public role permits unauthenticated access. The other roles require a login with the requisite role.

**Example**

```js
{
    rolew 'admin'
},
```


## view.panel.fields.select

| Name | view.panel.fields.select |
|-|-|
| Description | Selectable options for switch fields.
| Synopsis | `select: {options, ...}`

**Example**

```js
{
    select: {online: true, offline: false}
},
```
## view.panel.fields.type

| Name | view.panel.fields.type |
|-|-|
| Description | Field's input UI display type
| Synopsis | `type: "Type"`
| Note | If the type is not provided, the Manager attempts to sleuth the type based on the data value provided to edit.

**Example**

```js
{
    name: 'status',
    type: 'switch',
    select: {online: true, offline: false},
    width: 6
}
```

**The supported panel field data types are:

** checkbox
** combo
** date
** label
** password
** radio
** select
** slider
** switch
** text
** textarea


## view.panel.fields.width

| Name | view.panel.fields.width |
|-|-|
| Description | Number of columns the input field should occupy.
| Synopsis | `width: "1-12"`
| Note | The width is expressed as a number of columns between 1 and 12. The GenericEdit component uses a layout grid of 12 columns. GenericEdit will pack fields to fill a row, before starting a new display row.

**Example**

```js
{
    name: 'User Password',
    type: 'password',
    select: {online: true, offline: false},
    width: 6
}
```



## view.panel.name

| Name | view.panel.name |
|-|-|
| Description | Unique panel name
| Synopsis | `name: "Name"`

**Example**

```js
{
    name: 'TempEdit',
},
```


## view.panel.role

| Name | view.panel.role |
|-|-|
| Description | Required user role to allow access
| Synopsis | `role: "User-role"`
| Notes | The user role may be selected from "public", "user", "admin", "support" or "owner". The public role permits unauthenticated access. The other roles require a login with the requisite role.

**Example**

```js
{
    role: 'admin',
},
```



## view.panel.title

| Name | view.panel.title |
|-|-|
| Description | Panel Title
| Synopsis | `title: "Title"`
| Notes | If the panel title is not provided, a title is created using the name of the **model** defined in the parent view **table** property. The model name is prefixed with 'Create' or 'Modify' as appropriate. For example, if the model was "Port" and an existing port item was selected in the table, the panel title would be "Modify Port".

**Example**

```js
{
    title: 'Temperature Settings',
},
```


## view.panel.width

| Name | view.panel.width |
|-|-|
| Description | Display width of the panel
| Synopsis | `width: "NNpx"`
| Notes | The default panel width is 700px.

**Example**

```js
{
    width: '500px',
},
```



## view.path

| Name | view.path |
|-|-|
| Description | URL path for the view
| Synopsis | `path: "/URL/PATH"`
| Note | The URL path is used by VueJS when constructing the app routes and at runtime for navigating the views.

**Example**

```js
{
    path: '/device/list',
},
```


## view.refresh

| Name | view.refresh |
|-|-|
| Description | Update period to refresh the view's data
| Synopsis | `refresh: Number | "period"`
| Notes | This is the period for refreshable components to update their data. The period may be a number of seconds or a string equivalent.

**Example**

```js
{
    refresh: '5secs',
},
```


## view.role

| Name | view.role |
|-|-|
| Description | Required user role to allow access
| Synopsis | `role: "User-role"`
| Notes | The user role may be selected from "public", "user", "admin", "support" or "owner". The public role permits unauthenticated access. The other roles require a login with the requisite role.

**Example**

```js
{
    role: 'user',
},
```


## view.table

| Name | view.table |
|-|-|
| Description | View data table definition
| Synopsis | `table: {table-properties}`
| Note | The GenericList component displays database model items as a table. The table can be extensively customized by table properties.

**Background**

The table is displayed by retrieving items from the **table.model** database model type. The columns of the table are defined via the **table.fields** and are displayed in order. Table action menu options are derived from the **table.actions** collection with buttons from any relevant view panels.

** Data Table**
![Data Table](/images/manager/table.png){class="screen"}

**Example**

This example formats the image above:

```js
{
    table: {
        model: 'Event',
        fields: [
            {name: 'edit', icon: '$edit'},
            {name: 'timestamp', width: '5%'},
            {
                name: 'severity',
                width: '5%',
                icon: {
                    info: {name: '$info', color: 'green'},
                    warn: {name: '$warn', color: 'orange'},
                    error: {name: '$error', color: 'red'},
                    critical: {name: '$critical', color: 'red'}
                }
            },
            {name: 'source'},
            {name: 'subject', align: 'left'},
            {name: 'message'},
            {name: '*', launch: 'edit'}
        ],
        actions: {
            edit: {count: 1, launch: 'edit'},
            delete: {count: 2, confirm: true}
        }
    }
}
```


## view.table.actions

| Name | view.table.actions |
|-|-|
| Description | Actions that can be performed on selected table items.
| Synopsis | `actions: { action, ...}`
| Notes | The action collection has one or more action definitions. Each definition is a set of properties that scopes how many items can be manipulated (count), the view panel to display (panel), if user confirmation is required before taking the action (confirm) and whether a launch button should be displayed (launch).

**Example**

```js
{
    table: {
        actions: {
            edit: {count: 1, launch: 'edit'},
            delete: {count: 2, confirm: true}
        }
    }
}
```


## view.table.actions.confirm

| Name | view.table.actions.confirm |
|-|-|
| Description | Display a dialog requesting user confirmation before invoking the action.
| Synopsis | `confirm: true | false`

**Example**

```js
{
    table: {
        actions: {
            delete: {count: 2, confirm: true}
        }
    }
}
```


## view.table.actions.count

| Name | view.table.actions.count |
|-|-|
| Description | Number of selected items the action supports.
| Synopsis | `count: Number`
| Notes | Set count to 0 for "add" actions that require no selected items. Set count to 1 for actions that can operate on only 1 item at a time. Set count to 2 for actions that can operation on multiple selected items.

**Example**

```js
{
    table: {
        actions: {
            delete: {count: 2, confirm: true}
        }
    }
}
```


## view.table.actions.invoke

| Name | view.table.actions.invoke |
|-|-|
| Description | Panel name to display or URL to navigate to when the action is invoked
| Synopsis | `invoke: "ComponentName"`
| Notes | The invoke property defines a VueJS component that will be invoked when the action is triggered. The component will be passed properties containing the data item (item) and the data model (model).

**Example**

```js
{
    table: {
        actions: {
            restart: {count: 2, launch: 'NetRestart'}
        }
    }
}
```


## view.table.actions.launch

| Name | view.table.actions.launch |
|-|-|
| Description | Panel name to display or URL to navigate to when the action is invoked
| Synopsis | `launch: "PanelName" | "URL"`
| Notes | If set to a URL, you can use **:token** segments that will be expanded at runtime from the application route context.

**Example**

```js
{
    table: {
        actions: {
            add: {count: 0, launch: 'claim'}
        }
    }
}
```


## view.table.actions.panel

| Name | view.table.actions.panel |
|-|-|
| Description | Panel to display when the action is invoked
| Synopsis | `panel: "PanelName"`
| Notes | Panels can only be used for actions of count 0 or 1.

**Example**

```js
{
    table: {
        actions: {
            edit: {count: 1, launch: 'edit'}
        }
    }
}
```

## view.table.fields

| Name | view.table.fields |
|-|-|
| Description | Define the table fields (columns) to display.
| Synopsis | `fields: [ {field-definitions}, ...]`
| Notes | The fields define each column in the displayed table. A field definition includes the data items name, with display formatting options.<br><br>A pseudo field with the name "*" may be defined to specify a launch action that will be invoked as a default when a row/column combination is click.

**Example**

```js
{
    table: {
        model: 'Port',
        fields: [
            {name: 'edit', icon: '$edit', width: '5%'},
            {name: 'name', align: 'center'},
            {
                name: 'status',
                align: 'center',
                icon: {
                    online: {name: '$online', color: 'green'},
                    offline: '$offline'
                }
            },
            {name: 'negotiate', align: 'center', icon: '$check'},
            {name: 'duplex', align: 'center', icon: '$check'},
            {name: 'flowControl', align: 'center', icon: '$check'},
            {name: 'jumbo', align: 'center', icon: '$check'},
            {name: 'speed', align: 'center'},
            {name: '*', launch: 'edit'}
        ]
    }
}
```


## view.table.fields.align

| Name | view.table.fields.align |
|-|-|
| Description | Align the table column
| Synopsis | `align: "center | left | right"`

```js
{
    align: 'center'
}
```

## view.table.fields.css

| Name | view.table.fields.css |
|-|-|
| Description | CSS style name
| Synopsis | `style: "RuleName"`
| Note | CSS rule to apply to the displayed field cells. The CSS rule must exist in a custom component.

```js
{
    css:: 'unit-status'
}
```

## view.table.fields.icon

| Name | view.table.fields.icon |
|-|-|
| Description | Display an icon representing the field value
| Synopsis | `icon: "iconAliasName" | {value-map}`
| Notes | When set to a map value, the field value is used as an index into the map. If the index is not found, the "default" index is used. The map value may be either an icon name or a map containing a "name" property that specifies the icon name and a color property that specifies the color to use for the icon.

```js
{
    icon: 'mdi-pencil'

    // or
    icon: {
        online: {name: '$online', color: 'green'},
        offline: '$offline',
        default: '$offline'
    }
}
```

## view.table.fields.launch

| Name | view.table.fields.launch |
|-|-|
| Description | Panel to launch or URL to navigate to
| Synopsis | `launch: "PanelName" | "URL"`
| Notes | If set to a URL, you can use **:token** segments that will be expanded at runtime from the application route context.

```js
{
    launch: 'edit'
}
```



## view.table.fields.name

| Name | view.table.fields.name |
|-|-|
| Description | Name of the data item field to display
| Synopsis | `name: "fieldName"`
| Note | If a field.title property is not specified, the name is converted to PascalCase and used as the title.

```js
{
    name: 'id'
}
```


## view.table.fields.style

| Name | view.table.fields.style |
|-|-|
| Description | CSS style to apply to column cells
| Synopsis | `style: "CSS properties; ..."`

```js
{
    style: 'max-width: 400px; text-overflow: ellipsis;'
}
```


## view.table.fields.title

| Name | view.table.fields.title |
|-|-|
| Description | Column title to display for the field
| Synopsis | `title: "Column Title"`

```js
{
    title: 'Current Temperature'
}
```

## view.table.fields.width

| Name | view.table.fields.width |
|-|-|
| Description | Set the preferred width of the column.
| Synopsis | `width: "NNpx" | "NN%"`
| Note | This will set the initial preferred width of the column.

```js
{
    width: '5%'
}
```


## view.table.sort

| Name | view.table.sort |
|-|-|
| Description | How to sort the rows of the table
| Synopsis | `sort: "column:asc|desc"`

**Example**

This will sort the table based on an ascending order of the "name" column.

```js
{
    table: {
        sort: 'name:asc',
    }
}
```



## view.table.model

| Name | view.table.model |
|-|-|
| Description | Database model name to retrieve for table data
| Synopsis | `model: "ModelName"`

**Example**

```js
{
    table: {
        model: 'Event',
    }
}
```


## view.widgets

| Name | view.widgets |
|-|-|
| Description | Set of widgets to display when using the Dashboard component.
| Synopsis | `widgets: [ {widget}, ...]`
| Note | The widgets property defines an ordered set of widgets to be displayed by the Dashboard component. The enclosing view must set the component property to "Dashboard".

**Example**

```js
{
    views: [ {
        name: 'Overview',
        component: 'Dashboard',
        widgets: [
            {
                type: 'gauge',
                title: 'Network IO',
                min: 0,
                max: 10000,
                data: { model: 'Stats', field: 'io' }
            }
        ]
    } ]
}
```

**Supported Widget Types**

* button
* event
* file
* form
* gauge
* graph
* image
* input
* led
* numeric
* progress
* service
* shape
* sign
* text
* table

## view.widget.accept

| Name | view.widget.accept |
|-|-|
| Description | Define file types acceptable for use with a file up load widget
| Synopsis | `accept: 'image/*'`


## view.widget.action

| Name | view.widget.action |
|-|-|
| Description | Automation actions to invoke when the widget is clicked
| Synopsis | `action: { type: 'trigger', target: 'MyAction'}`

Widget actions are used to react to user input.

Therre are three action types:

* trigger - Invoke a device cloud automation trigger
* link - Navigate to a new URL in the app
* dashboard - Display the named dashboard

The action target is the name of the automation action, the navigation URL or the dashboard name, depending on the action type.

For **trigger** types, when the widget is clicked, the set of conditions are evaluated. For the first condition that evaluates to true, the specified automation trigger is invoked in the device cloud with the condition parameters.

**Example**

```js
{
    action: {
        type: 'trigger',
        trigger: 'MyAction',
        conditions: [{
            expression: 'expression-to-eval',
            params: {}
        }]
    }
}
```

**Example**

```js
{
    action: {
        type: 'link',
        target: '/ports',
    }
}
```

## view.widget.axes

| Name | view.widget.axes |
|-|-|
| Description | Axes labels for "graph" and "time" widgets.
| Synopsis | `axes: {"x" "text", "y": "Text"`

**Example**

```js
{
    axes: {
        x: 'Time', 
        y: 'KB'
    },
}
```

## view.widget.data

| Name | view.widget.data |
|-|-|
| Description | Map specifying the widget data source
| Synopsis | `data: {properties...}`

Note | The data.model property specifies the database model name. The data.field specifies the data field within that model.

Data can be sourced from the Ioto cloud database or Ioto metrics. To access data from the database, specify a **model**, **field** and row selection **where** expression.

**Database Example**

```js
{
    data: {
        model: 'Test',
        field: 'cpu',
    }
}
```

This will select the **cpu** field from the **Test** table. You can also use a **where** clause to select a table item (row). For example:

```js
{
    data: {
        model: 'Test',
        field: 'value',
        where: '${name} = {cpu}',
    }
}
```

This will select the **value** field from the **Test** table using the item (row) where the **name** field has the value "cpu".

**Metric Example**

To select an Ioto Metric, first define the metric to be created using the ...

Specify the metric **owner**, **namespace**, **metric** to select the desired metric. Then specify the metric data span to be one of "5min", "hr", "day", "wk", "mth" or "year". Set the metric statistic to be one of "avg", "min", "max", "count", "current" or "sum".

Metrics can have dimensions that further select the desired metric value. 

```js
{
    data: {
        owner: 'account',
        namespace: 'Embedthis/Device',
        metric: 'cpu',
        span: 'day',
        statistic: 'p90',
        dimensions: [{Device: 'deviceId'}],
    }
}
```


## view.widget.datetime

| Name | view.widget.datetime |
|-|-|
| Description | Enable the input widget calendar selection by date, time or datetime
| Synopsis | `datetime: 'datetime'"

**Example**

```js
{
    datetime: 'date'
}
```


## view.widget.field

| Name | view.widget.field |
|-|-|
| Description | Widget field text
| Synopsis | `field: "address"

The `field` property defines the input form field name in which to store the input data.

**Example**

```js
{
    field: 'firstName'
}
```

## view.widget.fields

| Name | view.widget.fields |
|-|-|
| Description | Table widget fields to display
| Synopsis | `fields: [table field names, ...],

The `fields` property defines the table widget fields and their order of display.

**Example**

```js
{
    fields: ['car', 'battery', 'house']
}
```

## view.widget.footer

| Name | view.widget.footer |
|-|-|
| Description | Widget footer text
| Synopsis | `footer: "Footer Text"

The widget header and footer are rendered over the widget in a standard position. You can modify the style and position of the header and footer by using Widget CSS properties.

**Example**

```js
{
    footer: 'Active Ports'
}
```

## view.widget.form

| Name | view.widget.form |
|-|-|
| Description | Form widget name
| Synopsis | `form: "FormName"

The form widget displays a "Save" button that when clicked will submit the values of all input widgets that refer to the form.

If the `widget.text` property is defined, that text will be used instead of "Save".

Input widgets can be used stand-alone without a form in which case, they will submit their value immediately when changed.

If input widgets refer to a form widget, they are only submitted to the cloud when the Save button is clicked.


## view.widget.format

| Name | view.widget.format |
|-|-|
| Description | Numeric display format
| Synopsis | `format: "Format String"

The format string is used to format numeric values.
The following format specifiers can be used:

Character | Description
-|-
0 | digits with leading zero
# | digit 
, | Thousand separators
% | format as percent
+ | Always show sign
- | Show sign if negative
^ | Round up
v | Round down

**Example**

```js
{
    format: '-0#,###.#^'
}
```

## view.widget.framed

| Name | view.widget.framed |
|-|-|
| Description | How to frame the widget
| Synopsis | `framed: boolean | null`

If set to true, the widget will be rendered in a frame. If set to false, it will not have a frame.
If set to null, which is the default, the widget will use the Dashboard frame setting.

**Example**

```js
{
    framed: true
}
```

## view.widget.header

| Name | view.widget.header |
|-|-|
| Description | Widget header text
| Synopsis | `header: 'Widget Header Text'`

The widget header and footer are rendered over the widget in a standard position. You can modify the style and position of the header and footer by using Widget CSS properties.

**Example**

```js
{
    header: 'Temperature Today'
}
```


## view.widget.height

| Name | view.widget.height |
|-|-|
| Description | Widget height in pixels
| Synopsis | `height: Pixels`

**Example**

```js
{
    height: '300'
}
```


## view.widget.input

| Name | view.widget.input |
|-|-|
| Description | Type of input widget
| Synopsis | `input: 'input type'`

If the widget type is set to `input`, the widget.input property defines the type of input.

The supported Input widget types are:

* Checkbox
* Combo
* Date
* File
* Password
* Radio
* Select
* Slider
* Switch
* Text Field
* Text Area

**Example**

```js
{
    input: 'text'
}
```

## view.widget.items

| Name | view.widget.items |
|-|-|
| Description | Set of items to use with the input widget selections
| Synopsis | `items: [{Array or Map}]`

The input `select`, `radio` and `combo` input types utilize selection items. You can provide
either an array of items or a map of items and their corresponding selection values.

**Example**

```js
{
    items: {red: '#FF0000', blue: '#0000FF'}
or
    items: ['red', 'blue', 'yellow'],
}
```


## view.widget.label

| Name | view.widget.label |
|-|-|
| Description | Label to use for input widgets
| Synopsis | `label: 'text label'`

**Example**

```js
{
    label: 'First Name'
}
```


## view.widget.limit

| Name | view.widget.limit |
|-|-|
| Description | Limit of items for the table widget to display 
| Synopsis | `limit: Number'`

The table widget will display items up to the limit and will provide pagination icons to navigate to the next page of results.

**Example**

```js
{
    limit: 20
}
```


## view.widget.left

| Name | view.widget.left |
|-|-|
| Description | Offset from the left of the display to position the widget
| Synopsis | `left: 100`

This property can be used to absolutely position a widget. The property can be set to the number of pixels or to a percentage fraction less than one.

If set to 0.25, the widget will be positioned 1/4 across the page.

**Example**

```js
{
    top: 0,
    left: 0.25,
    height: 100,
    width: 100,
}
```

## view.widget.max

| Name | view.widget.max |
|-|-|
| Description | Maximum data value
| Synopsis | `max: Value`
| Note | This defines the maximum value the data field may take. It is used to scale the widget display. The default is to set the maximum field value observed.

**Example**

```js
{
    max: 100
}
```

## view.widget.min

| Name | view.widget.min |
|-|-|
| Description | Minimum data value
| Synopsis | `min: Value`
| Note | This defines the minimum value the data field may take. It is used to scale the widget display. The default is set to the minimum field value observed.

**Example**

```js
{
    min: 100
}
```

## view.widget.options

| Name | view.widget.options |
|-|-|
| Description | Map of widget specific options
| Synopsis | `options: { properties }'`

Custom widgets can configure and store private options in the widget.options map.

**Example**

```js
{
    options: {
        span: 10000
    }
}
```


## view.widget.placeholder

| Name | view.widget.placeholder |
|-|-|
| Description | Placeholder text to use for input widgets
| Synopsis | `placeholder: 'text'`

The input widget can display placeholder text before a user has entered text.

```js
{
    placeholder: 'Enter a valid phone number'
}
```


## view.widget.prefix

| Name | view.widget.prefix |
|-|-|
| Description | Text prefix to prepend to the displayed value 
| Synopsis | `prefix: 'text'`

The prefix is displayed before the value text. If the prefix contains a `icon:` leading portion, the prefix will be interpreted as an icon.

**Example**

```js
{
    prefix: 'icon:$alarm'
}
```

## view.widget.range

| Name | view.widget.range |
|-|-|
| Description | The time range for data displayed
| Synopsis | `range: {period: Seconds}`

**Example**

```js
{
    range: {
        period: 3600
    }
}
```


## view.widget.statistic

| Name | view.widget.statistic |
|-|-|
| Description | Metric statistic to display
| Synopsis | `statistic: 'avg'`
| Note | Select from "avg", "min", "max", "count", "current" or "sum".

**Example**

```js
{
    statistic: 'sum'
}
```

## view.widget.suffix

| Name | view.widget.suffix |
|-|-|
| Description | Text suffix to append to the displayed value 
| Synopsis | `suffix: 'text'`

The suffix is displayed after the value text. If the suffix contains a `icon:` leading portion, the suffix will be interpreted as an icon.

**Example**

```js
{
    suffix: 'icon:$alarm'
}
```

## view.widget.text

| Name | view.widget.text |
|-|-|
| Description | Text to display. 
| Synopsis | `text: 'message'`

Some widgets such as the Button widget, can display a fixed messages instead of a data source value.

**Example**

```js
{
    text: 'Click Me'
}
```

## view.widget.ticks

| Name | view.widget.ticks |
|-|-|
| Description | The number of data items on the x axis
| Synopsis | `ticks: Number`

**Example**

```js
{
    ticks: 12
}
```

## view.widget.timezone

| Name | view.widget.timezone |
|-|-|
| Description | The timezone to use with the input widget when using a date input field
| Synopsis | `timezone: 'timezone'`

**Example**

```js
{
    timezone: 'utc'
}
```


## view.widget.title

| Name | view.widget.title |
|-|-|
| Description | Widget title to display
| Synopsis | `title: "Title"`
| Note | See also widget.footer


**Example**

```js
{
    title: 'Network IO',
}
```

## view.widget.url

| Name | view.widget.url |
|-|-|
| Description | Source URL for image widgets
| Synopsis | `url: 'URL'`

Image widgets can load images by specifying the widget.url property.

**Example**

```js
{
    url: 'https://example.com/sunset.jpg',
}
```


## view.widget.top

| Name | view.widget.top |
|-|-|
| Description | Offset from the top of the display to position the widget
| Synopsis | `top: 10`

This property can be used to absolutely position a widget.

**Example**

```js
{
    top: 0,
    left: 100,
    height: 100,
    width: 100,
}
```

## view.widget.type

| Name | view.widget.type |
|-|-|
| Description | Type of widget
| Synopsis | `widgets: [ {widget}, ...]`
| Note | The widget type must be set to one of: event, gauge, graph, led, numeric, progress, text, time.


**Example**

```js
{
    type: 'gauge',
    title: 'Network IO',
}
```

## view.widget.validate

| Name | view.widget.validate |
|-|-|
| Description | Validation regular expression for input widgets
| Synopsis | `validate: 'Regular Expression'`

The input widget can use the `validate` property to test user entered data conforms to the required data format.

The regular expression is NOT enclosed in slash delimiters.

**Example**

```js
{
    validate: '^[0-9]+$'

}
```


## view.widget.width

| Name | view.widget.width |
|-|-|
| Description | Widget width in pixels or percentage
| Synopsis | `width: Pixels|Percentage`

**Example**

```js
{
    width: '25%'
}
```

## view.widget.z

| Name | view.widget.z |
|-|-|
| Description | Set the z-order of a widget when using the Exact dashboard layout
| Synopsis | `z: Number`

The Exact dashboard layout engine positions widgets exactly and permits widgets to overlap.
By setting the Z ordering, you can overlay widgets to create a desired effect.

The default `z` value is 0.

**Example**

```js
{
    z: 2
}
```# REST Models

To facilitate the easy access to device data, the DevCore utilizes REST models that provide access methods to get, find, update and manage remote device data.

A REST model adapts Javascript requests for data into HTTP requests to a backend service. The DevCore REST models can communciate with cloud-based or local device backends with change.

## Constructing

For each device data entity, REST models can be created using the DevCore's Rest constructor. For example:

```js
import {Rest} from 'devcore'

const Port = new Rest('port')
```

Once constructed, the app can use the model to manage the controlled entity:

```js
let portList = await Port.find()
let port = await Port.get({name: 'eth-00'})
await Port.remove({id: port.id})
```

## Standard Methods

The Rest construct will create the following standard access methods:

Method | Method | URL | Description
|-|-|-|-|
get | POST | /:controller/get | Get a data item
find | POST | /:controller/find | Find a set of matching items
remove | POST | /:controller/remove | Remove an item
update | POST | /:controller/update | Update an item

Where **:controller** is replaced with the name provided to the Rest constructor. The Ioto cloud service only implements the "POST" method whereas the Ioto agent embedded web server supports all HTTP verbs.

## Custom Methods

You can provide additional methods for custom methods via an additional argument to the Rest constructor.

```js
const Port = new Rest('port', {
    rest: { method: 'POST', uri: '/:controller/reset' },
    ...
})
```

The Ioto embedded web server can define Action methods that connect with each of the REST model request methods via the **webAddAction** C API. 

Hosted device clouds provide standard backend methods. So to implement custom Rest methods, you use a different technique where the logic is implemented inline in the Rest method.

## Inline Custom Methods

You can provide inline methods to implement Rest methods with centralized logic for device operations. 

For example:

```js
const Port = new Rest('port', {
    reset: { invoke: async (fields) => {
        //  Custom logic
    }},
    ...
})
```

## Tunnels Requests

Hosted device cloud requests are handled by a **"Generic"** cloud controller rather than individual controllers for each Rest instance.

Consequently, Rest requests are "tunneled" though the "Generic" controller. To achieve this, the tunnel mapping is specified via the Rest constructor.

```js
const Port = new Rest('port', {}, {
    tunnel: 'Port',
})
```

This will tunnel Port requests to the Generic controller to access the **"Port"** database entity.

## Adding Context

It is sometimes convenient to add application context to the Rest request properties. This can be done via the **"context"** property.

The **context** method is provided the request body properties. These can be modified to add or remove values. 

The **state.app.context** collection stores the **deviceId** and other values added via the **state.app.addContext** method.

For example: this will add the deviceId to all requests:

```js
const Port = new Rest('port', {},
    context: (body) => {
        body.deviceId = state.app.context.deviceId
        return body
    }
)
```

## Rest API Properties

The Rest API method definitions can use the following properties:

Property | Description
-|-
base        | Base url to use instead of the config.api
body        | Post body data
clear       | Clear prior feedback
feedback    | If true, emit feedback on success. Default, emit only on errors.
invoke      | Function to invoke instead of issuing URI request
log         | Set to true to trace the request and response
method      | HTTP method verb
nologout    | Don't logout if response is 401
noparse     | Don't json parse any JSON response
noprefix    | Don't prefix the URL. Use the window.location host address.
progress    | If true, show progress bar.
raw         | If true, return the full response object (see below). If false, return just the data.
refresh     | To control cache refresh
throw       | If false, do not throw on errors
uri         | URI template. Fields prefixed with ":" are expanded.# App Display

You can customize the structure of an app's pages, menus, navigation, panels and add custom UI components.

## Display Configuration

The app's user interface is defined by a JSON5 configuration file named `display.json5`. The file is in a [JSON5](https://json5.org/) format which approximates native JavaScript.

The display.json5 file controls the following display items:

* Display color theme including dark and light modes
* Menu items and options
* UI pages
* Data tables and fields
* Device data edit property panels
* Dashboards and widgets
* Configurable Options

Here is a subset example of a display.json5 file:

```js
{
    version: '1.0.0',
    description: 'Display for Kickstart',
    features: {
        dash: {
            actions: true,
            edit: true,
            database: true,
            metrics: true,
        }
    },
    theme: {
        title: 'Device Manager',
        logo: '/images/ioto-logo.png',
        themes: {
            dark: { ... },
            light: { ... },
        }
    },
    views: [
        { path: '/', name: 'home' },
        { name: 'Login', path: '/auth', component: 'Login' },
        {
            name: 'devices',
            path: '/devices',
            icon: 'devices',
            sidebar: true,
            component: 'GenericList',
            table: {
                model: 'Device',
                subtitle: 'Click on a device to explore',
                fields: [
                    {name: 'product'},
                    {name: 'description'},
                    {name: 'model'},
                    {name: 'id', title: 'Device ID'},
                    {name: '*', launch: '/devices/:id/overview'}
                ],
                actions: {
                    add: { count: 0, launch: 'claim' },
                    release: { 'count': 2,
                        invoke: 'DeviceRelease', confirm: true }
                }
            },
            panels: [ {
                name: 'claim',
                component: 'DeviceClaim',
                button: 'Claim Device'
            } ]
        }
    ]
}
```

## Quick tour

A minimal display.json5 will consist of some top level properties, and a set of views.

**For Example**

```js
{
    version: '1.0.0',
    name: 'MyManager',
    title: 'My Manager',
    description: 'Display for MyManager',
    features: {...},
    views: [
        { name: 'Home', path: '/', redirect: '/dashboard' },
        { name: 'Login', path: '/auth/login', component: 'Login' },
        ...
    ]
}
```

The `title` is used as the application title in the navigation bar. The `version` and `description` are for documentation. The `features` define a set of configurable options.

The `views` define one or more views. If a view has `menu` property set, the app sidebar will display the view icon to launch the view.

See [Display properties](display-properties.md) for a full list of display properties.

## Display Themes

The `theme` property defines the light and dark mode color themes for the app. It may also specify the product logo image to use, font-sizes and default date and time formats.

Here is an example theme:

```js
theme: {
    logo: '/images/logo.png',
    formats: {
        mstime: 'mmm d, H:MM:ss:l',
        time: 'mmm d, HH:MM:ss',
        fulltime: 'ddd d mmm h:MM:ss tt',
        date: 'mmm d, yyyy'
    },
    themes: {
        dark: {
            dark: true,
            colors: {
                background: '#111217',
                surface: '#000000',
                primary: '#3F51B5',
                secondary: '#707070',
                error: '#fb6d6d',
                info: '#2196F3',
                success: '#4CAF50',
                warning: '#FB8C00',
                accent: '#82B1FF',
                'on-accent': '#FFFFFF',
                none: '#000000',
                sidebar: '#363636',
                extra: '#00CDCD',
                anchor: '#1976D2',
                nav: '#3F51B5',
                text: '#DBDBDB',
                form: '#363636',
                border: '#666666',
                'none-lighten-1': '#282828',
                'background-lighten-1': '#080808',
                'text-lighten-1': '#808080',
                'border-lighten-1': '#444444'
            },
            variables: {
                'font-size': '15px'
            }
        },
        light: {
            dark: false,
            colors: {
                background: '#F7F7F7',
                surface: '#FFFFFF',
                primary: '#3F51B5',
                secondary: '#707070',
                error: '#fb6d6d',
                info: '#2196F3',
                success: '#4CAF50',
                warning: '#FB8C00',
                accent: '#82B1FF',
                'on-accent': '#FFFFFF',
                none: '#FFFFFF',
                sidebar: '#FFFFFF',
                extra: '#00CDCD',
                anchor: '#1976D2',
                text: '#484848',
                nav: '#3F51B5',
                form: '#FFFFFF',
                border: '#CCCCCC',
                'none-lighten-1': '#FAFAFA',
                'background-lighten-1': '#F0F0F0',
                'text-lighten-1': '#A0A0A0',
                'border-lighten-1': '#DDDDDD'
            },
            variables: {
                'font-size': '15px'
            }
        }
    }
},
```

## Navigation

The `DevCore` framework provides two axes of navigation:

* Sidebar for top-level items
* Horizontal tabs below the app navigation bar

![Manager](/images/manager/home.png){class="screen"}

The sidebar is populated with items that have a `menu` property set. The horizontal tab menu is built from child views under a parent view that defines an empty `tabs` array property.

On a mobile display, the tabs navigation is placed at the bottom of the page.

## Views

UI pages are created for each item defined under the `views` properties. Each view is a displayable page for a specific browser URL.

The view defines a `name`, navigation `path` and typically a rendering `component`.

```js
{
    views: [
        { name: 'Home', path: '/', redirect: '/dashboard' },
        {
            name: 'Fleet',
            path: '/fleet',
            component: 'Fleet',
        },
        {
            name: 'account',
            path: '/account',
            icon: '$account',
            redirect: 'profile',
            menu: 'Account',
            tabs: [],
            views: [
                {
                    name: 'profile',
                    path: 'profile',
                    component: 'UserProfile'
                },
                ...
            ]
        }
    ]
}
```

If a view defines child views under a `views` property, those child views are presented as tabbed menu options under the parent view if the parent defines an empty `tabs` array.

Views may define a `redirect` property to redirect the browser to another target view.

## Table Views

The `DevCore` framework provides a **GenericTable** component that can be used to display device data as a table.

![Table](/images/manager/table.png){class="screen"}

The table component is a flexible component that can:

* Display data in pages
* Select data items for operations
* Select data via a search box
* Resize columns
* Reorder columns with drag and drop

Table views present data items that can be selected via checkboxes or by clicking on table cells. The display.json5 table definitions can specify how to respond to item selection and cell clicks via `actions`.

An **actions** definition will specify which panels to launch or components to run when the relevant action is invoked.

```js
{
    "table": {
        "model": "Device",
        "fields": [
            {"name": "product"},
            {"name": "id", "title": "Device ID"},
            {"name": "*", "launch": "/devices/:id/overview"}
        ],
        "actions": {
            "add": { "count": 0, "launch": "claim" },
            "release": { "count": 2, "invoke": "DeviceRelease" }
        }
    }
}
```

In this example: when a row in the table is clicked, the wild-card field definition ("*") will cause the browser will be redirected to the `/devices/ID/overview` page.

If table items are selected, depending on the count of items selected, the appropriate action will cause a panel to be "launched" or component to be "invoked" as required.

## Custom Views

The `DevCore` framework is a VueJS single-page app that provides core components to create responsive, interactive device management apps. Custom components will thus be VueJS components. 

Instead of using the GenericList component for a tabular view, you can create custom components to extend the DevCore. Custom views can be any VueJS page of your design -- the sky's the limit.

## Panels

To facilitate editing the properties of a data item, you can defines UI Panels.  A parent view may define zero or more panels that can be invoked to operate on selected data items from the parent view.

![Panel](/images/manager/panel.png){class="screen"}

The panel will animate and slide out from the right side of the screen when launched by a view action or button.

Panels are defined under a views `panels` property.

```js
{
    "panels": [
        {
            "name": "claim",
            "component": "DeviceClaim",
            "button": "Claim Device",
            "width": "500px"
        }
    ]
}
```

A panel has a `name` and a `component` to render and operate the panel. It may specify a `button` which will be added to the parent view table to launch the panel. Alternatively, panels may be launched via view table actions.

## Dashboards

The DevCore has a `Dash` component that can be used in any view to provide a graphical canvas to display interactive widgets connected to live device data.

Some of the supported widget types are:

* button
* event
* form
* gauge
* graph
* image
* input
* led
* numeric
* progress
* sign
* table
* text

Here is an example view:

```js
{
    name: 'Overview',
    title: 'Device Overview',
    menu: 'Overview',
    path: '/overview',
    icon: '$dashboard',
    component: 'Dash',
    widgets: [
        {
            type: 'gauge',
            name: 'Network IO',
            data: {
                model: 'Stats',
                field: 'io',
            },
            width: '.23',
        },
    ]
}
```

## Widget Data

You can connect device metric or database data to widgets via the `data` property.

To connect with database data, set the `model` and `field` properties. The `model` defines the database entity model. The `field` defines the database item attribute (column).

An optional `where` property defines a matching expression that is used to select the qualifying item (row).

```js
{
    data: {
        model: 'Test',
        field: 'cpu',
        where: '${name} = {cpu}',
    }
}
```

For metric data, define the `namespace`, `metric`, `dimensions`, `statistic` and `period` properties.

```js
{
    data: {
        namespace: 'Embedthis/Device',
        metric: 'UpdateSuccess',
        dimensions: [],
        statistic: 'avg'
        period: 3600,
    }
}
```

## Designing Pages and Widgets

It can be an easy and effective way to design your pages and widget layouts by using the low-code App Designer. Once the page is the way you like it, you can then export the page from the Pages list. This will export a JSON5 file that can then be modified and pasted into the display.json5.

## Authorizing Access

It may be required to control access to specific views based on the authorized role of a user. For example, you may only want administrators to be able to view certain resources.

The Manager allows the visibility of views, panels, table columns and panel fields to be controlled depending on the user's authorized role.

By specifying a `role` property, you can require that the user have at least this capability to access the designated element.

For example, to only allow access to a view by adminstrators:

```js
{
    "name": "fleet",
    "component": "Fleet",
    "role": "admin",
},
```

## Configurable Options

See the [Display properties](display-properties.md) for a full list of display features.

## Examples

The Ioto agent distribution includes several management applications that define **display.json5** display files to customize the appearance of the app.
# Demo App

The Demo app is a simple cloud-based app that demonstrates sending data to the device cloud.

The Demo app uses the Standard device manager UI with a customized data schema and custom device metrics.

The Demo App is an example of a [Customized Device Manager](/apps/patterns/). This means it adds a device data schema to the Standard device manager.

![Demo Dashboard](https://www.embedthis.com/images/demo/demo-home.avif){class="screen"}

The Demo App demonstrates

* How to download and build the Ioto agent with custom extensions
* How to create a custom database schema
* How to create a device cloud and manager app
* How to send device data to the cloud

This sample will:

* Download and build the Ioto device agent with custom logic.
* Create a regional device cloud.
* Create a device manager app.
* Create a custom metric based on the device data.

## Device Agent

The Demo app extends the Ioto agent by providing an extension code module, database schema and agent configuration. 

## Device Manager

The Demo app uses the unmodified, Standard Device Manager app &mdash; so you don't need to build or upload a manager UI app. 

The Demo app UI is designed to run on a mobile device, but can also be used on a desktop.

## Steps

<!-- no toc -->
- [Create Product](#create-product)
- [Download Agent](#download-agent)
- [Build Agent](#build-agent)
- [Create Device Cloud](#create-device-cloud)
- [Create Device Manager](#create-device-manager)
- [Run Agent](#run-agent)
- [Launch Device Manager](#launch-device-manager)
- [Claim Device](#claim-device)
- [Device Data](#device-data)
- [Show Data Metrics](#data-metrics)
- [Show Data Widgets](#data-widgets)

## Create Product

The first step is to create an Demo product definition in the [Builder](https://admin.embedthis.com/).

Navigate to the [Builder](https://admin.embedthis.com/clouds) site and select `Products` in the sidebar menu and click `Add Product`. Then create a product definition by entering a product name and description of your choosing. Select the `Ioto Agent` and select `By Device Volume` and enter `1` in the Total Device field. Your first device is free.

![Demo Product](https://www.embedthis.com/images/demo/demo-product-edit.avif){class="screen width-80"}

## Download Agent

Once the product definition is created, you can click `Download` from the Products list and save the source distribution to your system. The eval version of Ioto will be fine for this solution.

![Product List](https://www.embedthis.com/images/builder/product-list.avif){class="screen width-80"}

Take note of the `Product ID` in the product listing. You can also click on the product ID to copy it to the clipboard. You will enter this product ID in the Ioto configuration file: `apps/demo/config/device.json5`. 

## Build Agent

To build the Ioto agent with Demo extensions, first extract the source files from the downloaded archive:

    $ tar xvfz ioto-demo-src.tgz

Before building, edit the `apps/demo/config/device.json5` file and paste in the Product ID into the `product` property.
 
Then build Ioto with the Demo app, by typing:

    $ make APP=demo

This will build Ioto, the Demo app and will copy the Demo config files to the top-level `./config` directory.

## Create Device Cloud 

Before running Ioto, you need to create a Device Cloud for your agent to communicate with. The device cloud manages communication with devices and stores device data. 

To create a device cloud, navigate to the [Builder Clouds List](https://admin.embedthis.com/clouds) by selecting `Clouds` from the side menu. Then click `Add Cloud`. Enter your desired cloud name, and select `Hosted by Embedthis` in a region close to you. You can create the cloud and connect one device for free.

Check the `Upload Schema` option and upload the `./config/schema.json5` file from your extracted Ioto source code. This schema defines the database for the Demo app.

## Create Device Manager

To view your device state, you need to create a Device Manager that will host the Demo App UI. This will create an instance of the Standard device manager and host it globally on the EmbedThis Ioto device cloud.

Select `Managers` from the Builder side menu and click `Add Manager`. Enter your desired manager name (Demo) and pick a domain name for your Demo app. The domain will be a subdomain of the `ioto.me` domain and will be automatically registered and published for you. Later, if you create a dedicated device cloud, you can select your own custom domain with any TLD extension.

The Demo App uses the Standard device manager UI. In the future, if you wish to customize the UI, you can modify, rebuild or replace the portions or the whole of the underlying manager app with your own custom app.

The Standard device manager is a VueJS app that provides the following components:

* Login and auth
* Navigation
* Device claiming
* Dashboards & widgets
* Device Metrics and analytics
* Device data display and tables
* Alerts
* Responsive mobile & desktop presentation
* Dark/light mode support

After creating the manager, you need to wait a few minutes (and sometimes up to 30 minutes) to let the domain name entries propagate globally. While waiting, you can start the Ioto agent.

## Run Agent

The easiest way to run the Ioto agent with Demo extensions is to type:

```bash
$ make run
```

When Ioto is run, the Demo app will run a demo routine that updates the `Service` table with a counter every 30 seconds. The demo is configurable via the `ioto.json5` "demo" configuration collection. The demo can be configured to tailor the delay, number of updates and the mechanism used to perform updates. See comments in the `demoApp.c` for details.

In the console output, you will see a unique device ID displayed. This is a `Device Claim ID` that you can use to claim the device for exclusive management by your Demo app. Take note of that device claim ID.

When Ioto starts, it will register with the Builder and wait to be claimed by your Demo App.

## Launch Device Manager

From the Builder manager list, click the "Manage" column to launch your device manager. This will launch your default browser and navigate to the domain URL you chose when creating the manager.

![Manager List](https://www.embedthis.com/images/builder/manager-list.avif){class="screen width-80"}

Once launched, you will need to register and create a new account with the Device Manager. This is an "end-user" account for the owner of the device.

> Note: this is not the same as your Builder login. 

![Demo Login](https://www.embedthis.com/images/demo/demo-login.avif){class="screen width-80"}

Enter a username and password and click register. A registration code will be emailed to you. Enter that code in the next screen to complete the registration.


## Claim Device

Once logged in, you can `claim` your device.

Select `Devices` from the sidebar menu and click `Claim Device` and then enter the claim ID shown in the Ioto agent console output. 

![Demo Claim](https://www.embedthis.com/images/demo/demo-claim.avif){class="screen width-80"}

The Ioto agent will poll regularly to see if it has been claimed. After starting, the Ioto delay between polling gradually increases. If the agent has been running a long time, the polling period may be up to 1 minute in length. You can restart the agent to immediately check with the Builder.

## Import Dashboard

After claiming, you can import the Demo dashboard from `./config/Display.json5`. 

Select `Dashboards` from the sidebar menu and click `Actions/Import` and select the `./config/Dashboard.json5` file. 

After loading the dashboard, you can select the DemoHouse dashboard from the Dashboard list to display the Demo Dashboard.

Note: you can remove the Default dashboard at any time as it is not used by this sample.


## Show Device Data

After claiming the device for management, you will start to see device data in the Manager app. Navigate to `Device Data` and you will see a list of database tables.

![Table List](https://www.embedthis.com/images/demo/demo-table-list.avif){class="screen width-80"}

From the table list, click on the `Service` table to display its contents. 

![Service Table](https://www.embedthis.com/images/demo/demo-service-table.avif){class="screen width-80"}

You can edit values inline, your select a row and click edit to display the item edit panel.

![Table Edit](https://www.embedthis.com/images/demo/demo-table-edit.avif){class="screen width-80"}

## Show Data Metrics

You can create data metrics from device data so that you can track and manage device data values over time.  Metrics can be used to provide data for dashboard widgets such as graphs and gauges. Metrics can also be used to invoke automatic actions via metric triggers.

To create a device metric, navigate to the Builder `Automations` page and select the `Actions` tab, select your device cloud and click `Add Action`. Give your action a name like "Metric" and select `Manager Metric` from the action type list. Some actions take addition parameters, but the ManageMetric action does not.

Then select the `Triggers` tab and click `Add Trigger`. 

![Demo Trigger](https://www.embedthis.com/images/demo/demo-trigger-add.avif){class="screen width-80"}

Select `Database Update` as the Trigger Source and select the name of your Action created above as the Action. Select "COUNTER" as the Metric Name, "Device=${deviceId}" as the Metric Dimensions and "${value}" as the Metric Value.

This will create a metric named "COUNTER" for each device and use the `value` field from the Service table as the value.


### Data Widgets

You can display device data as graphical widgets from the Manager dashboard. Click `Home` to display the dashboard.

Then click the `+` plus icon to open the `Create Widget` panel and select "Graph" as the Widget type from the selection list. Then click the `Data` tab at the top to configure the data source for the widget.

Select `Database` as the namespace, `Service` as the table name and `value` as the item field. 

Then click `Save`. This will display your graph on the dashboard.

![Demo Dashboard](https://www.embedthis.com/images/demo/demo-home.avif){class="screen width-80"}


## How It Works

The following section provides a background on some of the design and implementation of the Demo app.

### Device Agent

The Ioto device agent is extended via an Demo module. There are three files:

File | Description
-|-
demoApp.c | Code for the Demo extension

This module uses the Ioto `ioStart` and `ioStop` hooks to start and stop the extension. When linked with the Ioto agent library, these hooks replace the stub functions and are called by Ioto on startup and shutdown.

The ioStart routine checks if the `demo.enable` property is true in the `ioto.json5` configuration file. If true, it schedules the `evalDemo` routine to run when Ioto connects to the cloud by using the `ioOnConnect` API.

### Database 

The database schema is used by both the Ioto agent and device cloud to define the Demo data app tables and items.

The `apps/demo/config/schema.json5` defines the overall schema and the `DemoSchema.json5` file defines the Demo specific portions.

The underlying agent database and the cloud database are based on the [AWS DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html) database which is a highly scalable, high-performance, NoSQL, fully managed database.

There are 2 database tables. These are:

Name | Sync Direction | Purpose
-|-|-
Service | up | A service-level table with a single item.
Log | up | Log table that creates new items with each update.

The Ioto database synchronization automatically replicates data up to the cloud and down to the device according to the sync direction. You do not need to explicitly send data to or from the cloud (unless you want to). Ioto database replication does this transparently, reliably and efficiently.

### Device Manager 


The Demo App is an example of a [Customized Device Manager](/apps/patterns/). This means it adds device data schema to the Standard device manager.

## See More

For another sample, checkout the [EcoHouse Sample](/apps/samples/eco/).

## Directories

| Directory | Purpose                      |
| --------- | -----------------------------|
| config    | Configuration files          |
| src       | Demo App C source code       |

## Key Files

| File               | Purpose                                   |
| -------------------| ------------------------------------------|
| DemoSchema.json5   | Demo database schema file                 |
| ioto.json5         | Primary Ioto configuration file           |
| schema.json5       | Complete database schema file             |
| src/*.c            | Device-side app service code              |
# Unit Testing Application

The Unit (test) application builds Ioto with test suites that can exercise the various Ioto subsystems.

This app is used by EmbedThis and customers to verify operation of Ioto.

## Building

To build the Unit application select the APP and run make:

```bash
$ make APP=unit clean build
```

The build will achieve the following goals:

* Build the Ioto agent with unit test suites 
* Copy the required configuration to the ./config directory

The Ioto agent binary will be located in the build/PROFILE/bin/ioto file.

Change the **ioto.json5** services property collection to enable or disable Ioto services.

## Testing

Run Ioto using:

```bash
$ make run
```

Currently the TestMe unit test suite is required to exercise the Ioto unit tests. 

A subset of the unit tests are located under the **./test** directory.# NoApp Application

The NoApp application builds Ioto with the required application integration start/stop callback functions but does not provide any user interface. This app is useful for building Ioto to operate "headless" as an embedded device agent or embedded web server without a user interface.

## Building

To build the NoApp application select the APP and run make:

```bash
$ make APP=noapp clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for local device management via the embedded web server
* Copy the required configuration to the ./config directory

The Ioto agent binary will be located in the build/PROFILE/bin/ioto file.

Change the **ioto.json5** services property collection to enable or disable Ioto services.

## Running

Run Ioto using:

```bash
$ make run
```# Auth Application

The Auth application builds a simple (trivial) user interface for testing the Ioto web user login primitives.

## Overview

The Auth application is a low-level sample for testing user login and authentication access. It is not intended to be used as the basis for any production application.

The Auth app offers a simple UI to login and logout as an "admin" or "guest" user. When logged in as a guest, you will have limited access to certain pages.

## Building

To build the Auth application select the APP and run make:

```bash
$ make APP=auth clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for local device management
* Build the Auth local web application
* Copy the required configuration to the ./config directory
* Copy the required local web site to the ./site directory

The Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The Auth application will be located under the **./site** directory.

## Running

Run Ioto using:

    $ make run

Then browse to

    https://localhost:4443

You will probably see a warning about the connection not being secure or "Your connection is not private". This is expected. This is a browser warning that the application is using a test TLS/SSL certificate. You may proceed as instructed and the app home page will be displayed.

![Auth Home](/images/ioto/auth-app.png){class="screen"}

## Test Users

The auth app defines two test users:

* admin
* guest

Both have a password of **"demo"**. 

You can login using either account and then test accessing the various UI tabs. The guest account will have access to only a subset of pages.# Kickstart Screen Shots

The following screenshots show some of the functionality of the Kickstart manager application.

## Home Screen

![Home Page](/images/kickstart/home.png){class="screen"}

The Kickstart home screen with dashboard and pulldown notification event window.

## Widgets

![Gauge Widget](/images/kickstart/gauge.png){class="screen"}
![LED Widget](/images/kickstart/LedWidget.png){class="screen"}
![Numeric Widget](/images/kickstart/NumericWidget.png){class="screen"}
![Graph Widget](/images/kickstart/GraphWidget.png){class="screen"}

The dashboard can use graphical widgets connected to a server-side data source. Data is pushed from the server over WebSockets. A gauge can define a min to max range and it uses animation to smooth transitions between data points.

## Graphs
![Graphs](/images/kickstart/graphs.png){class="screen"}

Server data can be plugged into charts for graphical display. Ioto provides primitives to convert device data to JSON that can be easily connected to a suite of charts.

## Sidebar Navigation

![Navigation](/images/kickstart/navigation.png){class="screen"}

Kickstart supports multi-level navigation. The current option is highlighted with show/hide indicators. Menus can be hidden if the authenticated user does not have the required permissions.

![Sub Menus](/images/kickstart/submenu.png){class="screen"}

## Events Screen

![Events](/images/kickstart/events.png){class="screen"}

The events log describes system events of interest according to severity. You can create events in the server for any custom condition.

## Feedback

![Feedback](/images/kickstart/feedback.png){class="screen"}

Error messages and user feedback are transparently channeled to the browser and displayed with appropriate color coding. This may be customized by modifying the application theme stylesheet.

![Feedback Theme](/images/kickstart/feedback-2.png){class="screen"}

## Login Screen

![Login](/images/kickstart/login.png){class="screen"}

Kickstart include a complete user login mechanism. Passwords are securely hashed using Blowfish encryption. Kickstart automatically ensures the login form and request are transported using SSL.
After login, users can be granted access to parts of the application dependent on their configured roles.

## Dialogs

![Dialogs](/images/kickstart/dialog.png){class="screen"}

Kickstart includes easy to use confirmation modal dialogs to confirm destructive actions.

![Modals](/images/kickstart/modal.png){class="screen"}
# Kickstart Application

The Kickstart app is a sample VueJS single-page application that you can use as a starting point for your device management applications. 

Kickstart demonstrates the capabilities and experience provided by an application created with Ioto and VueJS. It includes includes a UI/UX for a sample router/switch application. Kickstart uses proven designs and best-practices to lower development risk. It includes most of the required elements for a secure web application, so you can eliminate months off your development schedule.

The Kickstart App is an example of a [Customized Device Manager](/apps/). This means it rebuilds the Standard device manager app to add custom UI components, a customized data schema and dashboard.

![Kickstart](/images/kickstart/home.png){class="screen"}

## Kickstart Components

* User management
* User login
* Property edit
* Alert notification
* Event log
* Dashboard
* Dynamic tables and graphs
* Paged Data Tables
* Navigation
* Search
* Granular access control per page
* Help

Read the [Kickstart Components](./specs.md) for full details.

## Kickstart Screens

See the [Kickstart Screen Images](./screenshots.md) for a close up look.

## Building

To build the Kickstart application select the APP and run make:

```bash
$ make APP=kickstart clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for local device-based management.
* Build the Kickstart application.
* Copy the required configuration to the ./config directory.
* Copy the Kickstart app to the ./site directory.
* Initialize the Ioto local database with login user definitions.

After building, the Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The Kickstart application will be copied to the **./site** directory.

## Running

To run Ioto, type:

```bash
$ make run
```

## Browsing

To view the Kickstart home page, launch your browser and navigate to the URL:

```
https://localhost:4443
```

You will probably see a warning about the connection not being secure or "Your connection is not private". This is expected. This is a browser warning that the application is using a test TLS/SSL certificate. You may proceed as instructed and the app home page will be displayed.

You can login with the test user credentials:

Username | Password
-|-
**admin** | demo

## Demo

The Kickstart app includes some mock device data that emulates a simple router device with data updates every 5 seconds. 

![Console](/images/ioto/console-app.png){class="screen"}

The source to increment the database counter is in **apps/console/src/demo.c**.

## Device Schema

The Kickstart app defines a suite of device entities in the database schema via the configuration file: **apps/kickstart/config/schema.json5**. This includes database entities for Events, Ports, Port Mappings, Stats, and VLANs.

For more information about the device schema, See:

* [Device Tables / Database Schemas](/apps/database/schemas/)
* [Database Replication](/ioto/database/replication.md)

## Configuring the Kickstart Display

The Kickstart user interface is defined by the **apps/kickstart/config/display.json5** config file that can be modified or extended to suit your specific needs. 

The display.json5 file defines the following items:

* UI features
* Displayed Name
* Display color theme including dark and light modes
* Logo to display in the navigation bar
* Menu items and options
* UI pages and panels
* UI navigation routes
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

For more information about the display file, read [Manager Display](/apps/config/display.html).

<!--
## Cloud-Based Device Management

The [cloud-kickstart](../cloud-kickstart/) application emulates the Kickstart app for a sample cloud-based device manager.

This skin approximates the functionality of the local Kickstart app, but allows management of multiple devices via the cloud.
--># Kickstart Specs

Kickstart is an Ioto VueJS application that includes the following UI components:

* User management
* User login
* Property edit
* Alert notification
* Event log
* Dashboard
* Dynamic tables and graphs
* Paged Data Tables
* Navigation
* Search
* Help
* Granular access control per page

## Security

* Best practices security configuration
* Transport Layer Security (TLS/SSL)
* Secure user login
* Password storage with Blowfish hashing and salting
* Granular access control per-page or per URI
* Sandboxed resource limits
* Defensive counter-measures for DOS attacks
* Access and access violation logging
* Content Security Policy to minimize cross-site scripting
* CrossOrigin sharing support
* Hidden frame hijack prevention
* Hardened against Crime, Breach, Beast and Lucky 13 exploits
* Executes with minimal privilege in Chroot jail
* Safe portable runtime to protect against memory leaks and buffer overflows
* Angel monitoring process

## Performance

* Highly responsive UI with sub-second page transitions.
* Excellent request throughput and scaling.
* Small memory footprint even under heavy load (~1.5MB including TLS, database and entire application).
* HTML, Javascript and stylesheets minified, compiled and compressed into a single file.
* Data interchange with server via optimized JSON requests and responses.

## Pre-integrated Components

* VueJS 3 client-side Javascript library.
* Builds with the modern [Vite](https://vitejs.dev/) build tool.
* [Vuetify 3](https://vuetifyjs.com/en/) Material Design look and feel.
* Themeable SASS style sheets.
# Eco House App

The Eco House app is a demonstration, cloud-based energy management app that emulates a house with solar panels, battery and EV car. It provides configuration for the Ioto device agent, and a stylized mobile app for managing the "home". 

The Eco App is an example of a [Customized Device Manager](/apps/patterns/). This means it uses the Standard device manager UI with a customized data schema, dashboard and devic-cloud automations.

![Eco House Dashboard](https://www.embedthis.com/images/eco/eco-home.avif){class="screen width-60"}

The Eco House App demonstrates

* How to easily create an interactive mobile device manager UI.
* How to extend the Ioto device agent with custom data and logic.
* How to quickly create and deploy an IOT solution with the EmbedThis Builder.

This is not a "trivial" sample. To develop this sample from scratch without the Builder and Ioto would typically take many months of development with associated risk.

This sample will:

* Download and build a device agent with custom logic managing an ECO House.
* Create a regional device cloud to manage devices.
* Create and host a device manager app.
* Create a custom Eco House UI and control panel dashboard.
* Connect user actions from the app with custom logic to control the Eco House.

## Device Agent

The Eco House app extends the Ioto agent by providing an extension code module, database schema and agent configuration. In a "real" home, the Ioto agent with Eco extension would be run on an embedded device such as a [Raspberry PI](https://www.raspberrypi.com/) with wired connections to the solar panels, battery, gateway and EV chargers. For this sample, we run the device agent on a PC/Notebook to simulate a real Eco house embedded device.

## Device Manager

The Eco House app uses the unmodified, Standard Device Manager UI available from the Builder &mdash; so you don't need to build or upload a manager UI. 

The Eco House app is designed to run on a mobile device, but can also be used on a desktop.

## Steps

<!-- no toc -->
- [Create Product](#create-product)
- [Download Agent](#download-agent)
- [Build Agent](#build-agent)
- [Create Device Cloud](#create-device-cloud)
- [Create Device Manager](#create-device-manager)
- [Run Agent](#run-agent)
- [Launch Device Manager](#launch-device-manager)
- [Claim Device](#claim-device)
- [Import Dashboard](#import-dashboard)
- [Create Automation](#create-automation)

## Create Product

The first step to create the Eco House App is to create a product definition in the [Builder](https://admin.embedthis.com/).

Navigate to the [Builder](https://admin.embedthis.com/clouds) site and select `Products` in the sidebar menu and click `Add Product`. Then create a product definition by entering a product name and description of your choosing. Select the `Ioto Agent` and select `By Device Volume` and enter `1` in the Total Device field. Your first device is free.

![Create Eco Product](https://www.embedthis.com/images/eco/eco-product-edit.avif){class="screen width-80"}

## Download Agent

Once the product definition is created, you can click `Download` from the product list and save the source distribution to your system. The eval version of Ioto will be fine for this solution.

Take note of the `Product ID` in the product listing. You can also click on the product ID to copy it to the clipboard. You will enter this product ID in the Ioto configuration file: `apps/eco/config/device.json5`. 

## Build Agent

To build the Ioto agent with Eco extensions, first extract the source files from the downloaded archive:

    $ tar xvfz ioto-eval-src.tgz

Before building, edit the `apps/eco/config/device.json5` file and paste in the Product ID into the `product` property.
 
Then build Ioto with the Eco app, by typing:

    $ make APP=eco

This will build Ioto, the Eco app and will copy the Eco config files to the top-level `./config` directory.

## Create Device Cloud 

Before running Ioto, you need to create a Device Cloud for your agent to communicate with. The device cloud manages communication with devices and stores device data. 

To create a device cloud, navigate to the [Builder Clouds List](https://admin.embedthis.com/clouds) by selecting `Clouds` from the side menu. Then click `Add Cloud`. Enter your desired cloud name, and select `Hosted by Embedthis` in a region close to you. You can create the cloud and connect one device for free.

Check the `Upload Schema` option and upload the `./config/schema.json5` file from your extracted Ioto source code. This schema defines the database for the Eco House app.

## Create Device Manager

To view your device state, you need to create a Device Manager that will host the Eco App UI. This will create your Eco House App UI and host it globally on the EmbedThis Ioto device cloud.

Select `Managers` from the Builder side menu and click `Add Manager`. Enter your desired manager name (EcoHouse) and pick a domain name for your Eco app. The domain will be a subdomain of the `ioto.me` domain and will be automatically registered and published for you. Later, if you create a dedicated device cloud, you can select your own custom domain with any TLD extension.

You can specify an app logo for your device manager. For now, you can use the `apps/eco/config/eco-logo.avif` logo file.

The Eco App uses the Standard device manager UI navigation with a custom dashboard UI. In the future, if you wish to completely customize the UI, you can modify, rebuild or replace the portions or the whole of the underlying manager app with your own custom app.

The Standard device manager is a VueJS app that provides the following components:

* Login and auth
* Navigation
* Device claiming
* Dashboards & widgets
* Device Metrics and analytics
* Device data display and tables
* Alerts
* Responsive mobile & desktop presentation
* Dark/light mode support

After creating the manager, you need to wait a few minutes (and sometimes up to 30 minutes) to let the domain name entries propagate globally. While waiting, you can start the Ioto agent.

## Run Agent

The easiest way to run the Ioto agent with Eco House extensions is to type:

```bash
$ make run
```

In the console output, you will see a unique device ID displayed. This is a `Device Claim ID` that you can use to claim the device for exclusive management by your Eco House app. Take note of that device claim ID.

When Ioto starts, it will register with the Builder and wait to be claimed by your Eco House App.

## Launch Device Manager

From the Builder manager list, click the "Manage" column to launch your device manager. This will launch your default browser and navigate to the domain URL you chose when creating the manager.

![Manager List](https://www.embedthis.com/images/builder/manager-list.avif){class="screen"}

Once launched, you will need to register and create a new "end-user" account with the Device Manager. 

> Note: this is not the same as your Builder login. 

![Eco Login](https://www.embedthis.com/images/eco/eco-login.avif){class="width-50"}

Enter a username and password and click register. A registration code will be emailed to you. Enter that code in the next screen to complete the registration.

## Claim Device


Once logged in, you can `claim` your device.

Select `"Devices"` from the sidebar menu and click `Claim Device` and then enter the claim ID shown in the Ioto agent console output. 

![Eco Claim](https://www.embedthis.com/images/eco/eco-claim.avif){class="screen width-50"}

The Ioto agent will poll regularly to see if it has been claimed. After starting, the Ioto delay between polling gradually increases. If the agent has been running a long time, the polling period may be up to 1 minute in length. You can restart the agent to immediately check with the Builder.

## Import Dashboard

After claiming, you can import the Eco house dashboard from `./config/Display.json5`. 

Select `Dashboards` from the sidebar menu and click `Actions/Import` and select the `./config/Dashboard.json5` file. 

After loading the dashboard, you can select the EcoHouse dashboard from the Dashboard list to display the Eco Dashboard.

Note: you can remove the Default dashboard at any time as it is not used by this sample.

## Create Automation

To respond to user actions in the Eco House App, you create a `Builder Automation Action` and `Trigger`. Then when the user clicks an Eco House App button, a request is sent to the device cloud which invokes the trigger and action. 

In the Eco House sample, the `Charge Car` button is connected to a database update action in the device cloud. The Eco extensions in the Ioto agent subscribe to watch changes to this table and can react when the user wants to charge the car.

To configure a Builder action, navigate to the Builder `Automations` page and select the `Actions` tab, select your device cloud and click `Add Action`. Give your action a name like "Database" and select `Database` from the action type list. Some actions take addition parameters, but the database action does not.

Then select the `Triggers` tab and click `Add Trigger`. 

![Eco Trigger](https://www.embedthis.com/images/eco/eco-trigger-add.avif){class="screen width-70"}

Select `User Trigger` as the Trigger Source and select the name of your Action created above as the Action. Select `Upsert` and `Desired` as the database entity.

Now, when a user clicks the `Charge Car` button in the Eco App, that will send a message to the Automation trigger which will update the `Desired` database entity. The Eco App defines which field to update in the button widget. The imported Dashboard will have this already configured. 

If you are interested, you can put the dasboard into development mode by disabling `Fixed Design` and `Frameless Widgets` in the Dashboard edit panel.

![Eco Dashboard](https://www.embedthis.com/images/eco/eco-dash-edit.avif){class="screen width-70"}

Then you can modify a widget configuration by clicking the "Pencil" icon at the top right of the widget. This will display the Widget properties panel.

![Eco Widget](https://www.embedthis.com/images/eco/eco-widget-action.avif){class="screen width-70"}

## How It Works

The following section provides a background on some of the design of the Eco House app.

### Device Agent

The Ioto device agent is extended via an Eco House module. There are three files:

File | Description
-|-
eco.h | Eco House header
eco.c | Implementation of the ioStart and ioStop routines 
ecoApp.c | Code for the Eco House extension

This module uses the Ioto `ioStart` and `ioStop` hooks to start and stop the extension. When linked with the Ioto agent library, these hooks replace the stub functions and are called by Ioto on startup and shutdown.

The ioStart routine checks if the `demo.enable` property is true in the `ioto.json5` configuration file. If true, it schedules the `ecoManager` routine to run when Ioto connects to the cloud by using the `ioOnConnect` API.

### Database 

The database schema is used by both the Ioto agent and device cloud to define the Eco House database.

The `apps/eco/config/schema.json5` defines the overall schema and the `EcoSchema.json5` file defines the Eco House specific portions.

The underlying agent database and the cloud database are based on the [AWS DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html) database which is a highly scalable, high-performance, NoSQL, fully managed database.

There are 5 database tables. These are:

Name | Sync Direction | Purpose
-|-|-
Capacity | up | Stores battery capacity of the home and EV batteries
Charge | up | Stores the battery charge of the home and EV batteries
Desired | down | Stores the desired state of charging the EV
Flow | up | Stores the current flows to and from all components
State | up | Stores the current charging state of the EV

The Ioto database synchronization automatically replicates data up to the cloud and down to the device according to the sync direction. You do not need to explicitly send data to or from the cloud (unless you want to). Ioto database replication does this transparently, reliably and efficiently.

When the `Charge Auto` button in the Eco House App is clicked, the associated widget action sets the `Desired.car` field to true. This change is then replicated down to the device agent and the Eco House extension is notified of the change. 

### Device Manager 

The Eco House App is an example of a [Customized Device Manager](/apps/patterns/). This means it adds device data schema, custom dashboards to the Standard device manager, and utilizes cloud-side automated actions to react to user and device input.

The Eco house device manager provides a highly usable, responsive mobile and desktop UI.

### Modifying a Dashboard

The Eco House dashboard can be modified by selecting `Edit` from the dasboard list in the Eco app. Then disable `Fixed` and disable `Frameless Widgets`. This will display the dashboard toolbar and make it easy to see the widget size so that you can move and resize widgets. Using the toolbar, you can add or remove widgets and style individual widgets.

## Directories

| Directory | Purpose                                               |
| --------- | ------------------------------------------------------|
| config    | Configuration files                                   |
| src       | App C source code to link with Ioto                   |

## Key Files

| File               | Purpose                                   |
| -------------------| ------------------------------------------|
| Dashboard.json5    | Primary Ioto configuration file           |
| EcoSchema.json5    | Eco House database schema file            |
| ioto.json5         | Primary Ioto configuration file           |
| schema.json5       | Complete database schema file             |
| src/*.c            | Device-side app service code              |
# Manager Application

The Manager application is used by EmbedThis to create the default device app that is configured when apps are created. However, you can also use it as a basis for creating your own bespoke cloud-based management application.

The manager application includes core functionality useful for most cloud-based management apps by offering:

* User authentication (login/logout)
* User account registration (email verification, forgot password support)
* App navigation and menus
* Sidebar navigation 
* Display light / dark mode support
* Dashboards with information widgets (graphs, gauges, tables, numerics)
* Device data display, management and updating
* Device claiming and registration


## Building

To build the manager application select the APP and run make:

```bash
$ make APP=manager clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for cloud-based management
* Build the manager application
* Copy the required configuration to the ./config directory

After building, the Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The application will be located under the **apps/manager/ui/dist** directory which will contain the individual application files and a **app.zip** ZIP file that is ready for uploading via the Builder to the Ioto cloud service for hosting the UI.

## Deploying

To deploy the application, logon to the [Builder](https://admin.embedthis.com) site to create and configure a Device Manager. 

From the Builder app list, click on the **Add App" icon or the **Edit** icon to modify ann app.

![App List](/images/builder/app-list.png){class="screen"}

This will display the app configuration panel.

![App Designer](/images/builder/app-edit.png){class="screen"}


## Domain Name

If your app is hosted by Embedthis, select a sub-domain of your choosing under the **ioto.me** domain. You can select a unique sub-domain that reflects your company or product's brand. The sub-domain name you choose must be globally unique. 

If you are using a **dedicated** device cloud, you can register your own domain name and point that to the underlying Ioto manager site. To use a self-hosted domain, check the "Self Hosted Domain" checkbox and enter your full domain name. If using a self-hosted domain, you will need to use a Domain Registrar of your choosing.

## App Upload

To upload the built app, select **Custom App** and click on the **Zip File** upload field. Navigate to the **apps/manager/ui/dist/app.zip** file and then Save. This will upload the application and deploy to the Ioto service in the appropriate cloud region. It may take a few minutes for the application to be deployed by the Ioto service.

## Device Schema

The Ioto service uses the Ioto agent database schema to define what device specific data should be stored in the cloud and what are the device manageable entities.

The schema describes the device entities and their data properties and data types. Using this schema, the Ioto service and app are able to understand your device-specific data.

Ioto defines a default schema when you create the device cloud. This schema supports a generic key/value store. Initially, you can use the default schema, but as you progress, you may wish to define your own data entities to store device specific data. In this case, you will need to upload your application database schema to the Builder using the **Cloud/Edit** configuration panel.

For more information about the device schema, See:

* [Device Tables / Database Schemas](/apps/database/schemas/)
* [Database Replication](/ioto/database/replication.md)

## Configuring the App Display

The app user interface is defined by a JSON configuration file called **display.json5** that can be modified or extended to suit your specific needs.

The display.json file defines the following items:

* Displayed Name
* Display color theme including dark and light modes
* Menu items and options
* UI pages
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

The initial display.json5 configuration file defines a "developer" skin for the manager app. 

For more information about the display file, read [Manager Display](/apps/config/display.md).

## Learn More?

See [Manager Documentation](/apps/) for Device Manager configuration and operation details.# Management Applications

The Ioto source distribution and the Ioto Apps package contain a suite of management apps to help you get started with Ioto.

Some management apps provide browser-based UIs that are [VueJS](https://vuejs.org/) apps. These apps communicate with either the local Ioto web server or with the cloud-based Ioto service.

These apps are provided with the **Ioto Agent** source distribution.

Name | Pattern | Description
-|-|-
[auth](./auth/) | Local | Simple embedded web server user/group authentication.
blink | Local | Minimal ESP32 (only) blink app to demonstrate linking with Ioto on ESP32 microcontrollers.
[demo](./demo/) |  [Standard](/apps/patterns/)  | Cloud-based demo app for Ioto with data exchange.
[eco](./eco/) | [Customized](/apps/patterns/) | Cloud-based Eco House sample app.
[noapp](./noapp/) | N/A | Headless application without a UI.


These additional apps are provided as part of the **Ioto Apps** download package.

Name | Pattern | Description
-|-|-
[cloudkick](./cloudkick/) | [Rebuilt](/apps/patterns/) | Cloud-based version of Kickstart.
[console](./console/) | Local | Local developer console for Ioto.
[kickstart](./kickstart/) | [Rebuilt](/apps/patterns/)| Local Kickstart sample "router" management app.
[manager](./manager/) | [Standard](/apps/patterns/) | Cloud-based device manager developer console for Ioto.

Read [Building Apps](/agent/user/building.md) for details of how to build the **auth**, **demo** and **noapp** apps. The other apps are provided as part of the **Ioto Apps** download package. Read [Building Apps](./building.md) for details.

## Application Structure

Each application directory is organized with a similar directory /file structure:

Name | Description
-|-
Makefile | Top-level makefile for the application
README.md | Integrated documentation for the app
config | Directory containing the ioto.json5 and other configuration files
ui | VueJS user interface app (if present)
src | Device-resident code to integrate with Ioto

If the app provides a user interface, the **ui** directory will contain:

Name | Description
-|-
src | UI [VueJS](https://vuejs.org) source code for the app
ui/vite.config.js | [Vite](https://vitejs.dev) build configuration instructions
reports | Build assets size metrics
Makefile | UI Makefile
ui/public | Public assets for the UI (html pages, style sheets, images) 
ui/public/index.html | UI home page# Building Ioto Apps

This Ioto Apps distribution provides several sample device management applications for Ioto and includes a copy of the Ioto agent distribution.

The Ioto samples are available as source code distributions from the [Builder Site](https://admin.embedthis.com/product). To download, first create an account and login, then navigate to the product list, select the Ioto Eval and click the download link. Then select the desired Ioto or Ioto sample package.

<a href="https://admin.embedthis.com/product" target="_blank">
    <button class="button">Download Source Package</button>
</a>

The Ioto samples distribution contains all the required source files, headers, and build tools to build both the Ioto agent and Ioto samples.

Several build environments are supported:

-   **Linux** &mdash; Linux 4 with GNU C/C++
-   **Mac OS X** &mdash; Mac OS X 11 or later

For other environments, you will need to cross-compile. The source code has been designed to run on Arduino, ESP32, FreeBSD, FreeRTOS, Linux, Mac OS X, VxWorks and other operating systems. Ioto supports the X86, X64, Riscv, Riscv64, Arm, Arm64, and other CPU architecutres. Ioto can be ported to new platforms, operating systems and CPU architectures. Ask us if you need help doing this.

## Preparing to Build

To build the samples, NodeJS must first be installed. NodeJS is used as part of the build process to build the UI apps.

To install Node, go to:

```
https://nodejs.org/en/
```

and download the LTS distribution. Follow the instructions to install.

## Management Apps

The Ioto distribution build includes several demo apps for local or cloud-based management. Apps demonstrate device-side logic and include the client-side UI to manage devices. The default app is the "manager" app which builds the standard Ioto Device Manager using a developer skin.

Name | Directory | Description
-|-|-
cloudkick | apps/cloudkick | Cloud-based Kickstart sample "router" skin for the cloud Device Manager.
console | apps/console | Local developer console for Ioto.
kickstart | apps/kickstart | Local Kickstart sample "router" management app.
manager | apps/manager | Build the standard cloud-based Ioto Device Manager with a developer skin.

The "console" app is a local developer management app that communicates with the local web server in Ioto. This app is ideal for testing local management.

Each application has a README.md in the app directory that describes the application and provides operational instructions.

You can select the desired app when building via the **APP=NAME** option:

```bash
$ make APP=kickstart
```

## Configuration

You do not need to use a `configure` program when building via make. Instead, you simply run **make** and select your desired App. This will copy the App's configuration and conditionally compile the required services based on the App's **ioto.json5** configuration settings.

The configurable Ioto services are:

* database -- Enable the embedded database
* demo -- Demonstrate sending data to the cloud
* keys -- Get AWS IAM keys for local AWS API invocation (dedicated clouds only)
* logs -- Capture log files and send to AWS CloudWatch logs (dedicated clouds only)
* mqtt -- Enable MQTT protocol
* provision -- Dynamically provision keys and certificates for cloud based management
* register -- Register with the Ioto Builder
* serialize -- Run a serialization service when making the device
* shadow -- Enable AWS IoT shadow state storage
* sync -- Enable transparent database synchronization with the cloud
* url -- Enable client HTTP request support
* web -- Enable the local embedded web server

## Building with Make

If you are using ESP32, please follow the instructions in the [Building ESP32](/agent/user/building-esp32.md) document.

The top level Makefile parses your selected App's **ioto.json5** configuration file, detects your operating system and CPU architecture and then invokes the appropriate project Makefile for your system.

To build, nominate your selected app via the "APP=NAME" makefile option:

```bash
$ make APP=manager
```

## Running Ioto

To run ioto, type:

```bash
$ make run
```

or add the directory **build/bin** to your PATH environment variable.

```bash
export PATH=`make path`

$ ioto -v
```

If your selected app enables the web server, Ioto will listen for connections on ports 9090 for HTTP and 4443 for HTTPS and serve documents from the **./site** directory when run with the **dev** profile. When run with the **prod** profile, it will serve documents from **/var/www/ioto** and will listen on port 80 and 443.

## Build Profiles

You can change Ioto's build and execution **profile** by editing **ioto.json5**. Two build profiles are supported:

-   dev
-   prod

The **dev** profile will configure Ioto suitable for developement. It will define use local directories for state, web site and config files. It will also define the "optimize" property to be "debug" which will build Ioto with debug symbols.

The **prod** profile will build Ioto suitable for production deployment. It will define system standard directories for state, web site and config files. It will also define the "optimize" property to be set to "release" which will build Ioto optimized without debug symbols. 

The **ioto.json5** configuration file has some conditional properties that are applied depending on the selected **profile**. These properties are nested under the **conditional** property and the relevant set are copied to overwrite properties of the same name at the top level. This allows a single configuration file to apply different settings based on the current value of the profile property.

You can override the **"optimize"** property by building with a "OPTIMIZE=release" or "OPTIMIZE=debug" make environment variable.

### Debugging

To build Ioto with additional memory and stack debug checks, enable the **ME_FIBER_CHECK_STACK** compilation variable. This will cause the Ioto runtime to check stack integrity and track overall stack and fiber usage. This does have a performance impact and should only be used in debug builds.

```bash
DFLAGS=-DME_FIBER_CHECK_STACK=1 make clean build
```

### Stack Size

Ioto uses [fiber coroutines](/agent/dev/fiber.md) for parallelism instead of threads or callbacks. The size of fiber stacks is defined via the **limits.stack** property in the **ioto.json5** configuration file. Set this value to be sufficient for your application needs. 

In general, it is recommended that you avoid the use of large stack-based allocations and use heap allocations instead. It is also advised to limit the use of recursive algorithms.

A default stack of 32K should be sufficient for core Ioto use on 32-bit systems. For 64-bit systems, 64K should be a minimum.

## Directories

| Directory | Purpose                                                                  |
| --------- | ------------------------------------------------------------------------ |
| apps      | Managmement applications                                                 |
| bin       | Build tools                                                              |
| build     | Build artifacts                                                          |
| scripts   | Device management scripts including OTA script                           |
| state     | Ioto runtime state configuration, certificates, database and web pages   |

## Key Files

| File              | Purpose                                                      |
| ------------------| ------------------------------------------------------------ |
| LICENSE.md        | License information                                          |
| device.json5      | Device registration file                                     |
| display.json5     | UI display configuration for management apps                 |
| ioto.json5        | Primary Ioto configuration file                              |
| schema.json5      | Database schema                                              |
| signature.json5   | Web server REST API signnatures                              |
| web.json5         | Embedded web server configuration                            |
# Console Application

The Console application is a developer device manager for local device management over HTTP using the Ioto embedded web server. 

The Console application includes core functionality useful for most device management apps by offering:

* User authentication (login/logout)
* App navigation and menus
* Sidebar navigation 
* Display light / dark mode support
* Dashboards with information widgets (graphs, gauges, tables, numerics)
* Device data display, management and updating

The console uses the Ioto Device Manager VueJS core to provide this functionality.

## Building

To build the Console application select the APP and run make:

```bash
$ make APP=console clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for local device-based management.
* Build the Console application.
* Copy the required configuration to the ./config directory.
* Initialize the Ioto local database with login user definitions.

After building, the Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The Manager application will be copied to the **./site** directory.

## Running

To run Ioto, type:

```bash
$ make run
```

## Browsing

To view the Console, launch your browser and navigate to the URL:

```
https://localhost:4443
```

You will probably see a warning about the connection not being secure or "Your connection is not private". This is expected. This is a browser warning that the application is using a test TLS/SSL certificate. You may proceed as instructed and the app home page will be displayed.

You can login with the test user credentials:

Username | Password
-|-
**admin** | demo

## Demo

The Console app includes a simple demonstration that increments a database counter every ten seconds.
This demo consists of timed event running inside Ioto that increments a counter and the Console UI dashboard that displays the counter value via graph, gauge, table and numeric widgets.

![Console](/images/ioto/console-app.png){class="screen"}

The source to increment the database counter is in **apps/console/src/demo.c**.

## Device Schema

The Console app defines a Demo table in the database schema via the **apps/console/config/schema.json5** that includes the **apps/schemas/DemoSchema.json5**.

For more information about the device schema, See:

* [Device Tables / Database Schemas](/apps/config/schema.html)
* [Database Replication](/ioto/database/replication.html)

## Configuring the Console Display

The Console user interface is defined by the **apps/console/config/display.json5** config file that can be modified or extended to suit your specific needs. 

The display.json file defines the following items:

* UI features
* Displayed Name
* Display color theme including dark and light modes
* Logo to display in the navigation bar
* Menu items and options
* UI pages and panels
* UI navigation routes
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

The initial display.json5 configuration file defines a "developer" skin for the console. 

For more information about the display file, read [Manager Display](/apps/config/display.html).

## Learn More?

See [Manager Documentation](/apps/) for Device Manager configuration and operation details.# CloudKick Application

The CloudKick app is a variant of the Kickstart app that communicates with the cloud instead of the local web server. It reuses most of the Kickstart UI but provides a different database schema and communication adapters.

CloudKick demonstrates the capabilities and experience provided by an application created with Ioto and VueJS. It includes includes a UI/UX for a sample router/switch application. CloudKick uses proven designs and best-practices to lower development risk. It includes most of the required elements for a secure web application, so you can eliminate months off your development schedule.

The CloudKick App is an example of a [Customized Device Manager](/apps/patterns/). This means it rebuilds the Ioto Device Manager to add custom UI components, a customized data schema and dashboard.

![CloudKick](/images/manager/cloudkick.png){class="screen"}

## CloudKick Components

* User management
* User login
* Property edit
* Alert notification
* Event log
* Dashboard
* Dynamic tables and graphs
* Paged Data Tables
* Navigation
* Search
* Granular access control per page
* Help

Read the [Kickstart Components](../kickstart/specs.md) for full details.

## Building

To build the CloudKick application select the APP and run make:

```bash
$ make APP=cloudkick clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for cloud-based management
* Build the CloudKick application
* Copy the required configuration to the ./config directory

After building, the Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The clouckick application will be located under the **apps/cloudkick/ui/dist** directory which will contain the individual application files and a **app.zip** ZIP file that is ready for uploading via the Builder to the Ioto cloud service for hosting the UI.

## Deploying

To deploy the CloucKick application, logon to the [Builder](https://admin.embedthis.com) site to create and configure an App.

From the Builder App list, click on the **Add App" icon or the **Edit** icon to modify an app.

![App List](/images/builder/app-list.png){class="screen"}

This will display the app configuration panel.

![App Designer](/images/builder/app-edit.png){class="screen"}


## Domain Name

If your app is hosted by Embedthis, select a sub-domain of your choosing under the **ioto.me** domain. You can select a unique sub-domain that reflects your company or product's brand. The sub-domain name you choose must be globally unique. 

If you are using a **dedicated** device cloud, you can register your own domain name and point that to the underlying Ioto manager site. To use a self-hosted domain, check the "Self Hosted Domain" checkbox and enter your full domain name. If using a self-hosted domain, you will need to use a Domain Registrar of your choosing.

## App Upload

To upload the built CloudKick app, select **Custom App** and click on the **Zip File** upload field. Navigate to the **apps/cloudkick/ui/dist/app.zip** file and then Save. This will upload the app and deploy to the Ioto service in the appropriate cloud region. It may take a few minutes for the application to be deployed by the Ioto service.

## Device Schema

The CloudKick app uses the Ioto agent database schema to define what device specific data should be stored in the cloud and what are the device manageable entities.

The schema describes the device entities and their data properties and data types. Using this schema, the Ioto service and the CloudKick app are able to understand your device-specific data.

Ioto defines a default schema when you create the device cloud. This schema supports a generic key/value store. Initially, you can use the default schema, but as you progress, you may wish to define your own data entities to store device specific data. In this case, you will need to upload your application database schema to the Builder using the **Cloud/Edit** configuration panel.

For more information about the device schema, See:

* [Device Tables / Database Schemas](/apps/config/schema.md)
* [Database Replication](/ioto/database/replication.md)

## Configuring the CloudKick Display

The CloudKick user interface is defined by the **apps/cloudkick/config/display.json5** config file that can be modified or extended to suit your specific needs. 

The display.json5 file defines the following items:

* UI features
* Displayed Name
* Display color theme including dark and light modes
* Logo to display in the navigation bar
* Menu items and options
* UI pages and panels
* UI navigation routes
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

For more information about the display file, read [App Display](/apps/config/display.md).

## Learn More?

See [Manager Documentation](/apps/) for Device Manager configuration and operation details.# Account Settings

The account settings page displays and manages the device user's account name and billing email address.

![Settings](/images/builder/settings.avif){class="screen width-60"}

The settings page will be enabled if the user is an "owner" of the account. You become an owner by having a member role of "owner".

## Name

The account name is defined when a user creates their account. They can change their account name here if required.# Create an Account

To use the EmbedThis Builder site, you need to register and create an account. This is a simple, one-time task that will take you just a few minutes.

If you have been invited to an account by a co-worker, please click on the link in the invite email. That will ensure you become a member of the account that invited you.

To register, navigate to the Builder site at [https://admin.embedthis.com](https://admin.embedthis.com) and click on the Register tab.

All use of the EmbedThis Builder service and the device agent software is governed by the [Embedthis Terms of Use](https://www.embedthis.com/about/terms.html).

## Register

When you navigate to the admin site, you will see the login / registration dialog.

![Register](/images/eco/eco-login.png){class="screen width-50"}

You may register using an email address and password or you may use a social media account from Amazon, Facebook, or Google. If you register by email and password, you will be sent a confirmation code to validate your email address. This code will come from the domain sender: no-reply@verificationemail.com.

Once registered, you will be automatically logged in to the Builder site. Later, you can invite team members to join you on your account.
# Members

User's can invite and add team members to their account and designate member's roles.

Administrative users can add, remove or modify organization members.

![Invite Member](/images/builder/invite-member.png){class="screen"}

## Inviting Users

To add a user to a Manager account, invite them via the "Add Member" button on the Member List page.

When invited, the user is sent an invitation email with instructions. When clicking or entering the link provided, the user can register and login to your account.

## Member Role

When inviting a user or later when modifying the user's configuration, a user can be assigned a role. This role may be:

* user
* admin
* owner

User role members can view information but not change product, subscription or organization configuration. Users can view and open support issues and download software.

In addition to user roles capabilities, admin members can perform constructive or destructive operations on the organization. Admin users can create product definitions, configure subscriptions and confirm purchases.

In addition to the admin role, owners can control the entire account. They can add and modify billing cards and close the account.

## Remove Member

Administrative users can remove other users at any time. Once removed, the user will lose all access to the manager and relevant devices.
# Personal Profile

The personal profile displays the user's login information including their login information and personal preferences.

![Profile](/images/builder/profile.avif){class="screen width-60"}

## Changing Name

If the user has logged in using an email address and password, they can change their personal profile including first and last name.

## Social Media Login

If the user has logged on via a social media account such as Google, Amazon or Facebook, and they wish to change they profile, they need to do that via their social media account.

<!--
## Guide Hints

The Guide hint toggle controls the display of UI sign-posts that guide the user's use of the manager. While they can dismiss the guide posts individually on their respective pages, they can also turn off the Guide Hints toggle to turn off all sign-posts. If they decide to enable again in the future, they can select **Re-Enable** which will redisplay all posts including those they have individually dismissed.

--># Ioto&reg; IoT Apps

IoT device management apps enable you to control and monitor your devices and cloud services. With the Builder, you can create one or more apps tailored for device management. These IoT apps can support local management through the agent’s embedded web server or facilitate remote management via the cloud.  

You can customize IoT apps to suit different user groups, including end-users, developers, and support teams. For cloud-based management, the Builder streamlines global deployment by hosting and distributing the apps through device clouds.

<div class="clear" />

## DevCore UI Framework

IoT apps can be built two ways: using the EmbedThis [DevCore UI](/apps/framework/) framework or they can be developed as custom applications utilizing the Ioto APIs.

The **DevCore** framework is a versatile JavaScript UI library designed for device management across mobile, tablet, and desktop platforms. It provides essential features, including authentication, state management, request handling, navigation, device configuration, and data visualization.

With DevCore, you can create visually engaging user interfaces using a low-code visual app designer, enabling efficient and appealing app development.

![Home Page](/images/eco/eco-home.avif){class="screen width-50 center"}

The DevCore framework offers the following features:

* Pre-built components for authentication, navigation, dashboards, graphs, deployment, input forms, and monitoring.  
* Customization options for product name, logo, and color scheme.  
* Support for tailored device data and custom UI screens.  
* An integrated low-code app page designer for visually building screens and dashboards.  
* Data widgets to display device data with advanced metrics and statistics.  
* An API for creating custom UI components.  

With DevCore, you can quickly build your app and then progressively tailor it to meet your specific device management requirements. This approach enables rapid progress in developing an IoT solution while maintaining the flexibility to create a fully customized device management application.  

:::info 
DevCore will save you months of development time in creating your device management app.
:::

For use cases where the DevCore framework may not be suitable, you can leverage the Builder and Ioto service APIs directly to develop a unique device application using any app framework of your choice.

## Low-Code App Designer

The DevCore framework includes an inbuilt, low-code `App Designer` so you can visually create a highly appealling app UI for mobile and desktop apps. With the App Designer you can create and customize the app's user interface without unnecessary coding.

The App Designer supports a drag-drop design pattern where you can select UI controls and widgets from an extensive library of over 30 widgets. There are widgets for graphs, tables, numerics, shapes, gauges, buttons, images, input controls for all types of data entry.

![App Designer](/images/manager/page-designer.avif){class="screen width-100"}

The App Designer is used to customize your app and to create and modify UI pages. 

## Standard App

The Builder provides a pre-built device management app that can be extensively customized to meet your specific needs. The `Standard` app uses the `DevCore` framework as a foundation. You can use the `Standard` app with the in-built `App Designer` to change the look and feel of the app and UI pages as required.

## Creating Apps

IoT apps are created from the Builder's App list.

![App List](/images/builder/app-list.avif){class="screen"}

Once the app is created, you can launch the app from the Builer's app list and then you can modify the app UI and pages using the app's integrated low-code `App Designer`. This tool offers a visual interface for modifying the app UI and pages.


![Page List](/images/manager/page-list.avif){class="screen"}

### Developer UI

When you first define an app, the Builder creates a default management app based upon on the DevCore framework. This app has generic `Developer` UI suitable for testing your devices as you develop your IoT solution. This app UI can be progressively customized or extended to meet custom UI requirements.

![Ioto Device Manager](/images/manager/standard.avif){class="screen"}

# Creating DashBoards

You can create any number of dashboards from the Dashboard list.

![Dashboard List](/images/builder/dash-list.png){class="screen width-100"}

From the Dashboard list you can click the `Add` button to create a new dashboard or click on the `Edit` icon to modify an existing dashboard. When clicked, the dashboard configuration panel will be displayed.

The `Design` icon is used to launch the dashboard designer so you can modify the dashboard, content layout and styling.  While the `Show` icon is used to display the dashboard. 

## Modifying Dashboards

You can configure the board's properties and settings using the dashboad configuration panel. 

![Dashboard](/images/builder/dash-edit.png){class="screen width-50"}

## Dashboard Name

Each dashboard is given a unique name that is displayed in the dashboard list.

## Dashboard Layout

Dashboards have the choice of using one of two layout engines:

Name | Description
-|-
Exact | Layout widgets with exact positioning
Grid | Layout widgets on a grid

### Exact Layout

The `Exact` layout engine will position and size widgets wherever you place and configure them with per-pixel resolution. Widgets can overlap and cover widgets behind them. The exact layout does not use a grid.

The exact layout is useful to create composite dashboards with less regular widget placement.

### Grid Layout

The `Grid` layout will align widgets on a 20 pixel grid.

### Live Data

By default, dashboards will automatically update widget data based on the defined **Refresh Period**. You can disable **Live Data** update which can help you to focus on styling and arranging widgets without any display updates to break your concentration. 

### Framed Widgets

Widgets can be framed with a thin border. If you are creating a dashboard with a grid of data graphs, gauges and metrics, you typically frame the widgets with a consistent border.

![Framed Widgets](/images/builder/framed-widgets.avif){class="screen"}

If you are creating a composite page, you may wish to combine widgets so that the boundaries between widgets are less visible. In this case, disabling widget frames can assist to create a cohesive single page interface. For example, the EcoHouse app combines widgets to create a single page dashboard.

![Eco House](/images/eco/eco-home.avif){class="screen width-50"}

In this case, it is typically helpful to enable frames while you are designing a page and then disable frames when you are complete.

### Full Screen

![Nav Bar](/images/builder/full-screen.avif){class="screen"}

When full screen mode is enabled, the normal App navbar is hidden:

![Normal](/images/builder/normal-screen.avif){class="screen"}

This is useful for mobile displays and for production desktop dashboards.

## Show Toolbar

If the `Show Toolbar` option is enabled, a toolbar is displayed at the top of the dashboard. The toolbar can be used to select dashboards, change the data date range, refresh data, and modify dashboard and widget configuration. You can also click a `designer` icon to quickly return to the designer for more significant changes to the dashboard.

![Widget Toolbox](/images/builder/dashboard-toolbar.avif){class="screen width-80"}

### Refresh Period

You can define the default refresh rate for metrics and data widgets. Set the refresh rate to your desired update period in seconds. However, do not set needlessly low as this will impose increased load on your service.

### Device Emulation

When designing pages for a mobile app, it can be helpful to perform your design on a desktop PC and emulate the mobile device. Selecting a **mobile** device to be emulated will resize the dashboard to be that of an iPhone 15 Pro Max.

Dashboards are responsive and should scale up and down as browser windows are resized or when run on mobile devices of differing dimensions.

### Time Range

You can define an absolute or relative time period to use for metric data supplied to your widgets.
A relative time range may be set to the most recent number of minutes, hours, days, weeks, months or years. An absolute time range can specify a fixed start and end date.

If the dashboard has a **toolbar** widget, users can change the time range at any time.

### Dashboard CSS Properties

Dashboards can be styled with any valid CSS property. For example, you can set the background to red and foreground color to blue via:

Name | Value
-|-
background | red
color | blue

### Default Widget CSS Properties

Simlarly to Dashboard CSS properties, you can define default widget properties that are applied to all widgets. These can be overridden per-widget in the Widget edit panel. You can display a color picker by clicking the pencil icon in the table.

## Exporting and Importing Dashboards

You can export a dashboard to a JSON file by selecting the dashboard and clicking the `Export` option under `Actions`. You can import a dashboard from a JSON file by clicking the `Import` action.

## Creating and Selecting Dashboards

To create a new dashboard, click "Add Dashboard" from the dashboard list.

When you have finished creating or editing your dashboard, you can **Save** to persist your changes. You can rename a dashboard by entering a new name and clicking Save. 

Click **Copy** to copy an existing dashboard to a new dashboard. The **Apply** button saves your changes without dismissing the edit panel. Dashboards can be deleted via the `Delete` button.

You can create multiple dashboards that focus on different service aspects. For example, you may want a dashboard that features service load graphs and metrics and another dashboard to focus on outages and errors.

You can easily switch between dashboards by clicking on the name of the dashboard in the Dashboard toolbar. You can also, create enable a "dashboard switch" action to a button widget that lets you rapidly switch to another dashboard by clicking a button widget in the dashboard.# Dashboards

![Dashboard](/images/builder/dashboard.png){class="screen"}

Dashboards are the window into your device and device cloud state. Dashboards display interactive, graphical information for your devices, account and service. They combine interactive widgets to create composite dashboards that can focus on a particular aspect of your service.

Dashboards can be created by you or by your customers. Any number of dashboards can be created for your service. The set of dashboards create are saved uniquely for each user.

## Difference between Dashboards and Pages

Dashboards and Pages are similar in that they both display widgets. However, dashboards are designed to display data metrics via graphical widgets. Pages are designed to combine multiple graphical elements, including widgets, to create a composite device page. 

## Widgets

Dashboards render data via graphical widgets from the Ioto service and your own device metrics. 

Widgets can be added, removed, styled, positioned, and resized to meet your specific requirements. Dashboards supports 30 different types of widgets, including: gauges, graphs, numeric, text, image, data table and input widgets.

Widgets can dynamically style their colors, backgrounds, fonts, and overall presentation.
Widgets can be combined to create cohesive displays that intuitively convey important device and cloud state.

Input widgets such as buttons and switches can invoke actions when pressed or activated by the user. These actions can invoke devices-based commands such as rebooting a device, or perform cloud-based operations such as updating the device database or sending an SMS alert.

Dashboards offer support for:

- Graphical widgets such as graphs, gauges, and numeric and text displays.
- No-code drag-and-drop dashboard and widget designer.
- Customizable layouts with adjustable positioning and sizing of widgets.
- Responsive designs that adapt to various screen sizes.
- Creation of multiple dashboards, each focusing on different aspects of services.
- A gallery featuring additional widgets and data sources.
- The ability to save and share dashboard configurations with team members in your organization.

Dashboards enable you to monitor the performance of your devices and device clouds effectively.

## Widgets and Layouts

The Dashboard facility utilizes the `Board` component of the `DevCore` UI framework. The Dashboards and Pages facilities both leverage the `Board` component. See the Board documention for details regarding:

* [Widgets](../boards/widgets/)
* [Layouts](../boards/layouts.md)
* [Toolbar](../boards/toolbar.md)



# Dashboard Toolbar

The Dashboard toolbar provides icons and buttons to modify the dashboard and widget presentation.

![Navbar](/images/builder/dashboard-toolbar.png){class="screen width-80"}

The following fields and icons are provided:

Icon | Description
-|-
Dashboard | Selection list of available dashboards
Range | Time range for metrics data for widgets
Timer | Countdown timer to the next widget data refresh
Tools | Enable and disable **design** mode
Reset | Reset the current layout and discard unsaved changes
Dashboard | Open the Dashboard Panel to modify the dashboard
Plus | Open the Widget Panel to add a new widget to the dashboard

## Time Range 

You can customize the time range for the metric data given to dashboard widgets. You can select the period to be per hour, day, week, month or custom period using the **Range** button.

## Timer

## Design Mode

The dashboad can be placed in a **"design"** or **"fixed"** mode. When in design mode, the dashboard can be modified and widgets can be added, removed, resized and configured. When in fixed mode, all changes are prevented.

Production apps would typically put their dashboards in fixed mode.

When Design mode is enabled, the widget selection toolbox is displayed at the left side of the dashboard and a Dashboard toolbar is displayed at the top. 

## Reset

Clicking the **Reset** icon will discard any unsaved changes to the dashboard.

## Modify Dashboard

Clicking the **Dashboard** icon will open the modify dashboard panel.

## Add Widgets

Clicking the plus icon will open the **Add Widget** panel. You can also add widgets by draging a widget from the widget sidebar toolbox.

## Expanding Widgets

If you are using the grid layout, you can click an **Expand** icon in the dashboard toolbar to stretch widgets to the full width of the display and remove redundant white space. This will align widgets on the left and the right of the dashboard. This is useful to quickly align and apportion a grid of widgets.


# Dashboard Layouts

![Dashboard](/images/builder/dashboard.png){class="screen"}

Each Dashboard has the choice of using one of two layout engines:

Name | Description
-|-
Exact | Layout widgets with exact positioning
Grid | Layout widgets on a grid

### Exact Layout

The **Exact** layout engine will position and size widgets wherever you place and configure them with per-pixel resolution. Widgets can overlap and cover widgets behind them. The exact layout does not use a grid.

![Exact Layout](/images/builder/exact-layout.png){class="screen"}

The exact layout is useful to create composite pages where widget boundaries are not visible (using frameless widgets). For example:

![Eco House](/images/eco/eco-home.avif){class="screen width-50"}

### Grid Layout

The **Grid** layout engine is the default layout engine and is typically easier to arrange widgets. The grid layout engine will position widgets so that widgets align on a 20 pixel grid and no widgets overlap.

![Grid Layout](/images/builder/grid-layout.png){class="screen"}

<!--
By default, the Grid layout will align widgets on a grid. You can disable the grid via the **Snap to Grid** dashboad option at any time. When enabled, the Dashboard will align widgets on an 20 pixel grid. New dashboards will by default enable the grid layout. 

After creating a dashboard, it is useful to deselect the **Snap to Grid** so that that dashboard widgets will remain aligned if the browser window is resized. 
-->

## Widget Placement

You can adjust the position of widgets on the dashboard by moving and resizing widgets. To move a widget, click the widget and drag it to a new location. To resize a widget, click and drag the resize handle located at the bottom right corner to your preferred size. If you are using the grid layout, the dashboard automatically rearranges other widgets to prevent overlap and ensure clear visibility. If you are using the exact layout engine, widgets will be placed exactly where you position them.

If widgets are moved, a **Save** button will appear in the widget toolbar. Click Save to persist your changes, click the **Reset** icon to discard your changes.

## Expanding Widgets

If you are using the grid layout, you can click an **Expand** icon in the dashboard toolbar to stretch widgets to the full width of the display and remove redundant white space. This will align widgets on the left and the right of the dashboard. This is useful to quickly align and apportion a grid of widgets.

## Zooming a Widget

If you Cmd-Click a widget, it will be zoomed to full screen display. Press the escape key to restore the widget to normal size.

## Responsive Design

When widgets are positioned, the relative position to the left side of the browser, and the width of the widget are save as a percentage of the browser window size. Thereafter, if the window is resized, or if the app is viewed on a different sized mobile device, the widget will be scaled according to the size of the device. This permits a single dashboard design to scale for widely different user interface dimensions.

# Board Configuration

Whether using `Pages` or `Dashboards`, you can configure the board's properties and settings
using the board configuration panel. 

![Dashboard](/images/builder/dash-edit.png){class="screen width-50"}

## Board Name

Each board is given a unique name that is displayed in the dashboard or page list.

## Board Layout

Boards have the choice of using one of two layout engines:

Name | Description
|-|-|
Exact | Layout widgets with exact positioning
Grid | Layout widgets on a grid

### Exact Layout

The **Exact** layout engine will position and size widgets wherever you place and configure them with per-pixel resolution. Widgets can overlap and cover widgets behind them. The exact layout does not use a grid.

The exact layout is useful to create composite pages where widget boundaries are not visible (using frameless widgets).


### Grid Layout

The **Grid** layout will align widgets on a 20 pixel grid.

### Live Data

By default, boards will automatically update widget data based on the defined **Refresh Period**. You can disable **Live Data** update which can help you to focus on styling and arranging widgets without any display updates to break your concentration. 

### Framed Widgets

Widgets can be framed with a thin border. If you are creating a board with a grid of data graphs, gauges and metrics, you typically frame the widgets with a consistent border.

![Framed Widgets](/images/builder/framed-widgets.avif){class="screen"}

If you are creating a composite page, you may wish to combine widgets so that the boundaries between widgets are less visible. In this case, disabling widget frames can assist to create a cohesive single page interface. For example, the EcoHouse app combines widgets to create a single page UI.

![Eco House](/images/eco/eco-home.avif){class="screen width-50"}

In this case, it is typically helpful to enable frames while you are designing a page and then disable frames when you are complete.

### Full Screen

![Nav Bar](/images/builder/full-screen.avif){class="screen"}

When full screen mode is enabled, the normal App navbar is hidden:

![Normal](/images/builder/normal-screen.avif){class="screen"}

This is useful for mobile displays and for production desktop dashboards.

## Widget Toolbox

When designing the board, the widget selection toolbox is displayed at the left side of the board and a toolbar is displayed at the top. 

![Widget Toolbox](/images/builder/widget-toolbox.avif)

### Refresh Period

You can define the default refresh rate for metrics and data widgets. Set the refresh rate to your desired update period in seconds. However, do not set needlessly low as this will impose increased load on your service.

### Device Emulation

When designing pages for a mobile app, it can be helpful to perform your design on a desktop PC and emulate the mobile device. Selecting a **mobile** device to be emulated will resize the board to be that of an iPhone 15 Pro Max.

Boards are responsive and should scale up and down as browser windows are resized or when run on mobile devices of differing dimensions.

### Time Range

You can define an absolute or relative time period to use for metric data supplied to your widgets. A relative time range may be set to the most recent number of minutes, hours, days, weeks, months or years. An absolute time range can specify a fixed start and end date.

If the board has a **toolbar** widget, users can change the time range at any time.

### Board CSS Properties

Boards can be styled with any valid CSS property. For example, you can set the background to red and foreground color to blue via:

Name | Value
-|-
background | red
color | blue

### Default Widget CSS Properties

Simlarly to Board CSS properties, you can define default widget properties that are applied to all widgets. These can be overridden per-widget in the Widget edit panel. You can display a color picker by clicking the pencil icon in the table.
# Board Component

The `Board` component is a UI component that provides a canvas and suite of widgets to create composite UI pages or dashboards. It is utilized by the `Pages` and `Dashboards` facilities in the DevCore framework.

![Dashboard](/images/builder/dashboard.png){class="screen"}

Boards combine interactive widgets to create composite operational and information device interfaces.

## Widgets

Widgets render data from the Builder service, Ioto service, and your own custom device metrics. 

Widgets can be added, removed, styled, positioned, and resized to meet your specific requirements. Dashboards supports 30 different types of widgets, including: gauges, graphs, numeric, text, image, data table and input widgets.

Widgets can dynamically style their colors, backgrounds, fonts, and overall presentation.
Widgets can be combined to create cohesive displays that intuitively convey important device and cloud state.

Input widgets such as buttons and switches can invoke actions when pressed or activated by the user. These actions can invoke devices-based commands such as rebooting a device, or perform cloud-based operations such as updating the device database or sending an SMS alert.

Boards offer support for:

- Graphical widgets such as graphs, gauges, and numeric and text displays.
- No-code drag-and-drop widget designer.
- Customizable layouts with adjustable positioning and sizing of widgets.
- Responsive designs that adapt to various screen sizes.
- Creation of multiple boards, each focusing on different aspects of services.
- A gallery featuring additional widgets and data sources.

Boards enable you to monitor the performance of your devices and device clouds effectively.

Learn more:

* [Configuration](config.md)
* [Layouts](layouts.md)
* [Toolbar](toolbar.md)




# Widget Presentation

Widgets can be styled by anchoring their position, defining their stacking order and via CSS properties.

![Widget Presentation](/images/builder/widget-edit-presentation.avif){class="screen width-60"}

### Anchoring Widget Position

If you are using the **Exact** layout engine for your board, you can anchor widgets to various positions of the board. This is useful for example if you wish to anchor a widget to the bottom center of the board.

You can select a vertical and and a horizon anchor position with an offset. The offset can be expressed as a number of pixels or as a percentage of the board's height/width.

If you are using the **Grid** layout engine, widgets will be always compacted on the grid and anchoring widgets is not compatibile with the grid placement strategy.

### Z Stacking Order

With the **Exact** layout engine, widgets are permitted to overlap. You can define their stacking order by setting a positive **z-index** value for each widget. The default value is zero. You can also set the z-index by Cmd-Clicking on a widget to bring it to the foregound. This will set its z-index to the highest of all widgets.

## Show Expression

You can define an expression to determine if the widget should be displayed. The **show expression** is a JavaScript like expression that is evaluated to yield a true or false result.

The **show** expression is provided with a context of variables that can be accessed by the expression. The widget data value is provided in the **"value"** named variables. You can test this result using a Javscript like expression. For example:

    value > 0

Other context variables include:

Variable | Description
-|-
agent | Browser user agent string
dark | True if in dark mode 
desktop | True if running on a desktop PC
framed | True if the board is framing widgets
full | True if the board is in full screen mode
height | The browser width dimension (navigator.innerwidth)
language | The configured browser language (navigator.language)
live | True if the dashtop has enabled live data updates
mobile | True if running on a mobile device (<= 640px width)
value | The widget data (or input) value
width | The browser height dimension (window.innerWidth)

The query language supports the operators:

    + - * / ( ) ^ ! % == != < <= > >= ^= ^!= $= $!= << >> && || <> ><

These extension operators have the following meaning:

* a ^= b     means a starts with the string b
* a ^!= b    means a does not start with the string b
* a $= b     means a ends with the string b
* a $!= b    means a does not end with the string b
* a >< b     means a contains the string b
* a <> b     means a does not contain the string b

Sub-expressions can be grouped with parenthesis and the boolean operators && and || can group conditional operands.

Regular expressions (delimited by slashes) may be used with the "==" and "!=" operators. The regular expression can be on either side of the operator.

The expression language understands the types: Numbers, Boolean, String literals, Regular Expressions and null.

The expression is run-time limited to evaluate up to 50 terms. This is to protect your cloud against denial of service attacks.


### CSS Properties

Widgets will initially display with a default theme based on the current light or dark mode. However, you can override any CSS property for the widget to customize the widget size, colors and style. 

The Widget will also inherit any default widget CSS properties defined in the board configuration.

The CSS Property name can be any standard CSS property name. For example:

Name | Value
-|-
background | red

If the property name is **class*, the class name value will be added if the widget value is not zero (false). Otherwise the class name will be removed.

or it can use an enhanced encoding as follows:

Name | Value
-|-
[expression:][components...][property] | [true-value][:false-value]

The **expression:** is an optional expression that evaluates to a truthy value to determine if the CSS property is enabled or disabled. The expression can use the widget's `value` in the expression and the same set of context variables as for the **show** expression described above. For example:

```js
value == 'some-value' && width <= 640 
```

If an expression is supplied, the property value can supply two colon separated values. If the expression is true, the value before the colon is used, otherwise the one after the colon. For example:

Name | Value
-|-
value != 0:background | red:green

If the expression evaluates to true, the background will be set to **red**. If the expression evaluates to false, the background will be set to **green**.

The **components** are an optional set of DOM classes to select widget subcomponents to style. For example:

```js
footer.font-size
```

This selects the widget child footer element with the `footer` CSS class. See the [Widget Types](types.html) documentation for the available components for each widget type.

## Dynamic CSS Properties

Some widgets dynamically compute their CSS properties according to the size of the widget and placement on the board. To override these dynamic CSS settings, use a **--w-** prefix for the CSS property. For example:

```css
--w-font-size | 16px;
```# Basic Widget Configuration

The **Basic** widget configuration includes the widget type, title and other fields that are relevant for the selected widget type.

![Basic Configuiration](/images/builder/widget-edit.avif){class="screen width-60"}

Depending on the widget type, different configuration fields will be presented from the following list:

Name | Description
-|-
accept | File types to accept for the File upload widget
datetime | Set to "date", "time" or "datetime" for the date input widget.
field | Database field to update for input widgets
fields | Database fields to display for table widgets
footer | Widget footer to display at the bottom of the widget
form | Associated form widget to post input form fields
format | Widget numeric format string
header | Widget header text to display at the top of the widget
items | Selection items to use with input select and combo widgets
label | Input field label
max | Maximum expected data value
min | Minimum expected data value
multiple | Allow multiple selections for an input combo widget
pivot | Pivot the table widget data. Rows vs columns.
placeholder | Place holder text to use for input text widgets.
prefix | Text prefix to display before the value for numeric widgets.
presentation | Graph presentation.
rows | Numer of rows to display for a text area input widget
subtitle | Subtitle to display for the table widget
suffix | Suffix text to display after a numeric value
text | Static text to use for the widget value
timezone | Timezone to use for the date input wiget
url | URL to use for image and sound widgets
validate | Regular expression to use for validating text inputs.

### Formatting Numerics

The format field is used when formatting numberic widgets.

For example, the following will format numbers with an optional sign followed by the number portion with thousand separators and one decimal place. The number will be rounded up.

```
-0#,###.#^
```

The formatter characters are:

Character | Description
-|-
0 | digits with leading zero
# | digit 
, | Thousand separators
% | format as percent
+ | Always show sign
- | Show sign if negative
^ | Round up
v | Round down
# Widget Data

Widgets can retrieve and display metric and database information for devices and for device cloud and Builder services.  Widgets automatically refresh the displayed data according to the board refresh rate. Widgets can present current data or data for historial metrics.

The **Widget Data** panel configures the widget data source, table, metrics, dimensions and statistic to display. 

![Widget Data](/images/builder/widget-edit-data.avif){class="screen width-60"}

## Data Sources

The Builder dashboard can provide widget data from the Builder service or from any Device Cloud. If you are using a device App, the data source is always your device cloud for the app.

If using the Builder dashboard, select the desired data source from the **Source** pulldown list. Depending on your device clouds you will one or more data sources:

* Service: Builder
* Hosted: Hosted Cloud Name
* Dedicated: Dedicated Cloud Name

## Data Namespaces

Available device and cloud data is grouped into namespaces that define a realm of available data for presentation. The Builder and Device Clouds create a large selection of service and device metric that provide real-time and historical data.


The supported metric namespaces are:

Namespace | Board | Description
-|-|-
Database | App | Device database data
Embedthis/Device | App | Device metrics
Embedthis/Builder | Builder | Builder service metrics
Embedthis/Cloud | Builder | Cloud service metrics including software updates
Embedthis/Ioto | Builder | Cloud service metrics for Ioto including the number of devices claimed, connected, provisioned and message traffic metric
Embedthis/Manager | Builder | End-user metrics including the number of user registrations and device manager sessions.

Some namespaces are only available in the Builder and some only in device Apps.

If you are using a dedicated device cloud, the namespace list will include the standard and custom AWS CloudWatch metrics for services you are currently utilizing or have enabled.

### Device Database Data

The special namespace **"Database"** is available in App pages and dashboards and represents raw device database data.

![Widget Database Data](/images/builder/widget-data-database.avif){class="screen width-60"}

After selecting the `Dashboard` namespace, select the database table and field (column) value you require. For multi-row tables, you can enter a filter expression of the form:

    field=value

This will select the desired database table row/item.

### Metric Data

For **metric** namespaces, you specify the metric name, statistic and dimensions to select a required metric.

![Widget Metric Data](/images/builder/widget-data.avif){class="screen width-60"}

The available metrics are provided in the **Metric** pulldown selection list.

The supported metric **statistics** are: min, max, avg, sum, count and current. **Sum** is the sum of values over the request period. **Count** is the number of values sampled over the period. **Current** is the most recent updated value.

Some metrics have dimensions where specific resources have unique metric values. For example, you may have a "Temperature" metric for a device but also have "Temperature" metrics for each element of the device.

The **Resource Dimensions** pulldown list provides the available metrics on your system.

## Literal Widget Data

If you are creating a button or text widget, you can specify literal widget data instead of rendering dynamic database or metric data.

## Override Date

You can override the default date range by providing a widget-specific date range. The period can be set to a range relative to the current time, such as: the last 5 minutes, hour, day, week, month or year. Alternatively, it can be set to a fixed timespan.

<!--
For more information on metrics, please see [Metrics](/doc/agent/metrics.html#metric-naming).
-->
# Dashboard Widgets

Dashboard Widgets present device and service service information in a discrete, graphical and interactive manner.
Widgets can be combined to create integrated UI pages that focus on various aspects of your device and service.

The Dashboard supports over 30 different widget types that address a wide range of display and interactive input needs. These include: gauges, graphs, numerics, text, image, sound, and input widgets.

![Widet Toolbox](/images/builder/grid-layout.avif){class="screen width-80"}

## Adding Widgets

To add widgets to the dashboard, drag a widget from the widget sidebar toolbox to the desired location on the dashboard.

This will render a box where the widget will be placed and will then display the widget properties slide-out panel. From this panel, you can select your widget configuration.

![Widget Toolbox](/images/builder/widget-toolbox.avif){class="screen width-60"}

You can also add a widget by clicking on the **"Plus"** icon in the Dashboard toolbar. 

![Navbar](/images/builder/dashboard-toolbar.avif){class="screen width-60"}

## Widget Configuration

When creating or modifying a widget, the widget modify panel is used to configure the widget type, presentation, style, data source and associated automation actions.

![Add Widget](/images/builder/widget-edit.avif){class="screen width-60"}

There are four tabs to control the various aspects of a widget:

Name | Description
-|-
Basic | Widget type and extra output fields
Style | Widget position and styling
Data | Data source for the widget
Actions | Automated action to run when the widget is activated

From this panel you can save your changes and click Apply button if you wish to save changes, but keep the panel open for futher modifications.

## Deleting Widgets

From this panel you can also delete a widget or copy a widget to a new widget. 

To learn more:

* [Widget Basic](basic.md)
* [Widget Presentation](presentation.md)
* [Widget Data](data.md)
* [Widget Actions](actions.md)

# Widget Actions

Widgets can invoke actions when a widget is activated by user action, such as clicking a button. Widget actions can peform operations on devices, on the device cloud or initiate creating an alert or sending a notification.

A widget can be activated by:

* Clicking a widget
* Updating the value of an input widget
* Clicking a widget form submit button

When activated, the widget will invoke the associated action. There are two kinds of actions:

* UI Links
* Change Dashboard
* Automated Actions

## UI Links

UI links are in-app page redirections where the App will navigate to the nominated page.

## Change Dashboard

Change dashboard actions allow another dashboard to be selected when a button is clicked.

## Automated Actions

Automated Actions are cloud-side actions defined by the builder to operate on devices our the device cloud. If selected, an **Action Name** selection list will display the available actions.

![Widget Actions](/images/builder/widget-edit-actions.avif){class="screen width-80"}

### If / Then / Else / If

An widget can provide a context data to the automated action by configuring a set of properties that are used when an expression is true or not.  This is structured as a sequence of if/then/else statements. If the epxression is true, the properties provided by the **then** clause will passed as parameters to the action.

For example, the EcoHouse app tests the value of a **ChargeCar** Button widget to enable or disable charging.

In this image, the **{car: false}** properties are provided to a Database update action which set the **car** field of a **Desired** state table to false.

## If expressions

The **If** expression is a JavaScript like expression that is evaluated to determine which set of parameters should be provided to the automated action.

The **If** expression is provided with a context of variables that can be accessed by the expression. The widget data value is provided in the **"value"** named variables. You can test this result using a Javscript like expression. For example:

    value > 0

Other context variables include:

Variable | Description
-|-
agent | Browser user agent string
dark | True if in dark mode 
desktop | True if running on a desktop PC
framed | True if the board is framing widgets
full | True if the board is in full screen mode
height | The browser width dimension (navigator.innerwidth)
language | The configured browser language (navigator.language)
live | True if the dashtop has enabled live data updates
mobile | True if running on a mobile device (<= 640px width)
value | The widget data (or input) value
width | The browser height dimension (window.innerWidth)

The query language supports the operators:

    + - * / ( ) ^ ! % == != < <= > >= ^= ^!= $= $!= << >> && || <> ><

These extension operators have the following meaning:

* a ^= b     means a starts with the string b
* a ^!= b    means a does not start with the string b
* a $= b     means a ends with the string b
* a $!= b    means a does not end with the string b
* a >< b     means a contains the string b
* a <> b     means a does not contain the string b

Sub-expressions can be grouped with parenthesis and the boolean operators && and || can group conditional operands.

Regular expressions (delimited by slashes) may be used with the "==" and "!=" operators. The regular expression can be on either side of the operator.

The expression language understands the types: Numbers, Boolean, String literals, Regular Expressions and null.

The expression is run-time limited to evaluate up to 50 terms. This is to protect your cloud against denial of service attacks.
# Widget Types

The following widget types are supported:

Widget | Description
-|-
[button](#button-widget) | Clickable button
event | Table of top alert event
form | Input form
gauge | Numeric gauge
graph | Numeric graph
image | Image
input | Input field
led | RGB Leds
numeric | Numeric value
progress | Progress widget
set | Service Overview
shape | Arbitrary shape
sign | Signpost
table | Tabular data
text | Text 
toolbar | Dashboard Toolbar

The following Input widget subtypes are supported:

Widget | Description
-|-
checkbox | Checkbox
combo | Combination Box
date | Date
file | File
password | Password
radio | Radio
select | Select
slider | Slider
switch | Switch
text | Text Field
textarea | Text Area

## Button Widget

![Button Widget](/images/builder/widget-button.avif){class="screen width-60"}

The button widget provides a simple clickable button and is typically used with widget actions to navigate to a new app page or to invoke a cloud-side automated action.

There are two varieties of button:

* Text Button
* Icon Button

### Configurable fields

Field | Description
-|-
footer | Footer text to place at the bottom of the widget
header | Header text to place at the top of the widget
text | Button text if using a button icon
title | Title text. Not typically used.

### Custom CSS

Property | Description
-|-
--w-icon | Icon to use instead of text. E.g. "$edit".
--w-elevation | Elevation in pixels of the button. Default is 0.
--w-prepend-icon | Icon to prepend before the button text.
--w-append-icon | Icon to append after the button text.
--w-rounded | Set to round the button corners. Set to 0, XS, SM, LG or XL.
--w-variant | Set to elevated, flat, tonal, outlined, text or plain.

>**More widget documentation coming soon...**

<!--
const Select = {
    button: {
        header: true,
        text: true,
        footer: true,
    },
    event: {
        max: true,
    },
    gauge: {
        footer: true,
        header: true,
        min: true,
        max: true,
    },
    graph: {
        header: true,
        footer: true,
        min: true,
        max: true,
        // TODO: types: bar, line, scatter, bubble, pie, doughnut, polarArea, radar
        presentation: false,
    },
    form: {
        form: true,
    },
    image: {
        url: true,
    },
    input: {
        field: true,
        form: true,
        label: true,
        placeholder: true,
        type: true,
    },
    led: {
        header: true,
        footer: true,
    },
    list: {
        header: true,
        footer: true,
    },
    numeric: {
        footer: true,
        format: true,
        header: true,
        prefix: true,
        suffix: true,
    },
    progress: {
        header: true,
        footer: true,
        min: true,
        max: true,
    },
    set: {},
    shape: {},
    sign: {
        header: true,
    },
    table: {
        fields: true,
        header: true,
        pivot: true,
        subtitle: true,
    },
    text: {
        header: true,
        footer: true,
        text: true,
    },
    toolbar: {},
}

const SelectInput = {
    checkbox: {},
    combo: {
        items: true,
        multiple: 'switch',
    },
    date: {
        datetime: ['date', 'time', 'datetime'],
        prefix: true,
        suffix: true,
        timezone: true,
    },
    file: {
        accept: true,
        multiple: 'switch',
    },
    password: {
        prefix: true,
        suffix: true,
    },
    radio: {
        items: true,
    },
    select: {
        items: true,
        multiple: 'switch',
    },
    slider: {
        max: true,
        min: true,
        prefix: true,
        suffix: true,
    },
    switch: {},
    text: {
        prefix: true,
        suffix: true,
        validate: true,
    },
    textarea: {
        rows: true,
        validate: true,
    },
}
--> # Pages

You can create UI pages for your app to focus on different aspects of device operation and performance. For example, you may want a page that features constrols key device parameters and another displays service load graphs and metrics, while another may focus on outages and errors.  

Using the `Page Designer`, you can create and modify pages by dragging and dropping widgets onto the page canvas. Pages can be styled with CSS properties including a background color or image, such as a map. 

![Kickstart Page](/images/manager/dashboard.avif){class="screen"}

## Widgets and Layouts

The Page Designer utilizes the `Board` component of the `DevCore` UI framework. The Dashboards and Pages facilities both leverage the `Board` component. See the Board documention for details regarding:

* [Widgets](../boards/widgets/)
* [Layouts](../boards/layouts.md)
* [Toolbar](../boards/toolbar.md)

## Page Designer

The Page Designer offers the following:

- Graphical widgets including: graphs, gauges, numeric, text, button, image and user input widgets.
- Input widgets: checkbox, combobox, select list, date picker, file input, slider, switch, text,
  textarea and radio.
- Customizable layout and widget positioning sizing.
- Responsive design for varying screen sizes.
- Ability to style individual widgets and widget fields with any CSS properties.
- Ability to create multiple pages focussing on different service aspects.
- Ability to connect widgets to device metrics or device data.

## Launching the Page Designer

After creating a page, you can invoke the `Page Designer` by clicking on the `Design` icon in the pages list.

![Page Designer](/images/manager/page-designer.avif){class="screen"}

Once launched, you can drag and drop widgets onto the page canvas or modify existing widgets.

### Widgets

Pages supports a suite of widget types including: gauges, graphs, numeric, text, buttons, images, events, data tables and input widgets.

To add widgets to the page, drag the desired widget from the widget toolbox or click on the plus `Add Widget` icon in the page toolbar which will display the add widget slide-out panel.

![Add Widgets](/images/builder/widget-toolbox.png){class="screen width-60"}

From this panel, you can define your widget type, style, data source and associated actions.

![Add Widgets](/images/builder/widget-add.png){class="screen width-60"}

## Page Properties

You can control the style and operation of the page by defining the widget layout scheme, widget presentation, styling including spacing, colors and backgrounds.  Click on the `Modify` page propeties icon in the toolbar to display the page properties panel.

![Add Page](/images/builder/dash-edit.png){class="screen width-50"}

You can adjust the presentation of the page by modifing the presentation factors:

* Display the page full screen without (vs with) an application navigation bar. 
* Display page widgets with frames around their border.

When designing a page, it is easiest to work in non-full screen with framed widgets. This makes it easier to position and resize widgets.

When you are finished designing the page, you may wish to switch to `Full-screen` and `Frameless Widgets`.

## Page Layouts

Pages can arrange widgets using either an `Exact` layout or `Grid` layout engine.

The `Exact` layout is useful to create composite pages where widgets need to be placed "exactly" and widget boundaries may overlap. The exact layout will position and size widgets wherever you place and configure them with per-pixel resolution. Widgets can overlap and cover widgets behind them. 

The `Grid` layout engine is the default layout engine and is typically easier to arrange widgets when getting started. The grid layout engine will position widgets so that widgets align on a 20 pixel grid and no widgets overlap. You can switch between layout engines at any time.

The Grid layout is often easier to align and position widgets. The Exact layout can work best if you need widgets to be very close and perhaps overlapping to create a seamless, composite UI page.

When widgets are positioned, the width of the widget and its relative position to the left side of the browser are saved as a percentage of the browser window size. Thereafter, if the window is resized, or if the app is viewed on a different sized mobile device, the widget will be scaled according to the size of the UI display.
# App Designer

The App Designer is a visual low-code app UI designer so you can easily create stunning mobile and desktop apps to manage your devices. With the App Designer you can create and customize the app's user interface with UI controls, data, theme, colors and logo &mdash; all without coding. 

![Device Page Designer](/images/manager/page-designer.avif){class="screen"}

The App Designer is used to create UI pages and define the app UI navigation. The UI pages are constructed using a dashboard canvas upon which UI elements can be positioned and resized to suit your need.

The App Designer supports a drag-drop design pattern where you can select UI controls and widgets from an extensive library of over 30 widgets. There are widgets for graphs, tables, numerics, shapes, gauges, buttons, images, input controls for all types of data entry.

## Overview

The App Designer has three main components:

* Theme Editor
* Page Designer
* Feature Designer

## Theme Designer

The `Theme Designer` is used to configure the app's theme. This includes the app's colors, fonts, name, style sheet and logo.

![Theme Designer](/images/manager/theme-designer.avif){class="screen width-80"}

## Feature Designer

The `Feature Designer` is used to configure the app's supported features. This includes the app's features, such as authentication, navigation, cloud management, and visualization features.

![Feature Designer](/images/manager/feature-designer.avif){class="screen width-80"}

## App Pages

The App Designer enables you to create and modify UI pages.  Select the `Pages` tab of the `Designer` to view the list of pages. The page list displays the page's UI path, menu name and icon and the UI component used to render the page.

![Page Designer](/images/manager/page-list.avif){class="screen width-100"}

## Modifying Pages

For page's based upon the `Page` component, you can use the app designer by clicking on the page's design icon. For all pages, you can edit the page properties, including definining the page componany, by clicking on the page's edit icon. You can add a new page by clicking the `Add` button and then select the `Page` component.

![Page Edit](/images/manager/page-edit.avif){class="screen width-60"}

Pages must have a UI path and can optionally have an internal name. If a sidebar menu is enabled, the page will be added to the sidebar menu using the given menu icon.  

Pages can be secured by specifying a `role` that must be present in the user's role list. The supported roles are: `owner`, `admin`, `user`, `public` and `inherted`. If inherited is specified, the role is inherited from the parent page.

The `tab` navigation switch controls whether the page has children pages that should be displayed as tabs under the parent page.

### Page Designer

For pages that utilize the `Page` component, you can invoke the `Page Designer` to visually design the page by dragging and dropping widgets onto the page. The DevCore framework provides over 30 widgets to choose from.

![Page Designer](/images/manager/page-designer.avif){class="screen width-80"}

## Exporting and Importing Pages

You can export a page to a JSON file by selecting the page and clicking the `Export` option under `Actions`. You can import a page from a JSON file by clicking the `Import` action.

## Widgets

The App Designer composes pages drawing on a library of over 30 widgets including:

>Audio, Button, Event, Form, Gauge, Graph, Image, Input, Label, Led, Metric Table, Numeric, Progress, Overview, Shape, Sign, Table, Tabs, Toolbar and more.



# Theme Editor

The theme designer is used to configure the app's theme. This includes the app's colors, fonts, name, style sheet and logo.

![Theme Designer](/images/manager/theme-designer.avif){class="screen width-80"}

## App Name

The app name is used for identification and not displayed by the app.

## App Title

The app title is the name of the app as it will be displayed in the app's navigation bar and login panel.

## CSS Stylesheet

The CSS stylesheet is used to customize the app's appearance. This includes the app's colors, fonts, name, style sheet and logo.

## Logo

Your app may be changed by uploading your own corporate or product logo. This logo will be used on the login panel and in the top navigation bar of the app. Your logo should be a small, square, transparent logo in a format supported by most browsers. To upload, click on the Logo section and and check the Upload Logo and click on the Logo Image file selection box to select a logo file to upload.

## Display Upload

While you will probably use the `Page Designer` to create your app's pages, you can instead upload a display configuration file for the app. This file is typicaly generated by the `Page Designer` and is used to define the app's pages, widgets, and other UI elements. If you upload a display configuration file, it will override any pages you have created using the `Page Designer`.

To upload a display configuration file, click on the `Upload Display` checkbox to display a file upload dialog

# Feature Designer

The `Feature Designer` is used to configure the app's supported features. This includes the app's features, such as authentication, navigation, cloud management, and visualization features.

![Feature Configurator](/images/manager/feature-designer.avif){class="screen width-80"}

# Features

| Group | Path| Tip |
|-|-|-|
| **Auth**      | `auth.forgot`      | Forgot password recovery                 |
| **Auth**      | `auth.login`       | Login required to use app                |
| **Cloud**     | `cloud.enable`     | Enable cloud-based management            |
| **Dashboard** | `dash.edit`        | Enable dashboard editing                 |
| **Dashboard** | `dash.database`    | Enable dashboards database access        |
| **Dashboard** | `dash.metrics`     | Enable dashboard metrics                 |
| **Dashboard** | `dash.multiple`    | Support multiple dashboards              |
| **Dashboard** | `dash.responsive`  | Support responsive dashboards            |
| **Navigation**| `nav.alerts`       | Display alert notifications in navbar    |
| **Navigation**| `nav.cookies`      | Display navigation cookies in tabbed pages |
| **Navigation**| `nav.dark`         | Display dark theme option in navbar      |
| **Navigation**| `nav.doc`          | Display documentation link in navbar     |
| **Navigation**| `nav.help`         | Support help panel                       |
| **Navigation**| `nav.profile`      | Display user account profile link        |
| **Navigation**| `nav.settings`     | Display user account settings link       |
| **Navigation**| `nav.sidebar`      | Add app sidebar navigation               |
| **Navigation**| `nav.navbar`       | Add top level app navigation bar         |
| **Widget**    | `widget.actions`   | Enable widget actions                    |
| **Widget**    | `widget.multiCloud`| Widgets should support multiple clouds   |