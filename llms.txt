---
title: Doc Chat Bot
lastUpdated: false
---

<h1>Ioto Doc ChatBot</h1>
<div class="chat">
    <p>This documentation ChatBot has been trained on the Ioto documentation. Ask your support questions here. Note: that it is not a real person and may not always give the best answers.</p>
    <div _class="mb-5" v-for="item in page.questions">
        <div class="question"> {{ item.question}} </div>
        <div class="answer" v-html="item.answer"></div>
    </div>
    <form @submit.prevent="onSubmit">
        <div class="ask">
            <input
                ref="questionRef"
                v-model="page.question"
                type="text"
                name="question"
                id="question"
                size="80"
                placeholder="Ask any question about Ioto ..."
                required>
        </div>
        <div class="thinking" v-if="page.thinking">Thinking ...{{page.dots}}</div>
        <!--
        <button class="button" @click="newChat">New Chat</button>
        Thread: {{page.threadId}}
        -->
    </form>
</div>

<script setup>
import { onMounted, reactive, ref } from 'vue'
import { marked } from "marked"

const count = ref(0)

const questionRef = ref(null)

const page = reactive({
    dots: '',
    lifespan: 86400 * 1000 * 5,
    question: null,
    questions: [],
    thinking: null,
    threadId: null,
})

onMounted(() => {
    if (questionRef.value) {
        questionRef.value.focus()
    }
    localStorage['/embedthis/thread'] = {}
})

async function newChat() {
    localStorage['/embedthis/thread'] = {}
}

async function onSubmit(event) {
    event.preventDefault()
    let thread
    try {
        thread = JSON.parse(localStorage['/embedthis/thread'] || '{}') || {}
    } catch {}
    if (!thread || (thread.id && thread.expire > Date.now() + page.lifespan)) {
        thread = {}
    }
    page.threadId = thread.id

    let question = page.question
    let magic = '5ed3de37-dcc9-4d78-b1e9-546d8a9a2270'
    if (question) {
        try {
            let args = {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                    Origin: window.location.origin,
                },
                mode: 'cors',
                credentials: 'include',
            }
            page.thinking = true
            let response = await fetch('https://api.admin.embedthis.com/api/ai/chat',
                Object.assign({}, args, {
                    body: JSON.stringify({ message: question, threadId: thread.id, magic }),
                })
            )
            if (response.status != 200) {
                // Clear thread.id?
                throw new Error(await response.text())
            }
            let res = await response.json()
            console.log(res)
            let {threadId, text, status} = res
            page.threadId = thread.id = threadId
            localStorage['/embedthis/thread'] = JSON.stringify({id: threadId, expire: Date.now() + page.lifespan })
            page.dots = '...'

            console.log(text)
            if (text.indexOf('<html') >= 0) {
                text = text.replace(/```html\n/, '').replace(/\n```/, '')
            } else {
                text = marked.parse(text)
            }
            console.log(text)
            //  Remove cross-references
            text = text.replace(/.*<body>\n/s, '').replace(/<\/body>.*/, '').replace(/.\d+:\d+.source./g, '')

            page.questions.push({question: page.question, answer: text})
            page.question = null
            page.dots = ''
        } catch (err) {
            console.log(`Cannot submit form, please email`, {err})
            alert(
                `${err.message}.\n\nSorry, your form was not uploaded. Please contact sales via email at sales@embedthis.com`
            )
        } finally {
            page.thinking = false
        }
    }
}
</script>

<style module>
button {
  margin-top: 20px;
  background-color: #42b983;
  color: white;
  border: none;
  padding: 10px;
  cursor: pointer;
}
</style>
```text
URL(1)                           User Commands                          URL(1)

NAME
       url

SYNOPSIS
       url [options] [METHOD] URL [items,...]

DESCRIPTION
       URL: A simple client HTTP test program

       url [options] [METHOD] URL [items,...]

       Url
         /path
         port/path
         host:port/path
         scheme://host:port/path

       Options
         --benchmark 3
         --ca file
         --cert file
         --chunk size
         --ciphers cipher,...
         --clients count
         --continue
         --cookie CookieString
         --count NUM
         --debug
         --header 'key: value'
         --key file
         --nofollow
         --printable
         --protocol 0|1
         --quiet
         --range byteRanges
         --retries count
         --save file
         --show [HBhb]
         --timeout secs
         --trace file[:type:from]
         --upload
         --verify
         --verbose
         --webSockets
         --webSocketsProtocol proto
         --webSocketsSize num
         --zero

       The URL program is a pragmatic, simple, compact HTTP test client. It
       does not attempt to implement all the HTTP specifications. It supports
       HTTP/1 keep-alive and transfer-chunking encoding.


ARGUMENTS

       The url command takes an optional METHOD as the first argument. This
       must be an upper case word. If absent, the POST method is used if there
       is supplied body data items and otherwise the GET method is used.

       After the optional method is the required URL. The request URL uses a
       flexible format so you can supply only the essential URL components.
       For example.

           $ url /index.html
           $ url :8080
           $ url /
           $ url https:///index.html


URL

       The request URL is of the form:

           [http://|https://][hostname][:port][/path][?query][#hash]

       All portions of the URL are optional. You can supply just the
       components that are non-default.

       If the HTTP scheme is absent, "http" is used. If the hostname is
       missing, "localhost" is used. If the port is absent, the default HTTP
       port for the relevant scheme is used. If the path is not supplied, "/"
       is used. If the query or hash are absent, they are not used.


REQUEST ITEMS

       Requests can supply body data by appending request items to the command
       line. The following request item formats are supported.

           key=value       Request form parameters.

           {key:value,..} Request form parameters as a JSON string.

           @file           Request body supplied via a file.

           "Literal Data"  Request body as a literal string.

           Header:Value    HTTP headers

       If JSON is supplied, only one JSON item can be provided and a Content-
       Type of application/json will be added to the HTTP request headers.

       If a Key=Value parse are provided, multiple such values can be use and
       a Content-Type of x-www-form-urlencoded will be added to the headers.


SHOW TRACE

       By default, url will display the response HTTP headers and response
       data. This can be modified via the --show command option. Use the
       --quiet or --show "" to squelch outputting the response HTTP headers.


OPTIONS

       --benchmark
              Compute benchmark statistics for the requests.

       --ca file
              Certifiate authority. This is used to validate peer site
              certificates.

       --chunk size
              Send request body data using transfer chunk encoding of this
              maximum size.

       --ciphers cipher,cipher
              List of TLS cipers to use for the request.

       --clients count
              Use the requested number of simulated clients to run
              simultaneous requests. Default is 1.

       --continue
              Continue testing despite request errors.

       --cookie
              Cookie string header.

       --debug
              Enable debug tracing. (Shortcut -d).

       --header key:value
              Include the HTTP header key:value in the requeset.

       --key file
              Use the supplied private key when sending client certificates to
              the server.

       --nofollow
              Do not follow redirections. Default is to follow.

       --printable
              If the returned content contains binary data, convert to a
              printable hex format.

       --protocol 0|1
              If set to 0, use the HTTP/1.0 protocol, otherwise use the
              default HTTP/1.1

       --quiet
              Do not display HTTP response headers. Alias for --show "".

       --range byteRanges
              Add to the request the specified byte ranges.

       --retries count
              Define the retry limit for the request. This is used to retry
              requests and to follow redirections.  Default is 3.

       --save filename
              Save the response content to the given filename.

       --show [HBhb]
              Show the request headers/body (HB) and response headers/body
              (hb). Defaults to --show h. Set to an empty string to disable
              all tracing.

       --timeout secs
              Timeout the request if it does not complete in the required
              number of seconds.

       --trace file[:types[:sources]]
              Name the Ioto trace file. The types are a comma separated list
              of message types. Valid types include: info, debug, error, and
              trace. Sources are the code module names originating the trace
              messages. You can use "all" for types and sources to match all
              types/sources. You can also use "!type" and "!source" to negate
              a type or source.

       --upload
              POST the supplied data items (or files) using multipart-mime
              file upload.

       --verify
              Verify the server certificate using the certificate authority
              bundle supplied with the --ca file option. The default is to not
              verify.

       --verbose
              Run with more verbose tracing. (Shortcut -v).

       --version
              Output the product version number.

       --webSockets
              Force enable the WebSockets protocol. This is enabled automatically if using the ws:// or wss:// URL scheme.

       --webSocketsProtocol proto
              Select the given WebSockets sub-protocol.

       --webSocketsSize num
              Send test messages of the given size to the server.

       --zero 
              Exit with a zero status for any valid HTTP response.

REPORTING BUGS
       Report bugs to dev@embedthis.com.

COPYRIGHT
       Copyright (c) Embedthis Software.

url                                June 2024                            URL(1)
```
```text
NAME
    json - JSON parsing and query program

SYNOPSIS
    json [options] [cmd] file
    json --stdin [cmd] < file
    json field=value
    json field
    json .

DESCRIPTION
    JSON: A JSON parsing and query program

    json [options] [cmd] [file]

        --blend
        --check
        --compress
        --default value
        --env
        --export
        --header
        --json
        --json5
        --noerror
        --profile name
        --quiet
        --stdin
        --remove
        --overwrite

    Commands:
        property=value
        property
        .

    The JSON program is a pragmatic, simple JSON parse and query client.

COMMANDS
    json field=value
    json field
    json .

    The json command has several command forms.

        json [options] [cmd] file

    This form reads the supplied JSON or JSON5 file and performs the specified command and emits the result.

        json --stdin [cmd] < file

    When given the --stdin option, the command reads from stdin instead of a file.

QUERYING PROPERTIES
    You can query a property value using the "field" form.

        json address.zip file.json

    This will query the "address.zip" property from the JSON file and emit the result. You can specify the output format with the --json, --json5, --env, --header, and --blend options. For example, to emit the result as a shell environment variable, use the --env option.

        json --env address.zip file.json

SETTING PROPERTIES
    You can update a property value using the "field=value" form.

        json address.zip=98052 file.json

    The field can be a dotted path.

CONVERTING formats
        json --json5 file.json .

    This will convert the JSON file to JSON5 format and emit the result.

OPTIONS
    --blend
        Blend included files from blend[]

    --check
        Check syntax with no output

    --compress
        Emit without redundant whitespace

    --default value
        Default value to use if query not found

    --env
        Emit results as shell environment variables

    --export
        Add export prefix to env vars

    --header
        Emit query results as C header defines

    --json
        Emit output as JSON

    --json5
        Emit output as JSON5

    --noerror
        Ignore file open errors

    --profile name
        Merge properties from the named profile

    --quiet
        Quiet mode with no error messages

    --stdin
        Read from stdin

    --remove
        Remove queried property

    --overwrite
        Overwrite file when converting instead of outputting to stdout

COMMANDS
    property=value
        Set queried property

    property
        Query property which can be a dotted path.

    .
        Convert input to desired format.

REPORTING BUGS
    Report bugs to dev@embedthis.com.

COPYRIGHT
    Copyright (c) Embedthis Software.
``````text
IOTO(1)                          User Commands                         IOTO(1)

NAME
       ioto- Embedded Device Agent

SYNOPSIS

       ioto [options]

       ioto
           --account ID
           --background
           --cloud Token
           --config dir
           --count Number
           --debug
           --exit event|minutes
           --gen
           --home directory
           --id UCI
           --ioto path
           --nosave
           --product Token
           --profile profile
           --reset
           --show [bhBH]
           --state dir
           --sync up|down|both
           --test suite
           --timeouts
           --trace file[:type:from]
           --verbose
           --version

DESCRIPTION

       Ioto is a compact device agent that includes an MQTT client, HTTP web
       server, HTTP client, embedded database, JSON parser and integration
       with AWS IoT. It can run as a stand-alone as a device agent or the Ioto
       library can be embedded in applications.

       The Ioto web server supports HTTP/1.0, HTTP/1.1, TLS, user
       authentication, sessions, chunked transfers, file upload, and security
       limits.

       Ioto normally reads a set of JSON configuration files. It reads the
       ioto.json5 file for general configuration, the web.json5 for web server
       configuration, and shadow.json5 for persisted device shadow state.

       Ioto can trace activities to a file that defaults to 'stdout'. This can
       be modified via the --trace command line option.

       The --trace option specifies a destination file for trace messages.
       This will override the trace property in the Ioto ioto.json5 file. The
       trace argument syntax is fileName[:types:sources].

       The types are a comma separated list of message types. Valid types
       include: info, debug, error, and trace.  Sources are the code module
       names originating the trace messages.

       You can use "all" for types and sources to match all types/sources. You
       can also use "!type" and "!source" to negate a type or source.

       Ioto responds to the SIGUSR2 signal and increases the trace level.

OPTIONS

       --account ID
              Override the account property in the device.json5 configuration
              file when using pre-claimed device provisioning. The account
              property should be set to the user's device app account ID
              obtained from the Account/Settings page in the manager site.
              --background Run Ioto in the background and detach from the
              console.

       --cloud Token
              Override the cloudToken property in the device.json5
              configuration file when using pre-claimed device provisioning.
              The cloudToken property should be set to the Builder cloud claim
              token.

       --config dir
              Override the directory containing config files.

       --count Number
              Override the number of test iterations.

       --debug
              Enable debug tracing. (Shortcut -d).

       --exit event|minutes
              Exit Ioto when the given event is triggered or when the
              specified number of minutes have elapsed. Useful when performing
              limited tests.

       --gen  Generate a UID

       --home directory
              Change to the specified directory before running Ioto.

       --id UCI
              Override the id property in the device.json5 configuration file.
              The id property should be set to unique device claim ID for the
              device.

       --ioto path
              Override the path to the ioto.json5 configuration file.

       --nosave
              Run in-memory and do not save state.

       --product Token
              Override the "product" property in the device.json5
              configuration file when using pre-claimed device provisioning.
              The product property should be set to the Builder product token.

       --profile profile
              Override the operational profile. Defaults to "prod".

       --quiet
              Don't show web server HTTP headers. Alias for --show "".

       --reset
              Reset Ioto state to factory defaults. This erases database state
              under the ./state directory.

       --show [hbHB]
              Show request headers/body (HB) and resposne headers/body (hb).

       --state dir
              Override the directory where state is persisted.

       --sync up|down|both
              Sync the device database with the cloud.

       --test suite
              Run the select test described in the config/test.json5 test
              configuration file.

       --timeouts
              Run Ioto in debug mode and disable all timeouts. This disables
              request and session timeouts.

       --trace file[:types[:sources]]
              Name the Ioto trace file. The types are a comma separated list
              of message types. Valid types include: info, debug, error, and
              trace. Sources are the code module names originating the trace
              messages. You can use "all" for types and sources to match all
              types/sources. You can also use "!type" and "!source" to negate
              a type or source.

       --verbose
              Run with more verbose tracing. (Shortcut -v)

       --version
              Output the product version number.

FILES
       /etc/ioto
       /var/www/ioto
       /usr/local/lib/ioto

REPORTING BUGS

       Report bugs to dev@embedthis.com.

COPYRIGHT

       Copyright (c) Embedthis Software.

ioto                               June 2022                           IOTO(1)
```
```text
PASS(1)                          User Commands                         PASS(1)

NAME
       pass - Create and manage passwords

SYNOPSIS

       pass [--cipher bcrypt|sha256] [--password password] username

DESCRIPTION

       The pass program creates encrypted (hashed) authentication passwords
       for use by the Ioto embedded web server.

       These hashed passwords are typically stored in the Ioto embedded
       database.

            pass --password pass1 joshua


OPTIONS

       --cipher bcrypt|sha256
              Specifies the cipher to use to hash the password. Default is
              Bcrypt. Blowfish is substantially more secure.

       --password password
              Specifies a password to use to for the user.

DESCRIPTION

       The pass program is used to create and manage user passwords.

REPORTING BUGS

       Report bugs to dev@embedthis.com.

COPYRIGHT

       Copyright (c) Embedthis Software.

pass                               June 2024                           PASS(1)
```text
DB(1)                            User Commands                           DB(1)

NAME
       db- Ioto database command


SYNOPSIS
       db- Ioto database command

       db [options] --schema schema.json database [model] [field=value]

       Options
           --load data.json
           --reset
           --schema schema.json

DESCRIPTION

       The db utility is a database manager and query utility to interact with
       the Ioto embedded database. It can be used to query and set database
       values and reset or load seed data into the Ioto database.

       The --schema option specifies the database schema that defines the
       database entities, fields and data types. This option is required.


       The database file is specified as the first non-option argument. If no
       other arguments are provided, the data items of the database are
       printed to stdout as a series of JSON objects.

       If a model argument is provided after the database file, then only data
       items of that model type are printed.

       If a field=value argument is provided, database items that have a field
       with the specified value will be printed.

OPTIONS

       The --load option specifies a JSON file from which to load data. The
       JSON format is an object map of entities with an array of data items.

       For example:

       {
           User: [
               { name: 'Peter', role: 'user' },
               { name: 'Elisha', role: 'admin' },
           ] }

       The --reset command will reset the database and erase all existing
       items in the database.


REPORTING BUGS

       Report bugs to dev@embedthis.com.

COPYRIGHT

       Copyright (c) Embedthis Software.

db                                 June 2024                             DB(1)

```# Metrics

For device data that is synchronized to the cloud, you can create custom metrics from the data stream. These metrics can then be displayed or graphed in the device app.

Ioto metrics automatically calculate statistics for the last "5 minutes", "hour", "day", "week" "month", or "year". For each timespan, you can query the average, minimum, maximum or sum value for the metric. 

## Metric Naming

Metrics are created and subsequently queried by a set of naming properties including:

* namespace 
* metric name
* dimensions

The **namespace** is a global name to group related metrics. Currently, this must be set to `Embedthis/Device`.

The **metric** name is the specific metric name. For example: a device's `temperature`.

The **dimensions** select specific instances of a metric. For example, each device may have a `temperature` metric and we may also have an overall device pool average `temperature` metric.

### Defining Metrics

In the **process** section for a model, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:
```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
            }]
        }
    },
    ...
}
```

This will create a `temperature` metric from the item's `temp` attribute.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| where | `string` | Conditional expression to select items for which to create metrics. |
| buffer | `map` | Metric buffering directives. Defaults to null|.

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.

#### Where Expressions

The `where` property can be used to select matching items (rows).

The `where` query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

will select those items which have the `error` attribute set to "critical" and the `component` attribute set to "PS1".

For example:

```js
{
    ModelName: {
        metrics: [
            {
                namespace: 'Embedthis/Device',
                fields: [{CPU: 'value'}],
                where: 'key == "cpu"',
            }
        ]
    }
}
```

See [Expressions](../../apps/config/expressions.md) for more information on the expression syntax.


## Displaying Metrics

The device app can display metric data via graphical widgets

![App](/images/manager/home.png){class="screen"}

You can select from the following widget types:

* gauge
* graph
* table
* progress
* number
* leds

When creating or modifying a widget, you can select the data source to be either a database table item or a metric.

When selecting a metric, you enter the metric name, statistic and resource dimensions.

When selecting data directly from the database, you enter the database table model name, the model field (attribute) and a row selection expression.

![App Widget Edit](/images/manager/widget-edit.png){class="screen"}# Database Synchronization

The Ioto agent database (DB) supports optional transparent synchronization of data to and from the cloud.

Ioto takes the pain out of exporting device data into the cloud by automatically and transparently synchronizing data between your devices and a cloud device database.

Ioto will synchronize data from the device cloud database and the embedded database in your devices. This is similar to AWS Global Tables, but instead of between AWS regions, it is between an AWS region and a device.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-table basis.

The Ioto database is designed to be compatible with AWS DynamoDB so that it can easily replicate structured device data to the cloud. It is modeled after [AWS DynamoDB](https://aws.amazon.com/dynamodb/) and the [OneTable](https://doc.onetable.io/) access library.

## Database Replication Features

-   Transparent replication.
-   Bi-directional synchronization to and from the cloud.
-   Per-table synchronization control.
-   Resilient catch-up should the device or cloud go offline.
-   Database triggers for notification when changes arrive.

## Databases

The Ioto service creates a DynamoDB table called _ioto_ in each device cloud. A device cloud is created by the Embedthis Builder for your account to host your device data in an AWS account and region of your choosing. The _ioto_ database table contains the device data for all connected devices in that cloud.

The Ioto device agent creates a local database to hold structured data for the device.

These two databases are then connected and changes are replicated between device and cloud to keep them in sync.

## Why Synchronization

The Ioto Database Synchronization service dramatically eases the task of centralizing the data management of a pool of devices. Each device can store data locally and it will be transparently, efficiently and automatically replicated to the cloud. Once in the cloud, it can be easily interrogated and queried for analytics, operational control and intelligence.

Each side has fast, predictable local access to the data. Coupled with reliable replication semantics you can work locally while Ioto takes care of the replication.

## How It Works

To replicate cloud-side data, the Ioto service uses DynamoDB streams to capture modifications made to the table data. The stream is connected to an Ioto service Lambda which posts MQTT messages to a special topic that is only known to the device.

The Ioto device agent subscribes to this topic and receives MQTT messages containing the changed data. The agent then applies those changes to the local database.

In reverse, the Ioto agent registers a database trigger that is called whenever local changes are made to the device's database. When the trigger is invoked, the agent sends an MQTT message with the changes to the Ioto service that updates the cloud database.

When the device is rebooted, it sends a "sync" message to the Ioto service to retrieve all changes made to the cloud database since the last change notification was received from the cloud. In this way, changes made while the device is offline are not lost.

## Controlling Replication

Ioto can synchronize changes to the cloud on a per item basis. The schema **process** property defines how to synchronize each item type. You can "enable" a database item to be stored in the cloud, in the device or in both places. You can also control the replication direction flow of changes.

For each item type in the schema, a property under **process** specifies where the item resides and how it should be synchronized.

For example:

```c
{
    process: {
        Status:  { enable: 'cloud' },
        Fault:   { sync: 'up' },
    },
}
```

In this example: The **Status** type is only enabled (exists) in the cloud. The **Fault** type exists in both the cloud and on the device and synchronization occurs only from the device "up" to the cloud.

A type's **enable** property can be set to "cloud", "device" or "both" to define where the item can exist. The default is "both".

A type's **sync** property can be set to "up", "down", "both" or "none" to define the directional flow of replication updates. A value of "up" means replicate changes from the device "up" to the cloud. A value of "down" means replicate changes only from the cloud "down" to the device. The default is "none".

## Replication Best Practices

Synchronization of items is done on a per-item basis and not field by field. This means that a change of one field by the cloud can overwrite a change of another field on the device. For this reason, it is best to have the **sync** direction be either "up" or "down".

You should only select "both" as your **sync** direction for items that can be updated by both cloud and device at the same time without loss of data or conflict.

## Optimizations

To optimize network traffic, database changes will be sent up to the cloud in batches. These are controlled by the **database.syncDelay** and the **database.syncLimit** properties. The **syncDelay** is a delay before sending change batches to the cloud. The **syncLimit** is a size limit of the change set before sending a change batch. These are set to 5 seconds and 10K by default.

You can force a sync save at any point by calling **ioSync**.

Read more in [Database Replication](../database/replication.md).

## References

[OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).# Database Indexes

Schema indexes are defined using the **schema.indexes** property.

The **indexes** property can contain one or more indexes and must contain the **primary** key. Additional indexes will be treated as secondary Indexes.

!!!Note
    Ioto currently only supports the primary index.

```js
const MySchema = {
    indexes: {
        primary: {
            hash: 'pk',         //  Schema property name of the hash key
            sort: 'sk',         //  Schema property name of the sort key
        },
        //  Zero or more global secondary or local secondary indexes
        gs1: {
            hash: 'gs1pk',
            sort: 'gs1sk',
        }
    }
}
```
# Database Processing

The **schema.process** is a map of properties that control how data is stored in the database and how the data is processed. 

The `process` definitions define the following attributes:

* Where the database item will be stored: device / cloud / both.
* In what direction the database syncronization will flow: to-device / to-cloud / both.
* What metrics should be created from the data stream.

For each schema model, you may define an entry in the **process** collection. For example:

```js
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

Each map entry may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| enable | `string` | Control where the model is stored. Set to 'cloud' for in the cloud, 'device' for on the device and 'both' if in both locations. Defaults to 'both'. |
| sync | `string` | Define the direction of the data synchronization. Set to 'down' for down to the device, 'up' for up to the cloud, or 'both' for bi-directional. Defaults to null. |
| metrics | `Array` | Array of metric definitions. See below for details.|
| notify | `boolean` | Issue an AWS EventBridge notification event for matching data. Defaults to false.|

## Database Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-model basis.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

>To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for models that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Metrics

For data that is synchronized to the cloud, you can create custom metrics from the data stream. These metrics can then be displayed or graphed in the device apps.

In the **process** section for a model, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:
```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
            }]
        }
    },
    ...
}
```

This will create a `temperature` metric from the item's `temp` attribute.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| where | `string` | Conditional expression to select items for which to create metrics. |
| buffer | `map` | Metric buffering directives. Defaults to null|.

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.

#### Where Expressions

The `where` property can be used to select matching items for which to create metrics. `Where` expressions use a query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

See [Database Metrics](/agent/metrics/) for details.

## Event Notification

For dedicated device clouds, you can issue AWS EventBridge events for matching database items via the **notify** property. 

The `notify` property is set to the EventBridge bus name. It can be set to "default" or any custom EventBridge bus name.

The database item will be passed to the EventBridge bus as the event context data.

For example:

```js
{
    Store: {
        enable: 'both',
        sync: 'up',
        notify: 'default',
    }
}
```
The following attribute properties are supported:

| Property | Type | Description |
| -------- | :--: | ----------- |
| default | `string` | Default value to use when creating items or when reading items without a value.|
| generate | `string|boolean` | Set to 'ulid' or 'uuid' to automatically create a new ID value for the attribute when creating new items.|
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. If unset, the field will use the table default value for isoDates. Default to the schema params value. |
| nulls | `boolean` | Set to true to store null values or false to remove attributes set to null. Default false. |
| required | `boolean` | Set to true if the attribute is required. |
| schema | `object` | Nested schema. |
| type | `Type or string` | Field data type. |
| value | `string` | Template to derive the value of the attribute. These attributes are "hidden" by default. |


If the **default** property defines the default value for an attribute. If no value is provided for the attribute when creating a new item, the **default** value will be used.

If the **isoDates** property is defined and not-null, it will override the table isoDates value. Set to true to store the field date value as an ISO date string. Set to false to store the date as a Unix epoch date number.

The **schema** property permits nested field definitions. The parent property must be an Object as the type of items in arrays are defined using the **items** property.

The **type** properties defines the attribute data type. Valid types include: String, Number, Boolean, Date, Object, Null, Array, Buffer (or Binary) and Set. The object type is mapped to a **map**, the array type is mapped to a **list**. Dates are stored as Unix numeric epoch date stamps unless the **isoDates** parameter is true, in which case the dates are store as ISO date strings. Binary data is supplied via **buffer** types and is stored as base64 strings in DynamoDB.

The **value** property defines a literal string template that is used to compute the attribute value. This is useful for computing key values from other properties, creating compound (composite) sort keys or for packing fields into a single DynamoDB attribute when using GSIs.

String templates are similar to JavaScript string templates. The template string may contain **${name}** references to other fields defined in the item. If any of the variable references are undefined when an API is called, the computed field value will be undefined and the attribute will be omitted from the operation.

If you call **find** or any query API and do not provide all the properties needed to resolve the complete value template. i.e. some of the ${var} references are unresolved, OneTable will take the resolved leading portion and create a **begins with** key condition for that portion of the value template.
# Database Schemas

Ioto database schemas define how items will be stored in the database and in the cloud. A schema specifies the application models (entities), entity fields, indexes and other data access and replication parameters.

Schemas look like this:

```js
const DeviceSchema = {
    format: 'onetable:1.1.0',
    version: '0.0.1',
    indexes: {
        primary: { hash: 'pk', sort: 'sk' },
    },
    process: {
        /*
            Where the model is enabled (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status:  { enable: 'cloud' },
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        },
    },    
    models: {
        Status: {
            pk:             { type: 'string', value: 'status#' },
            sk:             { type: 'string', value: 'status#' },
            parameters:     { type: 'object' },
            version:        { type: 'string' },
            updated:        { type: 'date' },
        },
        Fault: {
            pk:             { type: 'string', value: 'device#${deviceId}' },
            sk:             { type: 'string', value: 'fault#${id}' },
            deviceId:       { type: 'string', required: true },
            id:             { type: 'string', generate: 'ulid' },
            timestamp:      { type: 'date', required: true },
            source:         { type: 'string', required: true },
            severity:       { type: 'string', required: true, enum: ['info', 'warn', 'error', 'critical', 'fatal'] },
            subject:        { type: 'string', required: true },
            message:        { type: 'string', required: true },
            expires:        { type: 'date', ttl: true },
        },

    },
    params: {
        'isoDates': true,
        'timestamps': true,
    },
}
```


## Schema Properties

The valid properties of the **schema** object are:

| Property | Type | Description |
| -------- | :--: | ----------- |
| format | `string` | Reserved. Must be set to 'onetable:1.1.0' |
| indexes | `object` | Hash of indexes used by the table. |
| models | `object` | Hash of model entities describing the model keys, indexes and attributes. |
| params | `object` | Hash of properties controlling how data is stored in the table. |
| process | `object` | Hash of model entities describing where the model should be stored and how it should be processed. |
| version | `string` | A SemVer compatible version string. |

The **format** property specifies the schema format version and must be set to **onetable:1.1.0**.

The **indexes** property specifies the key structure for the primary, local and secondary indexes.

The **models** property contains one or more models with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties.

The **params** property defines additional parameters for table data formats.

The **process** map defines how database model data should be processed, stored, replicated and whether metrics should be calculated from the data stream.

The **version** property defines a version for your DynamoDB model design. It must be a [SemVer](https://semver.org/) compatible version string. The version string is used by tools and consumers of the schema to understand compatibility constraints for the schema and stored data.


## Schema Models

The schema defines a model for each application entity. For example, consider a music example:

```js
{
    album: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        songs:  { type: 'number' },
    },
    artist: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        address: {
            type: Object, schema: {
                street: { type: 'string' },
                city: { type: 'string' },
                zip: { type: 'string' },
            },
        },
    }
}
```

For each model, all the entity fields are defined by specifying the field type, validations and other operational characteristics (uniqueness, IDs and templates).

The valid types are: 'array', 'binary', 'boolean', 'date', 'number', 'object', and 'string'.

Ioto will ensure that values are of the correct type before they are written to the database. Where possible, values will be cast to their correct types. For example: 'false' will be cast to false for Boolean types and 1000 will be cast to '1000' for String types.

The database will automatically add a model type via the **_type** attribute to each model. This is set to the name of the model. You can modify this via the **params.typeField** setting.


## Value Templates

The value of a field can be computed based on the value of other fields and a formatting "value template". This is useful for decoupling your key structure from your entity fields.

The value template is like a Javascript string literal where the value of fields are expressed in a "${field}" format. At runtime, the field references are expanded with the item's value for the named field.

In the example above, the primary key "pk" is calculated from the entity type **_type** and the **name** field by using the value template: **${_type}:${name}**.

## Expiring Items

Items can be automatically removed by defining a date field that specifies when the item should be removed. To do this, define a date field and set the **ttl: true** schema attribute. This supports the AWS DynamoDB TTL feature.

Database items are removed when the database service routine is run. This is run each hour by default. Additionally, expired items are removed transparently if a retrieval is attempted.

## Nested Schemas

For object attributes, you can define a nested schema for the object properties, as in the example above (repeated below).

A nested schema uses the **schema** property to define a nested map of attributes. Schemas can be nested to an arbitrary depth.

```js
address: {
    type: Object, schema: {
        street: { type: 'string' },
        city: { type: 'string' },
        zip: { type: 'string' }
    }
}
```


## Indexes

DB uses red-black balanced binary trees for indexes to provided ordered, rapid indexing of data. Currently, the database only supports a single primary index, but in the future, multiple indexes will be supported.


## References

[OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).
# Database Schema Parameters

The **schema.params** is a map of properties that control how data is stored in the database. It may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| createdField | `string` | Name of the "created" timestamp attribute. Defaults to "created". |
| hidden | `boolean` | Hide templated (value) attributes in Javascript properties. Default true. |
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. Default false. |
| nulls | `boolean` | Store nulls in database attributes vs remove attributes set to null. Default false. |
| timestamps | `boolean | string` | Make "created" and "updated" timestamps in items. Set to true to create both. Set to 'create' for only "created" timestamp and set to "update" for only an "updated" timestamp. See also: "updatedField" and "createdField" properties. Default false. |
| typeField | `string` | Name of the "type" attribute. Default "_type". |
| updatedField | `string` | Name of the "updated" timestamp attribute. Default "updated". |

For example:

```js
const MySchema = {
    params: {
        isoDates: true,
        timestamps: true,
    }
}
```
# Database Persistency

The Ioto database operates in-memory with a lazy save to persistent storage.

When changes are made to database items, a save to storage will be performed after a configurable delay as specified in the **database.saveDelay** property in the **ioto.json5** file. This is set to 1 second by default.

You can force a database save at any time via the *dbSave* API:

```c
dbSave(db, NULL);
```

This will persist data changes to the database file specified via *dbOpen*. You can supply a filename as the second argument to save to a different (backup) database file.
# Database Overview

The Ioto agent database (DB) is an ultra high performance NoSQL database for embedded applications. It supports fast, in-memory, local data access and optional transparent synchronization of data to and from the cloud. It is modeled after [AWS DynamoDB](https://aws.amazon.com/dynamodb/) and the [OneTable](https://doc.onetable.io/) access library.

The Ioto database stores items as JSON documents of arbitrary complexity. Data items are organized into entity tables via an entity schema that specifies data fields, types, attributes and validations.

The database uses Red/black binary search indexes and has controllable local persistency to disk and to the cloud on a per-table basis.

## Database Features

* High performance NoSQL management document database.
* JSON document items with flexible query API.
* Efficient import and export of database items.
* Red/black binary search indexes.
* Simple, non-waiting API.
* Controllable persistency with change triggers.
* Transparent bi-directional data synchronization with the cloud.
* Custom metrics extracted from synchronized data.
* Unified data schema between device and cloud databases.
* Based on AWS DynamoDB and DynamoDB OneTable.


### Default Database

The Ioto agent will open a default database for general purpose use. This database is loaded from the file "state.db" using the schema file "schema.json5". The filename and schema file can be modified via the **ioto.json5** properties under the **database** key. Most users would typically use this database and would not need to open another database instance.

The database instance reference is stored in the global **ioto** object in the **db** property.

```c
ioto->db
```

## JSON documents

The database stores items as JSON documents that are a nested collection of properties to arbitrary depth. As JSON is one of the most prevalent data exchange formats, storing data in JSON greatly reduces exchange costs.

Ioto includes a powerful JSON query engine that you can use to query and manipulate JSON documents.

## Data Types

All data types are stored internally as strings to optimize data transfer. Return values from database APIs typically return static strings that you do not need to free (const char*). To convert numbers, use the safe runtime conversion routines: stoi() and stoiradix().


## API Quick Tour

If you do choose to open another database rather than use the default database, use *dbOpen*:

```c
Db *db = dbOpen("./data.db", "./schema.json5", 0);
```

The dbOpen API will open the named database and schema.  Data is loaded from the database file and stored in-memory. The schema file describes the application entities, data fields and indexes. Read more about [Schemas](./schemas/).


### Creating an Item

Use *dbCreate* to create an item:

```c
CDbItem *item = dbCreate(ioto->db, "Fault", DB_PROPS(
    "timestamp", rGetTime(),
    "source", "bluetooth",
    "severity", "warn",
    "subject", "Failed to sync",
), NULL);
```

This creates an item in the database and returns a reference to the item. The item properties are provided using the DB_PROPS macro with key/value pairs for each property.

Database items are documents that store item properties in JSON format using JSON types (Objects, arrays, strings, numbers, booleans and dates). Properties can be nested to arbitrary depth.

You can also specify the item properties using the DB_JSON macro. This is useful when you have nested item properties:

```c
item = dbCreate(db, "User",
    DB_JSON("{name: 'user', details: {role: '%s'}}", role), NULL);
```

### Retrieving Fields

To retrieve a field from an item, use *dbGetField*:

```c
const char *id = dbGetField(item, "id");
```

This will retrieve a reference to the the "id" field from the previously read item.

You can also read nested properties from within the item's JSON document.

```c
cchar *errors = dbGetField(item, "interfaces.bluetooth.if1.errors");
```

### Reading Items

To read an item from the database, supply the required item key and call *dbGet*. The key can be the actual item key or it can be a set of fields that are used by the schema to create the key. See [Value Templates](./schemas/#value-templates) for details.

```c
CDbItem *item = dbGet(db, "Fault", DB_PROPS("id", id), NULL);
```

When debugging, you can use the utility routine *dbPrintItem* to print the contents of an item:

```c
dbPrintItem(item);
```

### Finding Items

To retrieve a set of matching items, use *dbFind*:

```c
DbGrid *items = dbFind(db, "Fault", DB_PROPS("severity", "critcal"), 0);
```

You can provide one or more properties to be used as a filter. Items will be returned that match all supplied properties.

When finished with the items, you must free the returned grid via dbFreeGrid.

```c
dbFreeGrid(items);
```

To iterate over the item list, use *ITERATE_ITEMS*:

```c
DbItem *item;
int    n;
for (ITERATE_ITEMS(items, item, n)) {
    dbPrintItem(item);
}
```

You can also use DB_JSON instead of DB_PROPS to provide query parameters as json:

```c
items = dbFind(db, "FAULT", DB_JSON("{severity:'%s'}", severity), 0);
```

The JSON can be provided as [JSON/5](../user/) which allows single quotes around string values.

### Getting and Setting Fields

To get a single field from an item, use *dbGet*:

```c
cchar *severity = dbGet(db, "Fault", "severity", DB_PROPS("id", id), NULL);
```

To set a single field in an item, use *dbSet*:

```c
DbItem *item = dbSetField(db, "Fault", "severity", "info", DB_PROPS("id", id), NULL);
```

You can also use the type specific set routines: dbSetBool, dbSetDate, dbSetDouble and dbSetNum.

### Updating Items

To update multiple fields in an item, use *dbUpdate*:

```c
item = dbUpdate(db, "Fault", DB_PROPS("id", id, "severity", "info", "subject": "Fault resolved"), NULL);
```

### Removing Items

To remove an item, use *dbRemove*:

```c
dbRemove(db, "Fault", DB_PROPS("id", id), NULL);
```

### Pagination

When retrieving items from a large data set, you may need to paginate your results.

You can specify a limit to the number of returned results via the `limit` param. The dbFind routine can take a **next** parameter that specifies where to begin returning results. The `next` parameter is actually the key of the last returned item and the search begins "after" that point.

```c
cchar *next = NULL;
do {
    DbGrid *grid = dbFind(db, NULL, NULL, DB_PARAMS(.next = next, .limit = 20));
    next = dbNext(grid);
    dbFreeGrid(grid);
} while (next);

```

### Cloud Replication

You can transparently replicate device data to the cloud using Ioto cloud synchronization. Data can be synchronized in either direction: from the cloud to the device, or from the device to the cloud.

Replication is controllable on a per-item basis via the database schema. The schema **process** property defines how to process and synchronize each database item type. The schema names database items as "models". You can "enable" an model to be stored in the cloud, in the device or in both places. You can also control the replication direction flow of changes to be "up" to the cloud, or "down" to the device.

For each item type in the schema, a property under the **process** collection specifies where the items reside and how they should be synchronized. 

```c
{
    process: {
        Status:  { enable: 'cloud' },
        Fault:   { sync: 'up' },
    },  
}
```

This enables the Status items to be stored only in the cloud whereas Fault items will be stored on the device and in the cloud and will be synchronized up from the device to the cloud.

### Custom Metrics

For items that are synchronized to the cloud, you can configure custom metrics to be created from the data stream. These metrics can then be displayed or graphed in the device app.

Metrics are specified via the **process** property. For example:

```json5
{
    process:
        Item: {
            enable: 'both',
            sync: 'up',
            metrics: [ {
                namespace: 'Embedthis/Device',
                fields: [{CPU: 'value'}],
                where: 'key == "cpu"',
                dimensions: [{Device: 'deviceId'}],
                buffer: {count: 5, elapsed: 10}
            } ]
        }
    }
}
```

This will create a **CPU** metric from the `value` item attribute. The `where` clause selects the appropriate matching rows. The metric is created in the `Embedthis/Device` namespace and is dimensioned by the device ID. The metrics are buffered and aggregated for up to 10 seconds or a maximum of 5 data points.

### Configuration

You can configure the Ioto database via the **ioto.json5** **database** property collection.

See [Database Configuration](../user/properties.md#database) for details.

```js
database: {
    path: 'db/state.db',
    schema: 'db/schema.json5',
    maxJournalSize: '1mb',
    maxJournalAge: '5mins',
    maxSyncSize: '10k',
},
```

### Debugging

Ioto provides a few routines that help with debugging DB API usage.

* dbPrint
* dbPrintItem
* dbPrintProperties
* jsonToString


## API Reference

The full API is specified here:

[DB API](/agent/ref/api/db.md)
# Ioto Licensing

The Ioto agent is licensed via a commercial license that provides you with the following benefits:

* The right to embed the Ioto agent software in your products.
* The right to develop and modify the software in your products.
* The ability to redistribute your products with the Ioto agent software.
* The ability to connect to the Ioto cloud service.
* The ability to keep your source code private.
* Apply security updates and upgrades.
* Receive priority support service plans.

You may use Ioto provided you fully comply with the governing terms.

* [EmbedThis License Terms](https://www.embedthis.com/about/terms.html)

Please contact us at: [licensing@embedthis.com](mailto:licensing@embedthis.com) if you have any licensing questions.
# Ioto Agent Reference Guide

This guide describes the Ioto agent programming APIs.

Before reading the APIs, you may wish to review some architectural overviews that explain the programming paradigms used by Ioto.

## Architectural Overviews

* [Ioto Background](../user/background.md)
* [Memory Allocation](../dev/memory.md)
* [Fiber Coroutine Programming](../dev/fiber.md)

## Programming APIs

The Ioto agent native APIs consist of C language headers, function prototypes, structure definitions and defines. They are divided into one of these areas.

| Area | Description |
|-|-|
| [Ioto](api/ioto.md) | Agent API |
| [Web Server](api/web.md) | Embedded Web Server |
| [DB](api/db.md) | Embedded Database |
| [MQTT](api/mqtt.md) | MQTT protocol client |
| [URL](api/url.md) | Http Client |
| [JSON](api/json.md) | JSON parser and query engine |
| [Crypt](api/crypt.md) | Crypto APIs |
| [R](api/r.md) | Portable Runtime |
| [OSDEP](api/osdep.md) | O/S Portability Layer |

## Stability Classifications

In addition to supporting <a href="https://semver.org/">SemVer</a> for Ioto version policy, we provide stability classifications.

APIs stability classifications document the likelihood of future change on a per-API basis. Rather than a general, meaningless backwards compatibility promise, these [Stability Classifications](stability.md) assist developers to understand the future risk of change.
# API Stability Classification

The programming interfaces and data structures are classified with a stability class. These classifications help developers understand which interfaces may change in future releases and may need to be wrapped within their applications.

When the classification is applied to an API, it applies to the complete function signature. When applied to a data structure or typedef, it applies to the structure name and not the internal structure fields. All structure fields are regarded as internal unless explicitly stated otherwise.

The version numbering for EmbedThis products follows the [SemVer](https://semver.org/) scheme. For example 2.1.3 is major version 2, minor version 1 and patch version 3.

| Classification | Description |
|-|-|
| Mature | Must be interoperable across at least two consecutive major releases so that applications are not required to change. These APIs must be deprecated before change or removal. |
| Stable | Will not change between minor releases (e.g. 2.0 to 2.1). May change between major releases. |
| Evolving | May change between major or minor releases. May not change between patch releases (e.g. 2.0.0 to 2.0.1) release. |
| Prototype | May change between any major, minor or patch releases. |
| Deprecated | For use by legacy applications only. Customers are advised that these interfaces may be removed in the next major or minor release. |
| Internal | Internal API or data structure and may change at any time. Customers are strongly advised not to use these APIs. Please notify EmbedThis if you feel compelled to use an internal API and we'll consider providing a better public interface that can be supported. |
# Compatibility

Ioto APIs are evolving, and are thus subject to change between minor releases.

The Ioto documentation provides a [Stability Classification](stability.md) for each API group that reflects their stability with respect to forward changes.

<!--
<a id="r5"></a>
<h2>Migrating from Earlier Releases</h2>
<p>Ioto 4 to 7 are highly compatible. Code written for Ioto 4 to 6 should migrate easily to Ioto 7.
Ioto 4 introduced new build tools, and a garbage collector for memory allocation, so if you are migrating from Ioto 2 or 3, you will have to perform more significant changes to your application, handlers or filters. </p>
-->

## Migrating to from Appweb or GoAhead

The Ioto web server configuration and APIs are simpler and different to those in Appweb or GoAhead. Porting from Appweb or GoAhead is feasible, but not trivial.

### Web Server Action Routines

The Ioto web server action routines are very similar to those in GoAhead and Appweb. So action code written for GoAhead and Appweb and should map easily to Ioto. However, some of the web server utility routines to read and write data are different.

The Ioto portable runtime (R) was adapted from GoAhead 5 and Appweb 8 and so the string, list, hashing and buffering APIs are very similar.

## Standards

Ioto supports the following standards web standards:

* [HTTP/1.1](http://www.w3.org/Protocols/rfc2616/rfc2616.html)
* [File Upload](http://www.ietf.org/rfc/rfc1867.txt)
# Ioto Manual Pages

This Ioto distribution provides manual pages that can be viewed (on Unix-like systems) using the systems **man** command. Text copies of the pages are included below:

| Topic | Description |
|-|-|
| [ioto](../man/ioto.md) | Ioto device agent. |
| [db](../man/db.md) | Database command line tool. |
| [json](../man/json.md) | JSON tool. |
| [url](../man/url.md) | URL HTTP client command line tool. |
| [pass](../man/pass.md) | Password manager. |
# Authentication

Authentication is the process by which a client's identity and capabilities are verified before granting access to server resources. Authentication is essential when you have content that you wish to protect and provide only to specific, approved clients.

The Ioto web server implements a powerful and flexible authentication framework that verifies username and password and controls client capabilities using a role based authorization mechanism.


## Overview

Web authentication has historically used [Basic or Digest](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication) authentication. However these two methods have security and usability flaws and should not be used.

A preferred method is to use a web form to capture the username and password and then transmit them securely using an encrypted TLS connection where the credentials are validated by the web server.

## Access Roles

Once authenticated, users are authorized with a role that defines their capabilities.

In Ioto, access roles are an ordered list of user roles with increasing capabilities. Typical roles are: "user", "admin" or "support".

Authentication roles for the Ioto web server are defined in the **web.json5** configuration file via the **auth.roles** property.

Here is a sample:

```js
{
    auth: {
        roles: ["user", "admin"],
        login: '/api/public/login',
        logout: '/api/public/logout',
    }
}
```

The Ioto web server controls access to resources by assigning a specific "role" on a route that provides access to a document or resource. If the authenticated user has the required role or better, then the user is granted access.

For example:

```js
web: {
    routes: [
        {match: '/api/admin/', role: 'admin'},
        {match: '/api/user/', role: 'user'},
        {match: '/api/'},
        {match: '/admin/', role: 'admin'},
        {match: '/user/', role: 'user'},
        {},
    ],
}
```

Each route specifies a matching URL prefix except for the last route which is a catchall. To restrict access, the route provides a "**role**" property that specifies the required user role to permit access.

## Users and Passwords

Users are defined in the Ioto database together with their hashed and salted passwords and access role. 

User entries are typically created by the device management or admin apps using the cryptMakePassword API. 

However, during development, users may be created in the database via the [dbcmd](../man/db.md) and [pass](../man/pass.md) programs.

To generate a hashed password for a user, use the **pass** program. For example:

```bash
pass --password demo-pass ralph
```

This will print the hashed password for "ralph". 

You can modify the **config/seed.json5** file with the required users and hashed passwords. Then apply this file to the
database using the "reset" make target.

    $ make reset

This will run the command:

    $ dbcmd --reset --load config/seed.json5 --schema modes/$(MODE)/schema.json5 state/state.db


## Verifying Passwords

Authentication schemes define how the user credentials are captured from the user and supplied to Ioto. 
There are two classes of authentication schemes.

* <a href="#form">Web Form Authentication</a>
* <a href="#app">Custom Authentication</a>

<a id="form"></a>

## Form Authentication

The form authentication scheme uses a HTML web form for the user to enter their username and password credentials and a HTTP Post request to submit credentials to the server for verification. Ioto manages the login/logout process and if authentication succeeds, a login session is created and a cookie is returned to the client's browser. Subsequent requests that include the cookie will be automatically authenticated using the session.

### Web Form

Here is a sample minimal example login page:

```html
<html><head><title>login.html</title></head>
<body>
    <p>Please log in</p>
    <form name="details" method="post" action="/api/public/login">
        Username <input type="text" name="username"><br/>
        Password <input type="password" name="password"><br/>
        <input type="submit" name="submit" value="OK">
    </form>
</body>
</html>
```

After the user enters their username and password and clicks OK, the form is posted and the **/api/public/login** URL is requested. This URL should be bound to an Action via **webAddAction** that will verify the password and then call **webLogin**.

You can use the inbuilt **webLoginUser** routine to validate the password against the value stored in the database by
setting the **auth.login** property in the **web.json5** config file.

For example:

```js
    auth: {
        login: '/api/public/login',
        logout: '/api/public/logout',
    },
```

If you require custom user authentication, you can define your own login action and leave the **auth.login** property 
unset. For example:

```c
static int login(Web *web)
{
    cchar *password, *username;

    username = webGetVar(web, "username", 0);
    password = webGetVar(web, "password", 0);

    // Your own custom password checking routine
    if (CheckPassword(username, password)) {
        webLogin(web, username, password);
        webRedirect(web, 302, "/welcome.html");
    } else {
        webRedirect(web, 401, "/login-failed.html");
    }
    return 0;
}
webAddAction(host, "/auth/login", login);
```

The login function will retrieve the username and password entered by the user from the form post data and then 
validate these in the custom CheckPassword function.

**SECURITY CAUTION:** The login request should only be performed over a secure TLS encrypted connection and never over plain "HTTP".

### Route Configuration

To implement the form based authentication, you should ensure the login and log out pages and all required graphics and stylesheets are accessible without authentication.

A typical set of routes for an authenticated web site is:

```js
web: {
    routes: [
        {match: '/api/admin/', role: 'admin'},
        {match: '/api/user/', role: 'user'},
        {match: '/api/'},
        {match: '/admin/', role: 'admin'},
        {match: '/user/', role: 'user'},
        {},
    ],
}
```

Authenticated users can access documents under the **/user** section. Administrators have access to the **/admin** section.  All other documents outside **/user** and **/admin** are public, such as the home page (/index.html), other HTML pages, stylesheets, javascript and images. These can be accessed without authentication. 

The **/api/admin** section is accessible only to administrators and the **/api/user** is accessible to all authenticated users. All other actions under **/api** including the login and logout actions do not require authentication to access.

The **{}** route is used to match all other URLs and does not require authentication.

### Route Table

|URL|Description|Required Role|
|:-|:-|:-|
/index.html | Home page | none
/css/ | Stylesheets | none
/js/ | JavaScripts | none
/images/ | Images | none
/api/admin | Actions requiring an administrator user | user
/api/user | Actions requiring an authenticated user | user
/api | Public actions including Login and logout | none
/admin | Documents visible only to administrative users | admin
/user | Documents visible to authenticated users | user

## Custom Authentication

You can easily create a custom or hybrid authentication scheme. You can choose to pass the username and password to the login action via other means such as an "Authorization" HTTP header or JSON payload. You would then adjust your login() function accordingly.

<a name="api"></a>

## Authentication APIs

See the the following API to manage authentication and authorization under program control.

* [webLogin](../ref/api/web.html#web_8h_1a6d153144eddd26485b974529adf88455)
* [webLogout](../ref/api/web.html#web_8h_1a85313a553af93814d35f794ac9eace84)

## Samples

Ioto provides a sample for user login:

* [Auth Sample](https://github.com/embedthis/ioto-doc/tree/master/samples/web-auth)
# Request Routing

Ioto includes a flexible request routing engine that routes client HTTP requests to appropriate request handlers. An Ioto configuration will typically have several routes. When a request is received, Ioto tests routes in sequence and selects the first matching route to handle the request.

<a id="configuration"></a>

## Route Configuration

Routes are defined in the **web.json5** configuration file.

```js
routes: [
    { match: '/public/' },
    { match: '/auth/' }
    { match: '/members/', role: 'user' }
    { match: '/admin/', role: 'admin' },
    { redirect: '/auth/login' },
],
```

This example defines five routes. Routes can specify a **match** property that defines a matching URL prefix for the route to be used.

## Route Ordering

When multiple routes are defined, a client request will test each route in the order in which they are declared in the routes array.

To process a request, Ioto compares the request URL with the route **match** property prefix. If the URL begins with the **match** property, the route is selected. So ordering is very important.

## Route Matching

A route that terminates with "/" will match any URL that begins with that pattern. If the route does not end with "/" it must match the entire URL path (without query or reference fragment).

The special route match pattern "/" will match only the URL "/". i.e. the site home page.

If the route does not contain a match pattern, all URLs will match. In this case, the route becomes a "catch-all".

Routes with longer or more qualified route **match** properties should be defined first before more general routes.

## Route Authorization

If the selected route contains an authorization **role** property, the user must be logged in and possess the required role specified by the **role** property.

If the user is not logged in, or if the user does not have the requisite ability, the request will not proceed.

In that case, if the route contains a **redirect** property, the request will receive a redirect 302 response toward the URL specified by the **redirect** property. If there is no such property, the request will receive a 401 Not Authorized response.


## Route Patterns

A common pattern for web management applications is to require user authentication for all operations. Such web apps may have two levels of authorization, registered users and administrators.

To support such two-level access control, consider the following route list:

```js
routes: [
    {match: '/api/admin/', role: 'admin'},
    {match: '/api/user/', role: 'user'},
    {match: '/api/'},
    {match: '/admin/', role: 'admin'},
    {match: '/user/', role: 'user'},
    {},
],
```

The following directory and URL structure could then be employed.

* /index.html &mdash; public home page
* /css &mdash; public stylesheets
* /js &mdash; public javascript
* /images &mdash; public images
* /login.html &mdash; login form
* /user &mdash; documents accessible by all authenticated users
* /admin &mdash; documents accessible by administrators only
* /api/admin &mdash; for action routines accessible by administrators
* /api/user &mdash; for action routines accessible by authenticated users
* /api &mdash; public action routines including login and logout actions

The {} route is used to match all other URLs and does not require authentication.
# API Signatures

The Ioto web server supports API access signatures. This feature allows you to verify the authenticity of requests to your API and the integrity of responses to the client.

This greatly improves the security of device agent by ensuring that only valid requests are processed and that important data is not exposed to unauthorized users.

## How it works

The web server can configure an API signature file that specifies the allowed API signatures. This specifies the request, query and response payloads data types and fields. The web server will then verify the signature of the request and response against the allowed signatures.

If a request does not match the allowed signatures, the web server will return a 400 Bad Request error.

## How to use it

The API signature file is a JSON file that specifies the allowed API signatures. The file is typically named `signatures.json5` and is specified via the `signatures` property in the web.json5 configuration file.

```json5
{
    signatures: {
        enable: true,
        path: 'state/config/signatures.json5'
        strict: true,
    }
}
```

The `path` property specifies the path to the API signature file. The `strict` property specifies whether the web server should strictly enforce the API signatures. If a request has unknown fields or missing required fields, the request will be rejected. If `strict` is false, the web server will warn about any requests that do not match the allowed signatures but will still process the request.

Strict mode also request that APIs must have request and response definitions.

## Example Signature File

Here is an example of a signature file:

```json5
{
    user: {
        login: {
            role: 'public',
            request: {
                fields: {
                    username: {type: 'string', required: true},
                    password: {type: 'string', required: true},
                }
            },
            response: {
                fields: {
                    token: {type: 'string', required: true},
                }
            },
        },
        logout: {
            role: 'user',
            request: {
                fields: {
                    token: {type: 'string', required: true},
                }
            },
            response: null,
        }
    }
}
```

## Matching Signature Entries

The signature file is indexed by the URL path after stripping the route matching prefix.

For example, consider the following routes in the `web.json5` configuration file:

```json5
{
    routes: [
        { match: '/auth/', handler: 'action', validate: true },
    ]
}
```

This creates a URL route for requests that start with `/auth/`. The `validate` property instructs the web server to validate the request against the signature file. 

The signature entry is indexed by the URL path after stripping the route matching prefix. If a request `/auth/user/login` was received, the `/auth/` would be stripped and the `user/login` would be used to index the appropriate entry in the signatures file. In this case, the controller name of `user` and the method of `login` would be used.

If you have a URL format that does not match the `controller/method` format, you can use the `webValidateRequest` function. You can invoke this manually from your webRequestHook on the WEB_HOOK_ACTION event. The function takes a search path into the signature file as a parameter. 

For example:

```c
if (!webValidateRequestBody(web, "user.login")) {
    // Failed to validate request body
}
```

Note that the path is in a dot notation format that maps to the signature file.

## Signature File Format

The signature file is in JSON5 format which is a superset of JSON and permits comments, trailing commas, unquoted keys and single quoted, and multiline strings. 

The top-level of a signature file is a set of controllers. Each controller is a JSON5 object that contains the method signatures for the controller.

There is a special method named `_meta` that contains metadata about the controller itself.

The methods blocks contain `request`, `response` and `request.query` blocks.

* The `request` block contains the request payload data types and fields.
* The `response` block contains the response payload data types and fields.
* The `request.query` block contains the request query parameters data types and fields.

A block can be set to a data type or a collection of properties. For example:

```json5
request: null,
request: 'string',
request: {
    type: 'array',
    ...
}
```

Supported types are: `object`, `array`, `string`, `date`, `number`, `boolean` or `null`. If the type is `object`, the block may contain a `fields` property that specifies the object fields. If the type is `array`, the block contains an `of` property that specifies the type of the array items. The `of` property is an object that contains sub-fields (or arrays). These can be nested to arbitrary depth.

The `fields` property contains zero or more field definitions where the field key is the name of the field. A special key of `*` can be used to specify that all fields not otherwise specified are allowed.


## Field Definitions

Field definitions can define the following properties:

- `default`: A default value to use for the field if not specified.
- `drop`: If true, the field is not included and is dropped.
- `fields`: Definition for a nested object.
- `of`: Definition for a nested array.
- `notes`: A markdown description of the field.
- `required`: If true, the field is required.
- `role`: The role required to access the field.
- `type`: The type of the field.
- `validate`: A regular expression to validate the field value.

### Drop Properties

It is useful to drop fields that should not be disclosed in the response. This can be done by setting the `drop` property to `true`. You can also set the drop property to a string that specifies the role required to retain the field. For example:

```json5
{
    fields: {
        password: {type: 'string', drop: true},
        balance: {type: 'string', drop: 'user'},
    }
}
```

So that drop fields can be specified in database schema, the following format is also supported:

```json5
{
    fields: {
        password: {type: 'string', drop: {
            request: 'admin',
            response: true,
        }},
    }
}
```

This will drop the `password` field for requests with roles less than admin and for all responses.

### Examples

#### Wildcard Field

```json5
{
    response: {
        type: 'object',
        fields: {
            name: {type: 'string', required: true},
            password: {type: 'string', drop: true},
            // Wildcard field that allows all other fields
            '*': {},
        },
    }
}
```

#### Primitive String Request/Response

```json5
{
    test: {
        request: { type: 'string' },
        response: { type: 'string' }
    }
}
```

#### Required Fields

```json5
{
    test: {
        //  Test request, response fields and required and drop
        request: {
            type: 'object',
            fields: {
                email: {type: 'string', required: true},
                name: {type: 'string'},
            }
        },
        response: 'object'
    }
}
```

#### Array of Objects

```json5
{
    test: {
        request: {
            type: 'object',
            fields: {
                users: {type: 'array', of: {
                    type: 'object',
                    fields: {
                        email: {type: 'string', required: true},
                        name: {type: 'string'},
                    }
                }},
            }
        },
        response: 'object',
    }
}
```

#### Default Values

```json5
{
    test: {
        request: {
            fields: {
                color: {type: 'string', default: 'red'}
            }
        }
        // No response signature allows all fields
    }
}
```

#### Nested Objects

```json5
{
    test: {
        request: {
            fields: {
                name: {type: 'string'},
                address: {type: 'object', fields: {
                    street: {type: 'string'},
                    zip: {type: 'string'},
                }},
            }
        },
        response: 'object'
    }
}
```# Dynamic Web Content

The Ioto embedded web server can serve static files and can also render dynamically generated responses.

Dynamic content is generated via the Action handler that binds specific URLs to corresponding C functions. The action handler is ideal for situations when you want to generate a dynamic response using C code.

Previously, earlier web servers used the [CGI](https://www.embedthis.com/blog/stories/stop-using-cgi/stop-using-cgi.html) and web frameworks like [PHP](https://www.php.net/) or [ESP](https://www.embedthis.com/esp/) to generate dynamic content. But these solutions are a poor fit for modern management applications that use [SPA](https://en.wikipedia.org/wiki/Single-page_application) techniques. They also consume considerable CPU and memory resources and are not the best approach for embedded devices. Further, they expose large attack surfaces due to excess features that are not essential.

Ioto uses a more efficient direct binding from URLs to C functions coupled with a flexible streaming, non-blocking API. When coupled with a JSON parser and query engine, a dramatically simpler and more efficient solution emerges.

## Registering Actions

Action routines are registered by calling [webAddAction](/agent/ref/api/web.md#group___web_1gaad50b8cbf88372dc6cdd7d08050b8de4). This API takes a function to run and a corresponding URI prefix.

```C
static void hello(Web *web)
{
    webWrite(web, "Hello World\n", -1);

    //  Signal end of output
    webWrite(web, NULL, 0);
}

//  Register the action
webAddAction(host, "/action/hello", hello);
```

The **webAddAction** call registers the hello C function to be invoked whenever the request URL begins with the string "/action/hello". By using a string prefix, you can have a single action match an entire set of URLs that being with a given URL prefix.

An action routine is responsible for rendering a complete response to the client. If your action routine needs to wait for I/O or block while reading required data from another service, read [Blocking](#blocking) below.

## Streaming Data

Ioto supports full-duplex streaming.

Clients can stream body data to the web server and the server can stream response data back to the client. Ioto supports full-duplex streaming via non-blocking, fiber enabled APIs.

The **webRead** routine is used to read body data from the client. The webRead call has the following signature:

    ssize webRead(Web *web, char *buf, ssize bufsize);

The webRead function will read data from the client and return the number of bytes read. The routine will block if required until data is available. Other fibers continue to run while blocked. The function returns zero when the end of the body data is received.

The **webWrite** routine is used to write data back to the client. The webWrite call uses the following signature:

    ssize webWrite (Web *web, cvoid *buf, ssize bufsize)

The **bufsize** argument is set to the length of data to write. It can be set to -1 if the data to write is a null terminated string and the length of the string will be determined by strlen.

The **web** parameter is passed to the action routine as its only argument.

A response to the client is concluded by calling [WebWrite](/agent/ref/api/web.md#group___web_1ga9bb3b0c8b44804e8cc329ca946c39aaa) with a NULL buffer or data length of zero. This signifies the end of the response.

Ioto uses [Transfer-Encoding](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding) by default for dynamically written data, so you don't need to define a response [Content-Length](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding). Each write will be wrapped in a transfer chunk.

## Web Forms

Web forms requests are a special case. They use POST requests with url encoded body data. Ioto will read and buffer form data and parse into form variables before invoking the appropriate Action routine. The action can then retrieve via the **webGetVar** API.

## Writing Headers

Ioto will automatically write the HTTP response headers when you first call **webWrite** in your action routine. However, you can call [webWriteHeaders](/agent/ref/api/web.md#group___web_1ga24c1f17628b8b1c854a378e0b47bcb89) to customize the HTTP headers. For example:

```c
static void hello(Web *web)
{
    cchar   *msg;

    msg = "Hello World\n";

    webWriteHeaders(web, "Content-Length: %d\r\n", slen(msg));

    webWrite(web, msg, -1);
    webWrite(web, NULL, 0);
}
```

The **webWriteHeaders** routine accepts one or more headers, each of which is terminated by "\r\n". It is essential that you use "\r\n" and not just a single new line character after each header.

Ioto will blend your supplied headers with other essential headers such as Date, Connection, Content-Length, Content-Type and Transfer-Encoding.

You can only issue one call to **webWriteHeaders, subsequent calls for a given request will be ignored.

## Status Code

HTTP responses always contain a [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status). This is set to 200 for successful requests, 301/302 for redirections, 4XX for client errors, etc.

By default, Ioto responds with a 200 successful HTTP status. You can set the status code via the [webSetStatus](/agent/ref/api/web.md#group___web_1ga12ab5a43c00f2a54c787d653af51430a) or
via **webWriteResponse**.

```c
static void failure(Web *web)
{
    cchar   *msg;

    webSetStatus(web, 404);
    webWrite(web, "Cannot find requested resource\n", -1);
    webWrite(web, NULL, 0);
}
```

## Reading Body Data

Ioto supports streaming request data via the [webRead](/agent/ref/api/web.md#group___web_1gab6843af41aa5abdaec4062d4a5f46a8b) API. For example:

```c
static void readStream(Web *web)
{
    char  buf[ME_BUFSIZE];
    ssize nbytes;

    while ((nbytes = webRead(web, buf, sizeof(buf))) > 0) {
        printf("Got %ld bytes\n", nbyte);
        //  Process buffer here
    }
    return webWriteResponse(web, 200, "Request processed");
}
```

The **webRead** routine will read body data and return the number of bytes read. It will return 0 when all the body data has been read. This routine supports requests with an explicit known Content-Length and those requests with indeterminate body lengths that use transfer encoding.

The **webRead** routine will block the current fiber if necessary to wait for more body data. Other fibers continue to run.

## Blocking

Because Ioto uses fiber coroutines, you can wait for I/O inside an action routine provided you are using the fiber-safe blocking routines provided by Ioto. Don't call Posix "sleep" as that can block the entire Ioto process.

If you need to wait for data from an external API or service, you have two options:

1. Create a thread to wait for the data and then call [rYieldFiber](/agent/ref/api/r.md#r_8h_1a531c892493b60bb2088705d7f4e447cb) in your action routine. When the thread has the required data, call [rResumefiber](/agent/ref/api/r.md#r_8h_1a059333256cfab39b5037149625e1133b) from the thread to resume the fiber.

2. Use the [Ioto R Portable Runtime](../runtime/) non-blocking socket I/O routines such as [rReadSocket](/agent/ref/api/r.md#r_8h_1a5e68016e4b9381eb07d94855361e4a6d) and [rWriteSocket](/agent/ref/api/r.md#r_8h_1a59d42a597c69a42387f41d62f0e8c5b2).

Note: that the Ioto request and inactivity timeouts in ioto.conf may terminate a long running request. If you need to extend these timeouts for a request, call
<a href="/doc/agent/ref/api/web.html#group___web_1gaa1b625ec1407586d184636914f284dfe">webExtendTimeout</a>.
# Configuring TLS

Ioto supports the TLS / SSL protocol for authenticating systems and encrypting data. Use of this protocol enables secure data transmission to and from clients in a standards-based manner.

This document provides step-by-step instructions for configuring TLS in the Ioto web server. If you are unfamiliar with TLS, please read the **[TLS Overview](./tlsOverview.md)** first.

## TLS Quick Start

The default source build of Ioto will support TLS for use by the Ioto web server. You can immediately test TLS access to documents by using the <b>https://</b> scheme. For example, to access the home page using TLS, use this URL in your browser:

    https://localhost/

<a name="tlsProviders"></a>
## TLS Providers

Ioto employs an open architecture TLS Provider interface so that customers can select or create an TLS provider for their needs.

Ioto provides multiple TLS implementations:

* OpenSSL -- default TLS. See <a href="http://www.openssl.org">http://www.openssl.org</a>.
* MbedTLS -- compact TLS (smaller but slower).

The default source build will use the OpenSSL provider by default. See the README.md file for details about how to build with MbedTLS.

<a id="sslConfigurationDirectives"></a>
## SSL Configuration Directives

Ioto uses several configuration [TLS properties](./properties.md#tls) to control TLS and manage secure access to the web server.

The relevant TLS properties are:

* [tls.certificate](./properties.md#certificate)
* [tls.key](./properties.md#key)

There are some additional properties that are necessary should you wish to have Ioto verify client
certificates. These :

* [tls.authority](./properties.md#tls.authority)
* [tls.verify.*](./properties.md#tls.verify)

<a id="sslConfigurationExample"></a>

## TLS Configuration Example

Consider the default Ioto TLS configuration in the web.json5 configuration file:

```js
web: {
    listen: [ "https://:443" ]
},
redirect: [
    { status: 302, to: "https://" },
},
tls: {
    certificate: "server.crt",
    key: "server.key",
    verify: {
        issuer: true
    }
}
```

This set of properties enables TLS on port 443 for all network interfaces and uses the default supplied self-signed certificate to identify the server.

The **listen** property instructs Ioto to process requests from all interfaces on port 443 using TLS.

The **certificate** property specifies the server certificate to use and the **key** property specifies the server private key for signing.

<b>SECURITY WARNING</b>: You must obtain or generate a SSL certificate before using this example in a production environment.

The server key file is a PEM encoded private key. You may supply either an encrypted private key or a
decrypted private key. If you use an encrypted private key, the server will prompt you for a pass-phrase to
decrypt the key when the server boots.

## Self-Signed Certificate

Ioto is shipped with a self-signed certificate to identify the web server.

<b>SECURITY WARNING</b>: This certificate is suitable for testing purposes only and your browser will issue a warning when you access the server. For production use, you should obtain your own service certificate from signing authorities such as <a href="http://www.verisign.com">Verisign</a>.

<a id="generatingKeys"></a>

## Generating Keys and Certificates

To generate a request file that you can send to a certificate issuing authority such as <a href= "http://www.verisign.com">Verisign</a>, use the following openssl command or equivalent command from your TLS provider:

```bash
openssl genrsa -des3 -out server.key 1024
openssl req -new -key server.key -out server.csr
```

This will generate a server key in the file "server.key" and will generate a certificate request in the file "server.csr" that you can send to the issuing authority. The issuing authority will generate a server certificate for your server and they will sign it with their private key. Subsequently, clients will be able to use the signing authorities public key to decrypt your server certificate and thus verify the identity of your server when negotiating a SSL session. When running these commands, you will be prompted to enter a pass-phrase password to decrypt the server private key. REMEMBER this password.

<b>SECURITY WARNING</b>: Safeguard the "server.key" private key jealously. If this falls into malicious
hands, then your server identity may be hijacked by another site.
# Web Properties

When Ioto starts, the contents of the **web.json5** configuration are blended with the **ioto.json5** and made available via the **ioto->config** in-memory JSON tree.

## documents

| Name | documents |
|-|-|
| Description | Directory containing the static file documents to be published for context. |
| Synopsis | `documents: "directoryPath"` |
| Notes | The documents property defines the directory containing the documents that will be served. All routes share the same documents directory. The directoryPath should not have a trailing slash.|

**Example**

```js
documents: "/var/www"
```

## headers

| Name | headers |
|-|-|
| Description | Define HTTP headers to add to the client response.|
| Synopsis | `headers: { "Header-Key": "Header-Value", ... }` |
| Notes | The **headers** property defines one or more HTTP headers that are added to the client response. You should only define unique headers that are not already added by action routines or by the Ioto web server core. Otherwise, your response will have duplicate headers. |

**Example**

```js
headers: {
    "Content-Security-Policy":   "default-src 'self'",
    "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
    "CrossOrigin":               "origin=* credentials=yes headers=X-CORS-HEADER age=3000",
}
```

## index

| Name | index |
|-|-|
| Description | Define the default index file to serve for directory requests. |
| Synopsis | `index: "filename"` |
| Notes | The index property specifies a document to be served when a HTTP request is made for a directory. <br><br>If a client requests a directory, but without a trailing "/" in the URI, the client will be redirected to the URI with a trailing "/". When the client then uses that URI, the directory index file will be used for the response.<br> <br>For example: if an index of "index.html" is specified and a user requests http://www.acme.com/products/, then the document /products/index.html will be returned to the user. |

**Example**

```js
index: "index.html"
```

## limits

The Ioto web server supports configuration properties that improve security by limiting the size and scale of incoming requests. This technique is know as "sandboxing" because it creates a limited or safer area in which Ioto executes.

| Name | limits |
|-|-|
| Description | Collection of limit properties |
| Synopsis | `limits: { "Limit-Property": "Limit-Value", ...}` |
| Notes | All limit values may be numbers or human-readable strings with unit suffixes. The unit suffixes can be upper or lower case. The supported units are: unlimited, infinite, kb, k, mb, m, gb, g, byte and bytes. Ioto has sensible defaults for these limits if not explicitly specified. |

**Example**

```js
limits: {
    body: "100K",
    connections: "100",
    header: "10K",
    sessions: "20",
    upload: "20MB",
},
```


## limits.body

| Name | limits.body |
|-|-|
| Description | Sets the maximum size of the request body in POST and PUT requests. |
| Synopsis | `body: "max-size"` |
| Notes | The body limit defines a maximum size for a POST request body data. For embedded applications, it is useful to limit the request body to the expected maximum. This ensures that rogue or malicious requests will not cause the server to allocate unwanted memory to servicing the request. The default limit is 100K. |

**Example**

```
body: "100K"
```


## limits.connections

| Name | limits.connections |
|-|-|
| Description | Defines the maximum number of simultaneous client connections. |
| Synopsis | `connections: "value"` |
| Notes | The connections limit defines the maximum number of simultaneous client connections to the server. Connections in excess of this count will be rejected. Set to "unlimited" for no limit. This property counts the number of client socket connections. A single browser may open many separate connections (typically up to 6). |

**Examples**

```js
connections: "100"
```

## limits.header

| Name | limits.header |
|-|-|
| Description | Sets the maximum header size of a request. |
| Synopsis | `header: "max-size"` |
| Notes | The header limit defines a maximum size for the request headers. For embedded applications, it is useful to limit the maximum headers size to ensure that rogue or malicious requests will not cause the agent to allocate unwanted memory for servicing the request. The default limit is 10K. |
| Security | This property can be quite useful in certain denial-of-service attacks where the attacker sends large documents of a certain type. |

**Example**

```js
header: "32K"
```


## limits.sessions

| Name | limits.sessions |
|-|-|
| Description | Sets the maximum number of active client sessions |
| Synopsis | `sessions: "max-sessions"` |
| Notes | The sessions limit property defines the maximum number of active client sessions that utilize server-side session state storage. Requests in excess of this count will be rejected. Set to "unlimited" for no limit. This property limits the number of client sessions, whereas the "connections" limit will limit the number of simultaneously connected client systems. NOTE: that many browsers can and will initiate multiple requests when requesting a page. These will share the same session state storage. |

**Examples**

```js
sessions: "40"
```

## limits.upload

| Name | limits.upload |
|-|-|
| Description | Maximum size of an uploaded file.|
| Synopsis | `upload: "max-size"` |
| Notes | The upload limit defines the maximum size of an uploaded file. In embedded applications, it is useful to limit the maximum file upload size to ensure that rogue or malicious requests will not cause the server to allocate unwanted space for uploads. Set to "unlimited" for no limit. If a file larger than the limit is uploaded, Ioto will reject the request and the client will receive an error. The default value is unlimited. |
| Security | This directive can be quite useful in certain denial-of-service attacks where the attacker sends requests with bogus URLs. |

**Example**

```js
upload: "20MB"
```

## listen

| Name | listen |
|-|-|
| Description | IP addresses and ports on which to listing for incoming requests.<
| Synopsis | `listen: [ "http(s)://[IP address:]portNumber", ...]` |
| Notes | The Listen directive specifies the IP endpoints on which Ioto will listen for incoming HTTP requests. If you specify only the port number and omit the IP address, Ioto will listen on all network interfaces including the loop-back adaptor. It will listen on both IPv4 and IPv6 if only a portNumber is specified. >To listen on IPv6 endpoints, enclose the IP address in square brackets. For example: Listen [2001:05c0:9168:0000:0000:0000:0000:0001]. To listen on IPv4 endpoints, supply an IPv4 IP address. You may use 0.0.0.0 to listen on all IPv4 interfaces. To listen for TLS requests, use a "https://" prefix. |



**Example**

```js
listen: [
    "http://:80",
    "https://:443",
]
```


## mime

| Name | mime |
|-|-|
| Description | Mime map to map document extensions to mime types. |
| Synopsis | `mime: { "ext": "mime-type", ...}` |
| Notes | The mime property defines additional mime types to be added to the Ioto mime type table. Mime type properties are indexed by the document file extension with the value of each key set to the corresponding mime type. |

**Example**

```js
mime: {
    ".html": "text/html",
    ".ico": "image/vnd.microsoft.icon",
}
```


## name

| Name | name |
|-|-|
| Description | Define the public hostname by which the server is known |
| Synopsis | `name: "hostname.com"` |
| Notes: | The name property specifies the preferred, public, fully qualified hostname for the server. If specified, this address will be used when constructing URLs and redirections. The given hostname should be a fully qualified domain name with port number if using a port other than the default port. If a name is not defined, a value will be determined from the listening endpoint that accepted the connection. |

**Example**

```js
name: "www.acme.com"
```


## redirect

| Name | redirect |
|-|-|
| Description | Redirect requests to a new target. |
| Synopsis | `redirect: [ { status: code, from: "URL", to: "URL" }, ... ]` |
| Notes | The redirect property maps requests from one URL to a new URL. <br><br>The status argument may be either 301 for a permanent redirect or 302 for a temporary redirect. The default is 302.<br><br>The **from** property defines a URL portion that must match for the redirect. If the **from** property is omitted, it will match all URLs.<br><br>The **to** URL defines a URL portion that will be combined with the existing URL. The **to** URL may be local to the system, in which case it will begin with a "/" character, or it may be on another system, in which case it will begin with "http://" or "https://". In both cases, the user will receive a HTTP redirection response informing them of the new location of the document. <br><br>The **from** and **to** URLs are of the form:<br><br>[http\|https]\[://][hostname][:port][/path][?query][#hash]. <br><br>Any of the URL components may be present or absent. For example, if only a path is supplied for the **to**, then the client will be redirected to the new path on the current site. |


**Example**

```js
redirect: [
    { status: 302, from: "example.com", to: "new-example.com" },
    { status: 302, from: "http://example.com:80", to: "https://example.com:443" },
    { status: 302, from: "http://example.com", to: "https://new-example.com" },
    { status: 302, from: ":443", to: "https://:4443" },
    { status: 301, from: "/old", to: "/new.html" },
],
```

## route

The Ioto web server responds to requests by selecting a matching request route that describes the processing for the request.

| Name | route |
|-|-|
| Description | Define a configuration to apply to a set of URLs. |
| Synopsis | `routes: [ match: "url-prefix", role: 'ability', ... ]` |
| Notes | The routes property specifies an ordered set of routes that defines the required request properties for the request to be accepted.<br><br>A route entry has a <b>match</b> property that defines the URL prefix that must match for the route to be used.<br><br>The <b>handler</b> property defines the handler to process the request. Valid handlers include 'file' and 'action'. The optional <b>methods</b> property specifies the valid HTTP methods for the route. If absent, the GET and POST methods are supported. <br><br>The optional "<b>role</b>" property defines a role that the user must possess for the route to be used. If the "<b>role</b>" property is absent, all users will match. If specified, the user must be authenticated first to determine their abilities.<br><br>If the route matches, but the user fails to be authorized, the "<b>redirect</b>" property will be used to redirect the user to the given URL.The optional <b>xsrf</b> property specifies whether to use XSRF tokens for the route. If absent, the XSRF tokens are not used.<br><br>Ioto tests routes in order and the first matching route is used. If no routes match, the client request is rejected with a 401 status code.|

**Example**

```js
routes: [
    { match: '/public/', handler: 'file' },
    { match: '/auth/', handler: 'action' }
    { match: '/members/', role: 'user', handler: 'action' }
    { match: '/admin/', role: 'admin', handler: 'action' },
    { match: '', handler: 'file', methods: ['GET'] },
],
```


## route[].handler

| Name | route[].handler |
|-|-|
| Description | Define the handler to process the request. |
| Synopsis | `handler: 'action'` |
| Notes | The handler property defines the routine to process the request. There are two builtin handlers: 'file' and 'action'. The file handler serves static files from the file system (like /index.html). The action handler invokes registered action routines that are bound to a specific URL. |

**Example**

```js
routes: [
    { match: '/public/', handler: 'file' },
    { match: '/ai/chat/', handler: 'action', methods: ['GET', 'POST'] },
    { /* Match all */, role: 'guest' }
],
```

## route[].match

| Name | route[].match |
|-|-|
| Description | Define the matching URL to accept the request. |
| Synopsis | `match: '/path'` |
| Notes | The match property defines the URL for the request to be accepted.<br><br>The match defines an exact URL match unless it terminates in a "/" in which case it defines the leading URL prefix. For example, a match of "/directory/" will match all requests that begin with "/directory/", and a match of "/file" will only match URLs equal to "/file".<br><br>An empty match or missing match property will cause the route to match all requests. This is useful as a catch-all route.|

**Example**

```js
routes: [
    { match: '/public/' },
    { match: '/private.html', role: 'admin' }
    { match: '/members/', role: 'user' }
    { match: '/admin/', role: 'admin' },
    { /* Match all */, role: 'guest' }
],
```


## route[].methods

| Name | route[].methods |
|-|-|
| Description | Array of supported HTTP method verbs. |
| Synopsis | `methods: [ 'GET', 'POST' ]` |
| Notes | The methods property defines the set of supported HTTP method verbs for the request to match the route. Any HTTP verb can be specified, however, different request handlers and action routines may only support specific methods. Common HTTP method verbse are: DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT and TRACE. <br><br>If the methods property is absent, the default method set of ['GET', 'POST'] is enabled. <br><br>WARNING: be careful enabling OPTIONS and TRACE as they have known adverse security implications.<br><br>The trim property can be useful to remove a leading portion of the request path. |

**Example**

```js
routes: [
    { match: '/trace/', methods: ['OPTIONS', 'TRACE'], trim: '/trace' },
],
```

## route[].redirect

| Name | route[].redirect |
|-|-|
| Description | Redirect matching requests that fail authentication |
| Synopsis | `redirect: '/auth/login' ]` |
| Notes | If the route matches, but the user fails to be authorized, the "<b>redirect</b>" property will be used to redirect the user to the given URL.|

**Example**

```js
routes: [
    { redirect: '/auth/login' }
],
```

## route[].role

| Name | route[].role |
|-|-|
| Description | Required authentication role |
| Synopsis | `role: 'user' ]` |
| Notes | The optional "<b>role</b>" property defines a role that the user must possess for the route to be used. If the "<b>role</b>" property is absent, all users will match. If specified, the user must be authenticated first to determine their abilities.<br><br>If the route matches, but the user fails to be authorized, the "<b>redirect</b>" property will be used to redirect the user to the given URL.<br><br>Call `webLogin` after authenticating the user's credentials to login the user and define the user's role. |

**Example**

```js
routes: [
    { match: '/public/' },
    { match: '/private.html', role: 'admin' }
    { match: '/members/', role: 'user' }
    { match: '/admin/', role: 'admin' },
],
```

## route[].trim

| Name | route[].trim |
|-|-|
| Description | Trim a leading portion from the request URL |
| Synopsis | `trim: '/prefix' ]` |
| Notes | The optional "<b>trim</b>" property defines a leading path segment that will be trimmed from the path before processing the request. This can be useful to define different URL spaces that require different user authentication or processing.|

**Example**

```js
routes: [
    { match: '/trace/', methods: ['OPTIONS', 'TRACE'], trim: '/trace' },
],
```

## route[].xsrf

| Name | route[].xsrf |
|-|-|
| Description | Specifies whether to use XSRF tokens for the route. |
| Synopsis | `xsrf: true | false ]` |

**Example**

```js
routes: [
    { match: '/forms/', handler: 'file', xsrf: true },
    { match: '/forms/', handler: 'action', xsrf: true },
],
```

## sessions

The Ioto web server supports server-side state sessions that are indexed by a session cookie. Ioto manages the creation of the session cookie and the management of sessions. APIs to get and set values in session state are provided.

The session cookie name is **-web-session-**. You can modify this when building by defining WEB_SESSION_COOKIE to be the cookie name of your choice.

Sessions are created on-demand when a value is stored in the session state. See the `limits.sessions` and `timeouts.sessions` for to configure the number of sessions and the session timeout.

| Name | session |
|-|-|
| Description | Collection of session properties. |
| Synopsis | `sessions: { "Sessions-Property": "Session-Value", ...}` |

**Example**

```js
sessions: {
    cookie: "-web-cookie-",
    httpOnly: true,
    sameSite: "lax",
},
```


## session.cookie

| Name | session.cookie |
|-|-|
| Description | Controls the name of the session state cookie.|
| Synopsis | `enable: true|false` |

**Example**

```js
cookie: 'my-session-cookie'
```

## session.sameSite

| Name | session.sameSite |
|-|-|
| Description | Sets the sameSite property in the cookie. |
| Synopsis | `sameSite: "Lax|None|Strict"` |
| Notes | The sameSite property defines the Set-Cookie HTTP header SameSite field. It may be set to "Lax" (the default), "None" or Strict.<br><br>See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite">MDN Set-Cookie SameSite</a> for more information. |
| Security | This property is used to effectively defend against CSRF attacks. |

**Example**

```js
sameSite: "Lax"
```

## timeouts

The Ioto web server supports timeout properties that improve security by limiting the duration of requests. These timeouts are blended with the timeouts provided via the [ioto.json5 timeouts](../user/properties.md#timeouts) configuration.

| Name | timeouts |
|-|-|
| Description | Collection of timeout properties. |
| Synopsis | `timeouts: { "Timeout-Property": "Timeout-Value", ...}` |
| Notes | All timeout values are strings, not numbers.<br><br>The string values may take human-readable suffixes which indicate the units for the value. The suffixes can be upper or lower case. The supported units are: infinite, never, sec, secs, seconds, min, mins, minute, minutes, hr, hrs, hour, hours, day, days, week, weeks, month, months, year, years.<br><br>Ioto has sensible defaults for these timeouts if not explicitly specified.|

**Example**
```js
timeouts: {
    parse: "10 secs",
    inactivity: "300 secs",
    request: "10 mins",
    session: "30 mins",
    tls: "1 day",
}
```

## timeouts.inactivity

| Name | timeouts.inactivity |
|-|-|
| Description | Defines the maximum duration of no I/O activity before the request will be terminated. |
| Synopsis | `inactivity: "duration"` |
| Notes | The inactivity timeout will be triggered if there is no read or write activity on the network connection to the client over the specified timeout period. |

**Example**

```js
inactivity: "30 secs"
```

## timeouts.parse

| Name | timeouts.parse |
|-|-|
| Description | Defines the maximum duration for parsing the request HTTP headers |
| Synopsis | `parse: "duration"` |
| Notes | The parse timeout will be triggered if Ioto cannot read and parse the HTTP headers over the specified timeout period.<br><br>It is a security attack vector to open a connection to a web server and then be very slow, or stall writing the HTTP headers. This consumes a network connection and can lead to a denial of service. Setting the parse timeout to be short will limit this attack. |

**Example**

```js
parse: "15 secs"
```


## timeouts.request

| Name | timeouts.request |
|-|-|
| Description | Defines the maximum duration for a request. |
| Synopsis | `request: "duration"` |
| Notes | The request timeout will be triggered if the request cannot be completed inside the specified timeout period.<br><br>It is good practice to set a request timeout to the maximum duration you expect the longest request to take. |


**Example**

```js
request: "2mins"
```


## timeouts.session

| Name | timeouts.session |
|-|-|
| Description | Defines the maximum duration of session inactivity for preserving session state. |
| Synopsis | `session: "duration"` |
| Notes | Session state will be preserved for up to the session timeout. When a client accesses or updates the session state, the timeout is restarted. |

**Example**

```js
session: "1hr"
```



## upload

| Name | upload |
|-|-|
| Description | Collection of Upload properties. |
| Synopsis | `upload: { "Upload-Property": "Upload-Value", ... }` |
| Notes | The Upload properties control requests that use multi-part mime file upload. They control where the files are placed and how long the files are retained. |


**Example**

```js
upload: {
    dir: '/tmp',
    remove: true,
}
```

## upload.dir

| Name | upload.dir |
|-|-|
| Description | Defines the directory to receive uploaded files. |
| Synopsis | `dir: "path"` |
| Notes | The directory to hold uploaded files should be outside the site "documents" directory.|

**Example**

```js
dir: "./tmp/uploads"
```

## upload.remove

| Name | upload.remove |
|-|-|
| Description | Defines whether the uploaded files should be preserved after the request completes.|
| Synopsis | `remove: true | false` |
| Notes | The <b>remove</b> property defines whether the uploaded file is removed when the request completes. By default, an action routine that receives the upload file request should process the file before completing. Then Ioto will observe this property to determine if the file should be removed.|
| Security | It is a denial-of-service risk to keep uploaded files in the upload directory after the receiving action routine completes. If the files are not immediately removed, attackers can upload more and more data and exhaust the capacity of the server. |

**Example**

```js
remove: true
```

## webSockets

| Name | websockets |
|-|-|
| Description | Defines configuration for the WebSockets protocol.|
| Synopsis | `websockets: {ping: '60sec', validateUTF: false}` |
| Notes | The <b>ping</b> property defines the frequency of sending `ping` keep alive messages. The protocol property defines the WebSocket sub-protocol to use. The validateUTF property enables or disables validation of UTF messages. |

**Example**

```js
webSockets: {
    ping: 'never',
    protocol: 'chat',
    validateUTF: false,
},
```
# Web Server 

The Ioto web server is a fast, compact web server designed for management web applications and serving device data.

Ioto can be configured to support the web server as an additional component or Ioto can be build to run only the web server and thus be a first-class replacement for any embedded web server. Embedthis has been developing embedded web servers for many years and the Ioto web server contains all that we have learned over this period.

The Ioto web server is unlike other enterprise or embedded web servers. It does not attempt to offer ALL HTTP features and functions. Rather, it aims to implement only the required core of HTTP/1.1 and thus deliver a tiny, fast, secure embedded web server that is exceptionally good at serving single page web applications and device data APIs.

The Ioto web server supports a cohesive feature set including: HTTP/1, HTTP/1.1, TLS/SSL, WebSockets, SSE, Action routines, user authentication, sessions, cookie management, request logging, and security sandboxing. Yet Ioto remains very small from 80K code and will run in as little as 200K RAM. It will serve over 3,000 requests/sec on a modest Raspberry PI.

<img class="fit" src="/images/ioto/web-server.png" alt="web server" />

## Goals

Our target use-cases for the Ioto web server were:

* Support device management applications that use [Single-Page Application](https://en.wikipedia.org/wiki/Single-page_application) techniques.
* Support device APIs using [REST APIs](https://www.redhat.com/en/topics/api/what-is-a-rest-api)

Our goals are:

* Be as compact as possible
* Enhance security by minimizing the code and feature footprint
* Provide a simple, intuitive API for web applications

## Features

The core web services include:

* HTTP/1.1 protocol engine
* TLS 1.3 support
* WebSockets
* Server-Sent Events (SSE)
* Non-blocking socket communications
* Multiple listen endpoints
* Flexible configuration via a web.json5 file
* Request routing with access control
* Binding URLs to C functions for dynamic content rendering
* Serve static files
* Configurable redirections
* Transfer encoding filter
* Session and cookie management
* Cross-site request forgery (CSRF) protection
* Authentication and User management
* File upload
* JSON parser and query engine
* Sandbox limits and timeouts

### Core Components

The Ioto web server components are:

|Component|Description|
|-|-|
| Safe Portable Runtime | Cross-platform, multi-threaded portable runtime. Includes services for memory allocation, dynamic module loading, safe string handling, lists, hashing, command execution, socket communications, threads, thread synchronization, thread-pool, events, timers, debug trace and logging.|
| Transport Security Layer (TLS) | TLS protocol stack. This is a virtual interface that can selectively support a variety of TLS providers including: the MbedTLS and OpenSSL stacks. |
| HTTP/1.1 | HTTP/1.1 HTTP protocol with keep-alive support. |
| WebSockets | WebSockets protocol. |
| SSE | Server-Sent Events (SSE) protocol. |
| Request Router | Request routing with user authentication and access control. |
| Redirections | Configurable redirections to TLS or new URL targets. |
| Dynamic Actions | Render dynamic content with Actions that bind URLs to C functions. |
| Static File Handler | The static File handler serves static content such as HTML pages, images and PDF files. |
| Upload Filter | The upload filter supports multipart mime file upload. |
| Authentication and User Management | Configurable user and password management. Control access to specific parts of the site. |
| Cookie and Session Management | Automatic session creation and cookie management. |
| Transfer Encoding Filter | The Chunk applies Transfer Chunk Encoding to outgoing data. Chunk encoding enables the HTTP connection to be reused for subsequent requests without having to establish a new TCP/IP connection. This can significantly improve network and application performance. |
| Logging | Configurable request and response tracing including HTTP headers. |


## Ioto Quick Tour

The web server uses a **web.json5** JSON/5 configuration file that specifies what ports and addresses to listen on, where to find the web pages, and how to route requests. This file is read when Ioto starts.

The Ioto web server is enabled via the ioto.json5 file. Set the **services.web** property to true.

```js
{
    services: {
        web: true
    }
}
```

The web server configuration is controlled via the **web.json5** file. Here is a simple example web configuration file:

```js
{
    web: {
        documents: "./site",
        listen: [
            "http://:80",
            "https://:443",
        ],
        tls: {
            certificate: "server.crt",
            key: "server.key",
        },
        redirect: [
            { status: 302, from: "http://:80", to: "https://:443" }
        ],
        routes: [
            { match: '/' },
            { match: '/index.html' },
            { match: '/public/' },
            { match: '/admin/', role: 'admin' },
            { match: '/upload/', methods: ['DELETE', 'GET', 'POST'] },
            { match: '/status/', stream: true },
            { match: '/unused/', redirect: '/auth/login' },
            { match: '/websockets/', methods: ['GET'], handler: 'action'},
            { redirect: '/auth/login' },
        ],
    }
}
```

The **documents** directory specifies where your web pages are located.  The **listen** property nominates the IP:PORT endpoints on which you wish to listen, and the **tls** property specifies your TLS private key file and certificate file.

The **redirect** property ensures all HTTP traffic is redirected over TLS. And finally, the **routes** property defines a set of processing rules for incoming requests. These rules can specify required roles (capabilities) for a user to be authenticated to access the URL.

See [Web Server Configuration](configuration.md) for details.

### Building Ioto with Web Server

The easiest way to build Ioto and enable the embedded web server is to select the local **Console** app. This will configure and build Ioto enabling the web server and also build the local Console device management VueJS app.

```bash 
$ make APP=console clean build
```

If you only want to build Ioto and don't want the Console app, select the **Empty** app.

```bash 
$ make APP=empty clean build
```

### Starting Ioto

You can manually run ioto via:

```bash
make run
```

This will run Ioto with the **-v** verbose option.  This will emit:

```bash
app: info: Starting Ioto 2.0.0, with "console" app 1.0.0, using "dev" profile
setup: info: Enabling services: db register serialize web
sync: info: Update device
register: info: Device already registered
web: info: Listening http://:9090
web: info: Listening https://:4443
app: info: Ioto ready
```

The **-v** means run in verbose mode where request to the server will be traced to the console. You can also run in debug mode via **-D** which emits more debug trace.

You can request a file from the server now with the `curl` utility:

    curl http://localhost:9090/index.html

or using the supplied **url** command utility:

    url 9090/index.html

## Dynamic Web Content

Dynamic content is generated via the Ioto **Action handler** that binds specific URLs to corresponding C functions. The action handler is ideal for situations when you want to respond with device data or generate a dynamic response.

Previously, earlier web servers used the CGI and web frameworks like PHP or ESP to generate dynamic content. But these solutions are a poor fit for modern management applications that use SPA techniques. They also consume considerable CPU and memory resources and are not the best approach for embedded devices. Further, they expose large attack surfaces due to excess features that are not essential.

Ioto uses a more efficient direct binding from URLs to C functions. This direct binding of HTTP URL requests to C code is extremely efficient and since most device data is manage by C API &mdash; this provides the most direct path to accessing device data.

When coupled with a flexible streaming, WebSockets, SSE, non-blocking API, and a JSON parser and query engine, the result is a dramatically simpler and more efficient device management platform.

```c
static int testAction(Web *web)
{
    char  buf[ME_BUFSIZE];
    ssize nbytes;
    int   i;

    //  Read POST body data. This will block, but other fibers can still run.
    while ((nbytes = webRead(web, buf, sizeof(buf))) > 0) {
        printf("Got body data %.*s\n", (int) nbytes, buf);
    }

    //  Stream a response without buffering and with minimal memory footprint
    for (i = 0; i < 10000000; i++) {
        //  This will block as required, but other fibers can still run.
        webWriteFmt(web, "Hello World, now is: %s\n", rFormatLocalTime(0, 0));
    }
    webFinalize(web);
    return 0;
}
```

## Ioto API 

Ioto provides a flexible, comprehensive API so you can fully tailor dynamic request responses.

For example:

To generate a simple one line response:

    webResponse(web, 200, "Hello World\n");

To set an output HTTP header with the response

    webAddHeader(web, "X-Custom", "%d", 42);

To set the HTTP response status:

    webSetStatus(web, 404);

To respond to a request with an error:

    webError(web, 404, "Cannot serve request");

To write a database item (record) to the response:

    DbItem *item = dbGet(db, "User", DB_PROPS("id", "u23877112"), 0);
    webWriteItem(web, item);

To write an array (grid) of items to the response:

    DbGrid *users = dbFind(db, "User", 0, 0);
    webWriteItems(web, users);

To redirect to a new page:

    webRedirect(web, 302, "/login");

To get the value of a request form field:

    const char *user = webGetVar(web, "username", 0);

To set a variable in the authenticated session store:

    webSetSessionVar(web, "username", username);

To send a WebSockets message:

    webSocketsSend(web->webSockets, "Hello %s", "world");

To send a Server-Sent Events message:

    webWriteEvent(web, id, "event-name", "Hello %s", "world");

### Ioto Background

The Ioto HTTP core is responsible for parsing the incoming HTTP request. A HTTP request is comprised of a request line followed by one or more HTTP headers that provide additional context.

The first line of the HTTP request specifies the HTTP operation method to use, the URI to access and the variant of the HTTP protocol to use. This typically looks like:

```http
<b>GET</b> /index.html HTTP/1.1
```

This example is asking for the /index.html document via the GET method using the HTTP/1.1 protocol.

After the first line follow the headers. These are keyword, value pairs that control how the request will be processed. Typically there are 5-15 headers in most requests.

```
HeaderName: value
```

Some typical headers are:

|Header|Description|
|-|-|
| Authorization | Authorization details including user name, realm, password digest and other authorization parameters to implement Basic and Digest authentication. |
| Connection | Describe how the TCP/IP connection should be managed when the request completes. |
| Content-Length | Length of any addition data with a POST request. |
| Content-Type | Mime types the client prefers to accept in response to this request. |
| Cookie | Cookie associated with the URI in the clients cookie cache. |
| Host | Name to the target host to serve the request. This specifies the host name when using virtual hosting. |
| If-Modified-Since | Only return the content if it has been modified since the date specified. Clients who have cached copies of a document (or graphics) use this header to allow the server to skip copying the document if it has not changed. |
| Keep-Alive | Request the server to keep the connection alive so that subsequent requests can reuse the connection. |

For example:

```
Connection: keep-alive
```

The HTTP core stores the parsed headers and their values for access by the request handlers. When all the headers have been processed Ioto proceeds to do request routing. This will occur before any associated POST data has been read from the client. POST data may be form data submitted by the client or it may be a file upload using the PUT method.

## Request Routing

Ioto has a flexible request routing engine that processes client HTTP requests and validates access using a role-based access control mechanism. The routing engine is configured with a set of routes from the Ioto configuration file. When a request is received, it examines the routes in sequence and selects the first matching route to handle the request.

Handlers are responsible for receiving the request and creating a response. They generate response content based on the HTTP request URI, headers, any associated body data, and potential application session state. The output data flows through the output pipeline before transmission over the network to the client.

Ioto supports two request handlers:

* Static file handler
* Dynamic action handler

The static file handler serves document files from the configured **documents** directory.

The dynamic action handler responds to requests by invoking an associated C function to generate a dynamic response. It is also used for WebSockets and SSE requests.


## Fiber Coroutines

Ioto does not provide a web framework  nor do we believe this is the best approach for remote device management applications. Rather, we provide compellingly simple, streaming primitives to serve data for REST APIs and for single page applications.

To do this, Ioto adopts a unique approach of using fiber coroutines for parallelism and streaming. This yields an exceptionally fast web server that will serve over 3K requests per second on a modest Raspberry PI 4 and yet runs using only 80K of code.

The main benefit of fibers, is a non-blocking straight line procedural programming style.

A fiber coroutine is code that runs with its own stack and cooperatively yields to other fibers when it needs to wait. You can think of a fiber as a thread, but only one fiber runs at a time so there is no thread sync to worry about. For Go programmers, fibers are like Go routines. For JavaScript developers, fibers are similar to async/await.

You can read more in [Fiber Coroutines](../dev/fiber.md), but for now, consider this sample Action routine:


## JSON Parser and Query Engine

Ioto includes an integrated JSON parser, query engine and persistency to enable it to respond to HTTP requests with JSON payloads and remit responses in JSON.

## Ioto Kickstart

Ioto has a fully working sample single page application called [Kickstart](/apps/samples/kickstart/). This is a VueJS application that serves a sample device application from Ioto.

To build the Kickstart app:

```bash
$ make APP=kickstart clean build
```

## WebSockets

The Ioto web server supports WebSockets for bidirectional, full-duplex communications over persistent TCP/IP connections. A WebSocket connection is established over a standard HTTP connection using a GET request and is then upgraded without impacting the original connection. 

Ioto implements WebSockets for both the HTTP web server and for the URL HTTP client. The WebSockets library implements the core WebSockets protocol, handshaking, and provides a C language API. The `web`library accepts incoming HTTP connections and upgrades WebSockets requests via to use the WebSockets protocol. Similarly, the `url`library provides APIs to initiate WebSockets connections via a HTTP client GET request and it then upgrades that connection to use the WebSockets protocol. The `url` client program supports WebSockets for load testing purposes.

## Server-Sent Events (SSE)

The SSE protocol is a simple, lightweight protocol that is supported by most modern browsers. It is a good fit for device management applications that need to push data to the client. The Ioto web server supports Server-Sent Events (SSE) for streaming data to the client.

Ioto implements SSE for both the HTTP web server and for the URL HTTP client. The `web`library accepts incoming HTTP connections and via the `webWriteEvent` can remite SSE responses. Similarly, the `url`library provides APIs to initiate SSE connections via a HTTP client GET request and it then upgrades that connection to use the SSE protocol. 
# Cross-Site RequestForgery (CSRF) Protection

The IOTO web server provides comprehensive protection against Cross-Site Request Forgery (CSRF) attacks. CSRF attacks trick a user's browser into sending unauthorized commands to a web server by leveraging an active user session.

To mitigate this, the web server employs CSRF tokens. This document outlines how to configure and use this protection mechanism.

## Mitigation Strategy

The CSRF protection is based on a double-submit cookie pattern using a cryptographically strong token.

1.  A unique CSRF token is generated on the server for a user session.
2.  The token is sent to the client as a `X-XSRF-TOKEN` response header with the first `GET` request. The client must save this token.
3.  For subsequent state-changing requests (`POST`, `PUT`, `DELETE`), the client must include the token in the request, either in the `X-XSRF-TOKEN` header or as a form parameter.
4.  The server validates the received token against the one stored in the user's session. If they do not match, the request is rejected with a `400 Bad Request` status.

This ensures that only requests originating from pages served by your web server can perform sensitive actions.

## Configuration

CSRF protection is configured in the `web.json5` file. Note that in the configuration and source code, `XSRF` is used as an abbreviation for CSRF.

To enable CSRF protection for a specific route, add the `xsrf: true` property to its definition in the `routes` array.

To ensure client-side scripts can access the CSRF token, the `X-XSRF-TOKEN` header must be exposed. Add `'Access-Control-Expose-Headers': 'X-XSRF-TOKEN'` to the `headers` section.

```json5
{
    routes: [
        { match: '/api/resource/', handler: 'action', xsrf: true },
        // ... other routes
    ],
    headers: {
        'Access-Control-Expose-Headers': 'X-XSRF-TOKEN',
    },
}
```

When CSRF protection is enabled for a route, a session is automatically created to store the token on the server. The session ID is returned to the client in a secure, `HttpOnly` session cookie with `SameSite=Lax`.

### Token Naming

You can customize the token names if required:
*   Default header name: `X-XSRF-TOKEN`
*   Default form parameter name: `-xsrf-`

## Client-Side Workflow

1.  **Enable CSRF protection** in the `web.json5` configuration for the required routes.
2.  **Request a Token**: Make an initial `GET` request to a protected route.
3.  **Extract and Store**: From the response, extract the value of the `X-XSRF-TOKEN` header and store it securely on the client-side.
4.  **Submit the Token**: For any subsequent `POST`, `PUT`, or `DELETE` request, include the stored token in one of two ways:
    *   As an `X-XSRF-TOKEN` request header.
    *   As a hidden form input with the name `-xsrf-`.

## Implementation Details

*   CSRF tokens are only created for routes that have `xsrf: true` enabled.
*   For `GET` requests to a protected route, the `webAddSecurityToken()` function is automatically called to generate and add the CSRF token to the response headers.
*   For incoming `POST`, `PUT`, or `DELETE` requests, `webCheckSecurityToken()` is called to validate the token.
*   If the token is missing or invalid, the request is rejected.# Configuration

The Ioto web server is built by default when compiling from source.

After building, the Ioto web server is enabled via the **ioto.json5** file. It is disabled by default.

```js
{
    services: {
        web: true
    }
}
```

If you wish to only run the web server, you can disable all the other services. In this manner, Ioto becomes a dedicated embedded web server.

The web server configuration is controlled via the **web.json5** file.

Here is a minimal sample web.json5 that will listen on port 80 for HTTP requests and port 443 for TLS requests.

```js
{
    web: {
        documents: "./site",
        listen: [
            "http://:80",
            "https://:443",
        ],
        tls: {
            certificate: "server.crt",
            key: "server.key",
        },
    }
}
```

The configuration file defines the following items:

* Public **name** of the server
* The **documents** directory for files to serve
* The ports on which to **listen** for requests
* Request **timeouts**
* Request **limits**
* The **tls** (TLS) certificates
* Instructions to **redirect** requests
* Processing **routes**
* Policy for file **upload**

The configuration properties are defined in the [Configuration Properties](./properties.md).

Here is a more detailed example:

```js
{
    web: {
        documents: "./site",
        headers: {
            'X-Frame-Options': 'SAMEORIGIN',
        },
        index: "index.html",
        limits: {
            body: "100K",
            connections: "100",
            memory: "1MB",
            header: "10K",
            sessions: "20",
            upload: "20MB",
        },
        listen: [
            "http://:80",
            "https://:443",
        ],
        name: "mysite.com",
        redirect: [
            { status: 302, to: "https://" },
            { status: 301, from: "/old", to: "/new.html" },
        ],
        routes: [
            { match: '/public/', role: 'user' },
            { match: '/auth/' },
            { match: '/trace/', methods: ['TRACE'], trim: '/trace' },
            { redirect: '/auth/login' },
        ],
        sessions: {
            cookie: "-web-cookie-",
            enable: true,
            sameSite: "lax",
        },
        timeouts: {
            parse: "10 secs",
            inactivity: "300 secs",
            request: "10 mins",
            session: "30 mins",
            tls: "1 day",
        },
        tls: {
            certificate: "server.crt",
            key: "server.key",
        },
        upload: {
            dir: '/tmp',
            remove: true,
        }
    }
}
```
# Session State Management

While HTTP is a stateless protocol, IOTO provides robust session state management to maintain context across multiple requests from the same client. This is essential for features like user authentication, device configuration, and multi-step operations.

Sessions work by creating a unique session ID for a client and sending it via a secure cookie. On subsequent requests, the browser returns the cookie, allowing the server to retrieve the session data. For memory-constrained embedded devices, sessions are managed efficiently and expire automatically after a configurable period of inactivity.

## Session Lifecycle

### Creation

A session is created automatically in one of two ways:

1.  **On-Demand**: When you store data in the session state for the first time using the `webSetSessionVar` API call.
2.  **Authentication**: When a user is successfully authenticated via `webLogin`. This creates a new, clean session for the authenticated user.

Upon creation, a session cookie containing the unique session ID is added to the `Set-Cookie` header of the HTTP response.

### Persistence

Once created, a session persists as long as there is client activity. Each new request from the client resets the session's inactivity timer. If the `timeouts.sessions` limit is reached, the session is automatically destroyed to conserve resources.

### Destruction

A session is destroyed in one of the following ways:

*   **Logout**: Calling `webLogout` explicitly destroys the current session.
*   **Timeout**: The session expires after the configured `timeouts.sessions` inactivity period.
*   **Limit**: If the maximum number of sessions (`limits.sessions`) is reached, the oldest inactive session may be reclaimed.

When a session is destroyed, the session cookie is removed from the client.

## Configuration

Session behavior is configured in the `web.json5` file.

```json5
{
    "limits": {
        "sessions": 20
    },
    "timeouts": {
        "sessions": "30m"
    },
    "sessions": {
        "cookie": "ioto-session",
        "httpOnly": true,
        "sameSite": "Lax",
        "secure": true
    }
}
```

*   `limits.sessions`: Maximum number of concurrent sessions.
*   `timeouts.sessions`: Session inactivity timeout.
*   `sessions.cookie`: The name of the session cookie.
*   `sessions.httpOnly`: If `true`, the cookie cannot be accessed by client-side scripts.
*   `sessions.sameSite`: Controls cross-site cookie sending. 'Lax' is a good default.
*   `sessions.secure`: If `true`, the cookie is only sent over HTTPS.

## Security

By default, session cookies are created with security best practices in mind:

*   **`Secure`**: The cookie is only transmitted over HTTPS.
*   **`HttpOnly`**: Prevents access from client-side JavaScript, mitigating XSS attacks.
*   **`SameSite=Lax`**: Provides protection against Cross-Site Request Forgery (CSRF) attacks.

These defaults can be overridden in the `sessions` section of `web.json5`, but it is strongly recommended to keep them enabled.
# Transport Layer Security (TLS) Overview

Ioto supports the Transport Layer Security (TLS) protocol for authenticating systems and encrypting data. Use of this protocol enables secure data transmission to and from clients in a standards-based manner. The Transport Layer Security protocol is a protocol layer which may be placed between a reliable connection-oriented network layer protocol (e.g. TCP/IP) and the application protocol layer (e.g. HTTP). TLS provides for secure communication between client and server by allowing mutual authentication, the use of digital signatures for integrity, and encryption for privacy.

This following document explains TLS. It has heavily borrowed from the Apache Documentation. Many thanks to the fine folks at Apache for this excellent base material and for Frederick Hirsch who authored quite a bit of the original material.

If you have a good understanding of TLS and now you want to configure TLS for Ioto, you may wish to skip the background and read immediately how to setup [TLS for Ioto](tls.md).

<a id="cryptographicTechniques"></a>
## Cryptographic Techniques

Understanding TLS requires an understanding of cryptographic algorithms, message digest functions (aka. one-way or hash functions), and digital signatures. The following section provides a brief introduction to the cryptographic foundations of TLS. If you are already familiar with this material, please skip forward to the <a href="#tlsOverview">TLS Overview</a> section.

### Cryptographic Algorithms

Consider the example of Alice who wants to send a message to her bank to transfer some money. She would like the message to be private, since it will include information such as her account number and transfer amount. One solution is to use a cryptographic algorithm, a technique that would transform her message into an encrypted form, unreadable except by those it is intended for. Once in this form, the message may only be interpreted through the use of a secret key. Without the key, the message is useless: good cryptographic algorithms make it so difficult for intruders to decode the original text that it isn't worth their effort.

There are two categories of cryptographic algorithms: conventional and public key.

<a id="symmetricCryptography"></a>
#### Symmetric Cryptography

Symmetric cryptography, requires the sender and receiver to share a key: a secret piece of information that may be used to encrypt or decrypt a message. If this key is secret, then nobody other than the sender or receiver may read the message. If Alice and the bank know a secret key, then they may send each other private messages. The task of privately choosing a key before communicating, however, can be problematic.

<a id="publicKeyCryptography"></a>
#### Public Key Cryptography

Public key cryptography also known as asymmetric cryptography, solves the key exchange problem by defining an algorithm which uses two keys, each of which may be used to encrypt a message. If one key is used to encrypt a message then the other may be used to decrypt it. This makes it possible to receive secure messages by simply publishing one key (the public key) and keeping the other secret (the private key).

Anyone may encrypt a message using the public key, but only the owner of the private key will be able to read it. In this way, you may send private messages to the owner of a key-pair (the bank), by encrypting it using their public key. Only the bank will be able to decrypt it.

<a id="messageDigests"></a>
### Message Digests

Although Alice may encrypt her message to make it private, there is still a concern that someone might modify her original message or substitute it with a different one, in order to transfer the money to themselves, for instance. One way of guaranteeing the integrity of Alice's message is to create a concise summary of her message and send this to the bank as well. Upon receipt of the message, the bank creates its own summary and compares it with the one Alice sent. If they agree then the message was received intact.

A summary such as this is called a <b>message digest</b>, `one-way function` or `hash function`. Message digests are used to create short, fixed-length representations of longer, variable-length messages. Digest algorithms are designed to produce unique digests for different messages. Message digests are designed to make it too difficult to determine the message from the digest, and also impossible to find two different messages which create the same digest &mdash; thus eliminating the possibility of substituting one message for another while maintaining the same digest.

Another challenge that Alice faces is finding a way to send the digest to the bank securely; when this is achieved, the integrity of the associated message is assured. One way to do this is to include the digest in a digital signature.

<a id="digitalSignatures"></a>
### Digital Signatures

When Alice sends a message to the bank, the bank needs to ensure that the message is really from her, so an intruder does not request a transaction involving her account. A `digital signature`, created by Alice and included with the message, serves this purpose.

Digital signatures are created by encrypting a digest of the message, and other information (such as a sequence number) with the sender's private key. Though anyone may `decrypt` the signature using the public key, only the signer knows the private key. This means that only they may have signed it. Including the digest in the signature means the signature is only good for that message; it also ensures the integrity of the message since no one can change the digest and still sign it.

To guard against interception and reuse of the signature by an intruder at a later date, the signature contains a unique sequence number. This protects the bank from a fraudulent claim from Alice that she did not send the message &mdash; only she could have signed it (non-repudiation).<a id="certificates"></a>

## Certificates

Although Alice could have sent a private message to the bank, signed it, and ensured the integrity of the message, she still needs to be sure that she is really communicating with the bank. This means that she needs to be sure that the public key she is using corresponds to the bank's private key. Similarly, the bank also needs to verify that the message signature really corresponds to Alice's signature.

If each party has a certificate which validates the other's identity, confirms the public key, and is signed by a trusted agency, then they both will be assured that they are communicating with whom they think they are. Such a trusted agency is called a `Certificate Authority`, and certificates are used for authentication.

### Certificate Contents

A certificate associates a public key with the real identity of an individual, server, or other entity, known as the subject. As shown in <a href="#table1">Table 1</a>, information about the subject includes identifying information (the distinguished name), and the public key. It also includes the identification and signature of the Certificate Authority that issued the certificate, and the period of time during which the certificate is valid. It may have additional information (or extensions) as well as administrative information for the Certificate Authority's use, such as a serial number.

<a id="table1"></a>

#### Table 1: Certificate Information

| Item | Description |
|-|-|
| Subject | Distinguished Name, Public Key |
| Issuer | Distinguished Name, Signature |
| Period of Validity | Not Before Date, Not After Date |
| Administrative Information | Version, Serial Number |
| Extended Information | Basic Constraints, Netscape Flags, etc. |

A distinguished name is used to provide an identity in a specific context &mdash; for instance, an individual might have a personal certificate as well as one for their identity as an employee. Distinguished names are defined by the X.509 standard, which defines the fields, field names, and abbreviations used to refer to the fields (see <a href="#table2">Table 2</a>).

<a id="table2"></a>

#### Table 2: Distinguished Name Information

| DN Field | Abbrev. | Description | Example |
|-|-|-|-|
| Common Name | CN | Name being certified | CN=Joe Average |
| Organization or Company | O | Name is associated with this organization | O=Snake Oil, Ltd. |
| Organizational Unit | OU | Name is associated with this organization unit, such as a department | OU=Research Institute |
| City/Locality | L | Name is located in this City | L=Snake City |
| State/Province | ST | Name is located in this State/Province | ST=Desert |
| Country | C | Name is located in this Country (ISO code) | C=XZ |

A Certificate Authority may define a policy specifying which distinguished field names are optional, and which are required. It may also place requirements upon the field contents, as may users of certificates. As an example, a Netscape browser requires that the Common Name for a certificate representing a server has a name which matches a wildcard pattern for the domain name of that server, such as <code>*.snakeoil.com</code>

The binary format of a certificate is defined using the ASN.1 notation. This notation defines how to specify the contents, and encoding rules define how this information is translated into binary form. The binary encoding of the certificate is defined using Distinguished Encoding Rules (DER), which are based on the more general Basic Encoding Rules (BER). For those transmissions which cannot handle binary, the binary form may be translated into an ASCII form by using Base64 encoding. This encoded version is called PEM encoded (the name comes from "Privacy Enhanced Mail"), when placed between begin and end delimiter lines as illustrated in the following example.

### Example of a PEM-encoded certificate (snakeoil.crt)
```
-----BEGIN CERTIFICATE-----
MIIC7jCCAlegAwIBAgIBATANBgkqhkiG9w0BAQQFADCBqTELMAkGA1UEBhMCWFkx
FTATBgNVBAgTDFNuYWtlIERlc2VydDETMBEGA1PEBxMKU25ha2UgVG93bjEXMBUG
A1UEChMOU25ha2UgT2lsLCBMdGQxHjAcBgNVBAsTFUNlcnRpZmljYXRlIEF1dGhv
cml0eTEVMBMGA1UEAxMMU25ha2UgT2lsIENBMR4wHAYJKoZIhvcNAQkBFg9jYUBz
bmFrZW9pbC5kb20wHhcNOTgxMDIxMDg1ODM2WhcNOTkxMDIxMDg1ODM2WjCBpzEL
MAkGA1UEBhMCWFkxFTATBgNVBAgTDFNuYWtlIELlc2VydDETMBEGA1UEBxMKU25h
a2UgVG93bjEXMBAGA1UEChMOU25ha2UgT2lsLCBMdGQxFzAVBgNVBAsTDldlYnNl
cnZlciBUZWFtMRkwFwYDVQQDExB3d3cuc25ha2VvaWwuZG9tMR8wHQYJKoZIhvcN
AQkBFhB3d3dAc25ha2VvaWwuZG9tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB
gQDH9Ge/s2zcH+da+rPTx/DPRp3xGjHZ4GG6pCmvADIEtBtKBFAcZ64n+Dy7Np8b
vKR+yy5DGQiijsH1D/j8HlGE+q4TZ8OFk7BNBFazHxFbYI4OKMiCxdKzdif1yfaa
lWoANFlAzlSdbxeEVHoT0K+gT5w3UxwZKv2DLbETzLZyPwIDAQABoyYwJDAPBgNV
HRMECDAGAQH/AgEAMBEGCWCGSAGG+EIBAQQEAwIAQDANBgkqhkiG9w0BAQQFAAOB
gQAZUIHAL4D09oE6Lv2k56Gp38OBDuILvwLg1v1KL8mQR+KFjghCrtpqaztZqcDt
2q2QoyulCgSzHbEGmi0EsdkPfg6mp0penssIFePYNI+/8u9HT4LuKMJX15hxBam7
dUHzICxBVC1lnHyYGjDuAMhe396lYAn8bCld1/L4NMGBCQ==
-----END CERTIFICATE-----
```

<a id="certificateAuthorities"></a>

### Certificate Authorities

By first verifying the information in a certificate request before granting the certificate, the Certificate Authority assures the identity of the private key owner of a key-pair. For instance, if Alice requests a personal certificate, the Certificate Authority must first make sure that Alice really is the person the certificate request claims.

#### Certificate Chains

A Certificate Authority may also issue a certificate for another Certificate Authority. When examining a certificate, Alice may need to examine the certificate of the issuer, for each parent Certificate Authority, until reaching one which she has confidence in. She may decide to trust only certificates with a limited chain of issuers, to reduce her risk of a "bad" certificate in the chain.

#### Creating a Root-Level CA

As noted earlier, each certificate requires an issuer to assert the validity of the identity of the certificate subject, up to the top-level Certificate Authority (CA). This presents a problem: Since this is who vouches for the certificate of the top-level authority, which has no issuer? In this unique case, the certificate is "self-signed", so the issuer of the certificate is the same as the subject. As a result, one must exercise extra care in trusting a self-signed certificate. The wide publication of a public key by the root authority reduces the risk in trusting this key &mdash; it would be obvious if someone else publicized a key claiming to be the authority. Browsers are preconfigured to trust well-known certificate authorities.

A number of companies, such as <a href="http://www.thawte.com/">Thawte</a> and <a href= "http://www.verisign.com/">VeriSign</a> have established themselves as Certificate Authorities. These companies provide the following services:

* Verifying certificate requests
* Processing certificate requests
* Issuing and managing certificates

It is also possible to create your own Certificate Authority. Although risky in the Internet environment, it may be useful within an Intranet where the organization can easily verify the identities of individuals and servers.

#### Certificate Management

Establishing a Certificate Authority is a responsibility which requires a solid administrative, technical, and management framework. Certificate Authorities not only issue certificates, they also manage them &mdash; that is, they determine how long certificates are valid, they renew them, and they keep lists of certificates that have already been issued but are no longer valid (Certificate Revocation Lists, or CRLs). Say Alice is entitled to a certificate as an employee of a company. Say too, that the certificate needs to be revoked when Alice leaves the company. Since certificates are objects that get passed around, it is impossible to tell from the certificate alone that it has been revoked. When examining certificates for validity, therefore, it is necessary to contact the issuing Certificate Authority to check CRLs &mdash; this is not usually an automated part of the process.

### Notes

If you use a Certificate Authority that is not configured into browsers by default, it is necessary to load the Certificate Authority certificate into the browser, enabling the browser to validate server certificates signed by that Certificate Authority. Doing so may be dangerous, since once loaded, the browser will accept all certificates signed by that Certificate Authority.

<a id="tlsOverview"></a>
## Transport Layer Security (TLS) Overview

The Transport Layer Security protocols designed to support a range of choices for specific algorithms used for cryptography, digests, and signatures. This allows algorithm selection for specific servers to be made based on legal, export or other concerns, and also enables the protocol to take advantage of new algorithms. Choices are negotiated between client and server at the start of establishing a protocol session.

<a id="table4"></a>
### Table 4: Versions of the TLS protocol

<table title="protocols" class="ui table celled segment">
<thead>
    <tr>
        <th>Version</th>
        <th>Source</th>
        <th>Description</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td>TLS v2.0</td>
        <td>Expired</td>
        <td>First TLS protocol for which implementations exists</td>
    </tr>
    <tr>
        <td>TLS v3.0</td>
        <td>Expired</td>
        <td>Revisions to prevent specific security attacks, add non-RSA ciphers,
        and support for certificate chains</td>
    </tr>
    <tr>
        <td>TLS v1.0</td>
        <td>Internet Standard</td>
        <td>TLSv1.0 is a revision of TLS 3.0 to update the MAC layer to HMAC,
        add block padding for block ciphers, message order standardization
        and more alert messages.</td>
    </tr>
    <tr>
        <td>TLS v1.1</td>
        <td>Internet Standard</td>
        <td>TLSv1.1 adds protection against Cipher block chaining attacks.</td>
    </tr>
    <tr>
        <td>TLS v1.2</td>
        <td>Internet Standard</td>
        <td>TLSv1.2 deprecates using MD5 as a hash and deprecates TLSv2.</td>
    </tr>
    <tr>
        <td>TLS v1.3</td>
        <td>Internet Standard</td>
        <td>TLSv1.3 improves performance and fast connection startup.</td>
    </tr>
</tbody>
</table>

There are a number of versions of the TLS protocol, as shown in <a href="#table4">Table 4</a>. As noted there, one of the benefits in TLS 3.0 is that it adds support of certificate chain loading. This feature allows a server to pass a server certificate along with issuer certificates to the browser. Chain loading also permits the browser to validate the server certificate, even if Certificate Authority certificates are not installed for the intermediate issuers, since they are included in the certificate chain. TLS 3.0 is the basis for the Transport Layer Security protocol standard, currently in development by the Internet Engineering Task Force (IETF).

### Session Establishment

The TLS session is established by following a handshake sequence between client and server. This sequence may vary, depending on whether the server is configured to provide a server certificate or request a client certificate. Though cases exist where additional handshake steps are required for management of cipher information, this article summarizes one common scenario: see the TLS specification for the full range of possibilities.

### Note
Once an TLS session has been established it may be reused, thus avoiding the performance penalty of repeating the many steps needed to start a session. For this the server assigns each TLS session a unique session identifier which is cached in the server and which the client can use on forthcoming connections to reduce the handshake (until the session identifier expires in the cache of the server).

<p class="figure">The elements of the handshake sequence, as used by the client and server, are listed below:</p>

1. Negotiate the Cipher Suite to be used during data transfer
2. Establish and share a session key between client and server
3. Optionally authenticate the server to the client
4. Optionally authenticate the client to the server

The first step, Cipher Suite Negotiation, allows the client and server to choose a Cipher Suite supportable by both of them. The TLS3.0 protocol specification defines 31 Cipher Suites. A Cipher Suite is defined by the following components:

* Key Exchange Method
* Cipher for Data Transfer
* Message Digest for creating the Message Authentication Code (MAC)

These three elements are described in the sections that follow.

### Key Exchange Method

The key exchange method defines how the shared secret symmetric cryptography key used for application data transfer will be agreed upon by client and server. TLS 2.0 uses RSA key exchange only, while TLS 3.0 supports a choice of key exchange algorithms including the RSA key exchange when certificates are used, and Diffie-Hellman key exchange for exchanging keys without certificates and without prior communication between client and server.

One variable in the choice of key exchange methods is digital signatures &mdash; whether or not to use them, and if so, what kind of signatures to use. Signing with a private key provides assurance against a man-in-the-middle-attack during the information exchange used in generating the shared key.

### Cipher for Data Transfer

TLS uses the conventional cryptography algorithm (symmetric cryptography) described earlier for encrypting messages in a session. There are nine choices, including the choice to perform no encryption:

* No encryption
* Stream Ciphers
- RC4 with 40-bit keys
- RC4 with 128-bit keys
* CBC Block Ciphers
    - RC2 with 40 bit key
    - DES with 40 bit key
    - DES with 56 bit key
    - Triple-DES with 168 bit key
    - Idea (128 bit key)
    - Fortezza (96 bit key)

Here "CBC" refers to Cipher Block Chaining, which means that a portion of the previously encrypted cipher text is used in the encryption of the current block. "DES" refers to the Data Encryption Standard, which has a number of variants (including DES40 and 3DES_EDE). "Idea" is one of the best and cryptographically strongest available algorithms, and "RC2" is a proprietary algorithm from RSA DSI.

Digest Function
The choice of digest function determines how a digest is created from a record unit. TLS supports the following:
* No digest (Null choice)
* MD5, a 128-bit hash (deprecated in TLS/1.2)
* Secure Hash Algorithm (SHA-1), a 160-bit hash

The message digest is used to create a Message Authentication Code (MAC) which is encrypted with the message to provide integrity and to prevent against replay attacks.

### Handshake Sequence Protocol

The handshake sequence uses three protocols:
* The <dfn>TLS Handshake Protocol</dfn> for performing the client and server TLS session establishment.
* The <dfn>TLS Change Cipher Spec Protocol</dfn> for actually establishing agreement on the Cipher Suite for the session.
* The <dfn>TLS Alert Protocol</dfn> for conveying TLS error messages between client and server.

These protocols, as well as application protocol data, are encapsulated in the <dfn>TLS Record Protocol</dfn>. An encapsulated protocol is transferred as data by the lower layer protocol, which does not examine the data. The encapsulated protocol has no knowledge of the underlying protocol.

The encapsulation of TLS control protocols by the record protocol means that if an active session is renegotiated the control protocols will be transmitted securely. If there were no session before, then the Null cipher suite is used, which means there is no encryption and messages have no integrity digests until the session has been established.

### Data Transfer

The TLS Record Protocol is used to transfer application and TLS Control data between the client and server, possibly fragmenting this data into smaller units, or combining multiple higher level protocol data messages into single units. It may compress, attach digest signatures, and encrypt these units before transmitting them using the underlying reliable transport protocol (Note: currently all major TLS implementations lack support for compression).

### Securing HTTP Communication

One common use of TLS is to secure Web HTTP communication between a browser and a web server. This case does not preclude the use of non-secured HTTP. The secure version is mainly plain HTTP over TLS (named HTTPS), but with one major difference: it uses the URL scheme <code>https</code> rather than <code>http</code> and a different server port (by default 443).
# Listening for Connections

Ioto can listen for HTTP requests on multiple IP addresses and ports. Incoming requests may be served by a single server, or they may be processed by different logical servers often called virtual hosts.

The process of opening TCP/IP ports to listen for requests is called binding. By default, Ioto will listen on all the interface network cards in the system, but the Ioto configuration file allows explicit control over which interfaces, IP addresses and ports are used.

## Listen Directive

The <a href="properties.html#listen">Listen</a> configuration file property specifies the IP endpoints on which Ioto will listen for incoming HTTP requests. It takes the form:

```json
listen: [
    'http:// | https://][IP][:PORT]',
    ...
]
```

The HTTP scheme portion is optional and indicates whether TLS is to be use. If **https://** is used, then TLS will be applied to the connection.

The IP address and port components are optional, but at least one must be present. If the IP address is absent, Ioto will listen on all network interfaces including the loop-back adapter. If the PORT is absent, Ioto will listen on the default port which is typically configured to be port 80.

For example:

```json
listen: [
    "http://:80",
    "https://:443",
]
```

## IPv6

Ioto will listen on both IPv4 and IPv6 endpoints. To specify IPv6 endpoints you need to use IPv6
encoding. IPv6 addresses have eight colon separated segments. For example:

```
2001:0db8:85a3:08d3:1319:8a2e:0370:7348
```

Because IPv6 addresses contain a colon character, you need to enclose the IPv6 address in brackets if
you want to also specify a network port when using the Listen directive.

```json
listen: [
    "http://[2001:0db8:85a3:08d3:1319:8a2e:0370:7348]:7777"
]
```

These two documents are useful IPv6 references:
* [Understanding IPv6 Addresses](http://www.enterprisenetworkingplanet.com/netsp/article.php/3633211)
* [Wikipedia IPv6](http://en.wikipedia.org/wiki/IPv6)
# File Upload

Ioto has an integrated file upload filter that accepts and processes file upload requests.

The Ioto upload filter intercepts uploaded files, saves them to disk and passes details about the
uploaded file to Ioto Action routines for processing.

File upload uses multi-part mime encoding to transport files over HTTP POST requests. This is specified in
the IETF standard <a href="http://www.ietf.org/rfc/rfc2388.txt">RFC 2388</a>.

<a id="overview"></a>

## Overview

Because uploaded files can be very large, Ioto uses specialized handling for the receipt, storage and processing of uploaded files. When an upload request is received, Ioto will accept and store the uploaded file before starting the Action routine to respond to the request. The Action routine does not directly receive the uploaded file. Rather, Ioto passes the name of the temporary file holding the uploaded file. Ioto expects that the Action routine will process, copy or move the temporary file before completing the request. Once complete, Ioto will remove any remaining upload temporary files.

<a id="directives"></a>

## Ioto Upload Configuration

There are two **web.json5** configuration properties that control the upload filter.
* [upload.dir](properties.md#upload.dir) &mdash; This specifies directory to receive uploaded files.
* [upload.remove](properties.md#upload.remove) &mdash; This specifies if the uploaded files should be automatically removed from the upload directory after the action routine has completed processing the request.

<a id="details"></a>
## Upload File Details

Once a file is uploaded, the Action routine responsible for processing the request will receive details about
uploaded files via the request parameters.

Ioto provides direct access to the uploaded files structure. Each uploaded file is described
by a [WebUpload](../ref/api/web.md#group___web_upload) structure.

These structures are stored in an RHash table indexed by their HTML file upload ID.

The [WebUpload](../ref/api/web.md#group___web_upload) structure is defined as:

```c
typedef struct WebUpload {
    char *filename;       /**< Local (temp) name of the file */
    char *clientFilename; /**< Client side name of the file */
    char *contentType;    /**< Content type */
    char *name;           /**< Symbolic name for the upload supplied by the client */
    ssize size;           /**< Uploaded file size */
    int fd;               /**< File descriptor used while writing the upload content */
} WebUpload;
```

You can access uploaded files via:

```c
WebUpload  *file;
cchar      *name;

for (ITERATE_NAME_DATA(web->files, name, file)) {
    webWriteFmt(web, "FILENAME %s\n", file->filename);
    webWriteFmt(web, "CLIENT_NAME %s\n", file->clientFilename);
    webWriteFmt(web, "TYPE %s\n", file->contentType);
    webWriteFmt(web, "SIZE %d\n", file->size);
}
```

<a id="post"></a>
## Alternative Upload Technique

File upload using POST requests is one way to upload files. Another is to use the HTTP PUT method.
This uploads a file without encoding and can offer higher performance. The HTTP DELETE method can then
be used to delete files from the server.
# Security Considerations

Securing applications that are accessible to the Internet is not a trivial task.

When a device enables an embedded web server, the security exposure increases significantly as it is listening for unsolicited incoming connections and requests.

>You should disable the Ioto web server unless you definitely need to provide HTTP web services.

This page outlines some of the issues, and offers best-practices and tips to help you secure your application using the Ioto web server.

## Updates

Even the best or most secure application server can experience some security vulnerabilities that are discovered after being deployed in the field. It is highly recommended that you stay up to date with the latest version of Ioto. [Download Ioto](https://www.embedthis.com/ioto/download.html).

<a href="https://embedthis.com/">Embedthis</a> provides security protection as part of the Ioto commercial license that will proactively notify you of any security flaws and will expedite fixes or workarounds to minimize any vulnerabilities.

## Sandboxing

Sandboxing is the term applied to running the Ioto web server in a confined environment. For device management, the profile of client access is typically well known, and the profile of malicious attacks are well outside this profile. The profile includes the rate of accesses, the type and size of requests.

The Ioto web server has a set of configuration file properties that allow you to define a sandbox which specifies how Ioto must be used for a request to be serviced. By using a well defined sandbox, you can minimize the chance that your application will be compromised by malicious requests. You should customize the sandbox limits to use minimum values and thus provide the most protection.

### Security Limits and Timeouts

The Ioto security limits can be used to effectively block some denial of service attacks. Limits should be set as low as possible while still permitting all valid requests and workloads.

Setting the LimitRequestsPerClient to a low value can restrict the ability of a malicious client to monopolize the server. One attack method for denial of service attacks is to initiate requests, but not conclude the request headers. The server is then forced to wait for the client to complete the request before it can act. However, setting the RequestParseTimeout directive to a low value will abort such requests and prevent such attacks.

Ioto can monitor sandbox limits and trigger defensive responses if access is outside defined norms. See the <a href="#dos">Denial of Service</a> section for more details.

## Sandbox Limits

The additional sandbox [limit](./properties.md#limits) properties are:

| Limit | Description |
|-|-|
| limits.body | Maximum size of the incoming request body for POST and PUT requests. Does not include file upload size. |
| limits.buffer | Maximum size of the response buffer for buffered responses. |
| limits.connections | Maximum number of simultaneous client connections. |
| limits.header | Maximum size of the request headers |
| limits.sessions | Maximum number of sessions |
| limits.upload | Maximum size of a file upload request |
| limits.uploads | Maximum number of files uploaded |

## Timeout Properties

The important Ioto security [timeout](./properties.md#timeouts) properties are:

| Timeout | Description |
|-|-|
| timeouts.inactivity | Maximum request and connection inactivity duration. This can be defined per route, so if you have a long running request, create a dedicated route for that request. |
| timeouts.parse | Maximum duration to parse the request headers. This should be set very short. Typically a browser will send all the request headers in one network packet. Recommended value is 5 secs. |
| timeouts.request | Maximum request duration. Set this to the maximum time a request can take. This can be defined per route, so if you have a long running request, create a dedicated route and RequestTimeout for it. |
| timeouts.session | Maximum duration of session inactivity. |

See the [Limit Properties](./properties.md#limits) and [Timeout Properties](./properties.md#timeouts) documentation for further details.

## Ioto User Account

It is important that you run Ioto with the lowest system privilege that will get the job done. If any application is compromised, including Ioto, then the system will be safest if the compromised application has as few privileges as possible.

## Unix Account

On Unix, create a dedicated user account and group for Ioto.

## Directory and File Permissions

When Ioto is installed, it is configured for maximum security. This section explains the policy should you need to move or modify files and directories.

To enhance security you need to consider the directory and file permissions for three classes of content:

* Pages served by the HTTP server
* Scripts run by the HTTP server
* Configuration and log files used by the HTTP server.

Pages served by the Ioto server should be owned by root or administrator and should be only readable by the Ioto user account. Directories containing served pages should be readable and executable only.

Scripts run by the Ioto server should always be outside all directories containing served pages. After all, you don't want prying eyes viewing your scripts! Scripts should be owned by the <b>root</b> or <b>administrator</b> and should only be readable and executable by the Ioto user account.

Configuration and log files used by the Ioto server should always be outside all directories containing served pages or scripts. The directory containing the log files must be writable by the Ioto user account.

## Home Directory Permissions

The root directory for Ioto is called the Home directory and is defined by the Home directive in the configuration file. The Home directory, and the logs and lib directory below it, should be owned by <b>root</b> (or admin), and should be in the group <b>root</b> (or administrators). They should only be writable by this specific user and group.

For Linux, these commands will ensure the privileges are correctly set up:

```bash
cd    /etc/ioto
chown root .
chgrp root .
chmod 755  .
cd    /var/www/ioto
chown root .
chgrp root .
chmod 755  .
```

## Chroot Jail

One of the best forms of isolation for the server is to run inside a <a href="http://en.wikipedia.org/wiki/Chroot">chroot</a> jail. A chroot jail is when an application changes its root directory to be isolated from the real file system root directory. Any access then to files outside the jail is protected and impossible. Ioto supports chroot jails via the **chroot** command.

## Securing TLS

It is important to select a sufficiently long key length and strong cipher to protect TLS communications. It is recommended to use the AES cipher and avoid the older RC4 cipher suite. See the section below regarding <a href="#threats">Common Security Threats</a> for threats against the RC4 ciphers.

## TLS Forms

A common practice is to use HTTP for regular communications and to post login forms using TLS. However, this approach is flawed. The web form itself must be served using TLS as well as the URL receiving the login information. This prevents attackers injecting code into the form and hijacking login credentials.

For more information regarding TLS, please read:

* <a href="tlsOverview.html">TLS Overview</a>
* <a href="tls.html">Configuring TLS</a>

## Authentication

It is important to adequately secure all passwords stored at the server. Simply hashing the passwords with MD5 is insufficient as MD5 and other "fast" hashing techniques can be quickly compromised by dedicated password cracking and hashing tools.

Ioto includes the SHA256 and Blowfish/Bcrypt ciphers as an alternative that are more secure than MD5. The <a href="http://en.wikipedia.org/wiki/Blowfish_(cipher)">Blowfish</a> cipher is especially well suited for password hashing partly. Partly because it is slow, it does not easily succumb to brute-force cracking.

If using a web page for users to submit their credentials, it is strongly recommended that you use TLS for both the web form page and for the request validating the user credentials.

Lastly, remember to define routes to restrict access to content that should only be served to certain users. Otherwise those pages will also be visible via the default server.


## Log Files

Ioto will log satisfied requests to the access log (usually logs/access.log) and errors to the error log (usually logs/error.log). It is recommended that you regularly review these logs for suspicious activity.


## Common Security Threats

This section details some common security threats and issues and the steps you can take to mitigate them.

## Server Information Disclosure

HTTP responses often disclose information that an attacker can use to refine their attack. At a minimum, too much information enables the attack to proceed faster. Ioto minimizes these disclosures and does not emit a **Server** HTTP header and strives to minimize unnecessary disclosures in responses. In cases where an illegal request is detected, Ioto will simply disconnect the client without issuing a response.

## Mixed Transports

Is is a bad idea to mix secure and non-secure content in one page. This means a web page should be totally served by HTTP or by HTTPS but not mix transports on one page. The reason is that a page served by HTTP can be compromised and the guarantee of HTTPS and that green-browser https logo is diminished if the form page from which the user enters there data is not 100% trust-worthy.

Ioto can support the "Strict-Transport-Security" HTTP response header. This header instructs the browser that all connections thereafter must only request over HTTPS. The specified age limit is in seconds To enable this, use the following directive:

```js
web: {
    headers: {
        'Strict-Transport-Security': 'max-age="31536000"',
    }
}
```

## Denial of Service

Denial of service attacks can be difficult to detect and defend against. However, Embedded devices typically have a well defined, understood and anticipated work load. Unlike enterprise system, which have highly variable work loads, embedded systems typically serve a specific purpose with known clients that follow a more predictable access pattern. This allows an embedded system to define a range of operation that is considered "normal" and to trigger alerts and defenses if access is outside of this "normal" operation.

## Cross Site Scripting

Cross-site vulnerabilities have ballooned over recent years. Unfortunately, there is no, single complete cure. However, Ioto supports the <a href="http://en.wikipedia.org/wiki/Content_Security_Policy">Content Security Policy (CSP)</a> scheme that can go a long way to reduce the exposure. It does this by exactly specifying and restricting what cross-site access is permitted.

The following Ioto directive enables the Content Security Policy and restricts all access to the origin site. This is a good starting point.

```js
{
    web: {
        headers: {
            "Content-Security-Policy":  "default-src 'self'"
        }
    }
}
```

See <a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/">An introduction to Content Security Policy</a> for more information.

## Cross Site Sharing

Cross origin sharing is often required when using XMLHttp (Ajax) requests to communicate with another server. <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross Origin Resource Sharing (CORS)</a> is a mechanism that allows scripts to make XMLHttp requests to another domain different from that which served the web page. This relaxes the same-origin policy of the browser, but in a controlled manner.

```js
headers: {
    CrossOrigin: "origin=* credentials=yes headers=X-CORS-HEADER age=3000",
}
```


## Hidden Frames

Hidden frames may be inserted by attackers to provide a launch-pad for running malicious scripts. Denying the ability to run frames can close of this attack vector.

The following Ioto directive will prevent frames or iframes from running in the web page.

```http
Header set X-Frame-Options deny
```

```js
headers: {
    "X-Frame-Options": "deny",
}
```

## High Profile Threats

There have been several high profile exploits that pose specific risks and have captured media attention. These are addressed specifically below with details on how to mitigate their effects.

## Crime Exploit

The <a href="http://en.wikipedia.org/wiki/CRIME_(security_exploit)">Crime Security Exploit</a> attacks and exploits leakage of information due to the varying effectiveness of TLS compression.

* Access to intercept and redirect client communications
* Ability to initiate requests from the client
* Encrypted communications TLS/SSL
* TLS level compression

By default, Ioto does not use TLS with TLS compression and is thus not vulnerable to this exploit. If you are using OpenSSL, the OpenSSL SSL_COMP_add_compression_method will enable TLS compression, so it is important not to use this OpenSSL API.

## Breach Exploit

The <a href="http://breachattack.com">Breach</a> exploit is a variant of the Crime exploit. It attacks and discovers private server information, such as CSRF tokens, by observing the compression of HTTP responses over TLS. This exploit requires the following to be effective:

* Access to intercept and redirect client communications
* Ability to initiate requests from the client
* Encrypted communications TLS
* Server-side encryption of dynamic responses
* Unmodified inclusion in the response body of client specified query or form data

Ioto does not dynamically compress response content and so is not vulnerable to this exploit.

## Beast Exploit

The <a href="http://en.wikipedia.org/wiki/BEAST_(computer_security)#BEAST_attack">Beast Security Exploit</a> attacks block ciphers used by TLS to access encrypted packets. This exploit requires the following to be effective:

* Use of TLS 1.0. This exploit has been addressed in TLS 1.1 and later.
* Ability to position attacker as man-in-the-middle between server and client
* Encrypted communications TLS
* Using a block cipher.

Notes:

* OpenSSL 0.9.6d and later are not vulnerable.
* Ioto 3.3 and later have shipped with fixed OpenSSL libraries.
* Using RC4 will mitigate the attack if upgrading OpenSSL is not feasible, however this cipher is vulnerable to the Luck 13 exploit described below.

## Lucky 13 Exploit

The <a href="http://www.isg.rhul.ac.uk/tls/TLStiming.pdf">Lucky 13</a> exploit attacks TLS by using varying padding for block ciphers.

This exploit requires the following to be effective:

* Ability to position attacker as man-in-the-middle between server and client
* Encrypted communications TLS
* Using a block cipher.
* Use of the RC4 cipher.

Notes:

* Mitigate by not using an RC4 cipher
* RC4 was not the default cipher in any Ioto release

## Documented Vulnerabilities

Ioto documents discovered security issues in the Builder product security center.

Go to the [Builder Products List](https://admin.embedthis.com/product) to see the product list and product security center.

Specific issue reports are created for all confirmed or erroneous security reports that receive a CVE classification. 

## Other Security References

Some of these articles may provide good background regarding security web servers.

* <a href="http://www.isg.rhul.ac.uk/tls/TLStiming.pdf">http://www.isg.rhul.ac.uk/tls/TLStiming.pdf</a>
* <a href="http://html5sec.org/">http://html5sec.org/</a>
* <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a>
* <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)</a>
* <a href="https://www.owasp.org/images/b/be/Cracking-into-embedded-devices-and-beyond.pdf">https://www.owasp.org/images/b/be/Cracking-into-embedded-devices-and-beyond.pdf</a>
* <a href="http://media.blackhat.com/bh-ad-11/Sutton/bh-ad-11-Sutton_Embeded_Web_Servers_WP.pdf">http://media.blackhat.com/bh-ad-11/Sutton/bh-ad-11-Sutton_Embeded_Web_Servers_WP.pdf</a>
* <a href="http://www.imperialviolet.org/2012/07/19/hope9talk.html">http://www.imperialviolet.org/2012/07/19/hope9talk.html</a>
* <a href="https://www.owasp.org/images/b/be/Cracking-into-embedded-devices-and-beyond.pdf">https://www.owasp.org/images/b/be/Cracking-into-embedded-devices-and-beyond.pdf</a>


## Ioto Secure By Default

Ioto is designed to be secure by default. This means that the default configuration enables security best-practices to limit cross-site-scripting vulnerabilities. It also implies a fairly restrictive security sandbox. This default configuration may be a little too restrictive for your application. In that case, you can easily remove or override these defaults by the relevant Ioto configuration properties.

Ioto uses the following built-in configuration for the default route.

```js
{
    headers: {
        "X-XSS-Protection": "1; mode=block",
        "X-Frame-Options": "deny",
        "X-Content-Type-Options": "nosniff",
        "Content-Security-Policy": "default-src 'self'",
    }
    timeouts: {
        inactivity: "30 secs",
        parse: "5 secs",
        request: "5 mins",
        session: "5 mins",
    }
    limits: {
        body:               "100K",
        connections:        50,
        form:               "10K",
        header:             "10K",
        sessions:           20,
        upload:             "1MB",
    }
}
```

The default Content Security Policy header is set to only permit content loaded from the server running ioto. It also bans inline scripts as these are vulnerable to inline script injection. See <a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/">An Introduction to Content Security Policy</a> for more information.
# Server WebSockets 

The Ioto web server supports WebSockets for bidirectional, full-duplex communications over persistent TCP/IP connections. A WebSocket connection is established over a standard HTTP connection using a GET request and is then upgraded without impacting the original connection. 

Read the [WebSockets Library](/agent/websockets/) for background first.

## Configuration

To configure WebSockets in the web server, define a request route for web sockets requests. This route ill use a unique URI prefix for WebSocket communications and configure the `action` handler to be invoked upon receipt of a connection requeset.

```
routes: [
    { match: '/upload/', methods: ['DELETE', 'GET', 'PUT'] },
    { match: '/ws/', methods: ['GET'], handler: 'action' },
    { /* Catch all */ },
],
```

WebSockets is configured via several `web.json5` configuration directives.

Path | Default | Description
-|-|-
limits.maxMessage | MAXINT | Define the maximum message size.
limits.maxFrame | 131072 | Define the maximum frame size.
webSockets.ping | none | Define the ping keep-alive message frequency.
webSockets.protocol | chat | Define the application-level sub-protocol.
webSockets.validateUTF | true | Enable validation of UTF8 message.

When WebSockets messages are sent, they may be divided into frames. On receipt, the client will aggregate into a unified message.

## API Quick Tour

This is a quick tour of the WebSockets server API.

When a WebSockets connection request is received by the Ioto web server, the HTTP `upgrade` header will instruct Ioto to upgrade the connection to use WebSockets.

To respond to the connection, you should define an `action` routine to be invoked when the connection is established. To define the action function, specify the request URL and provide the function to invoke. This definition should be placed in your Ioto `ioStart` routine.

```c
webAddAction(host, "/test/websockets", myAction, NULL);
```

When a WebSockets request is received, your `myAction` function will be invoked:

```c
static void myAction(Web *web)
{
    webAsync(web, onRead, web);
    //  Run web sockets until closed and invoke onEvent for each incoming message and event
    if (webWait(web, onEvent) < 0) {
        //  Error
    }
    // Closed
}
```

The `webAsync` routine defines a callback routine to invoke for incoming WebSocket messages, errors and connection events. The `webWait` routine blocks until the WebSocket connection is closed.

If the connection is closed, `webWait` will return a value <= 0. If less than zero, the socket was closed due to an error. If the API returns zero, the connection has been orderly closed.

```c
void onEvent(WebSocket *ws, int event, char *buf, ssize len, void *arg)
{
    switch (event) {
    case WS_EVENT_OPEN:
    case WS_EVENT_CLOSE:
    case WS_EVENT_ERROR:
        break;

    case WS_EVENT_MESSAGE:
    case WS_EVENT_PARTIAL_MESSAGE:
        printf("Received %s\n", buf);
        webSocketSend(ws, "%s", "Response message");
        break;
    }
}
```

To send a message to the peer, use `webSocketSend`:

```c
//  Send a message to the client
webSocketSend(web->webSocket, "WebSocket connected");
```

To close the connection, you can call `webSocketSendBlock` with a close message type.

```c
webSocketSendClose(web->webSocket, status, reason);
```

or alternatively, call `webFinalize` which will close the HTTP connection and the WebSocket connection.

```c
webFinalize(web);
```

## Keep Alive

To keep a communications channel alive, it is sometimes necessary to send regular messages to indicate the channel is still being used. Some servers, browsers, or proxies may close an idle connection. The Ping/Pong WebSockets messages are designed to send non-application-level traffic that will prevent the channel from being prematurely closed.

Automatic ping message can be sent from the web server by setting the `webSockets.ping` directive to the desired frequency. For example:

```json5
webSockets {
    ping: "1min"
}
```

## Timeouts

The standard Ioto request and inactivity timeouts can be used for WebSocket communications by defining the `timeouts.request` and `timeouts.inactivity` web.json5 directives. These are the same request and inactivity timeouts used for ordinary requests. 

You can extend the timeouts by calling `webUpdateDeadline` in your `onRead` callback whenever a message is received or sent.

```
timeouts: {
    inactivity: '5 mins',
    request: '1 hour',
},
```

## API

* [WebSockets API](/agent/ref/api/websockets.md)

## References

- [RFC 6455](http://tools.ietf.org/html/rfc6455) - The WebSockets Protocol
- [WebSocket API](http://dev.w3.org/html5/websockets/) - The Javascript WebSockets API
- [WebSockets Wikipedia](http://en.wikipedia.org/wiki/WebSocket) - WebSockets Wikipedia# Growable hash table

Simple hash table that can store arbitrary objects associated with string names.

## API Quick Tour

To create a hash table:

```c
RHash *table = rAllocHash(size, 0);
```

To free the table:

```c
rFreeHash(table);
```

To add a name and value to the hash:

```c
RName *name = rAddName(table, "some-name", value, flags);
```

To lookup a name, use:

```c
void *value = rLookupName(hash, "some-name");
```

To remove a name, use:
```c
rRemoveName(table, "some-name");
```

To iterate over hashed names:

```c
RName *item;
for (ITERATE_NAMES(table, item)) {
    printf("Item %s has value %s", item->name, item->value);
}
```
# File

Ioto provides some simple helper functions to read and write files.

To read a file in one go:

```c
ssize   size;

char *data = rReadFile("file.txt", &size);
```

To write a file:

ssize length = rWriteFile("file.txt", data, dataLen, 0644);
```c

```

To get the current working directory:

```c
char dir = rGetCwd();
```

To get the base directory containing the application executable:

```c
char dir = rGetAppDir();
```


To join two file paths:

```c
PUBLIC char *rJoinFile(cchar *base, cchar *other);
```

To matach a file against a glob pattern. This tests a filename against a file pattern that list may contain the wildcards: "?" Matches any single character, "*" matches zero or more characters of the file or directory and "**"/ matches zero or more directories

```c
if (rMatchFile("file.text", "*.txt")) {
    //  Matches
}
```

To get a list of files in a directory or subdirectories that match the given wildcard pattern.

```c
RList *list = rGetFiles("/somedir", "*.txt", 0);
```

To walk a directory tree and invoke a callback for each path that matches a given pattern.

```c
rWalkDir("/dir", "*.txt", fn, arg, 0);
```

To get a temporary filename:

```c
char *path = rGetTempFile("/tmp", "TEMP-");
```

This returns a temporary filename in /tmp starting with the "TEMP-" prefix.
# String

The Ioto runtime provides a suite of "safe" string handling routines.

These help guard against buffer overflows and NULL dereferencing errors.

The strings are all NULL tolerant and will not crash when passed NULL arguments. For example, copying a NULL string will return an empty string and searching for a pattern in a NULL string will return false.

The string routines all use a "s" prefix.

## API Tour

There are many (many) runtime string routines. Here is a short sampling:

Search for a character in a string (strchr):

    char *ptr = schr(str, '\n');


Clone (duplicate) a string (strdup):

    char *ptr = sclone(str);

Get the length of a string (strlen):

    ssize length = slen(str);

Check if a string contains a pattern (strstr):

    char *ptr = scontains(str, "abc");

Format a string (sprintf):

    char *str = sfmt("Hello %s", "world");

Join two strings

    char *result = sjoin("one", "two", NULL);

Get a title case string (Leading cap):

    char *str = stitle("pool")

Trim a string of certain characters:

    char *trimed = strim(str, " \t\n\r", R_TRIM_BOTH);


## API Reference

The full API is specified here:

[String API](/agent/ref/api/r.md#rstring)
# Sockets

The Ioto agent provides a cross platform Socket abstraction to make network programming easier and simpler.

The Socket API is fiber aware in that blocking API calls will transparently resume other waiting fibers while waiting for I/O. This enables a simple, straight-line procedural programming style without ugly callbacks or complex threads. See [Fiber Coroutines](../dev/fiber.md) for more details.

All the socket APIs must be called from a fiber.

## API Tour

First you need a socket object. To allocate a socket object:

```c
RSocket *sock = rAllocSocket();

//  and to free

rFreeSocket(sock);
```

### Connecting

To connect to a host or IP address:

```c
int status = rConnectSocket(sock, "www.example.com", 80, 0);
if (status < 0) {
    //  error connecting
}
```

### Listening for Connections
To listen for connections:

```c
rListenSocket(sock, NULL, 80, connectionHandler, data);
```

The second argument is the IP address(s) on which to bind. If NULL, the socket listens on all interfaces.


### Testing the Socket

To test if the socket is closed:

```c
if (rIsSocketClosed(sock)) {
    //  Socket is closed
}
```


To test for end-of-file. i.e. if the peer has closed the other end of the socket:

```c
if (rIsSocketEof(sock)) {
    //  No more data
}
```


To determine if a socket is using TLS. i.e. is secure:

```c
if (rIsSocketSecure(sock)) {
    //  Connection is using TLS
}
```


### Closing the Socket

To close a socket:

```c
rCloseSocket(sock);

//  Still need to free the socket resources
rFreeSocket(sock);
```

### Reading Data

To read from a socket. The read call will return with whatever bytes are available. If none is available, this call will block and yield the current fiber and resume another fiber. When data is available, the call will resume.

```c
ssize count = rReadSocket(sock, buf, sizeof(buf), deadline);

The last argument to rReadSocket (and some other Socket APIs) is a deadline. This is time at which the read request should be aborted. Note: this is not a timeout value, but rather a time value.

Use the following to get a deadline of 30 seconds.

```c
Time deadline = rGetTime() + (30 * 1000);
```

Set the deadline to zero to use the Ioto default deadline timeout which is infinite.

### Writing Data

To write to a socket:

To write a block of data to a socket, use rWriteSocket. If the socket is in non-blocking mode (the default), the write may return having written less than the required bytes. If no data can be written, this call will yield the current fiber and resume another fiber. When data is available, the call will resume.

```c
ssize count = rWriteSocket(sock, buf, bufSize, deadline);
```


### Using TLS
To configure the socket TLS certificates, use rSetSocketCerts:

```c
rSetSocketCerts(socket, privateKey, certificate, authority, revoke);
```

To select the preferred ciphers:

```c
rSetSocketCiphers(sock, cipherList);
```

To control how the Socket will verify peers:

```c
rSetSocketVerify(sock, verifyPeer, verifyIssuer);
```

## API Reference

The full API is specified here:

[Socket API](/agent/ref/api/r.md#rsocket)
# Buf - Dynamic Buffer Module

The RBuf module is a flexible, dynamic growable buffer structure that is ideal as a network and file buffer.

RBuf has start and end pointers to the data buffer which act as read/write pointers. Routines are provided to get and put data into and out of the buffer and automatically advance the appropriate start/end pointer. By definition, the buffer is empty when the start pointer == the end pointer.

Buffers can be created with a fixed size or can grow dynamically as more data is added to the buffer.

For performance, the specification of RBuf is deliberately exposed. All members of RBuf are implicitly public. However, it is still recommended that wherever possible, you use the accessor routines provided.

## Features

* Dynamically growable memory buffer
* Routines to get references to start and end pointers
* Option to null terminate the buffer
* Formatted add to buffer

## RBuf

The RBuf definition is:

```c
typedef struct RBuf {
    char *buf;      /**< Actual buffer for data */
    char *endbuf;   /**< Pointer one past the end of buffer */
    char *start;    /**< Pointer to next data char */
    char *end;      /**< Pointer one past the last data character */
    ssize buflen;   /**< Current size of buffer */
} RBuf;
```

## API Quick Tour

To create a buffer with an initial size. Set the size to zero for a default size of 4K.

```c
#include "r.h"

RBuf *buf = rAllocBuf(initialSize);

// and to free the buffer

rFreeBuf(buf);
```

To add data to the buffer. It will automatically grow as required.
```c
rPutStringToBuf(buf, "Hello World");
rPutFmtToBuf(buf, "My favorite number is %d", 42);
rPutBlockToBuf(buf, data, dataLen);
```

To get the buffer length

```c
ssize length = rGetBufLength(buf);
```

Note: ssize is a typedef from "osdep.h" for ssize_t which is a 64-bit signed quantity.

To add a NULL character to the buffer without moving the end pointer. i.e.

```c
rAddNullToBuf(buf, data, dataLen);
```

To explicitly grow the buffer:

```c
rGrowBuf(buf, 8000);
```

To see how much space is available in the buffer. This is (endbuf - end).

```c
ssize available = rGetBufSpace(buf);
```

To get a reference to the end of the buffer:

```c
cchar *ptr = rGetBufEnd(buf);

//  and to the start
ptr = rGetBufStart(buf);
```

To adjust the start or the end:

```c
rAdjustBufEnd(buf, amount);
rAdjustBufStart(buf, amount);
```

To copy data out of the buffer, reference the start pointer and adjust:

```c
ssize count = rGetBufLength(buf);
memcpy(rGetBufStart(buf), count);
rAdjustBufEnd(buf, count);
```

To empty the buffer:

```c
rFlushBuf(buf);
```

## API Reference

The full API is specified here:

[Buf API](/agent/ref/api/r.md#rbuf)
# List

The RList module is a simple growable list suitable for storing simple primitive data values or pointers to arbitrary objects.

## API Tour

To create a list:

```c
#include "r.h"

RList *list = rAllocList(initialSize, flags);
```

Lists can be created so that when the list is freed, each of the list items will also be freed.
If the `flags` are set to R_DYNAMIC_VALUE, then rFree() will be called on each list item when the list is freed. If the flags are set to R_STATIC_VALUE (the default), then list items will not be freed.

To free a list:

```c
rFreeList(list);
```

To add an item to the end of the list:

```c
rAddItem(list, myObject);
```

To clear the list:

```c
rClearList(list);
```

To get the number of items in the list:

```c
ssize length = rGetListLength(list);
```

To iterate over items in a list:

```c
void *item;
int index;
for (ITERATE_ITEMS(list, item, index)) {
    //  Process item
}
```

ITERATE_ITEMS is defined as:

```c
#define ITERATE_ITEMS(list, item, index) \
    index = 0; \
    list && index < list->length && ((item = list->items[index]) || 1); \
    index++
```

To get an item from the list at a specific index position:

```c
int index = 4;
rGetItem(list, index);
```

To insert an item at a specific position. This will insert myObject at index 4.

```c
rInserItemAt(list, 4, myObject);
```

To remove an item:

```c
rRemoveItem(list, myObject);

//  or remove at an Index
rRemoveItemAt(list, 4);
```

To grow a list:

```c
rGrowList(list, 1000);
```

To push and pop items:

```c
rPushItem(list, item);
item = rPopItem(list);
```

## API Reference

The full API is specified here:

[List API](/agent/ref/api/r.md#rlist)
# Thread

Ioto is single threaded and uses fiber coroutines for parallelism. Ioto is not thread safe and you cannot call Ioto APIs from program threads without ensuring all access to Ioto data structures are serialized via thread locks.

Ioto provides a cross platform thread library so you can create threads and implement appropriate locks.

NOTE: this is not a recommended design pattern. It is simpler, faster and more reliable to use fiber coroutines that to use threaded programming.

# API Tour

## Locking

To create a lock:

    RLock *lock = rAllocLock();

and to free a lock

    rFreeLock(lock);

To assert a lock, use **rLock**. This will block the current thread until resumed.

NOTE: do not use this call in a fiber.

    rlock(lock);

To unlock:

    runlock(lock);

To try for a lock without waiting or blocking:

    if (rTryLock(lock)) {
        //  Got the lock
    }

## Spin Locks

Ioto also provides spin locks which may be faster on some operating systems:

```c
rSpinLock(lock)
rSpinUnlock(lock)
```


## API Reference

The full API is specified here:

[Buf API](/agent/ref/api/r.md#rbuf)
# Logging Trace

If you are using a dedicated device cloud running in your AWS account, Ioto provides a convenience wrapper to make uploading log files to AWS CloudWatch logs easier.

The purpose of the error log is to record essential configuration and error conditions. Per-request log typically is sent to a separate log.

The default log file captures log messages issued throughout the various Ioto modules and writes them to the default log file. Log typically is enabled in both debug and release builds and may be controlled via the build compile define ME_R_LOGGING which is typically set to true.

Log messages should be a single text line to facilitate machine processing of log files.

## API Tour

To write an informational log message to the error log file.

```c
rlog("info", "my-module", "Log message: %s", "Hello World");
```

The Ioto runtime defines four convenience routines for logging:

```c
rDebug("my-module", "Status code at %d is %d", __LINE__, status);
rError("my-module", "Bad error: %d", code);
rFatal("my-module", "Insufficient resources, cannot continue");
rInfo("my-module", "Connected to server");
rTrace("my-module", "Active user count %d", count);
```

The convenience routines wrap rlog() and supply the first argument which is the message type. You can create custom types just by using them with rlog(). These standard types are provided: debug, error, fatal, info and trace.

The debug type is for trace trace that should only be emitted in debug builds. The fatal type will cause Ioto to immediately exit. Trace is for more verbose messages that are not emitted by default in production builds but can be enabled at runtime.


### Changing Levels

To change which messages are emitted by Ioto, you can define the log filters via the Ioto command line and via the **rSetLog** API.

To change the default Ioto log trace settings, customize the **ioto.json5** **trace** property:

```js
trace: {
    path: '/var/log/ioto.log',
    format: '%D %H %A[%P] %T %S %M',
    types: 'error,info',
    sources: 'all',
}
```

See the [Trace Configuration](../user/properties.md#trace) for details.

You can also change trace levels via the command line. This will override the **ioto.json5** trace settings. See the [Ioto Trace Command Line](../user/running.md#logging-and-tracing) for information.

Via the API, you can override log settings:
```c
rSetLog("/tmp/newlog.out:all:all", "%D %H %A[%P] %T %S %M", 1);
```

This will direct log output to newlog.out for all types and all sources.

### Log Handlers

You can also override Ioto's log handling and define your own log handler routine that will be invoked to process log messages.

```c
rSetLogHandler(myLogHandler);
```

This routine will be invoked for all log messages with the type, source and message parameters.


## API Reference

The full API is specified here:

[Log API](/agent/ref/api/r.md#rlog)
# Ioto Safe Runtime (R)

Ioto is built upon a safe portable runtime (R). This layer insulates the rest of Ioto from the underlying platform and allows it to be highly portable to new operating systems or hardware.

![Ioto Architecture](/images/ioto/ioto-agent.png)

The safe runtime provides a suite of services that facilitate the creation of high performance, non-blocking management applications by providing: fiber coroutines, lists, hashing, safe strings, buffering, timers, events, networking, buffer management and JSON parsing.

The safe runtime provides a more secure environment in which to program as it replaces 'C' APIs that are prone to buffer overflows and other similar security exploits. The safe runtime includes a fast, safe string library that supports a secure programming style.

# Ioto Types

The Ioto Agent uses an operating system dependent layer called "osdep".

By including "osdep.h", you gain access to these cross-platform types. Some types are implemented natively on some platforms and others are provided by "osdep".


## Quick Tour

Here are some primitive data types:

```c
bool   b;
int8   i8;
int16  i16;
int32  i32;
int64  i64;
uint8  u8;
uint16 u16;
uint32 u32;
uint64 u64;
schar  c;      //  Signed char
uchar  c;      //  Unsigned char
cchar  c;      //  Const char
cuchar  c;     //  Const unsigned char
```

Other useful types:

```c
ssize   length;     //  64-bit signed length
Time    time;       //  Time in milliseconds since Jan 1, 1970
Ticks   ticks;      //  Elapsed time in system millisecond ticks (never goes backwards)
```

For a full list of the osdep types, see: [OSDEP API](/agent/ref/api/osdep.md)


## Return Values

Many Ioto APIs return an integer value that is zero for success and otherwise set to a negative error code.

Here are the return codes used by the Ioto runtime:

```c
#define R_ERR_OK              0
#define R_ERR_BASE            -1
#define R_ERR                 -2
#define R_ERR_ABORTED         -3
#define R_ERR_ALREADY_EXISTS  -4
#define R_ERR_BAD_ACK         -5
#define R_ERR_BAD_ARGS        -6
#define R_ERR_BAD_DATA        -7
#define R_ERR_BAD_FORMAT      -8
#define R_ERR_BAD_HANDLE      -9
#define R_ERR_BAD_NULL        -10
#define R_ERR_BAD_REQUEST     -11
#define R_ERR_BAD_RESPONSE    -12
#define R_ERR_BAD_SESSION     -13
#define R_ERR_BAD_STATE       -14
#define R_ERR_BAD_SYNTAX      -15
#define R_ERR_BAD_TYPE        -16
#define R_ERR_BAD_VALUE       -17
#define R_ERR_BUSY            -18
#define R_ERR_CANT_ACCESS     -19
#define R_ERR_CANT_ALLOCATE   -20
#define R_ERR_CANT_COMPLETE   -21
#define R_ERR_CANT_CONNECT    -22
#define R_ERR_CANT_CREATE     -23
#define R_ERR_CANT_DELETE     -24
#define R_ERR_CANT_FIND       -25
#define R_ERR_CANT_INITIALIZE -26
#define R_ERR_CANT_LOAD       -27
#define R_ERR_CANT_OPEN       -28
#define R_ERR_CANT_READ       -29
#define R_ERR_CANT_WRITE      -30
#define R_ERR_DELETED         -31
#define R_ERR_MEMORY          -32
#define R_ERR_NETWORK         -33
#define R_ERR_NOT_CONNECTED   -34
#define R_ERR_NOT_INITIALIZED -35
#define R_ERR_NOT_READY       -36
#define R_ERR_READ_ONLY       -37
#define R_ERR_TIMEOUT         -38
#define R_ERR_TOO_MANY        -39
#define R_ERR_WONT_FIT        -40
#define R_ERR_WOULD_BLOCK     -41
#define R_ERR_MAX             -42
```

## NULL Tolerance

Ioto adopts a technique call NULL tolerance where APIs, wherever possible, tolerate NULL arguments and attempt to do something reasonable with their arguments, rather than crashing the applications.

The standard C library is not NULL tolerant. If you pass a NULL pointer to routines such as as free() or strlen() your program will crash.

The Ioto memory allocator is NULL tolerant when calling **rFree**. Similarly, Ioto provides a safe string library that will accept NULL arguments wherever possible. In the case of strlen, Ioto provides **slen()** which will return zero if passed a NULL pointer.
# Time

Ioto provides a suite of time management routines to help format, parse and manage time values.

Ioto stores calendar time in **Time** values that store the date/time as elapsed milliseconds since Jan 1, 1970. Time values may go backwards if the system date clock is adjusted.

Ioto stores system time in **Ticks** values that are a system representation of elapsed time in milliseconds. Ticks will never go backwards even if the system date clock is adjusted.

## API Tour

To get the current time:

    Time time = rGetTime();

To get the current time in ticks:

    Ticks ticks = rGetTicks()

To get a high resolution CPU tick counter on some systems:

    uint64 rGetHiResTicks();

To convert the time to a string local time representation:

    char *str = rFormatLocalTime("%a %b %d %T %Y %Z", time);

To convert to universal time:

    char *str = rFormatUniversalTime("%FT%TZ", time);

To get a local string representation of the current date:

    char *str = rGetDate(NULL);

To get an ISO format date:

    char *str = rGetIsoDate(time);

To get the elapsed time since a prior measurement:

    Ticks elapsed = rGetElapsedTicks(mark);

To get the remaining ticks until a timeout:

    Ticks remaining = rGetRemainingTicks(mark, timeout);

To parse an ISO date string:

    Time time = rParseIsoDate(isoDateString);

## API Reference

The full API is specified here:

[Time API](/agent/ref/api/r.md#rtime)
# Event

R provides a simple eventing mechanism to schedule events to run at some time in the future.

Events are described by REvent objects which are created and queued via #rCreateEvent. Events are scheduled once unless restarted via rRestartEvent.

## API Tour

To create an event to run a function at some delay in the future.

```c
Ticks delay = 1000;
REvent event = rCreateEvent(fn, data, delay);
```

This will run the fn() function in 1 second and pass the reference data as an argument.

```c
void fn(void *data) {
    //  Do something
}
```

The rCreateEvent API will return an event ID that can be used to cancel the event before it is run by calling **rStopEvent**.

```c
rStopEvent(event);
```

You can lookup an event to see if it is scheduled:

```c
if (rLookupEvent(event)) {
    //  scheduled
}
```

## Running Events

The Ioto main program calls the **rServiceEvents()** API to run scheduled events as they come due.

This call will call rRunEvents() to run due events and then wait via **rWait** for any pending I/O.

If you replace the Ioto main program, you must call rServiceEvents in your main.

## Watching for Conditions

You can watch for certain conditions to happen and be notified when they do. For example, it can be useful to be notified when the network connects or disconnects to the cloud.

To watch for a condition:

```c
rWatch("mqtt:connect", fn, data);
```

To then signal a condition, call:

```c
rSignal("mqtt:connect", arg);
```

This will invoke fn() with the watch data and the signal argument.

```c
void fn(void *data, void *arg) {
    //  Do something
}
```

To disable watching, call:

```c
rWatchOff("mqtt:connect", fn, data);
```

This will disable the watch registered with exactly the same arguments.
# Use Cases

The Ioto device agent can be utilized in a variety of use cases:

- [IoT Cloud Agent](#iot-cloud-agent)
- [HTTP Client](#http-client)
- [Local Device Management](#local-device-management)
- [Embedded Web Server](#embedded-web-server)
- [MQTT Client](#mqtt-client)

## IoT Cloud Agent

Device management via the cloud typically requires the MQTT protocol and an understanding of the MQTT topics supported by cloud provider.

The Ioto agent is pre-integrated with the AWS Cloud and is easily configured to enable MQTT communications with AWS IoT Core.

Ioto supports a wide set of AWS services including: DynamoDB, IoT Core rules, IoT Shadows, S3, CloudWatch Logs, and CloudWatch metrics. Using IoT rules, you can also direct messages and data to many other AWS services.

The Ioto agent can:

- Send messages to AWS IoT and other services via MQTT.
- Upload data and files to AWS S3.
- Replicate structured device data to and from AWS DynamoDB.
- Send control-plane data to AWS IoT Shadows.
- Store Ioto, device and O/S logs in AWS CloudWatch logs.
- Create device and operational metrics in AWS CloudWatch Metrics.
- Save audit trails to AWS CloudTrail.

### Replicated Device Data

Ioto can replicate device data from its internal embedded device database to an AWS DynamoDB database in the cloud. This replication can operate in either direction so that data can be either sent to devices or aggregated from devices.

This replication is reliable and transparent and the device developer does not need create any custom code to implement. The replication is configurable and granular on a table-by-table basis, and is resilient in the event of network outages.

## HTTP Client

Ioto includes a streaming HTTP Client so you can make REST and HTTP requests to external web services.

The API provides a simple GET and POST routines and a powerful fully streaming fetch call.

As Ioto uses fiber coroutines, you can process streamed data (in either direction) without ugly callbacks or complex threads. Other fibers in Ioto continue to run transparently while the HTTP client is waiting for I/O.

Ioto uses the HTTP client to communicate with the EmbedThis Builder site and various AWS services. Ioto includes AWS SigV4 signing APIs so you can issue any AWS API using the HTTP client without requiring the significant overhead of the full AWS SDK.

### Example
```c
//  Simple get
data = urlGet("https://www.example.com");

//  Simple post
data = urlPost("https://www.example.com", "POST", body, bodyLen,
    "Authorization: bearer %s\r\n", authToken);

//  Or fully streaming fetch
char  buf[1024];
ssize nbytes;
int   status;

status = urlFetch(up, "https://www.example.com", "POST", body, bodyLen, headers);
do {
    if ((nbytes = urlRead(up, buf, sizeof(buf))) > 0) {
        printf("%s", buf);
    }
} while (nbytes > 0);
```

## Local Device Management

Embedded web servers are useful for a variety of use cases including:

* Local end-user device setup and ongoing management.
* Provide a programatic REST API for device operation, data and metrics.
* Provide a debug web interface for developers creating connected devices.

## Embedded Web Server

The Ioto agent can be used as a stand-alone embedded web server without any cloud management features enabled.

Ioto can be configured and compiled to run only the web server and thus be a first-class replacement for any embedded web server. EmbedThis has been developing embedded web servers for many years and the Ioto web server contains all that we have learned over this period.

>*Ioto is our best embedded web server with performance and security that surpasses other web servers.*

The Ioto web server is unlike other embedded web servers in that it does not try to offer *ALL* HTTP features and functions. Rather, it implements only the essential core of HTTP/1.1 and thus deliver a tiny, fast, secure embedded web server that is exceptionally good at serving single-page device management web applications and device data APIs with a very small security footprint.

The Ioto web server supports: HTTP/1, HTTP/1.1, TLS/SSL, Action routines, user authentication, sessions, cookie management, request logging, and security sandboxing. Best of all, Ioto is tiny using only 80K of code. It will serve over 3,300 requests/sec on a Raspberry PI class of device.

The Ioto web server is fully streaming for receive and transmit data. It can receive live streaming data and dynamically generate responses based on device data.

### Example
```c
//  Bind a URL to a function to generate the response

webAddAction(host, "/test", testAction);

//  Invoked for /test requests
static int testAction(Web *web)
{
    char  buf[ME_BUFSIZE];
    ssize nbytes;
    int   i;

    //  Streaming read of POST body data
    while ((nbytes = webRead(web, buf, sizeof(buf))) > 0) {
        printf("Got body data %.*s\n", (int) nbytes, buf);
    }

    //  Streaming a response without buffering and with minimal memory footprint
    for (i = 0; i < 10000000; i++) {
        //  This will block as required, but other fibers can still run.
        webWriteFmt(web, "Hello World, now is: %s\n", rFormatLocalTime(0, 0));
    }
    //  Finalize
    webWrite(web, NULL, 0);
    return 0;
}
```

![Ioto Web Server](/images/ioto/web-server.png)

For more details, please read the [Ioto Web Server](../web/).

## MQTT Client

Most IoT cloud management services rely on the [MQTT](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html) protocol.

MQTT is a light-weight client/server publish/subscribe messaging transport protocol. It is simple and has very low overhead and this makes it ideal for use in embedded devices and IoT where a small code footprint and minimal network overhead is required.

For a device to be managed by the cloud requires not only MQTT support, but also an understanding of what MQTT topics are required to integrate with the specific cloud provider.

Ioto has a high-performance, flexible MQTT client that can be used to communicate with any cloud service supporting MQTT 3.2.1.

The Ioto MQTT agent is non-blocking, but also supports a blocking mode where you can wait for a message to be acknowledged or receipt of a response. This enables the MQTT protocol to be used for request/response APIs. Because, Ioto uses fiber coroutines, even when an MQTT sequence of operations are blocking, other APIs and services continue to run in other fibers.

```c
PUBLIC int ioStart(void)
{
/*
    Subscribe for incoming notifications.
    This call will block and wait for acknowledgement.
    Note: call blocks, but agent is not.
 */
mqttSubscribe(ioto->mqtt, incoming, MQTT_QOS_2, MQTT_WAIT_ACK, "/myDevice/change");

/*
    Publish an "initialized" message with quality of service (1) which means send at most once.
    Don't wait for sending or acknowledgement.
 */
mqttPublish(ioto->mqtt, "Initialized", 0, MQTT_QOS_1, MQTT_WAIT_NONE, "/myDevice/init");
```
# WebSockets

[WebSockets](http://en.wikipedia.org/wiki/WebSocket) is a technology providing interactive communication between a server and client. It is an IETF standard defined by [RFC 6455](http://tools.ietf.org/html/rfc6455).

Normal HTTP connections follow a request/response paradigm and do not easily support asynchronous communications or unsolicited data pushed from the server to the client. WebSockets solves this by supporting bidirectional, full-duplex communications over persistent TCP/IP connections. A WebSocket connection is established over a standard HTTP connection using a GET request and is then upgraded without impacting the original connection. This means it will work with existing networking infrastructure including firewalls and proxies.

WebSockets is currently supported in the current releases of all major browsers, including Chrome, Brave, Firefox, Edge, Opera, and Safari.

## Ioto Implementation

Ioto implements WebSockets for both the HTTP web server and for the URL HTTP client. The WebSockets library implements the core WebSockets protocol, handshaking, and provides a C language API. The `web`library accepts incoming HTTP connections and upgrades WebSockets requests via to use the WebSockets protocol. Similarly, the `url`library provides APIs to initiate WebSockets connections via a HTTP client GET request and it then upgrades that connection to use the WebSockets protocol.

The `url` client program supports WebSockets for load testing purposes.

## WebSocket Handshake

A WebSocket connection begins life as a normal HTTP request and is upgraded to the WebSocket protocol. For the web server, the WebSockets connection is activated by a set of WebSocket HTTP headers from the client that describes a desired WebSocket connection. Here is a typical client HTTP request requiring a WebSocket upgrade:

```
GET /websock/proto/msg HTTP/1.1
Host: example.com
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Protocol: chat, better-chat
Sec-WebSocket-Key: 50cLrugr7h3yAbe5Kpc52Q==
Sec-WebSocket-Version: 13
Origin: http://example.com
```

WebSockets constructs a handshake response that includes an accepted key and selected protocol. For example:

```
HTTP/1.1 101 Switching Protocols
Server: Embedthis-http
Date: Sat, 06 Oct 2014 05:10:15 GMT
Connection: Upgrade
Upgrade: WebSocket
Sec-WebSocket-Accept: 58ij/Yod1NTjzqcyjkZbZk6V6v0=
Sec-WebSocket-Protocol: chat
X-Inactivity-Timeout: 600
X-Request-Timeout: 600
```

After the handshake message has been sent, the server is free to send messages to the client. Once the client receives the handshake, it can send messages to the server. Either side can send at any time thereafter. Communications are thus full-duplex.

## Message Types

WebSockets supports several message types:

- Text in UTF-8
- Binary
- Close
- Ping/Pong

### Text Messages

Text messages must be valid UTF-8 strings. The receiving peer will validate and reject non-conforming strings. However, Ioto can be configured to accept invalid UTF-8 strings via the `validate` Ioto directive in the web.json5 configuration file.

### Binary Messages

Binary messages allow the transmission of any content. Messages can be an arbitrary length up to the maximum specified by the WS_MAX_MESSAGE constant or the web.json5 `limits.maxMessage` directive.

When messages are transmitted, they may be divided into frames of no more than the length specified by the WS_MAX_FRAME constant or the web.json5 `limits.maxFrame` directive. Incoming message frames are not subject to this limit. WebSockets will aggregate message frames into complete messages before passing to the `onRead` callback.

### Close Message

Ordinarily, WebSocket communications are terminated by sending a *Close* message. The close message includes a status code and an optional *reason* string to explain why the connection is being closed.

### Ping/Pong Messages

To keep a communications channel alive, it is sometimes necessary to send regular messages to indicate the channel is still being used. Some servers, browsers, or proxies may close an idle connection. The Ping/Pong WebSockets messages are designed to send non-application-level traffic that will prevent the channel from being prematurely closed.

Automatic ping message can be sent from the web server by setting the `webSockets.ping` directive to the desired frequency. For example:

```json5
webSockets {
    ping: '1min'
}
```

## Timeouts

The standard Ioto request and inactivity timeouts can be used for WebSocket communications by defining the `timeouts.request` and `timeouts.inactivity` web.json5 directives.


## Web Server Configuration

See [Web Server WebSockets](/agent/web/websockets.md) for details on how to configure WebSockets in the web server.
See [URL Client](/agent/url/websockets.md) for details on how to configure WebSockets in the URL HTTP client.

## Quick Tour

See [URL Client WebSockets](/agent/url/index.html#api-quick-tour) for a quick tour of the WebSockets client API.

See [Web Server WebSockets](/agent/web/websockets.html#api-quick-tour) for a quick tour of the WebSockets client API.

## API

* [WebSockets API](/agent/ref/api/websockets.md)

## References

- [RFC 6455](http://tools.ietf.org/html/rfc6455) - The WebSockets Protocol
- [WebSocket API](http://dev.w3.org/html5/websockets/) - The Javascript WebSockets API
- [WebSockets Wikipedia](http://en.wikipedia.org/wiki/WebSocket) - WebSockets Wikipedia# Device Configuration

The **device.json5** configuration file contains device identification and descriptive properties to uniquely identify a device. It is used during device registration and cloud provisioning.

The device.json5 contains properties for:

* The device unique ID
* A product token indicating which product on which the device is based
* When the device was made
* Identifying description and model strings
* Whether the device is a test device

You can also add any other properties to the device.json5 that may provide useful device context. These properties will be saved in the cloud device database and will be available to device apps.

**Example**

```js
{
    id: "731KPY4BA6",
    product: "01GHTB33NJZXYZ1XA80GY5SZSN",
    name: "Acme Router",
    created: "2022-12-14T03:20:39.347Z",
    description: "Acme Router for Home Office",
    model: "Office-Hub",
    test: false,
    ports: 16,
    memory: "256MB"
}
```

## created

| Name | created |
|-|-|
| Description | An ISO date for when the device was manufactured. |
| Synopsis | `created: 'ISO Date'`.|

**Example**

```js
created: '2022-12-14T03:20:39.347Z'
```

## description

| Name | description |
|-|-|
| Description | A short description of your product. |
| Synopsis | `description: 'Short sentence'`|
| Notes | This should be a one sentence description of your product.|

**Example**

```js
description: 'Acme Router for Home Office'
```

## id

| Name | id |
|-|-|
| Description | The unique device claim ID. |
| Synopsis | `id: "Unique device ID"` |
| Notes | The <b>id</b> property defines a unique per-device ID. This must be a globally unique ID. This should have a minimum of 80-bits of entropy. For more information, see [Device Serialization](/ioto/provisioning/serialize.html).|

**Example**

```js
id: '731KPY4BA6'
```


## model

| Name | model |
|-|-|
| Description | A product model string. |
| Synopsis | `model: 'Short model string'`|
| Notes | This should be a short identifier that describes your device model type.|

**Example**

```js
model: 'Office-Hub-32'
```


## name

| Name | name |
|-|-|
| Description | The name of your product. |
| Synopsis | `name: 'Few words'`|
| Notes | This should be the short, public name of your product.|

**Example**

```js
name: 'Acme Rocket'
```

## product

| Name | product |
|-|-|
| Description | The product ID token is a Builder token that identifies the product on which the device was based. |
| Synopsis | `product: 'product-id'` |
| Notes | To obtain a product token, use the Builder to create a product definition and then get the **ProductID** token from the token list.|

**Example**

```js
product: '01GHTB33NJZXYZ1XA80GY5SZSN'
```


## test

| Name | test |
|-|-|
| Description | Determine if the device is a test device |
| Synopsis | `test: true | false`|
| Notes | This defaults to false.

**Example**

```js
test: true
```
# Supported Hardware

Ioto is highly portable and runs on a wide variety of operating systems, environment and CPU architectures.  

Ioto has been ported to:

* ESP32
* FreeBSD
* FreeRTOS
* Linux
* Mac OS X
* Quadros
* VxWorks
* Windows on WSL

on the following CPU architectures:

* arm
* arm64
* mips
* mips64
* ppc
* ppc64
* riscv
* riscv64
* tidsp
* sh
* x86
* x64 
* xtensa 

Ioto has also been ported by customers to many other environments including:

* QNX
* Quadros

When porting Ioto to a new environment, Ioto generally requires:

* Flash code storage for ~300K
* Flash file system for embedded database and configuration
* 1-2MB RAM on a 32-bit system that is cloud connected
* Network connection 

The code can be compiled to include only the required components. The size of the flash file system is determined by the size of your device data. The configuration files are typically < 25K.

The RAM requirements are dominated by the TLS package. A typically cloud-networked device will utilize TLS for security and will require 1-2MB of RAM.



## Supported CPU Architectures

### ARM Cortex-A7

Raspberry Pi 2 Model B (Rev 1.1)

Manufacturers:  Broadcom BCM2836

32-bit, quad-core Cortex-A7, commonly used in lower-power applications.

### ARM Cortex-A53

Raspberry Pi 3 Model B, Model B+, Raspberry Pi 2 Model B (Rev 1.2)
64-bit, quad-core Cortex-A53, used in the more powerful, power-efficient Pi models.

Manufacturers: Broadcom BCM2837

Raspberry Pi 3 Model A+. 64-bit, quad-core Cortex-A53, similar to the BCM2837 with slight differences in power management and packaging.

Manufacturers: Broadcom BCM2710A1


### ARM Cortex-A72

Raspberry Pi 4 Model B, Raspberry Pi 400
64-bit, quad-core Cortex-A72, providing substantial performance improvements, capable of running full desktop environments.

Manufacturers: Broadcom BCM2711

### ARM Cortex-A76

Raspberry Pi 5. 64-bit, quad-core Cortex-A76 paired with quad Cortex-A55 cores for big.LITTLE architecture, offering even higher performance with modern architecture.

Manufactuers: Broadcom BCM2712

### ARM Cortex-A15

Raspberry Pi 1 Model A, Model A+, Model B, Zero, Zero W
32-bit, single-core ARM11, based on the older ARMv6 architecture, making it compatible with lightweight applications.

Manufacturer: Broadcom BCM2835 (ARM11)

### ARM Cortex-M Series (M0, M0+, M1, M3, M4, M7, M23, M33, M35P)

Manufacturers: STMicroelectronics, NXP, Microchip (Atmel), Texas Instruments, Renesas, Cypress (Infineon), Silicon Labs, Nordic Semiconductor, GigaDevice, Dialog Semiconductor, Maxim Integrated, Particle, Arduino, Adafruit, SparkFun

### ARM Cortex-R Series (R4, R5, R7, R8)

Manufacturers: NXP, TI (Automotive/Industrial applications)

### ARM7 (ARM7TDMI)

Xtensa LX6/LX7 (32-bit)

Manufacturers: Espressif Systems (ESP32 series: ESP32, ESP32-S2, ESP32-S3, ESP-C)

### AVR32 UC3

Manufacturers: Microchip (Atmel)

### ColdFire V2, V3, V4

Manufacturers: NXP (legacy and industrial systems)

### RISC-V 32-bit

Manufacturers: SiFive, GigaDevice, Espressif (ESP32-C3)

### MIPS32 (32-bit)

Manufacturers: Microchip (PIC32 series)

### Renesas RX (RX100, RX200, RX600)

Manufacturers: Renesas Electronics

### Intel x86 (32-bit, 64-bit)

Manufacturers: Various # Downloading Ioto

Ioto releases are available as source code distributions from the [Builder Site](https://admin.embedthis.com). The Builder portal provides an integrated service for creating connected devices, downloading device software, creating and managing device clouds.

To use Builder, you need to register and create an account. This is a simple, one-time task that will take you just a few minutes.

To register, navigate to the Builder site [https://admin.embedthis.com](https://admin.embedthis.com), and enter your email address and desired password and click on the Register tab.  You will be sent an email confirmation code to complete your builder login.

If you have been invited to a Builder account by a co-worker, please click on the link in the invite email. That will ensure you become a member of the account that invited you.

## Downloading Ioto

To download the Ioto device agent, visit the **Products** page and click on the **Download** icon for the **Ioto Evaluation Product**. This will download the complete Ioto evaluatione source code package.

[Download Source Package](https://admin.embedthis.com)

In the future, you can create a product definition for your product, purchase a subscription and download the release software or any historical device agent version.

You can also download the [**Ioto Apps**](/apps/samples/building.md) package which is a suite of full device management apps.

## Extracting the Ioto Source Code

Copy the downloaded `ioto-eval-src.tgz` compressed tar archive to a suitable directory and extract the contents. This will place the ioto source in a `ioto-1.0.0` directory.

The eval source is a recent release and is always set to verion 1.0.0. It may not include all the latest features and patches that are present in the full release -- but it is ideal for evaluating Ioto.

```bash
$ tar xvfz ioto-eval-src.tgz
x ioto-1.0.0/EVAL.md
x ioto-1.0.0/LICENSE.md
x ioto-1.0.0/Makefile
...
```
# Cross-Compiling Ioto

Building Ioto for platform different to that of the local system is called **cross compiling**. Sometimes this compiling is just for a different instruction set (say x64 instead of x86). Other times, it is for a completely different operating system and/or CPU architecture. In such cases, a cross-compiler is typically required to build for the target platform.

To cross compile, you will typically need to install a cross-compiler tool chain for your target architecture. Once installed and before you attempt to build Ioto, it is best to test compiling a simple, stand-alone *HelloWorld* program to ensure the cross compiler is working correctly.

If you are targeting the popular [ESP32 Architecture](https://www.espressif.com/en/products/socs/esp32) please read the dedicated instructions [Building for ESP32](building-esp32.md).

If you are interested in porting Ioto to a new platform, please read [Porting Ioto](../dev/porting.md).

## Invoking Make

To cross-compile Ioto, invoke the relevant project makefile and pass the required CPU architecture as a make variable. For example, to cross compile for VxWorks on ARM:

```bash
$ make -f projects/ioto-vxworks-default.mk ARCH=arm PROFILE=debug
```

When the project makefile is invoked directly, it will place the output products (executables, libraries and objects) in a platform-specific output directory. This is named using the form: OS-ARCH-PROFILE. For example: vxworks-arm-debug. In this manner, make can be invoked multiple times, once for each target platform and the results will be captured in separate platform output directories. Some of the supported architectures for the ARCH field are:

```
arm, arm64, mips, mips64, ppc, ppc64, riscv, riscv64, sh, sparc, x64, x86 and xtensa.
```

The PROFILE variable is a descriptive name chosen by you for your configuration.

If there is not a makefile for your target operating system, copy the closest makefile and edit to suit your target platform. The project makefiles are generated and are thus highly regular and easy to modify.

## Specifying the CPU

The build will use the generic CPU type within the specified architecture. To override the default choice and specify a CPU type within an architecture, use the CPU variable. For example:

```bash
$ make OS=vxworks ARCH=arm CPU=arm7tdmi
```

## Specifying a Tool Chain

You may need to specify where make can locate your cross-compiler and other tools. You can supply these via the make variables: CC, CFLAGS, DFLAGS, IFLAGS, LD and LDFLAGS. For example:

```bash
$ make CC=/opt/bin/ccarm.exe LD=/opt/bin/ccarm.exe ARCH=arm PROFILE=release \
        -f projects/ioto-vxworks-default.mk
```

# Running Ioto

After building Ioto, the Ioto and other binaries and libraries will be in the **bin** directory.

You may want to add this directory to your shell PATH.
```bash
export PATH=`pwd`/build/bin:$PATH
```
Or you can easily run Ioto via **make run**:

```bash
$ make run
app: info: Starting Ioto 2.1.1, with "standard" app 1.0.0, using "dev" profile
setup: info: Enabling services: db provision register sync serialize test web
app: info: Device Claim ID: M72DANY8BZ
register: info: Device registered with https://api.admin.embedthis.com/api
{
    "product": "01H4R15D3478JD26YDYK408XE6",
    "id": "M72DANY8BZ",
    "created": "2024-01-23T02:03:57.062Z"
}
register: info: Device not yet claimed
web: info: Listening http://:9090
web: info: Listening https://:4443
app: info: Ioto 2.4.0 ready, Device firmware 1.3.0
```

When Ioto runs, it listens on any required HTTP ports (if you are running the web server service) and registers with the cloud. If your selected services enable the web server, Ioto will listen for connections on ports 80 for HTTP and 443 for HTTPS and serve documents from the **./site** directory.

To manage your device from the cloud, read [Managing from the Cloud](../clouds/).


## Ioto Command Line

On Linux or Mac OS X, Ioto is installed by default in the directory /usr/local/lib/ioto. The Ioto binary program is installed at /usr/local/bin/ioto, and the Ioto configuration is at /etc/ioto.

The Ioto command line is:

```bash
ioto [options]
```

## Ioto Command Options

Option | Description
-|-
--account ID | Manager account for self-claiming.
--background | Run Ioto in the background detached from the terminal.
--cloud Token | Cloud claim token for self-claiming.
--config dir | Set the directory for config files.
--configFile | Path to the ioto.json5 configuration file.
--debug | Emit very verbose debug tracing.
--exit event or seconds | Exit on event or after 'seconds'.
--home directory | Change to directory to run.
--id Token | Device claim ID. Overrides device.json5.
--ioto path | Set the path for the ioto.json5 config.
--mode mode | Select execution mode from ioto.json5 (dev,prod).
--nolocal | Do not apply local.json5.
--nosave | Run in-memory and do not save state.
--product Token | Product claim ID. Overrides device.json5.
--profile profile | Select execution profile from ioto.json5
--quiet | Don't show web server headers. Alias for --show ''.
--reset | Reset state to factory defaults.
--show [HBhb] | Show request headers/body (HB) and response headers/body (hb).
--state dir | Directory for the state files.
--test Suite | Run test suite from config/test.json5.
--timeouts | Disable timeouts for debugging.
--trace file[:types:from] | Trace to file.
--verbose | Verbose operation. Alias for --show Hhb plus module trace.
--version | Output version information

When Ioto starts, it reads the **ioto.json5** and other configuration files from the Ioto **config** directory. These are copied at build-time from the **apps/NAME/config** directory.  The **ioto.json5** file defines the default logging and tracing configuration. This can be overridden by command line options and environment variables. See below for details.

See [Configuration Files](./) for details.

## Logging and Tracing

Ioto provides detailed log tracing for all operational aspects of Ioto. 

The Ioto tracing is configured via the **log** property collection in the **ioto.json5** file. 

The **log** property specifies the trace destination via the **path** property. This property can be set to **stdout**, **stderr**, or any filename or **cloud** to send log files to AWS cloudwatch.

```js
log: {
    path: 'ioto.log',
    format: '%D %H %A[%P] %T %S %M',
    types: 'error,info',
    sources: 'all',
},
```

The **format** property specifies how the log messages will be formatted. It contains a printf style string with tokens that are expanded at runtime. The supported tokens are: 'A' for the application name, 'D' for the local datetime, 'H' for the system hostname, 'M' for the trace message, 'P' for the process ID , 'S' for the message source, and 'T' for the trace message type.

### Message Types

Ioto classifies trace messages according to types. The supported types are: debug, error, fatal, info, and trace. The **types** property specifies a comma separate list of trace message types to emit.

### Message Sources

Log messages are emitted from "sources". These are the names of the code module that originate the trace messages. The **sources** property is a comma separated list of sources. Some of the Ioto trace message sources are: "runtime", "tls", "json", "url" and "web".

You can use **"all"** for types and sources to match all types/sources. You can also use "!type" and "!source" to negate a type or source.

For example:

```js
types: 'all,!debug,!trace'
```

This will emit messages of all types, except for debug and trace messages.

### Command Line

The logging configuration defined in the **ioto.json5** file can be overridden via via the **--trace**, **--verbose** and **--debug** Ioto command line options. It can also be overridden via the **LOG_FILTER** environment variable.

The **--trace** option specifies the trace file destination and a list of types and sources.

```bash
$ ioto --trace FILENAME[:TYPES[:SOURCES]]
```

The types are a comma separated list of message types. Valid types include: info, debug, error, trace and all. Sources are the code module names originating the trace messages. You can use "!type" and "!source" to negate a type or source.

For example:

```bash
$ ioto --trace trace.log  # Same as path:trace.log   
$ ioto --verbose          # Same as path:stdout, types:raw,error,info, sources:all
$ ioto --debug            # Same as path:stdout, types:raw,error,info,trace,!debug, sources:all
$ ioto --trace file:all:all 
$ ioto --trace file:all,!debug,!trace:all
```

You can also use the **-v** short cut for **--verbose** and **-d** for **--debug**.

### Trace Environment Overrides

Similar to the command line options, you can override the trace configuration via two environment varables.

Command Line Options | Environment Variable | Description
-|-|-
--trace | LOG_FILTER | Override the log filter definition
--verbose | | Override the log filter definition
--debug | | Override the log filter definition

These variables take the same string values as their command line option counterparts. 

The order of precedence of configuration is:

1. Command line --trace, --debug or --verbose options
2. Environment variable LOG_FILTER, LOG_FORMAT values
3. ioto.json5 configuration

## Web Server Tracing

Ioto provides special control for the web server HTTP request and response tracing. You can selectively trace HTTP request and response headers and bodies via the **show** property.

```js
log: {
    show: 'hB',
    path: 'ioto.log',
    format: '%D %H %A[%P] %T %S %M',
    types: 'error,info',
    sources: 'all',
},
```

The **show** property is a string with the following characters:

Character | Description
-|-
b | Show the response body
h | Show the response HTTP headers
B | Show the client request HTTP body
H | Show the client request HTTP headers
empty | Show no HTTP trace

You can override the **ioto.json5** **show** property configuration via the **--show** Ioto command line option.

For example:

```bash
$ ioto --show hH
```

You can also override the configuration via the **WEB_SHOW** environment variable.

Command Line Options | Environment Variable | Description
-|-|-
--show | WEB_SHOW | Override the **show** definition

The order of precedence of configuration is:

1. Command line --show option value
2. Environment variable LOG_FILTER, LOG_FORMAT values
3. ioto.json5 configuration

## HTTP Client Tracing

Similar to the web server HTTP tracing, you can trace client HTTP requests and responses. Tracing HTTP client requests can be enabled via the **URL_SHOW** environment variable.

For example:

```bash
$ URL_SHOW=hH ioto --trace trace.log
```

This will trace any client HTTP requests issued via the URL module. This includes internal Ioto client requests and your own client HTTP requests that use the URL API.

## Other Environment Varialbes

You can override the Ioto **mode** and **profile** settings via environment variables:

Command Line Option | Environment Variable | Description
-|-|-
--mode MODE | IOTO_MODE | Override the execution mode (cloud \| local)
--profile PROFILE | IOTO_PROFILE | Override the execution profile (dev \| prod)


## Test Suites

Ioto provides a test facility via the **Unit** testing app. The **apps/unit/test.json5** configuration file defines the available test suites. 
You can create your own tests in the **unitTest.c** source file and define them in the **test.json5** config file.

The default Ioto source distribution includes a **demo** property collection to run a simple demo test that will increment a counter and post to the device database.

```js
demo: {
    count: 30,
    delay: '30sec',
    enable: true,
    type: 'sync',
},
```

The **count** property defines how many test iterations will be performed. The **delay** property indicates the delay between each test. The **type** property selects the type of test.


## Ioto Manual Pages

This Ioto distribution provides manual pages that can be viewed (on Unix-like systems) using the systems **man** command. Text copies of the pages are included below:

| Topic | Description |
|-|-|
| [ioto](../man/ioto.md) | Ioto device agent |
| [db](../man/db.md) | Database client program |
| [json](../man/json.md) | JSON tool |
| [pass](../man/pass.md) | Password manager |
| [url](../man/url.md) | URL HTTP client test program |
# Building for FreeRTOS 

This document covers building Ioto with FreeRTOS. Please read the [General Building](building.md) for general background first.

## Requirements

Ioto on the FreeRTOS has the following requirements for the target hardware:

* TLS stack
* A flash file system
* 32-bit CPU
* 2MB RAM

The flash file system such as [LittleFS](https://github.com/littlefs-project/littlefs) is required to store database and configuration data. 

The instructions below assume you have your development environment setup with FreeRTOS installed and you have successfully built one of the FreeRTOS demo applications for your target device.

Ioto requires a TLS stack for secure network communications. Ioto support MbedTLS and OpenSSL. See [Building TLS](building.md) for details.

Please read [Supported Hardware](hardware.md) for a complete target hardware list.

## Download Ioto

Navigate to the [Builder](https://admin.embedthis.com/clouds) site and select `Products` in the sidebar menu and click on the download link for the `Ioto Evaluation`.  

Extract the Ioto source code into your FreeRTOS app directory and rename the ioto-VERSION director to **ioto**.

    tar xvfz ioto-VERSION.tgz
    mv ioto-* ioto

## Preparing Ioto Source

Before building your Ioto source code, you need to configure Ioto for your desired set of services. The Ioto distribution build includes several demo apps that define a set of services required for that app. The Ioto services are selected via the **ioto.json5** configuration file. The services are:

Service | Description
-|-
database | Enable the embedded database
keys | Get AWS IAM keys for local AWS API invocation (dedicated clouds only)
logs | Capture log files and send to AWS CloudWatch logs (dedicated clouds only)
mqtt | Enable MQTT protocol
provision | Dynamically provision keys and certificates for cloud based management
register | Register with the Ioto Builder
serialize | Run a serialization service when making the device
shadow | Enable AWS IoT shadow state storage
sync | Enable transparent database synchronization with the cloud
url | Enable client HTTP request support
web | Enable the local embedded web server

The included apps are:

Name | Directory | Description
-|-|-
auth | Simple embedded web server user/group authentication.
blink | Minimal ESP32 blink app to demonstrate linking with Ioto on ESP32 microcontrollers.
demo | Cloud-based management of a device. Demonstrates simple data synchronization and metrics.
eco | Customized cloud-based device management of an **Eco House** demo app.

The default app is the **demo** app which sends device data and metrics to the cloud. The **eco** app emulates a simple Home charging networks and a mobile app.

To select an app, invoke **make config** with your desired APP:

```bash
make APP=demo config
```

This will copy the app's configuration to the **ioto/config** directory. From there, you can copy the config files to your Flash file system.

If you want a complete sample, please see the [Building ESP32](building-esp32.html) for a demo app that uses FreeRTOS on ESP32 hardware micro-controllers.

## Embedding Ioto

To invoke the Ioto library from your main program you will need to include the **ioto.h** header in your source and call Ioto APIs to initialize and run. 

In your main program, use:

```c
#include "ioto.h"

int main() {
    //  Start the Ioto runtime
    ioStartRuntime(1);

    //  Run Ioto services until instructed to exit
    //  You need to call vTaskStartScheduler() before ioRun
    ioRun();

    ioStopRuntime();
}

int iotStart() {
    //  This is invoked by ioRun when Ioto is ready
    //  Put your user code here
}

void iotStop() {
    //  This is invoked by ioRun when Ioto is shutting down
}
```

## Building Ioto and FreeRTOS

The Ioto source files are contained in the **ioto/lib** directory which contains C files and one assembly file. The assembly code contains some high performace stack management code that is used on Arm, Mips, RiscV and X86 platforms.

To build your FreeRTOS application with Ioto, edit the FreeRTOS app Makefile and add the following lines. This will cause the Makefile to build the Ioto source code when compiling FreeRTOS.

```make
// Must be after the OBJ_FILES definition

C_FILES     = $(wildcard ioto/lib/*.c)
A_FILES     = $(wildcard ioto/lib/*.S)
OBJ_FILES   += $(C_FILES:%.c=$(BUILD_DIR)/%.o)
OBJ_FILES   += $(A_FILES:%.S=$(BUILD_DIR)/%.o)
CFLAGS      += -Iioto/include -I/path/to/openssl/include
LDFLAGS     += -L/path/to/openssl/lib -lssl -lcrypto
```

Use the following if you are using MbedTLS

```
CFLAGS  += -I/path/to/mbedtls/include
LDFLAGS += -L/path/to/mbedtls -lmbedtls -lmbedcrypto -lmbedx509
```

Then build with **make**

```bash
$ make
```

## Filesystem

Ioto requires a flash file system with a Posix API to store config and state files. The file system should be defined with the following directories and files:

Directory | Description
-|-
state | Runtime state including database, provisioning data and provisioned certificates

File | Description
-|-
ioto.json5 | Primary Ioto configuration file
web.json5 | Local web server configuration file
schema.json5 | Database schema
device.json5 | Per-device definition
roots.crt | Top-level roots certificate
aws.crt | AWS root certificate

Copy the **state** files to your flash file system.

## Local Management

If the selected app enables the embedded web server, files will be served from the **site** directory. The Ioto embedded web server is configured via the **config/web.json5** configuration file which is then copied to the **config/web.json5** directory.

## Tech Notes

The stack size is configured to be 32K for the main app task and for spawned fiber tasks. Observationally, the minimum stack for the core Ioto is ~14K.

Ioto uses its own optimized printf implementation which uses less stack (<1K) and is more secure, being tolerant of errant NULL arguments.# Installing Ioto

One Linux or MacOS, you can natively install Ioto to the standard system directories by using `make install`

```bash
$ sudo make install
[Run] make --no-print-directory -f projects/ioto-macosx-dev.mk install
[Info] Ioto installed at /usr/local/lib/ioto/1.4.0
[Info] Configuration directory /etc/ioto
[Info] Documents directory /var/www/ioto
[Info] Executables directory /usr/local/lib/ioto/1.4.0/bin
[Info] Use "man ioto" for usage
[Info] Run via 'cd /etc/ioto ; sudo ioto'
[Info] Then browse to http://localhost
[Info] install complete
```

After installing, you can run via:

```bash
$ cd /etc/ioto
$ sudo ioto
```
# Configuration Properties

These are the configuration properties for the primary **ioto.json5** configuration file.

See the following descriptions for other configuration files:


| File | Description |
|-|-|
| [device.json5](device-properties.md) | Device configuration file. |
| [local.json5](local.md) | Local Ioto overrides configuration file. |
| [web.json5](../web/configuration.md) | Web server configuration file. |
| [schema.json5](../database/schemas/) | Database data schema. |


## ai

| Name | ai |
|-|-|
| Description | AI Connection Properties. |
| Synopsis | `ai: { "enable": true, endpoint: "..." }` |
| Notes | The <b>ai</b> property collection defines AI configuration. The api.enable will enable/disable the service at runtime. The `endpoint` property defines the LLM API URL. The api.model defines the default LLM model. The api.key property defines the LLM access key.|

## api

| Name | api |
|-|-|
| Description | Collection of API endpoint URLs. |
| Synopsis | `api: { "builder": "value", serialize: "value" }` |
| Notes | The <b>api</b> property collection defines various API endpoints. The api.builder endpoint is for the Builder public API. The api.serialize endpoint is for your local device serialization service employed during device manufacture.|

**Example**

```js
api: {
    builder: 'https://api.admin.embedthis.com/api',
    serialize: 'http://localhost:4100/ioto/serialize',
}
```

## certs

| Name | certs |
|-|-|
| Description | Ioto Certificates. |
| Synopsis | `certs: { aws: 'path', url: 'path' }` |
| Notes | The <b>certs.aws</b> property defines a filename for the AWS root certificate bundle. The <b>certs.url</b> property defines a root certificate bundle that is used to verify domains used by the URL client.<br><br>Ioto includes default certificates for the AWS root and URL root certificates.|

**Example**

```js
certs: {
    aws: 'certs/aws.crt',
    url: 'certs/roots.crt',
}
```


## conditional

| Name | conditional |
|-|-|
| Description | Conditional configuration properties. |
| Synopsis | `conditional: { "Set-Name": { /* properties */ }` |
| Notes | The <b>conditional</b> property collection is used to define a suite of different configurations for Ioto. For example, it can select a "dev" profile for development and a "prod" profile for productions.<br><br>Selections are made based on a controlling top level property. The **mode** and **profile** properties are used to select relevant configuration sets to apply.

**Example**
```js
conditional: {
    profile: {
        dev: {
            directories: {
                log: '.',
                state: 'state'
            }
        },
        prod: {
            directories: {
                log: '/var/log',
                state: '/var/lib/ioto'
            }
        }
    }
}
```

## database

| Name | database |
|-|-|
| Description | Control the Ioto database. |
| Synopsis | `database: { properties... }` |
| Notes | The <b>database</b> property collection defines the database, schema and operational parameters that govern the Ioto database.The <b>path</b> property defines the filename of the on-disk database store. Ioto will also create a database journal log file that appends a ".jnl" extension to this path.<br><br>The <b>schema</b> property defines the database scheme that defines the database indexes, entities and data types.<br><br>The <b>maxJournalSize</b> defines how big the database journal log should grow before Ioto rewrites the database. The <b>maxJournalAge</b> defines how long data should be preserved in the journal log before the database file is updated. These values should be sufficiently long as writing updated data to the journal is much more efficient that updating the database file.<br><br>The <b>maxSyncSize</b> property defined how much data should be buffered before synchronizing to the cloud. The path and schema properties can use @db and @config prefixes which will be expanded to "state/db" and "state/config" respectively. <br><br>The <b>service</b> property defines when to run a database maintenance task to remove expired items that define an expiry time via the "ttl" schema property. |

**Example**

```js
database: {
    path: '@db/state.db',
    schema: '@config/schema.json5',
    maxJournalSize: '1mb',
    maxJournalAge: '1min',
    maxSyncSize: '10k',
    service: '1hr',
},
```

## directories

| Name | directories |
|-|-|
| Description | Define default Ioto directories. |
| Synopsis | `directories: { "log": ".", state: "./state" }` |
| Notes | The <b>directories</b> property collection defines various directories used by Ioto. The directories.log directory is where log files will be saved. The directories.state directory is where runtime state including databases, certificates, web pages, configuration and shadow state will be stored. These can be overridden via the ioto command line --config, --state and --ioto options. |

**Example**

```js
directories: {
    log: '/var/log',
    state: '/var/lib/ioto',
}
```

## limits

| Name | limits |
|-|-|
| Description | Define execution limits for Ioto. |
| Synopsis | `limits: { "key": "value", ... }` |
| Notes | The **limits** property collection defines various execution limits for Ioto. The **limits.reconnect** property defines the delay after MQTT communications are lost before the agent will reconnect. This is useful to throttle network load in the event of a network disconnection. The **limits.stack** property defines the default size of fiber coroutine stacks. |

**Example**

```js
limits: {
    reconnect: '10 secs',
    stack: '32K',
}
```


## limits.stack

| Name | limits.stack |
|-|-|
| Description | Define the stack size of fiber coroutines for Ioto. |
| Synopsis | `limits: { stack: "Number" }` |
| Notes | The <b>limits.stack</b> property specifies the stack size for Ioto coroutines. This should be set to the maximum anticipated stack size for your executing code. The default stack size is 64K. The core Ioto code requires a stack size of 12K.<br> <br>It is recommended that you minimize your use of big stack buffer variables and your use of deep recursion both of which require much bigger fiber stacks. |

**Example**

```js
limits: {
    stack: '16K',
},
```


## files

| Name | files |
|-|-|
| Description | Define the list of files to ingest and send to CloudWatch logs. |
| Synopsis | `files: { path: "filename", group: "log-group', stream: "log-stream" }` |
| Notes | The <b>files</b> property contains one or more file definitions to ingest and send to CloudWatch logs. The definitions define the log file name, AWS CloudWatch log group and stream names.<br> <br>The <b>path</b> property may contain wild cards and all matching files will be ingested.<br> <br>The <b>group</b> property specifies the AWS log group name which must exist.<br> <br>The <b>stream</b> property specifies the AWS log stream name which must exist.<br> <br>The group and stream properties may contain tokens that are expanded before use. The supported tokens are: "{hostname}" which translates to the system hostname, "{instance}" which expands to the AWS EC2 instance name and "{deviceId}" which expands to the provisioned provision.deviceId property. |
**Example**

```js
files: [ {
    path: '/var/log/sys*log',
    group: 'ioto',
    stream: '{hostname}'
} ],
```


## log

| Name | log |
|-|-|
| Description | Control the Ioto log file output. |
| Synopsis | `log: { path: 'path', format: 'format', types: 'types', sources: 'sources' }` |
| Notes | The <b>log</b> property collection defines how and where Ioto logs execution information.<br><br>The <b>log.path</b> property specifies the destination of the Ioto trace log. Set it to "stdout" or "stderr", "aws" or a filename. If set to "aws", then the <b>log.group</b> property specifies the AWS log group name and the <b>log.stream</b> property specifies the AWS log stream name.<br><br>The <b>format</b> specifies a leading format for the message that contains printf style tokens that are expanded at runtime. The supported tokens are: 'A' for the application name, 'D' for the local datetime, 'H' for the system hostname, 'M' for the message, 'P' for the process ID , 'S' for the message source, and 'T' for the message type.<br><br>The <b>types</b> property specifies the types of messages to emit. It may contain the following types: debug, error, info and trace. It may be set to "all" for all types.<br><br> The <b>sources</b> property specifies a comma separated list of message sources to emit. Sources may be prefixed with "!" to subtract from the list. For example: "all,!json" will emit messages from all sources except "json".|

**Example**

```js
log: {
    path: '/var/log/ioto.log',
    format: '%D %H %A[%P] %T %S %M',
    types: 'error,info',
    sources: 'all'
}
```

## mqtt

| Name | mqtt |
|-|-|
| Description | MQTT configuration. |
| Synopsis | `mqtt: { properties }"` |
| Notes | The <b>mqtt</b> property collection is used to configure MQTT communications to the cloud. The mqtt.cert and mqtt.key properties define filenames to the X.509 certificate and key used to secure MQTT communications. <br><br> The mqtt.client defines the MQTT client ID used to uniquely identify the device. <br><br>The alpn property defines the HTTPS ALPN identification string required when using HTTP port 443 for communications. The mqtt.ca property defines the authority certificate from AWS that is used as the root certificate to verify the MQTT broker endpoint. <br><br>The cert, key, client and endpoint properties can be set to "auto" to have their values dynamically configured from AWS IoT core at runtime.<br><br>The timeout property defines the time period in which to disconnect an idle mqtt connection. The delay property defines how long to wait before reconnecting. The schedule property is a "cron" style specification that defines the time window in which MQTT connections can be established. |

**Example**
```js
mqtt: {
    cert: 'auto',
    key: 'auto',
    client: 'auto',
    endpoint: 'auto',
    port: 443,
    alpn: 'x-amzn-mqtt-ca',
    ca: 'certs/aws.crt',
    timeout: '5 mins',
    delay: '1 min',
    schedule: '* * * * *',
}
```

## optimize

| Name | optimize |
|-|-|
| Description | Build for debug or production release. |
| Synopsis | `optimize: "debug|release"` |
| Notes | If **debug** is selected, Ioto will be built with debug symbols.<br><br>If **release** is selected, Ioto will be built optimized without debug symbols.|

```js
optimize: 'release'
```

## profile

| Name | profile |
|-|-|
| Description | Configuration profile to select. |
| Synopsis | `profile: "dev | qa | prod | ..."` |
| Notes | The <b>profile</b> property is used to select different build and execution configurations for Ioto at runtime. For example, it can select a "dev" profile for development and a "prod" profile for productions.<br> <br>The <b>profile</b> property selects a set of configuration properties from the **conditional.profile** collections. These are copied to the top level and overwrite any existing top-level properties. |

**Example**
```js
profile: "prod"
```

## scripts

| Name | scripts |
|-|-|
| Description | Set of scripts used for various management tasks.|
| Synopsis | `scripts: { update: './scripts/update'}` |
| Notes | The <b>scripts.update</b> property defines a script that is invoked to apply software updates. The script is invoked with the pathname to the update image as the first and only argument.|

```js
scripts: {
    update: './scripts/update'
}
```

## services

| Name | services |
|-|-|
| Description | Configure which Ioto services to enable at runtime.|
| Synopsis | `services: { 'Service-Name': true | false, ... }` |
| Notes | The <b>services</b> property collection defines which Ioto services to enable.<br><br>The supported services are: <ul> <li>ai &mdash; OpenAI LLM connections</li><li>database &mdash; Local embedded database</li> <li>keys &mdash; Generate and rotate IAM access credentials</li> <li>logs &mdash; Send local O/S log files to CloudWatch logs</li> <li>mqtt &mdash; MQTT services</li> <li>provision &mdash; Enable registration and provisioning of device in the cloud</li> <li>serialize &mdash; Invoke manufacturing serialization service at first boot during test.</li> <li>shadow &mdash; AWS IoT device shadows</li> <li>sync &mdash; Send device state to AWS database</li> <li>url &mdash; Client HTTP service</li> <li>web &mdash; Local web server</li> </ul><br>Some services depend on others. Lower-level services will be forcibly enabled if upper level services require them. |


**Example**

```js
services: {
    database: true,
    keys: true,
    logs: true,
    mqtt: true,
    provision: true,
    register: true,
    serialize: 'auto',
    shadow: true,
    sync: true,
    update: true,
    url: true,
    web: true
}
```

## timeouts

Ioto supports timeout properties that improve security by limiting the duration of requests. Additional timeouts are provided from the [web.json5 timeouts](../web/properties.md#timeouts) configuration.

| Name | timeouts |
|-|-|
| Description | Collection of timeout properties. |
| Synopsis | `timeouts: { "Timeout-Property": "Timeout-Value", ...}` |
| Notes | All timeout values are strings, not numbers.<br><br>The string values may take human-readable suffixes which indicate the units for the value. The suffixes can be upper or lower case. The supported units are: infinite, never, sec, secs, seconds, min, mins, minute, minutes, hr, hrs, hour, hours, day, days, week, weeks, month, months, year, years.<br><br>Ioto has sensible defaults for these timeouts if not explicitly specified.|

**Example**
```js
timeouts: {
    api: "30 secs",
    aws: "60 secs",
    checkin: "30 secs",
    download: "5 mins",
}
```

## timeouts.api

| Name | timeouts.api |
|-|-|
| Description | Defines the maximum duration of requests to the Ioto cloud. |
| Synopsis | `api: "duration"` |
| Notes | The api timeout will be used for general calls via the Ioto cloud. The default is 30 seconds.|

**Example**

```js
api: "30 secs"
```


## timeouts.aws

| Name | timeouts.aws |
|-|-|
| Description | Defines the maximum duration of requests to the AWS cloud. |
| Synopsis | `aws: "duration"` |
| Notes | The aws timeout will be used for all calls via the **aws()** API. The default is 60 seconds.|

**Example**

```js
aws: "60 secs"
```


## timeouts.checkin

| Name | timeouts.checkin |
|-|-|
| Description | Defines the frequency of the **checkin** API call to the Ioto cloud. |
| Synopsis | `checkin: "elapsed"` |
| Notes | The checkin API will be called when Ioto starts and thereafter at this frequency. Defaults to 24 hours. |

**Example**

```js
checkin: "24 hours"
```


## timeouts.download

| Name | timeouts.download |
|-|-|
| Description | Defines the maximum duration of a software download from the Ioto cloud. |
| Synopsis | `download: "duration"` |
| Notes | The software download is used to deploy new firmware to devices. The default duration is 5 minutes. |

**Example**

```js
download: "5 mins"
```


## tls

| Name | tls |
|-|-|
| Description | Collection of TLS properties. |
| Synopsis | `tls: { "Tls-Property": "Tls-Value", ... }` |
| Notes | TLS properties apply to web server https connections. They do not apply to Ioto MQTT or Ioto client connections. <br><br>The authority, certificate and key paths may use @certs prefixes to refer to the "state/certs" director. |

**Example**

```js
tls: {
    authority: "@certs/ca.crt",
    certificate: "@certs/server.crt",
    key: "@certs/server.key",
    verify: {
        client: true,
        issuer: true
    }
}
```

## tls.authority

| Name | tls.authority |
|-|-|
| Description | Defines the location of the certificate file for client authentication. |
| Synopsis | `authority: "path"` |
| Notes | The <b>authority</b> property defines the file containing the certificates to use when authenticating client certificates. This property is only necessary if you wish to verify client certificates. If so, you must also define the "verify.client" to be true.<br><br>The certificate file contains the concatenated certificates to use in preference order. The path may be an absolute path or it may be relative to the Home directory. The path can also use the "@certs" prefix which will be expanded to "state/certs". |

**Example**

```js
authority: "/var/ioto/ca.crt"
```

## tls.certificate

| Name | tls.certificate |
|-|-|
| Description | Defines the location of the X.509 file containing the server certificate |
| Synopsis | `certificate: "path"` |
| Notes | The SSLCertificateFile directive defines the file containing the PEM encoded X.509 certificate for the server. The file may also contain the private key for the server in which case you do not need to use the <b>key</b> property. |  

**Example**

```js
certificate: "@certs/server.crt"
```

## tls.key

| Name | tls.key |
|-|-|
| Description | Defines the location of the server's private key. |
| Synopsis | `key: "path/to/key"` |
| Notes | The key property defines the file containing the PEM encoded private key file for the server. This property is not required if the server's private key is combined with the certificate file. The private key should not be encrypted. |
| Security | There is a dilemma here. If you use an encrypted private key, the server will pause until you enter the pass-phrase which makes headless operation impossible. If you do not encrypt the private key, your private key is more vulnerable should the server be compromised. |

**Example**

```js
key: "@certs/server.key.pem"
```

## tls.verify


| Name | tls.verify |
|-|-|
| Description | Collection of TLS verification properties |
| Synopsis | `verify: { "client": "value", "issuer": "value" }`
| Notes | Control the type of certificate verification. |

**Example**

```js
verify: {
    client: true,
    issuer: true,
}
```

## tls.verify.client

| Name | tls.verify.client |
|-|-|
| Description | Control the type of client certificate verification.|
| Synopsis | `client: true|false` |
| Notes | This property controls whether the client must provide a client certificate for the server to verify the identity of the client. If disabled, no certificate is required. If one is supplied, it will be ignored. The certificate and the certificate's issuer will be verified. Use the "verify.issuer" directive to turn off verification of the issuer if you need to use a self-signed test certificate.<br><br>If the property is enabled, the client must provide a valid certificate. The default is disabled. |

**Example**

```js
verify: {
    client: true,
}
```

## tls.verify.issuer

| Name | tls.verify.issuer |
|-|-|
| Description | Defines whether the issuer of the client certificate is verified. |
| Synopsis | `issuer: true|false` |
| Notes | This property controls whether the issuer of the client certificate will be verified. If set to <b>off</b>, the certificate issuer will not be verified. This is useful to accept self-signed test certificates. |

**Example**

```js
verify: {
    issuer: true,
}
```

## update

| Name | update |
|-|-|
| Description | Collection of software update properties. |
| Synopsis | `update: { "Update-Property": "Update-Value", ... }` |
| Notes | The update collection controls the schedule and behavior of requesting, downloading and applying software updates. 

**Example**

```js
update: {
    apply: '* 0 * * *',
    jitter: '1 hr',
    period: '24 hr',
    schedule: '* 18-23 * * *',
    throttle: 100,
}
```

## update.apply

| Name | update.apply |
|-|-|
| Description | Cron-like schedule defining when the Ioto agent will apply a downloaded software updates. |
| Synopsis | `schedule: "cron-spec string"` |
| Notes | See [Cron](https://en.wikipedia.org/wiki/Cron) for details about Cron strings.

**Examples**

```js
update: {
    apply: 'midnight',
}
```

## update.jitter

| Name | update.jitter |
|-|-|
| Description | Random time period to delay the scheduled software update check so that multiple devices will not all hit the service at once.

| Synopsis | `jitter: "1 hr"` |

**Examples**

```js
update: {
    jitter: '2 hrs',
}
```

## update.period

| Name | update.period |
|-|-|
| Description | The minimum delay in seconds before checking for a software update. |
| Synopsis | `period: "number or string numeric with suffix"` |
| Notes | The minimum period will be applied in addition to the defined **schedule**. The supported suffixes are "min", "hr", "day". |

**Examples**

```js
update: {
    period: '6 hr',
}
```


## update.schedule

| Name | update.schedule |
|-|-|
| Description | Cron-like schedule defining when the Ioto agent will check for new sofwtare updates. |
| Synopsis | `schedule: "cron-spec string"` |
| Notes | See [Cron](https://en.wikipedia.org/wiki/Cron) for details about Cron strings.

**Examples**

```js
update: {
    schedule: '* 18-23 * * *',
or
    schedule: 'midnight',
}
```

## update.throttle

| Name | update.throttle |
|-|-|
| Description | The time in milliseconds to pause between reading 4K of a software download update. |
| Synopsis | `throttle: 50` |
| Notes | This delay is useful to lessen the CPU and network impact on the device due to downloading a software update. Set to zero for no delay.

**Examples**

```js
update: {
    throttle: 100,
}
```

## version

| Name | version |
|-|-|
| Description | Set the agent version. |
| Synopsis | `version: "SemVer Version String"` |
| Notes | The version string defines the versions of the embedded agent including your software. It is used when selecting software updates deployed from the Builder. Don't confuse this with the underlying Ioto version. The version string must conform to the [Semantic Versioning 2.0](https://semver.org/) spec.
# Building for ESP32 

This document covers building Ioto for ESP32 using the [ESP IDF](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/index.html).

Please read the [Building](building.md) for general background first.

## Requirements

Ioto on the ESP32 has the following requirements:

* ESP32 device
* At least 2MB PSIRAM

Please read [Supported Hardware](hardware.md) for a complete list.

## Building Ioto for ESP32

This build sequence assumes you have your development environment setup on Linux or MacOS with the ESP-IDF installed. See [ESP-IDF Setup](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/linux-macos-setup.html) for details.

To begin open a terminal and create a directory for your project and the Ioto component. Choose any name you like for the project directory.

    mkdir -p myproject
    cd myproject
    mkdir components

Next, add the [ESP IDF](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/index.html) to your environment.  

    . ~/path-to-esp-idf/export.sh

## Download Ioto

Navigate to the [Builder](https://admin.embedthis.com/clouds) site and select `Products` in the sidebar menu and click on the download link for the `Ioto Evaluation`.  

<img src="https://www.embedthis.com/images/builder/product-list.avif" alt="Product List" class="screen"><br>

Extract the Ioto source code into the components directory. Then rename the **ioto-VERSION* directory to **ioto**.

    cd components
    tar xvfz ioto-VERSION.tgz
    mv ioto-* ioto
    cd ..

## Sample apps

The Ioto source distribution includes several ESP32 sketch example apps. Each example includes the necessary configuration files that are copied from the relevant app directory into build tree.

Name | Directory | Description
-|-|-
blink | apps/blink | Blink a GPIO LED within the Ioto agent framework
demo | apps/demo | Create a demo counter and synchronize with the local and cloud databases

The default app is the **blink** app which is ideal to test if you have ESP and Ioto successfully installed and configured.  You can select an app by providing an **APP=NAME** option to the make command.

To prepare for building the app and Ioto, invoke **make** with your selected app.  The **components/ioto/apps** directory contains master copies of the Ioto demonstration apps. When you select an app, the code and configuration are copied to the **./main** and **./fs** directories.

    make -C components/ioto esp32

or

    make -C components/ioto APP=blink esp32

This command will perform the following steps:

* Create the blink app at main/main.c
* Create the app CMakeLists.txt
* Create the file system partitions.csv
* Create the app sdkconfig.defaults
* Initialize the components/ioto for the blink app 
* Create some test certificates that may be required by the app

## Configuration

Next, ensure your ESP target device is defined. For example, to set the target to **esp32-s3**:

    idf.py set-target esp32-s3

The default build configuration is defined via the **sdkconfig.defaults** file. You can tailor the configuration by running:

    idf.py menuconfig

The Ioto services are enabled via the Ioto menu config option. Navigate to 

    Components config ---> 
    Ioto
    
Then enable the desired services. This will update the **ioto.json5** and regenerate the **sdkconfig** and **include/ioto-config.h** files.

Check your **sdkconfig** that the following settings are defined:

Key | Value | Description 
-|-|-
CONFIG_ESP_MAIN_TASK_STACK_SIZE | 8192 | Main task stack size (in words)
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ | 240 | CPU frequency setting to the fastest setting
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_240 | y | CPU frequence alias
CONFIG_ESPTOOLPY_FLASHSIZE | 8MB | Flash memory size
CONFIG_ESPTOOLPY_FLASHSIZE_8MB | y | Flash size alias

The full list is in components/ioto/apps/NAME/sdkconfig.defaults

## Building with idf.py

Building is done using the ESP-IDF **idf.py** command rather than using the normal Ioto generic Makefiles which are used when building natively on Linux or MacOS.

To build for ESP32, run:

    idf.py build

## Update the Board Flash 

To update your device with the built application:

    idf.py -p PORT flash

Where PORT is set to the USB/TTY serial port connected to your device.

## Monitoring Output

You can view the ESP32 and Ioto trace via the ESP32 monitor:

    idf.py monitor

The app will turn the LED On/Off every 2 seconds and trace the LED status to the monitor.

## Local Management

If the selected app enables the embedded web server, files will be served from the **./site** directory. The Ioto embedded web server is configured via the **web.json5** configuration file which is then copied to the *state** directory.

## Tech Notes

The stack size is configured to be 32K for the main app task and for spawned fiber tasks. Observationally, the minimum stack for the core Ioto is ~14K.

Ioto uses its own optimized printf implementation which uses less stack (<1K) and is more secure, being tolerant of errant NULL arguments.

The PlatformIO and Arduino build frameworks are not (yet) supported.# Configuration

The Ioto Agent is controlled via several [JSON/5](https://json5.org/) configuration files that are that are read at startup by Ioto.

The configuration files are are copied from the select appplication **./app/NAME/config** directory into the top-level **./state** directory. 

| File | Description |
|-|-|
| [device.json5](device-properties.html) | Device registration configuration. |
| [ioto.json5](properties.html) | Primary Ioto configuration file. Configures enabled services, logging and log file ingestion |
| ioto.crt | Allocated Ioto certificate for cloud communications. |
| ioto.key | Allocated Ioto certificate key for cloud communications. |
| [local.json5](local.html) | Local configuration for development. |
| provision.json5 | Device and cloud provisioning configuration. |
| [schema.json5](../database/schemas/) | Database data schema. |
| signature.json5 | REST API signatures. |
| shadow.json5 | Local copy of the AWS IoT shadow state. |
| state.db | Saved database. |
| [web.json5](../web/configuration.md) | Web server configuration file. |

## JSON/5

Ioto uses a human-readable JSON/5 for configuration. JSON/5 an extension of JSON that makes it easier to create, read and maintain configuration files in JSON.

JSON/5 adds the following JavaScript features to JSON.

* Object keys may be JavaScript identifiers without quotes.
* Objects or arrays may have a trailing comma.
* Strings may be single quoted.
* Strings may span multiple lines (single, double or back-tick quotes).
* Numbers may have a leading or trailing decimal point, can be hexadecimal, and may begin with a plus.
* Values may be regular expressions.
* The **undefined** value may be used.
* Single and multiline comments are allowed and preserved.

```js
{
    // single-comment
    /*
        Multi-line comment
    */
    unquotedKey: 42,
    singleQuoteString: 'The "lazy brown fox" jumped...',
    multiLine: "Line one
        line two
    ",
    hex: 0x42,
    trailingComma: {
        one: 1,
        two: 2,
    },
}
```

Some Ioto configuration properties accept numeric values as human-readable string with unit suffixes. In this case, the value must be string. The **limits** and **timeouts** properties in the web.json5 file support the suffixes: unlimited, infinite, kb, k, mb, m, gb, g, byte, bytes, infinite, never, sec, secs, seconds, min, mins, minute, minutes, hr, hrs, hour, hours, day, days, week, weeks, month, months, year and years.

## Profiles

Configuration files can provide multiple property profiles that can be selected at runtime. When Ioto is run, it executes with selected profile. This is typically `prod` for production and `dev` for development. However, you can create your own profiles for any desired execution configuration such as `qa` or `test`.

The Ioto profile is defined via the PROFILE environment variable or via the `--profile` command line option.

Configuration profiles are defined under the **conditional.profile** property in any configuration file. The relevant configuration properties are selected by the current Ioto **profile**. When selected, the relevant set are copied to overwrite properties of the same name at the top level. This allows a single configuration file to apply different settings based on the current values of the profile property.

```js
conditional: {
    profile: {
        dev: {
            limits: {
                //  Override the default stack size
                stack: '64k',
            }
        },
        prod: {
            log: {
                //  Send trace to a specific output file
                path: 'ioto.log',
            }
        }
    }
}
```

## Ioto Configuration

The primary Ioto configuration file is called **ioto.json5**.

Here is a sample ioto.json5:

```js
{
    services: {
        database: true,
        keys: true,
        logs: false,
        mqtt: true,
        provision: true,
        serialize: 'auto',
        shadow: false,
        sync: true,
        update: true,
        url: true,
        web: false,
    },
    files: [
        {path: '/var/log/sys*log', group: 'ioto', stream: '{hostname}' }
    ],
    limits: {
        stack: '16k',
    },
    log: {
        path: 'aws',
        format: '%D %H %A[%P] %T %S %M',
        types: 'error,info',
        sources: 'all',
    }
}
```

The configuration file defines the following items:

* The **services** to enable.
* The **files** files to capture and send to CloudWatch logs.
* The Ioto execution **limits** that defines the default stack size
* The Ioto **log** log configuration.

The configuration properties are defined in the [Configuration Properties](./properties.md).

The ioto.json5 **services** property collection defines which services to build and enable when running Ioto.

The selectable Ioto services are:

* database -- Enable the embedded database
* demo -- Demonstrate sending data to the cloud
* keys -- Get AWS IAM keys for local AWS API invocation (dedicated clouds only)
* logs -- Capture log files and send to AWS CloudWatch logs (dedicated clouds only)
* mqtt -- Enable MQTT protocol
* provision -- Dynamically provision keys and certificates for cloud based management
* register -- Register with the Ioto Builder
* serialize -- Run a serialization service when making the device
* shadow -- Enable AWS IoT shadow state storage
* sync -- Enable transparent database synchronization with the cloud
* url -- Enable client HTTP request support
* web -- Enable the local embedded web server
# Ioto Services

Ioto can be compiled to include or exclude support for various services.

The optional services are:

Name|Description|
-|-
database | Local embedded Database
keys | Local AWS IAM keys for AWS APIs
logs | Log file capture to AWS CloudWatch
mqtt | MQTT protocol used for cloud communications
provision | Provision AWS certificates for cloud management
register | Register device with the Builder
serialize | Serialization during manufacturer
shadow | AWS IoT Shadow state support
sync | Database sync to the cloud
update | Device agent software updates from the cloud
url | Url Http Client
web | HTTP Web server

If a component is compiled, you can also selectively enable or disable support at runtime via the  **services** property in the **ioto.json5** file.

When Ioto starts, it will enable services as defined in the **services** property collection.

```js
{
    services: {
        database: true,
        keys: true,
        logs: true,
        mqtt: true,
        provision: true,
        register: true,
        serialize: 'auto',
        shadow: true,
        sync: true,
        update: true,
        url: true,
        web: true,
    }
}
```

## Startup Order

When Ioto starts, it will configure services (if enabled) in a specific order. If services are not enabled during compilation or are disabled in the **ioto.json5** file, the step will be skipped.

The order is:

1. Serialize the device.
2. Open the database
3. Register with the build service (one time).
4. Start the embedded web server.
5. Provision certificates and keys from the device cloud (one time).
6. Initialize MQTT communications with the cloud.
7. Start database synchronization and retrieve changes while powered off.
8. Start additional cloud services

Please read the [Provisioning for the Cloud](../aws/provisioning.md) for details about the device provisioning process.

## Serialization

For secure device operation it is essential that each device can be uniquely identified. Most devices are created with a serial number that may include the product code, manufacturing batch number and individual serial number. However, while this serial number may be unique, it can be easily guessed because serial numbers typically follow a predictable format. This can present a security vulnerability when claiming device by serial number.

Instead of using the existing serial number, Ioto uses a random, unique claim ID (UCI) that is a random, 80-bit number that is not guessable and does not follow a predictable pattern. When paired with the product ID, it is used as a unique claim ticket for users to claim devices for management. For example:

```bash
JT08FFQXWQ
```

The 10 letter UCI results in over 1 quadrillion possible numbers (32^10).

During manufacturer, each device should be given a UCI that identifies the device to the Ioto service and is used by the user to "claim" the device after purchase or installation.

The UCI should be printed on the device label and be clearly identified as the Claim ID. The Claim ID can also be represented as a QR code if you choose to develop a mobile app for users to claim devices. (See Claiming below).

The UCI should be saved in the **device.json** configuration file in the **claim** property.


```json
{
    "claim": "7423FFA8DT",
    "product": "01GAQD45HGSN90AAF5QFVEBVTS",
    "test": 0
}
```

## Device Registration

Before a device can be managed, it must be registered and then be "claimed" by a user once purchased.

Registration is a one-time step that happens only when the device is first powered on.

When the device boots during system test, the Ioto agent will connect to the EmbedThis Builder service to register. The agent will send the contents of the device.json over an encrypted TLS connection to the EmbedThis Builder service.

The **device.json** file contains the UCI device identifier and the "product" registration token. You can get the ProductID registration token from the Builder Token List.

Once Ioto registers the device, the Ioto agent awaits for a user to claim the device.

## Device Claiming

When a user purchases or installs a device with the Ioto agent, they can "claim" the device to manage from the cloud. While waiting, cloud services are pending, but other Ioto services can run, including the embedded web server for local management (if enabled).

The user claims their device using the unique claim ID (UCI) printed on the device label. This claim request is sent to the Builder service that provisions the necessary X.509 certificates and AWS IoT resources required to support and manage the device. These are then returned to the Ioto Agent who saves them in the **provision.json5** config file.


## Device Connection

When the device is powered on, but unclaimed, the Ioto agent will regularly check with the Ioto service to see if it has been claimed. In this state, it is "unmanaged" by the cloud and awaiting orders.

The Ioto agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay up to a defined limit. If the device is rebooted, the polling process recommences.

Once claimed, when the agent next polls the Ioto service, it will receive management instructions and be redirected to the relevant AWS device cloud for ongoing management and the provisioning process is complete.

## Firewall Ports

If the embedded web server is enabled, Ioto will listen on the interfaces and ports specified in the **listens** property in the **web.json5** config file.

If cloud services are enabled, Ioto will communicate out on port 443 using HTTPS to the EmbedThis Builder cloud at **admin.embedthis.com**. It will also connect over port 443 to **amazonaws.com** using MQTT and HTTP protocols.

# Ioto Overview

The Ioto device agent is a compact management agent and library. It provides local and remote management capabilities including: HTTP web server, MQTT client, HTTP client, embedded database, AWS IoT cloud integration, cloud database sync, state persistency, provisioning and OTA upgrading. It also includes several browser-based management apps for local or cloud-based management.

Ioto is fast and compact, with a tiny memory footprint of less than 200K of code.

![Ioto Agent Architecture](/images/ioto/ioto-agent.png)

## Goals

Embedded agents for managing devices have several competing goals:

* Provide a strong and standard management feature set
* Minimize memory footprint
* Minimize CPU consumption
* Maximize security

To meet all these goals in one agent is difficult, but Ioto utilizes a safe runtime to assist. This maximizes code reuse and security, allowing management services to be coded as simply and efficiently as possible.


## Processing Architecture

Ioto is based on an event-driven, single-threaded fibre coroutine core. It uses a non-blocking, event-driven architecture and is capable of running many inbound and outbound requests simultaneously with minimal CPU and memory resources.

Ioto eliminates the ugliness of event callbacks and the complexity of threads by using fiber coroutines. A fiber coroutine is a segment of code that runs with its own stack and cooperatively yields to other fibers when it needs to wait. You can think of a fiber as a thread, but only one fiber runs at a time. For Go programmers, fibers are like Go routines. For JavaScript developers, fibers are similar to async/await.

Ioto fibers are baked into the I/O system so you can easily support parallelism by overlapping requests without any effort. You can read and write sockets, issue HTTP client requests, send MQTT messages or respond to web server requests using a straight-line procedural programming model.

All Ioto services are "fiber-enabled". This means that your user extension code is simple, easy to debug and maintainable over the long haul.

### Core Components

Ioto has a modular architecture where modules can be conditionally compiled as required to minimize your memory and security footprint.

The key components of Ioto are:

| Component | Description |
|-|-|
| Embedded Web Server | Embedded web server supporting HTTP/1.1, TLS 1.3, C action functions, file upload, transfer-encoding, user management, sessions and cookies, authentication, sandbox limits. |
| Embedded Database | Embedded NoSQL database with JSON documents, red/black indexing, local persistency, triggers and replication to the cloud. |
| MQTT 3.1.1 Client | Supports publish, subscribe, ping and disconnect messages. Includes retained message support and connect over port 443 via ALPN. |
| Cloud-based Management | AWS cloud support with data export to IoT shadows, S3, CloudWatch logs, CloudWatch metrics, Kinesis for streaming and DynamoDB for structured device data. |
| Transport Layer Security (TLS/SSL) | Secure Socket Layer protocol stack. This is a virtual interface that can selectively support a variety of TLS providers including: the MbedTLS and OpenSSL stacks. |
| JSON | JSON and JSON 5/6 parser. This module includes JSON persistency to files and a powerful JSON query engine. |
| Safe Portable Runtime | Cross-platform safe portable runtime. Includes services for memory allocation, buffer management, safe string handling, lists, hashing, sockets, events, timers, logging and fiber coroutines. |
| Suite of Management Applications | Browser-based VueJS management applications |


## Ioto Configuration

Ioto uses a set of JSON configuration files to control execution. These configuration files are read when Ioto starts.

The configuration files use a relaxed JSON format called JSON/5. This format is similar to the JavaScript object literal notation. Specifically, it supports: comments, keys without quotes, trailing commas and multiline strings.

Embeddable files are stored under the **./state** directory.

|File|Description|
|-|-|
| state/config/ | Configuration files. |
| state/db/ | Database files. |
| state/certs/ | Certificates. |
| state/site/ | Web site files. |

|File|Description|
|-|-|
| ioto.json5 | Primary Ioto configuration file. Configures enabled services, logging and log file ingestion |
| device.json5 | Device registration configuration. |
| local.json5 | Local configuration for development. |
| schema.json5 | Database schema. |
| signature.json5 | REST API signatures |
| web.json5 | Web server configuration file. |
| provision.json5 | Cloud provisioning endpoints and keys. |
| shadow.json5 | Local copy of the AWS IoT shadow state. |


See [Agent Configuration](index.md) for more details.

## Applications

When the Ioto agent is built, a selected management application will also be built. 

The management apps are browser-based [VueJS](https://vuejs.org/) apps that communicate with either the local Ioto web server or with the cloud-based Ioto service. The applications are stored under the **./apps** directory.

You can use the supplied management applications "as-is" or you can use them as a base for creating your own device-specific management solutions.


## Ioto HTTP Web Server

The Ioto web server is a fast, compact web server designed for local device management and for hosting embedded device management applications. It can also be used for serving device data over the network.

Management applications are best created using [Single Page Application](https://en.wikipedia.org/wiki/Single-page_application) design techniques where the application is rendered locally in the browser and it requests pure-data from the device to populate dynamic content.

Ioto is ideal for this approach. It includes an integrated embedded database, JSON parser and query engine to enable it to receive HTTP requests with JSON payloads and remit responses in JSON.

Ioto does not provide a web framework &mdash; nor do we believe that dynamically generating HTML is the most compact, secure or best approach for performing device management.

A working sample single page application called Kickstart is available for download from the Builder. This is a VueJS application that serves a sample device application for Ioto.

The core web services include:

* HTTP/1.1 protocol engine.
* Non-blocking socket communications.
* TLS (SSL) 1.3 support.
* Multiple listen endpoints.
* Flexible configuration via the web.json file.
* Session and cookie management.
* Authentication and User management.
* Serve static files.
* File upload.
* Transfer chunk encoding in both directions.
* Fully streaming receive and transmit data.
* Dynamic content rendering via binding URLs to C functions.

The Ioto web server module is exceptionally fast and will serve over 3K requests per second on a modest Raspberry PI 4 and yet runs using only 80K of code.

## Cloud-based Management

The Ioto agent can integrated with the AWS IoT back-end to make the job of creating IoT enabled devices dramatically easier.

The AWS integrations are optional and can be enabled or disabled via the application's **ioto.json5** configuration file.

Features:

* Simply provision devices for management by AWS IoT.
* Send messages to AWS IoT and other services via MQTT.
* Easy publish data to the cloud via MQTT.
* Create metric from any data for graphical display.
* Replicate and synchronize structured data to AWS DynamoDB.

For device clouds hosted on your own AWS account, you gain direct access to additional AWS features:

* Generate IAM temporary access credentials to call AWS API services on the device.
* Use the compact AWS SigV4 REST APIs from the device.
* Upload data and files to AWS S3.
* Send control-plane data to AWS IoT Shadows.
* Store the Ioto log file in AWS CloudWatch.
* Capture device O/S logs and upload to AWS CloudWatch.
* Emit metrics to AWS CloudWatch metrics.
* Save an audit trail to AWS CloudTrail.


## Agent Security

Ioto provides a suite of measures designed to increase the security of the Ioto device agent:

* TLS &mdash; Secure Sockets Layer
* Sandbox limits directives
* Authorization directives
* Safe, secure portable runtime
* Simple fiber coroutine programming paradigm

Ioto supports the MbedTLS and OpenSSL stacks. You can configure server and/or client certificate-based authentication.

## Safe Portable Runtime (R)

Ioto is built upon a portable runtime layer called the Safe Portable Runtime or "runtime" for short. This layer insulates the rest of the product from the underlying platform and allows it to be highly portable to new operating systems or hardware.

The runtime provides a suite of services that facilitate the creation of high performance management applications, including: buffer management, networking, safe string handling, events, wait management, logging, lists and hashing.

The runtime permits the rest of the Ioto code to be more secure by using the safe primitives offered by the runtime. It includes many mechanisms to assist in the creation of secure applications. One such facility is a safe string and buffer handling module to help eliminate the buffer overflows that have plagued many products.
# local.json5

Sometimes during development, it is useful to be able to override settings in the **ioto.json5** configuration file for testing purposes.

The **local.json5** configuration file serves this purpose and is blended with and overrides the **ioto.json5** configuration file.

The **local.json5** configuration file has the same properties as the [ioto.json5](properties.html) configuration file.

## Profiles

The **local.json5** configuration can use multiple property profiles that are selected at runtime. 
When Ioto is run, it executes with selected profile. This is typically `prod` for production and `dev` for development. However, you can create your own profiles for any desired execution configuration such as `qa` or `test`.

The Ioto profile is defined via the PROFILE environment variable or via the `--profile` command line option.

Configuration profiles are defined under the **conditional.profile** property in any configuration file. The relevant configuration properties are selected by the current Ioto **profile**.

For example:

```js
conditional: {
    profile: {
        dev: {
            limits: {
                //  Override the default stack size
                stack: '64k',
            }
        },
        prod: {
            log: {
                //  Send trace to a specific output file
                path: 'ioto.log',
            }
        }
    }
}
```

## Overriding the device.json5

A typical use-case for the **local.json5** is to override the device.json5 and specify a test device ID and product. You can also specify a manager account and cloud ID to auto-claim the device.

```json
{
    conditional: {
        profile: {
            dev: {
                device: {
                    id: 'P4CH123456',
                    product: '01HAVJGGHYG7FXXXXXXXXXXXXX',
                    name: 'Acme Router',
                    description: 'Acme Router for Home Office',
                    model: 'Office-Hub',
                    test: true,
                    account: '01HK6J56WN9XXXXXXXXXXXXXXX',
                    cloud: '01HJ7W4YBWXXXXXXXXXXXXXXXX',
                }
            }
        }
    }
}
```# Building Ioto

The Ioto source code has been designed to run on Arduino, ESP32, FreeBSD, FreeRTOS, Linux, Mac OS X, VxWorks and other operating systems. Ioto supports the X86, X64, Riscv, Riscv64, Arm, Arm64, and other CPU architecutres. Ioto can be ported to new platforms, operating systems and CPU architectures. Ask us if you need help doing this.

Several build environments are supported: 

-   **Linux** &mdash; Linux 4 with GNU C/C++
-   **Mac OS X** &mdash; Mac OS X 11 or later
-   **Windows** &mdash; Windows 11 with WSL v2
-   **ESP-32** &mdash; Using the [ESP IDF](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/index.html) in VS Code

For other environments, you will need to [cross-compile](cross-compiling.md). 

## Build Configuration

You do not need to use a `configure` program when building via **make**. Instead, you select the desired sample app and just run make. 

The Ioto distribution build includes several demo apps for local or cloud-based management. Apps demonstrate device-side logic to implement various management use cases. The default app is the "demo" app which sends device data and metrics to the cloud.

When `make` is first invoked, it will copy the selected app's **ioto.json5** file to the **state** directory. Each time `make` is invoked, it will parse the **ioto.json5** file and generate a **src/ioto-config.h** header that will ensure the required services are compiled.

## Building

If you are building on Windows, or for ESP32 or FreeRTOS, please read the specific instructions for various build environments:

* [Building on Windows](#building-on-windows)
* [Building for the ESP32](building-esp32.md) 
* [Building for FREERTOS](building-freertos.md)

Read below for generic build instructions.

## Building with Make

To build on Linux, MacOS or Windows via WSL, use the system **make** command. The supplied Makefile will build the Ioto library (libioto.a) and the "ioto" main program. If you are embedding Ioto in another program, you should link the Ioto library with your program. See [Linking](#linking-with-ioto) below for details. 

The top level Makefile parses your selected App's **ioto.json5** configuration file, detects your operating system and CPU architecture and then invokes the appropriate project Makefile for your system. It copies the selected app configuration from the **apps/NAME/config** directory to the **state** directory.

To build, nominate your selected app via the "APP=NAME" makefile option:

```bash
$ make APP=demo
```

The default build of Ioto is configured to build the Ioto agent and the `demo` management app which saves device data and metrics to the cloud.

## Building on Windows

Building on Windows utilizes the [Windows SubSystem for Linux (WSL)](https://learn.microsoft.com/en-us/windows/wsl/about). Using WSL, you get a tightly integrated Linux environment from which you can build and debug using VS Code.

To build, first [install WSL](https://learn.microsoft.com/en-us/windows/wsl/install) by running the following command as an administrator:

```bash
$ wsl --install
```

Then invoke **wsl** to run a wsl (bash) shell:

```bash
$ wsl
```

To configure WSL for building, install the following packages from the wsl shell.

```bash
$ apt update 
$ apt install make gcc build-essential libc6-dev openssl libssl-dev
```

Then extract the Ioto source distribution:

```bash
$ tar xvfz ioto-VERSION.tgz ioto
```

Finally build via **make**:

```bash
$ cd ioto
$ make
```

To debug with VS Code, add the [WSL extentension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl) to VS Code and then from a WSL terminal, open VS Code from the ioto directory:

```bash
$ cd ioto
$ code .
```

This will open a remote WSL project for the Ioto distribution.

## Building with an IDE

Ioto includes Xcode projects that provide easy access for building and debugging. The generated IDE projects will build Ioto using default settings and are somewhat limited in their configurability.

To build with the Xcode on Mac OS X, run Xcode 12 or later and open the projects/ioto-macosx.xcodeproj project. Then select the Product -> Build menu option to build the software. To debug, you will need to create use Product -> Edit Scheme to set the executable to run under the Info tab, and define the working directory under the Options tab.

## Build Profiles

You can change the build and execution **profile** by editing **ioto.json5**. Two build profiles are supported:

* dev
* prod

The **dev** profile will build Ioto with debug symbols and local state directories suitable for debugging.

The **prod** profile will build Ioto optimized without debug symbols. Database state and logs will be stored in the appropriate O/S locations.

After changing the profile, run:

```bash
$ make clean
$ make
```

## Changing the TLS Stack

Ioto includes support for multiple TLS stacks including:

* [OpenSSL](https://www.openssl.org)
* [MbedTLS](https://tls.mbed.org)

Ioto is built with OpenSSL by default. OpenSSL is a leading open source TLS stack that is faster, but bigger. MbedTLS is a compact TLS implementation. When built for ESP32, the supplied ESP32 MbedTLS will be used.

### Downloading OpenSSL

Most Linux distributions include OpenSSL with their default distribution. We support the latest stable and LTS releases only. If you want to build with a custom OpenSSL build, you will need to supply the Ioto project with the pathname to your OpenSSL source code directory.

### Building with MbedTLS

To build with MbedTLS, install MbedTLS version 3 or later using your O/S package manager. For example:

```bash
# On mac
$ brew install mbeddtls

# On Linux
$ apt-get install libmbedtls-dev
```

Then build via:

```bash
make ME_COM_MBEDTLS=1 ME_COM_OPENSSL=0 SHOW=1
```

To install MbedTLS from source, download and install [MbedTLS](https://github.com/Mbed-TLS/mbedtls.git) from:

```bash
$ git clone https://github.com/Mbed-TLS/mbedtls.git 
```

Then checkout the latest stable release (at least version 3.6)

```bash
$ git tag
$ git checkout PICK-TAG
```

For a debug build:

```bash
cmake -DCMAKE_BUILD_TYPE=Debug .
make VERBOSE=1
```

Then build Ioto:

```bash
$ make ME_COM_MBEDTLS=1 ME_COM_OPENSSL=0 ME_COM_MBEDTLS_PATH=/path/to/mbedtls SHOW=1
```

If you wish to use test certificates, you may need this patch (needed for 3.6.0): [MbedTLS Issue 8509](https://github.com/Mbed-TLS/mbedtls/issues/8509#issuecomment-2076818915)

### OpenSSL via Make

Ioto will build with the system installed OpenSSL libraries by default on Linux.

If you want to use a custom OpenSSL build or you are cross-compiling, run make:

```bash
$ make ME_COM_MBEDTLS=0 ME_COM_OPENSSL=1 ME_COM_OPENSSL_PATH=/path/to/openssl SHOW=1
```

### OpenSSL via Xcode

Open the MacOS project:

```bash
$ open projects/ioto-macosx-default.xcodeproj/project.pbxproj
```

Then click on "Build Settings" in the panel in the center. Scroll down to define the path to your OpenSSL source code directory in the ME_COM_OPENSSL_PATH property.

# URL HTTP Client

The Ioto URL API is a HTTP client for interacting with HTTP servers. It is a full-duplex streaming HTTP client that can retrieve both documents and live streaming data. The URL client supports both HTTP and WebSockets over HTTP.

The URL client uses a fiber coroutines to that you can write natural, blocking, procedural code without ugly callbacks or complex threads. It is a highly efficient HTTP and WebSockets client that uses minimal CPU from only 11K of code.

## URL Features

* HTTP/1.0, HTTP.1.1 client.
* WebSockets client.
* Fully streaming API for dynamic input and output.
* Convenience JSON API for interacting with REST services.
* Single-threaded, fiber coroutine event-based runtime without ugly callbacks or complex threads.
* TLS/SSL 1.3 with certificate verification controls.

## API Quick Tour

The URL API provides a high-level simple API and a lower-level API with more granular control.

The high-level API consists of the routines *urlGet* and *urlPost*.

### Get Request

To get a remote document, use the *urlGet* API:

```c
char *document = urlGet("https://example.com/index.html", headers);
printf("Document %s\n", document);
rFree(document);
```

This call will block the current fiber while other fibers continue to run. When the document has been retrieved, the call will resume and the document will be returned. If the request fails and a non-200 HTTP status is returned, the call returns NULL. When complete, you must free the returned string using *rFree*.

### HTTP Headers

To supply headers with your requests, you can use the headers printf style arguments:

```c
urlGet("https://example.com/data", "Authorization: %s\r\n", password);
```

Each header in the format string must be separated by "\r\n".

### Post Request

To issue a post request, use *urlPost* API

```c
char *document = urlPost("https://my.com/post", data, dataLength, httpHeaders);
```

If the data is a string, you can set the length to be -1 and the length will be calculated from the string. The last NULL argument is for optional HTTP headers.

```
char *document = urlPost("https://my.com/post", "Hello World", -1, NULL);
```

### JSON Responses

If you want to issue a POST request and retrieve a JSON document, you can use the JSON variants *urlPostJson*:

```c
Json *json = urlPostJson("https://my.com/", data, dataLength, NULL);
jsonPrint(json);
```

Use the [JSON](../dev/json.md) APIs to manage the returned JSON in-memory tree result.

### WebSockets

To start a WebSockets session, use the *urlWebSockets* API:

```c
int status = urlWebSocket("https://my.com/post", onRead, NULL, NULL);

// This return zero when closed, otherwise a negative status code.

void onRead(WebSocket *ws, char *buf, ssize len, void *arg)
{
    printf("Received %s\n", buf);
    webSocketSend(ws, "%s", "Response message");
}
```

See [URL WebSockets](websockets.md) for details.

## Low Level API

The URL client also offers a [low-level API](low-level.md) for granular control.


## API

* [URL API](/agent/ref/api/url.html)
* [WebSockets API](/agent/ref/api/websockets.html)# Low-Level API

To use the low-level API, first create a URL instance via *urlAlloc*:

```c
Url *url = urlAlloc();
```

When finished, free the URL with *urlClose*.

The primary low-level API is *urlFetch*. This API supports issuing any HTTP method with body data and headers.

### urlFetch

```c
int status = urlFetch(url, "POST", "https://my.com/data", data, dataLength, NULL);
```

This call returns a HTTP status code. To retrieve the returned data, use *urlGetResponse* or *urlGetJsonResponse*:

### urlGetResponse

```c
char *data = urlGetResponse(url);

// or

Json *json = urlGetJsonResponse(url);
```

### urlFetchJson

You can also use the JSON variant *urlFetchJson* which returns the JSON tree if the HTTP return status is a successful 200 code.

```c
Json *json urlFetchJson(url, "POST", "https://my.com/data", data, dataLength, NULL);
```

In this case, you can call *urlGetStatus* to return the HTTP status code.

### urlGetHeader

To retrieve returned HTTP headers, use *urlGetHeader*:

```c
cchar *length = urlGetHeader(url, "Content-Length");
```

## Streaming

The Ioto URL client fully supports streaming data in both directions.

To start a streaming request, use *urlStart*. Then write data blocks with *urlWrite*.

When complete, write a NULL block to signify the end of the posted data.

```c
urlStart(url, "POST", "https://my.com/data");
urlWriteHeaders(url, "X-Custom: %s\r\n", "custom-header");

urlWrite(url, data, dataLength);
urlWrite(url, moreData, moreDataLength);
//  signify end of data
urlFinalize(url0);
```

To stream the response, use *urlRead*:

```c
char buf[1024];
do {
    if ((nbytes = urlRead(url, buf, sizeof(buf))) == 0) {
        //  End of input
        break;
    } else if (nbytes < 0) {
        //  Error
    }
} while (nbytes > 0);
```

## Timeouts

You can define a timeout limit for URL requests incase the server should hang.

```c
urlSetTimeout(url, timeInMillisconds);

//  or set for all requests
urlSetDefaultTimeout(timeInMillisconds);
```

## API

* [URL API](/agent/ref/api/url.html)
* [WebSockets API](/agent/ref/api/websockets.html)# WebSockets Client

The WebSockets client offers a high-level and a low-level API.

## Starting a Session

To start a WebSockets client session using the high-level API, use the *urlWebSockets* API:

```c
if (urlWebSocket("https://my.com/post", onEvent, arg, headers) < 0) {
    //  Error
}
```

This call return zero when closed, otherwise a negative status code.  You can supply HTTP headers on the call if required. 

## Protocol Selection

To select the WebSocket sub-protocol, add a "Sec-WebSocket-Protocol" header.

```c
if (urlWriteHeaders(up, "Sec-WebSocket-Protocol: real-time\r\n") < 0) {
    //  Connection error
}
```

## Incoming Messages

When incoming messages are received, the `onEvent` callback will be invoked with the argument provided when **urlWebSocket** was called.

```c
void onEvent(WebSocket *ws, int event, char *buf, ssize len, void *arg)
{
    switch (event) {
    case WS_EVENT_OPEN:
    case WS_EVENT_CLOSE:
    case WS_EVENT_ERROR:
        break;

    case WS_EVENT_MESSAGE:
    case WS_EVENT_PARTIAL_MESSAGE:
        printf("Received %s\n", buf);
        webSocketSend(ws, "%s", "Response message");
        break;
    }
}
```

## Sending Data

Use **webSocketSend** to send a printf styled formatted message. To send a literal string, use **webSocketSendString**  and to send binary data, use **webSocketSendBlock**. 

```c
webSocketSend(ws, "Hello %s", "World");
webSocketSendString(ws, "Hello World");
webSocketSendBlock(ws, WS, "Hello World", 11);
```

## Closing Connections

To instruct the peer to do an orderly close, call **webSocketSendClose**.

```c
webSocketSendClose(ws, WS_STATUS_OK, "End of session");
```

## Low-Level API

WebSockets also provides a low-level API for more granular operation:

```c
Url *url = urlAlloc(0);

if (urlStart(url, "GET", "wss://example.com/websockets/test") < 0) {
    // Connection failed
}
if (urlWriteHeaders(up, NULL) < 0 || urlFinalize(up) < 0) {
    //  Connection error
}
urlAsync(up, onEvent, up);

//  Serve events and wait for the connection to close
urlWait(up);
urlFree(url);
```

The `urlAsync` call defines the callback to invoke for incoming messages, errors and connection events.
The `urlWait` call blocks until the connection is closed. This call is optional. You may wish to continue with other operations and call `urlFree` when processing is complete.

## API

* [WebSockets API](/agent/ref/api/websockets.html).
* [URL API](/agent/ref/api/url.html)# Cloud Messaging

### Best Practices 

Implementing an efficient data communication design is crucial for successful IoT solutions. When managing a large pool of devices, excessive cloud communication can result in high costs, poor performance, and scalability issues.

The Ioto cloud solution offers powerful communication mechanisms such as MQTT messaging and transparent database synchronization. However, if used indiscriminately by sending excessive or redundant data to the cloud, it can compromise your solution and lead to throttling.

To protect your devices, customers, and the service, Ioto enforces data limits. If a device or group of devices sends too much data, Ioto will throttle (slow down) incoming data from those devices. Persistent overuse can result in the offending devices being disconnected from the network.

Follow these best practices to ensure a successful IoT strategy:

1. **Only send necessary data to the cloud**: Limit cloud communication to data that is required at the cloud. Don't send data that is never accessed by the cloud.
2. **Send only changed data**: Avoid redundant data transmission by sending updates only when data changes. If a data item has only one changed field, consider splitting into fixed and changing data items.
3. **Separate configuration data from runtime statistics**: Define database entities to differentiate between the two. Configuration data changes infrequently and can be synchronized to the cloud when updated. Statistics can be buffered and can be sent less frequently.
5. **Utilize automatic metric creation**: Take advantage of automated metrics for efficient monitoring. Ioto can transparently create metrics from database data that can be graphically displayed or used for automated actions.
6. **Synchronize database tables in one direction only**: Ensure that synchronized tables are not bidirectional to prevent conflicts. Split tables to be synchronized up to the cloud, or down to the device, not both.
7. **Avoid messaging loops**: Implement safeguards to prevent loops in your messaging system.
7. **Monitor throttle messages**: Listen for Ioto throttle messages and adjust your device behavior accordingly.

When designing your data strategy, it is helpful to categorize your data into domains. The Ioto database supports easy creation of entities that can wrap the various categories or concerns.

A helpful segmentation is:

1. Deivce configuration that must be shared with the cloud (changes infrequently)
2. Local state that does not need to be sent to the cloud (changes frequently)
2. Error conditions and records 
3. Performance statistics

By segmenting data that is local to the device and the data that must be sent to the cloud, you can achieve a higher performing solution.

## Device Modes

It may also be a useful strategy for devices to be moded as:

1. Under focussed management
2. Self-managing

When a device is under focus, it can send more data to the cloud to permit **live** monitoring, issue diagnosis and resolution. When a device is self-managing, it should communicate only essential data with the cloud. This can permit very high-bandwidth device communications when required, but still maintain a low overall message traffic rate.

## Device Cloud Limits

Ioto defines data limits to protect you, your devices, customers and the service. If a device or devices send too much data to the cloud, Ioto protects you and your customers by throttling (slowing) incoming data from offending devices. 

Depending on your Device Cloud plan these limits and enforcement policies may vary. 

### Data Traffic

The amount of data you send to the device cloud is measured as the number of KBytes sent on average per device per hour. This traffic is then compared with the limit for your device cloud.

As you connect more devices, your data limit scales automatically with the number of devices connecting to the cloud. What is measured is the average data traffic over your entire pool of connecting devices.

For example, if you have 100 devices and a limit of 60 messages per device per hour, this means that your pool of devices can send up to 6,000 messages to the cloud per hour. 

Ioto supports short-term burst traffic above the limit, but if your sustained, aggregate traffic exceeds your limit, the offending devices will have their sending rate throttled.

### Data Limits

The data limits vary depending your your device cloud type and plan. 

For Hosted device clouds and the Evaluation device cloud, data limits ensure the cloud infrastructure is not monopolized by any one device, set of devices or users.

The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It has higher limits, as it is typically used with few devices and consequently lower aggregate device pool limits.

For a Dedicated cloud, you are the sole user of the cloud running in your own AWS account. In this case limits are advisory and can be increased if required. Contact support if you need a limit increase.

### Cloud Limits

Device Cloud| Limit
-:|:-
Eval Cloud | 60 messages (1K) per device per hour
Hosted Cloud | 10 messages (1K) per device per hour
Dedicated Cloud | 100 messages (1K) per device per hour# Cloud Management

Cloud based management is enabled via the **ioto.json5** services.

```json
{
    services: {
        database: true,
        demo: true,
        keys: false,
        logs: false,
        mqtt: true,
        provision: true,
        register: true,
        serialize: 'auto',
        shadow: false,
        sync: true,
        update: true,
        url: true,
        web: false,
    },
}
```

The **mqtt** service enables cloud communications. The **provision** service enables devices to be claimed by cloud-based device apps and to be provisioned with TLS certificates for communication with the cloud service. The **sync** service enables transparent synchronization of device data with the cloud.

The easiest way to configure cloud-based management is to select the **Demo** app when building Ioto. The app will supply a configured **ioto.json5** file.

```
make APP=demo clean build
```

The **Demo** app builds and configures Ioto for cloud-based management.


## Running Ioto

After [Building Ioto](../user/building.md) run Ioto via **make run**:

```bash
$ make run
app: info: Starting Ioto 1.4.0 in "cloud" mode using "dev" profile
setup: info: Enabling services: db provision register sync serialize test web
app: info: Device Claim ID: M72DANY8BZ
register: info: Device registered with https://api.admin.embedthis.com/api
{
    "product": "01H4R15D3478JD26YDYK408XE6",
    "id": "M72DANY8BZ",
    "created": "2024-01-23T02:03:57.062Z"
}
register: info: Device not yet claimed
app: info: Ioto 1.4.0 ready, Device firmware 1.3.0
```

When Ioto starts, it registers with the EmbedThis Ioto cloud service and waits to be claimed by a user for management. 

## Device Association

The process of associating a device with a user is called **"Claiming"** and consists of a user presenting a device claim ID that authorizes the user as the owner of the device. The unique claim ID is typically printed on the manufactured device. When evaluating Ioto, the Ioto agent will display the claim ID to the console. 

An Ioto enabled device can be claimed by any user. Once claimed, the device is associated with the user and the underlying device cloud.

During evalution, it is easiest to use the pre-existing Builder **Eval Cloud** and **Eval Device App**. The Builder's Eval Cloud is a multi-tenant, shared cloud for evaluating Ioto. The Eval Device App is a developer device app suitable for examining and managing devices and device data.

To claim the device using the Eval App, navigate to the builder and select the **Apps** page.

[![App List](/images/builder/manager-list.png){class="screen"}](https://admin.embedthis.com/apps)

Then click the **Launch** icon for the **Eval** app. This will launch the [Eval App](/apps/).

## App Login 

When you log into the device app, you are logging in as a device user. This is a different account to your Builder login account. Device app logins are unique for each device cloud.

![App Login](/images/manager/developer-login.png){class="screen width-40"}

Enter your desired username and password and click **Register**. You will be sent an email confirmation code to complete your app login.

# Claiming a Device

After logging in, you will see the device list, which will be initially empty. Click the **Claim Device** button and enter your device claim ID to claim your device for management.

![App Login](/images/manager/device-claim.png){class="screen"}

The Claim ID is the unique device ID displayed by Ioto when run. This ID is dynamically allocated when first run, but can be initialized via the **config/device.json5** configuration file. During production, a generated device claim ID is typically printed on the device packaging and device label. 

Read more in the [Builder Claiming Devices](/ioto/provisioning/claiming.html) documentation.

```bash
$ make run
...
app: info: Device Claim ID: M72DANY8BZ
```


While an Ioto-enabled device is waiting to be claimed, Ioto will periodically check with the cloud service to see if it has been claimed. 

Once the device is claimed via the app, Ioto will display:

```bash
provision: info: Device claimed
provision: trace: {
    accountId: "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    certificate: "state/ioto.crt",
    endpoint: "xxxxxxxxxxxxx-ats.iot.xxxxxxxxxxxxxx.amazonaws.com",
    id: "M72DANY8BZ",
    key: "state/ioto.key",
    port: 443
}
provision: info: Device provisioned
checkin: info: Device has no pending updates for version: 1.3.0
mqtt: info: Connected to mqtt: xxxxxxxxxxxxx-ats.iot.xxxxxxxxxxxx-1.amazonaws.com:443
demo: info: Running demo cloud counter
demo: info: Send counter update via MQTT -- counter 0
```

When claimed, the Ioto agent will be provisioned with a unique device certificate for secure TLS communications and will connect to the cloud using the MQTT protocol. These will be saved under the **./state** directory as **ioto.crt** and **ioto.key**.

## Cloud Messaging

The default Ioto configuration will run a demo routine to update a counter and send the updated value to the cloud. This counter updates every thirty seconds and can be monitored via the device app.

In the device app, select the claimed device from the device list.

![App Login](/images/manager/device-list-1.png){class="screen"}

This will then display the database tables and dashboard for this device.

## Key/Value Store

The default device schema has a key/value table called the **"Store"**. The demo counter, will update a value with the key of **"counter"**. Click on the **Store** table to display the store contents.

This will display all the data items in the store for claimed devices. From here, you can modify an item by clicking the **Edit** icon or you can edit in place by clicking on a teal color cell and updating the value and then clicking **Save**.

![Store Table](/images/manager/store-table.png){class="screen"}

You can reload the table contents by clicking the table reload icon.

## App Dashboard

The device app includes the ability to display one or more dashboards with data widgets.

Click the **Dashboard** tab to display the default dashboard, then click the **Add Widget** icon to display the add widget panel.

![Store Widget](/images/manager/widget-add.png){class="screen"}

You can display database and metric data using numeric, gauge or graphical widgets.

To display the demo counter as a numberic from the database, enter the following widget configuration:

Field | Value
-|-
Type | Numeric
Namespace | Database
Model | Store
Field | value
Select Item | key=counter

This will select the Store table item that has a key value set to "counter" and display the "value" field.

After the ioto agent has run for a minute, there will be sufficient data points for a "COUNTER" metric to be created. Metrics permit the display of current and historical data using graphical widgets.

To display the demo counter as a graph using metrics, enter the following widget configuration:

Field | Value
-|-
Type | Graph
Namespace | Embedthis/Device
Metric | COUNTER
Statistic | avg
Resource Dimensions | Device=YOUR-CLAIM-ID

That should get you started with Ioto and posting data to the cloud from your device.# Cloud Overview

Device clouds are regional management hubs, from which you can centrally operate and manage a set or fleet of devices. 

A device cloud stores device data and manages communications with your devices. By aggregating critical device data in one place, you can more easily manage your devices and extract important data analytics and intelligence from your device pool. You can create one or more device clouds to segment your products and devices.

![Builder Dashboard](/images/builder/dashboard.png){class="screen"}

When creating device clouds, the Builder will create the necessary AWS resources including a DynamoDB device database and IoT messaging services.


## Device Cloud Services

The Ioto device cloud offers the following:

* Automatically provision Ioto-based devices with X.509 certificates for secure communications.
* Setup MQTT communications between devices and the cloud.
* Create and maintain a cloud-based device database store for centralized management and analytics.
* Transparently create and manage dedicated AWS IAM access keys for each device.

## Data Privacy

The Device Cloud is created in a region of your chosing so you have total control and privacy regarding your device data. Device data goes directly from your devices to your device cloud database. The device data is not sent through other third-party services and is encrypted througout. This is important as governments are increasingly requiring that data only be stored, processed and managed locally.

Unlike other IoT services which transport your device data around the globe, Ioto provides decreased latency by locating device data in an AWS cloud in a nearby region of your choosing. This lowers cost and boosts performance of your cloud-based management solution.
 
## Device Certificates

Devices require X.509 certificates to securely connect and communicate with the cloud. The certificates are used to uniquely identify and authenticated devices and then to encrypt communications to prevent tampering or eavesdropping.

Ioto will automatically create and distribute the required certificates as devices are assigned to a device cloud. This eliminates much of the pain of certificate distribution.

## Device Messaging

During device provisioning, the Ioto service will setup the necessary AWS resources to enable secure efficient messaging via AWS IoT core using the MQTT protocol.

MQTT is a messaging protocol for IoT. It is a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices.

When connected, your management applications can control devices, send commands and retrieve data using the MQTT messaging service.

## Device Data Aggregation

Collecting, aggregating and sending device data to a central management store can be complex and costly. Ioto takes the pain out of exporting device data to the cloud by transparently synchronizing device data with the cloud.

Device data written saved the device to the Ioto database will be transparently exported to the cloud. Similarly, data written to the cloud database will be distributed to appropriate devices as required. No programming is required.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-device and per-table basis.

This is similar to AWS Global Tables, but instead of acting inside AWS between AWS regions, it is between an AWS region and a device.

The Ioto replicated device database is unique to Ioto and dramatically simplifies the creation of IoT solutions.

## Device Access Keys

Ioto can optionally create and manage AWS IAM access keys for your devices. AWS uses IAM access keys to authenticate and authorize actors on AWS resources. The Ioto device cloud can create specific IAM keys to enable devices to issue requests to the device cloud and AWS services.

Ioto generates temporary IAM access keys that have tightly controlled access permissions. The keys are automatically distributed to devices and reissued as required.

## Device Logging

If required, device logs and files can be captured and sent to AWS CloudWatch logs for storage, analysis and governance.

The Ioto agent can be configured without coding, to capture any O/S log or program output and send it to CloudWatch Logs. The Ioto agent log is similarly exportable.

## Device Metrics and Analytics

AWS provides a comprehensive metric service via CloudWatch Metrics. The Ioto agent can emit metrics that will be captured by the device cloud and managed by CloudWatch.

Using these metrics, you can create detailed device analytics and dashboards to focus on any aspect of your device or fleet performance.

## Account Audit

When your device cloud is created, Ioto configures and enables CloudTrail which captures and audit trail of **all** activity on your account and device cloud.  This records a complete record to AWS S3 so you can reliably audit operations and determine root cause of any security incidents.

# Ioto<sup>&reg;</sup> Device Agent

![Agent](/images/ioto/embedded-agent.avif){class="width-30 left"}

The EmbedThis Ioto Agent is an powerhouse embedded device agent for direct or remote device management. It is compact, but blazing **fast** and has an extensive suite of management protocols and capabilities.

The Ioto Agent includes a HTTP web server, MQTT client, HTTP client, embedded database, JSON parsing, AWS IoT cloud integration, easy provisioning, over-the-air software upgrading and the ability to run and invoke AI models.

The agent can be used for local management via its embedded web server or it can be integrated with the cloud via comprehensive AWS IoT integration.

## Cloud Ready

The agent is cloud ready and provides data synchronization with the cloud and integration with a suite of AWS services including: AWS IoT core, rules, shadows, AWS EventBridge and AWS DynamoDB. The agent transparently synchronizes device data into the cloud-side DynamoDB database. Optional support is provided for dedicated clouds to capture logs into CloudWatch Logs, and utilize file and data upload to AWS S3 data lakes.

## Apps Included

The Ioto Agent source distribution includes a few sample management applications that are integrated with Ioto. These apps are are browser-based [VueJS](https://vuejs.org/) apps that are designed to be used with the Ioto Agent.

Name | Directory | Description
-|-|-
auth | apps/auth | Test user login and authentication app
blank | apps/blank | Blank slate application
demo | apps/demo | Demonstration app for cloud-based management
unit | apps/unit | Unit tests app

## Modular and Configurable

If you only want an embedded web server, the agent is easily configured to enable just the modules you need. You can configure the agent to include only the web server, or include the HTTP client or you can enable full cloud management integration.

## Highly Optimized

The agent is optimized for embedded device management via an evolved, high performance management runtime that delivers exceptional throughput and effective memory utilization. Ioto eliminates the ugliness of event callbacks and the complexity of threads by using fiber coroutines. Ioto is compact and is especially effective in reducing per-request CPU and memory overhead.

The agent has a tiny memory footprint of only 200K of code. It is ideal for Linux and FreeRTOS systems and is easily ported to other platforms.

## Deployed Widely

The Ioto agent draws from our code base at EmbedThis, where we have experience in providing the most widely deployed embedded web servers. Our software has been deployed in networking equipment, telephones, mobile devices, and consumer and office equipment worldwide in many hundreds of millions of devices for over 20 years.

## Components

The Ioto agent provides the following components:

* HTTP/1.1 server with dynamic rendering, authentication, cookies, sessions and file upload
* HTTP/1.1 client
* MQTT/3.1.1 client
* WebSockets client and server
* Server-Sent Events (SSE) client and server
* Embedded database
* JSON/5 parser and query engine
* Transport Layer Security (TLS/SSL) with ALPN support
* OpenAI API support for chat, reponses, and real-time streaming
* AWS IoT Integration with IoT Core, Shadows, Events and Rules
* AWS service integration with S3, Lambda, Kinesis and CloudWatch
* Transparent Database synchronization to AWS DynamoDB (like Global Tables)
* Safe, secure runtime core
* Easy provisioning
* Over-the-air software and firmware upgrading
* User authentication
* Complete documentation
* Extensive Samples
* Full Source code

## Want More?

To learn more about Ioto, please read:

* [Ioto Developer Background](user/background.md)
* [Ioto Use Cases](start/uses.md)
* [Ioto Web Site](https://www.embedthis.com/ioto/)
* [Ioto Agent Download](https://admin.embedthis.com)
* [EmbedThis Web Site](https://www.embedthis.com)
# Agents and Tools

The OpenAI Responses API supports the use of tools and agents. Tools are pre-defined functions that can be invoked by the LLM or agent to access information or perform actions. Agents are automated AI entities that can independently accomplish tasks by invoking tools to achieve a goal.

The OpenAI Responses API provides cloud-side tools for web searches, file retrievals, and computer operations. The Ioto Agent framework extends the Responses API to provide an environment for local tools that can be used to augment the pre-trained knowledge of the LLM. Ioto also provides a suite of built-in tools, such as: upgrade-device, reboot-device, and signal-condition.

## API Tour

Here is a simple example of an AI agentic workflow. The example demonstrates a patient monitor that "measures" a patient's body temperature and will call an ambulance if the patient needs urgent care.

The example is triggered by running the `patient.html` web page. The page will ask the cloud LLM to evaluate the patient's state. The LLM will respond and request the device to get the patient's temperature. The device will respond with the temperature and the LLM will evaluate the patient's state again and reccomend treatment. If an emergency ambulance is required, the LLM will respond with a request to call an ambulance via the callEmergency() function.

```c
#include "ioto.h"

void example(void)
{
    Json *request, *response;
    char *text;

    request = jsonAlloc(0);
    jsonSetString(request, 0, "input", "How is the patient doing?");
    jsonSetString(request, 0, "instructions",
        "Your are a doctor. You are given a patient temperature and you need to determine if the patient is in urgent need of medical attention. If so, call emergency response by using the callEmergency() function. In your response, state the patient's temperature in C and the result of your assessment. Do not give any other information.");

    jsonSetJsonFmt(request, 0, "tools", "%s", SDEF([{
        type: 'function',
        name: 'getTemp',
        description: 'Get the patient temperature',
        parameters: { type: 'object', properties: {} },
    }, {
        type: 'function',
        name: 'callEmergency',
        description: 'Call emergency response as the patient is critically ill',
        parameters: { type: 'object', properties: {} },
    }]));

    if ((response = openaiResponses(request, agentCallback, NULL)) == NULL) {
        jsonFree(request);
        return sclone("Cannot determine treatment for patient.");
    }
    printf("Response: %s\n", jsonGet(response, 0, "output_text", 0));

    jsonFree(request);
    jsonFree(response);
}
```

```c
static char *agentCallback(cchar *name, Json *request, Json *response, void *arg)
{
    if (smatch(name, "getTemp")) {
        return getTemp();
    } else if (smatch(name, "callEmergency")) {
        return callEmergency();
    }
    return sclone("Unknown function, cannot comply with request.");
}

static char *getTemp(void)
{
    static cchar *temps[] = { "36", "37", "38", "39", "40", "41", "42" };
    static int   index = 0;

    if (index >= sizeof(temps) / sizeof(temps[0])) {
        index = 0;
    }
    return sclone(temps[index++]);
}

static char *callEmergency(void)
{
    return sclone("Ambulance dispatched");
}
```

The `openaiResponses` API takes a JSON object which represents the Response parameters. The `SDEF` macro is a convenience to make it easier to define JSON objects in C code. The SFMT macro expands `printf` style expressions. The `jsonParse` API parses the supplied string and returns an Ioto Json object which can be passed to the `openaiResponses` API.

The `agentCallback` parameter is invoked when the LLM needs to invoke a local tool. The callback is passed the tool name and the request and response JSON objects. The callback should return a string containing the results of the tool call.

The response object returned by the `openaiResponses` API is a JSON object that can be queried using the Ioto JSON library `jsonGet` API. The `output_text` field contains the complete response output text.

Consult the [Responses API](https://platform.openai.com/docs/api-reference/responses) for parameter details.

See the `ai` app in the Ioto Agent source download for this example. The `patient.html` web page initiates the demo. The **apps/ai/aiApp.c** file contains the example code and the web action to invoke the example.

## References

Consult the OpenAI documentation for API details:

* [OpenAI Agents API](https://platform.openai.com/docs/guides/agents)
* [OpenAI Responses API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)---
image: https://www.embedthis.com/images/ioto/embedded-agent.avif
---

# AI at the Edge

![IoT AI](/images/ioto/embedded-agent.avif){class="width-30 left"}

Artificial Intelligence (AI) significantly enhances edge devices by enabling more intelligent, autonomous operations. The recent advances in large language models (LLMs) executing in the cloud is leading to transformative applications in the IoT space.

Developers typically select from three principal AI integration patterns: on-device models, cloud-based models, and hybrid models.

**On-device language models** operate entirely within the local hardware environment. This approach guarantees superior data privacy, reduced latency, and consistent operation regardless of network conditions, making it ideal for real-time applications with intermittent connectivity or stringent privacy requirements. However, the complexity and scale of these models are constrained by the limited computational resources of edge devices.

**Cloud-based language models** offload computationally intensive processing to remote servers, enabling the use of robust, large-scale LLMs that surpass the resource capabilities of edge devices. This design provides advanced features, seamless scalability, and simplified updates. Nevertheless, it relies on continuous internet connectivity and may introduce latency.

**Hybrid approaches** combine on-device processing with cloud-based computing. In this pattern, tasks that are privacy-sensitive or critical are executed locally, while more complex, resource-intensive operations are handled in the cloud. This approach effectively blends the strengths of privacy, responsiveness, and scalability, delivering an optimal balance that significantly improves system performance and user experience.

## Ioto IoT AI

Ioto provides an AI library that simplifies interactions with cloud-based LLMs, facilitating tasks such as data classification, sensor data interpretation, information extraction, and logical reasoning. This capability is particularly beneficial for applications in predictive maintenance within industrial settings, smart agriculture, healthcare, smart homes, and environmental monitoring.

>The Ioto AI library facilitates seamless interaction with **cloud-based language models** through integration with the OpenAI Chat Completion, Response, and Real-Time APIs.

## OpenAI and Foundation Models

The Ioto AI provides IoT AI support for the standard OpenAI Chat Completions, Responses and Real-Time APIs. 
While the core API is targeted at the OpenAI implementation, it is easily adapted for other models that utilize the same APIs as the Chat Completions API is supported by many other foundation models. 

### Ioto IoT AI

Ioto provides support for the following LLM APIs:

* [OpenAI Chat Completions API](chat-completion.md)
* [OpenAI Response API](responses.md)
* [OpenAI Response Streaming API](stream.md)
* [OpenAI Real-Time API](real-time.md)

## Configuration

To enable the IoT AI API, ensure the `services.ai` is set to true. The `services.ai` is a compilation and run-time control to initialize the AI library.

```json5
services: {
    ai: true,
    ...
},
```

Then configure the OpenAI access key for your OpenAI account and define your preferred model.

```json5
ai: {
    enable: true,
    provider: "openai",
    model: "gpt-4o",
    endpoint: "https://api.openai.com/v1",
    key: "sk-proj-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
}
```

The `ai.enable` setting enables run-time control of the AI service.

If you are using another foundation LLM other than OpenAI, you can define the API endpoint for that service via the `endpoint` property.   

## References

Consult the OpenAI documentation for API details:

* [Response API](https://platform.openai.com/docs/api-reference/responses)
* [Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [Realtime API](https://platform.openai.com/docs/api-reference/realtime)# OpenAI Chat Completions

The OpenAI Chat Completions API allows developers to integrate OpenAI's conversational models, such as GPT-4 and GPT-3.5, into their applications to create interactive, natural-language conversations with users. It's designed specifically for building chat-based interactions, from simple Q&A chatbots to sophisticated conversational agents.  

Many other foundation models offer APIs that are compatible with the OpenAI Chat Completions API and for these models, the Ioto support may usable. 

It is expected that the newer Responses API will replace the Chat Completions API over time and so developers should use the Response API for new projects.

## API Tour

Here is an example calling the Chat Completions API to ask a simple question. 

```c
PUBLIC void aiChatCompletionExample(void)
{
    Json  *request, *response;
    cchar *model;
    char  buf[1024];

    request = jsonParse(\
        "{messages: [{"
            "role: \"system\","
            "content: \"You are a helpful assistant.\""
        "},{"
            "role: \"user\","
            "content: \"What is the capital of the moon?\""
        "}]}", 0);
    response = openaiChatCompletion(request);

    // Extract the LLM response text from the json payload
    text = jsonGet(response, "choices[0].message.content", 0);
    printf("Response: %s\n", text);

    jsonFree(request);
    jsonFree(response);
}
```

See the `ai` app in the Ioto Agent source download for an example `completion.html` web page that uses the Chat Completion API.

## References

Consult the OpenAI documentation for API details:

* [OpenAI Response API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)# OpenAI Responses API

OpenAI's Responses is newly introduced API designed to help developers create advanced AI agents and workflows capable of performing tasks cloud-based tasks like web searches, file retrievals, and computer operations on behalf of users. This API streamlines the integration of OpenAI models with built-in tools, eliminating the need for multiple APIs or external services. 

## Features of the Responses API:

**Built-in Tools**: The API offers tools such as web search, file search, and computer use, enabling agents to access real-time information, retrieve specific documents, and perform tasks on a user's device. 
OpenAI Developer Community

**Simplified Development**: By combining the simplicity of Chat Completions with enhanced tool usage and state management, the Responses API facilitates the creation of more dynamic and capable AI experiences. 

## API Tour

Here is an example calling the Responses API to ask a simple question. This example uses file search (aka [RAG](https://blogs.nvidia.com/blog/what-is-retrieval-augmented-generation/)) to augment the pre-trained knowledge of the LLM.

```c
#include "ioto.h"

void example(void)
{
    cchar *vectorId = "PUT_YOUR_VECTOR_ID_HERE";
    char  buf[1024];

    /*
        SDEF is used to catentate literal strings into a single string.
        SFMT is used to format strings with variables.
        jsonParse converts the string into a json object.
     */
    Json *request = jsonParse(SFMT(buf, SDEF({
        model: 'gpt-4o-mini',
        input: 'What is the capital of the moon?',
        tools: [{
            type: 'file_search',
            vector_store_ids: ['%s'],
        }],
    }), vectorId), 0);

    Json *response = openaiResponses(request);

    // Extract the LLM response text from the json payload
    text = jsonGet(response, "output_text", 0);
    printf("Response: %s\n", text);

    jsonFree(request);
    jsonFree(response);
}
```

The `openaiResponses` API takes a JSON object which represents the Response parameters. The `SDEF` macro is a convenience to make it easier to define JSON objects in C code. The SFMT macro expands `printf` style expressions. The `jsonParse` API parses the supplied string and returns an Ioto Json object which can be passed to the `openaiResponses` API.

If you are using local tools, you can pass an "agent" callback as the 2nd parameter to the `openaiResponses` API. This callback is invoked when the LLM needs to invoke a local tool. The callback is passed the tool name and the request and response JSON objects. The callback should return a string containing the results of the tool call.

The response object returned by the `openaiResponses` API is a JSON object that can be queried using the Ioto JSON library `jsonGet` API. The `output_text` field contains the complete response output text.

Consult the [Responses API](https://platform.openai.com/docs/api-reference/responses) for parameter details.

See the `ai` app in the Ioto Agent source download for an example `response.html` web page that uses the Responses API.


## References

Consult the OpenAI documentation for API details:

* [OpenAI Responses API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)
# OpenAI Real-Time API

The OpenAI Realtime API enables the creation of low-latency, multimodal applications capable of real-time interactions. This API supports both text and audio inputs and outputs, allowing for seamless speech-to-speech conversations and real-time transcription services.

Under the hood, the Realtime API establishes a persistent WebSocket connection, facilitating continuous, bidirectional communication between the application and OpenAI's GPT-4o model. This setup enables applications to handle interruptions gracefully and maintain natural conversational flows, similar to human interactions.

Ioto supports the Real-Time API via its WebSocket protocol support. This results in a high-performance direct connection to the LLM.

## API Tour

The following example demonstrates using the `openaiRealTimeConnect` API to establish a WebSocket connection to the OpenAI Real Time API endpoint.

This example loops calling a `getUserQuestion` API to prompt the user for a question to ask. The text is then sent via the `webSocketSend` API to the LLM. This example does not include error handling for clarity.

```c
static void aiChatRealTime(Web *web)
{
    Url   *up;
    cchar *question;
    char  buf[1024];

    if ((up = openaiRealTimeConnect(NULL)) == NULL) {
        webError(web, 400, "Cannot connect to OpenAI");
        return;
    }
    //  This will cause the onEvent to be invoked for incoming messages
    urlAsync(up, (WebSocketProc) onEvent, up);

    while ((question = getUserQuestion()) != NULL) {
        //  Send the user's input question
        webSocketSend(up->webSocket, SFMT(buf, SDEF({
            type: 'conversation.item.create',
            item: {
                type: 'message',
                role: 'user',
                content: [{
                    type: 'input_text',
                    text: '%s',
                }],
            },
        ), question));

        //  Ask for the model to respond
        webSocketSend(up->webSocket, SDEF({
            type: 'response.create',
            response: {
                modalities: [ 'text' ],
                instructions: 'Please assist the user with their question.',
            },
        ));
        //  Incase not yielding in getUserQuestion, yield here for events to run
        rSleep(0);
    }
    urlFree(up);
}
```

On connection events, errors and for incoming messages, the `onEvent` callback will be invoked. The Real Time API sends progressive output via `response.text.delta` messages. These can be incrementally displayed to the user.

See the [Realtime API](https://platform.openai.com/docs/api-reference/realtime) for details.

```c
/*
    Callback for the OpenAI Real Time API.
    This is called when a message is received from OpenAI.
 */
static void onEvent(WebSocket *ws, int event, cchar *message, ssize len, void *arg)
{
    Json    *json;
    cchar   *delta, *type;

    if (event == WS_EVENT_MESSAGE) {
        json = jsonParse(message);
        type = jsonGet(json, 0, "type", 0);
        if (smatch(type, "response.text.delta")) {
            delta = jsonGet(json, 0, "delta", "");
            //  Display the "delta" text to the user
        }
        jsonFree(json);

    } else if (event == WS_EVENT_CLOSE) {
        //  Set a flag to stop processing
    }
}
```

See the `ai` app in the Ioto Agent source download for an example `real-time.html` web page that uses the Real Time API. This sample proxies a browser WebSocket connection to Ioto with the OpenAI Real Time API WebSocket connection.

## References

Consult the OpenAI documentation for API details:

* [OpenAI Response API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)# OpenAI Responses Streaming API

[OpenAI's Responses](responses.md) API is also capbable of streaming responses.

See the [OpenAI Documentation](https://platform.openai.com/docs/api-reference/responses) for details.

## API Tour

Here is an example calling the Streaming Responses API to ask a simple question. 

```c
#include "ioto.h"

void example(void)
{
    Url   *up;
    cchar *vectorId = "PUT_YOUR_VECTOR_ID_HERE";
    char  buf[1024];

    /*
        SDEF is used to catentate literal strings into a single string.
        SFMT is used to format strings with variables.
        jsonParse converts the string into a json object.
     */
    Json *request = jsonParse(SFMT(buf, SDEF({
        model: 'gpt-4o-mini',
        input: 'What is the capital of the moon?',
        tools: [{
            type: 'file_search',
            vector_store_ids: ['%s'],
        }],
    }), vectorId), 0);

    up = urlAlloc(0);
    up = openaiStream(request, (UrlSseProc) aiStreamCallback, 0);
    jsonFree(request);
    if (up == NULL) {
        rError("example", "Cannot connect to OpenAI");
        return;
    }
    urlWait(up);
    urlFree(up);
}

static void streamCallback(Url *up, ssize id, cchar *event, cchar *data, void *arg)
{
    printf("id: %ld\nevent: %s\ndata: %s\n", id, event, data);
}
```

The `openaiStream` API takes a JSON object which represents the Responses parameters. The `SDEF` macro is a convenience to make it easier to define JSON objects in C code. The SFMT macro expands `printf` style expressions. The `jsonParse` API parses the supplied string and returns an Ioto Json object which can be passed to the `openaiStream` API.

The API returns a HTTP status of which 200 indicates success. The callback function is called for each event in the stream. The `id` is the event id. The `event` is the event type. The `data` is the event data. The `arg` is the user data passed to the `openaiStream` API.

Consult the [Responses API](https://platform.openai.com/docs/api-reference/responses) for parameter details.

See the `ai` app in the Ioto Agent source download for an example `stream.html` web page that uses the Responses API in streaming mode.


## References

Consult the OpenAI documentation for API details:

* [OpenAI Responses API](https://platform.openai.com/docs/api-reference/responses)
* [OpenAI Chat Completion API](https://platform.openai.com/docs/api-reference/chat)
* [OpenAI Realtime API](https://platform.openai.com/docs/api-reference/realtime)# Ioto Agent Samples

The Ioto agent provides a suite of samples for common embedded design patterns.

| Name | Description |
|-|-|
| [link-agent-main](https://github.com/embedthis/ioto/tree/main/samples/agent/link-agent-main/README.md) | Embed the Ioto library in your application and use the Ioto main(). |
| [own-main](https://github.com/embedthis/ioto/tree/main/samples/agent/own-main/README.md)  | Embed the Ioto library with your own main(). |
| [url-fetch](https://github.com/embedthis/ioto/tree/main/samples/agent/url-fetch/README.md">url-fetch) | Issue client HTTP requests to issue REST API request. |
| [url-get](https://github.com/embedthis/ioto/tree/main/samples/agent/url-get/README.md) | Issue simple client HTTP GET requests. |
| [web-auth](https://github.com/embedthis/ioto/tree/main/samples/agent/web-auth/README.md) | Demonstrate user login for a web application. |
| [web-dynamic](https://github.com/embedthis/ioto/tree/main/samples/agent/web-dynamic/README.md) | Generate dynamic responses for HTTP client requests. |
| [web-static](https://github.com/embedthis/ioto/tree/main/samples/agent/web-static/README.md) | Serve static files for HTTP client requests. |
| [web-upload](https://github.com/embedthis/ioto/tree/main/samples/agent/web-upload/README.md) | Process uploaded file in the web server. |
# JSON

The Ioto JSON parser is a high performance JSON parser, serializer and query engine.

It parses JSON text into an in-memory tree for efficient examination, storage and export.

## Json Features

* JSON and JSON5 parser
* Stores parsed JSON as an in-memory tree
* Fast, flexible query engine mange and navigate the JSON tree
* Simple get/set API to retrieve and update JSON values.
* APIs to walk, iterate and navigate a parsed tree
* Overlay and blend JSON trees
* Supports JSON/5 with extensions
* Serialize in strict or JSON/5 formats
* Persist to flash/disk.

## API Quick Tour

To parse a JSON string, call the *jsonParse* API:

```c
Json *json = jsonParse("{Weather: 'Sunny'}", 0);
```

This parses the given JSON text and returns a Json instance which represents the in-memory parsed JSON tree.

!!!Note
    You can provide data to parse as either JSON or JSON/5 format strings. JSON/5 which permits a more relaxed JSON format where property keys may omit quotes and single quotes can be used on values. Also, values can be multi-line strings and may use back-ticks instead of quotes to delimit the strings. Finally, the last item in an object map may be terminated with a trailing comma.

### Getting Values

To query a value from the JSON tree, use *jsonGet*:

```c
cchar *value = jsonGet(json, 0, "weather", NULL);
```

This will retrieve the weather value (Sunny) as a static string that does not need freeing.

When calling jsonGet, you can provide keys with dots:

```c
cchar *value = jsonGet(json, 0, "address.city", NULL);
```

and you can provide a default value to be returned as the last parameter if the property is not defined in the JSON tree.

```c
cchar *value = jsonGet(json, 0, "weather", "rainy");
```

The second argument (0) in these calls defines the starting point from which to search. This is a numeric node ID. Don't worry about it for now, but you'll appreciate it later when searching deeper in a JSON tree.

You can use the *jsonGetInt* and *jsonGetBool* APIs to return data as an integer or boolean data type.

### Setting Values

To update or set a value, use the *jsonSet* API:

```c
jsonSet(json, 0, "weather", "sunny", 0);
```

This will update the value of the given property in-memory. Again, you can use dotted key properties of any depth.


### Data Types

The last parameter to **jsonSet** can be used to specify a data type for the value. In general, the Ioto JSON API can sleuth the data type for you. But as data values are supplied as strings, you may need to specify a type if you want the value to be stored as a number.

The valid types are: JSON_OBJECT, JSON_ARRAY, JSON_STRING and JSON_PRIMITIVE. The primitives are false, true, null, undefined and numbers.

To remove a property, use *jsonRemove*:

```c
jsonRemove(json, 0, "weather");
```

When you are finished with a JSON tree, remember to free it with *jsonFree* to prevent memory leaks.

```c
jsonFree(json)
```

This will release allocated memory.

## Serialization

To save your in-memory tree as a string, use *jsonToString*:

```c
char *string = jsonToString(json, 0, 0, 0);
```

This will save the in-memory tree as JSON/5.

To save in strict JSON, use:

```c
char *string = jsonToString(json, 0, 0, JSON_STRICT);
```

To save a sub-set of the tree, specify the root node to export:

```c
char *string = jsonToString(json, 0, "address", JSON_STRICT);
```

This will save all properties under the "address" (including address) property.


## Working with Files

You can parse a JSON file with the *jsonParseFile* API:

```c
Json *json = jsonParseFile("./file.json", NULL, 0);
```

and you can save the in-memory JSON tree using *jsonSave*:

```c
jsonSave(json, 0, "data.json", 0644, 0);
```

## Navigating and Iterating

Properties in the JSON tree are stored as nodes. These nodes can be identified by a numeric ID or by node reference. Nodes and node IDs are used to very efficiently traverse and enumerate property values.

To get a node ID, use *jsonGetId*:

```c
int id = jsonGetId(json, 0, "address");
```

You can retrieve a node using another node as a starting point:

```c
int addressId = jsonGetId(json, 0, "address");
int cityId = jsonGetId(json, addressId, "city");
```

In fact, most APIs such as *jsonGet* and *jsonSet* take a node ID as a parameter that specifies a root of the tree to base the operation. For example, these are equivalent:

```c
int addressId = jsonGetId(json, 0, "address");
int cityId = jsonSet(json, addressId, "city", "Seattle", 0);

// and

jsonGetSet(json, 0, "address.city", "Brisbane", 0);
```

Similarly, you can retreive a node reference:

```c
JsonNode *node = jsonGetNode(json, "address", "city");
```

You can iterate over nodes using the ITERATE_JSON macro:

```c
JsonNode *child;
int id;
for (ITERATE_JSON(json, 0, child, id)) {
    printf("Property %s has value %s\n", child->name, child->value);
}
```

## Debugging

Use the *jsonPrint* API to print a JSON tree to the console:

```c
jsonPrint(json);
```

## JSON/5

JSON/5 an extension of JSON that makes it easier to create, read and maintain configuration files in JSON.

JSON/5 adds the following JavaScript features to JSON.

* Object keys may be JavaScript identifiers without quotes
* Objects or arrays may have a trailing comma
* Strings may be single quoted
* Strings may span multiple lines (single, double or back-tick quotes)
* Numbers may have a leading or trailing decimal point, be hexadecimal, may begin with a +.
* Values may be regular expressions
* Undefined is a valid value
* Single and multiline comments are allowed and preserved

```js
{
    // single-comment
    /*
        Multi-line comment
    */
    unquotedKey: 42,
    singleQuoteString: 'The "lazy brown fox" jumped...',
    multiLine: "Line one
        line two
    ",
    hex: 0x42,
    trailingComma: {
        one: 1,
        two: 2,
    },
}
```

## Memory References

The JSON engine returns values as static pointers into the in-memory tree. Values are returned as const char* (cchar*) values and this saves having to duplicate strings. This reduces memory footprint and is much more efficient.

It is important not to cast returned values to (char*) or to modify the referenced strings using "dirty" programming to break the const typing protection.

## Optimizations

When JSON parses text, it tokenizes the original text and uses it for individual property keys and values. This means the Ioto JSON parser does not need to re-allocate the JSON text and greatly reduces the memory footprint.

JSON nodes are allocated in a single block which may need to grow if you insert new properties into a JSON tree. For this reason, JSON node references should not be persistently stored. JSON node IDs will be stable despite growing the node storage, but node reference will be re-based. If you need to store JSON node references, you should save IDs rather than node references. 

## References

[JSON5 Spec](https://json5.org/)
# Parallelism

To implement parallelism in an application, a developer has three choices:

1. Threads
2. Non-blocking APIs with callbacks
3. Fiber coroutines

## Threads

Programming with threads can be appealing at first, however a multithreaded design can be problematic. Subtle programming errors due to timing related issues, multithread lock deadlocks and race conditions can be extraordinarily difficult to detect and diagnose. All too often, they appear in production deployments.

## Callbacks

The second approach of using non-blocking APIs with callbacks is simpler to debug. But code quality suffers with the all too common "callback-hell". Relatively simple algorithms become obscure when scattered over cascading callbacks.

## Fiber Coroutines

A compelling alternative, is to use **Fiber coroutines**. A fiber coroutine is code that runs with its own stack and cooperatively yields to other fibers when it needs to wait.

You can think of a fiber as a thread, but only one fiber runs at a time so there is no need for thread locking or synchronizing. For Go programmers, fibers are like Go routines. For JavaScript developers, fibers are similar to async/await.

Fibers allow programs to overlap waiting for I/O or other events with useful compute tasks. They achieve parallelism without the pain.

Fibers solve the main problem with multi-threaded programming where multiple threads access the same data at the same time and require complex locking to safeguard data integrity. Fibers solve this problem by enabling a procedural straight line coding style.

Fibers are not perfect. They will not let you utilize all the CPU cores of a system within one program. But for the use case of embedded device management, this is not a significant concern. Device management applications are generally secondary in purpose to the primary role of the device and consequently should not be monopolizing the CPU cores of the device.

## Parallelism Compared

Consider a **threaded** example:

```c
int count = 0;
pthread_mutex_t mutex;

void increment() {
    pthread_mutex_lock(&mutex);
    count = count + 1;
    pthread_mutex_unlock(&mutex);
}

void getCount() {
    int c;
    pthread_mutex_lock(&mutex);
    c = count;
    pthread_mutex_unlock(&mutex);
    return c;
}
```

Now consider the **fiber** solution:

```c
int count = 0;

void increment() {
    count = count + 1;
}

void getCount() {
    return ccount;
}
```

Since only one segment of code is executing at any one time, there is no possibility of fiber collisions.

## Eliminating callbacks

When doing I/O, applications can choose to perform blocking or non-blocking I/O. Blocking I/O while being simpler, means the application cannot perform any other functions while waiting for I/O to complete.

Consider an application that needs to perform a REST HTTP request to retrieve some remote data. While this request is waiting several seconds, the application cannot perform any other task as it is blocked waiting for the request to complete.

Non-blocking I/O solves this problem, but creates another: "callback hell".

Consider this pseudo-example:

```c
//  Issue a request and invoke the onData callback on completion
httpFetch("https://www.example.com", onData)
return;

//  First Callback
static void onData(HttpResult *result)
{
    if (!result) {
        //  Invoke another request
        httpFetch("https://www.backup.com/);
    }
}

//  Second Callback
static void onComplete(HttpResult *result)
{
    //  Now we done and can process the result
}
```

You can see that callbacks quickly obscure the code's intent.

The alternative Ioto code using **fiber coroutine** would look like this:

```c
int data = urlGet("https://www.example.com");
if (!data) {
    data = urlGet("https://www.backup.com/");
}
```

The calls to urlGet will yield and other fibers will run while waiting for I/O. When the request completes, this fiber is transparently resumed and execution continues.

Fiber-based code is simpler to code, debug and maintain. When converting Ioto from callbacks to fibers, several of our algorithms reduced in lines of code by over 30%.

## Fibers in Practice

In practice, you typically don't need to explicitly code fiber yielding or resuming. The Ioto socket APIs are fiber-aware and will do the yielding for you. The **rReadSocket** and **rWriteSocket** APIs will block the current fiber as required, but other fibers will continue to run. NOTE: that only one fiber is ever running at a time.

In all Ioto services, including the web server, Url client, MQTT client and AWS services: the async APIs are fiber-aware and will yield and resume automatically.

For example:

```c
char buf[1024];

while ((nbytes = rSocketRead(sock, buf, sizeof(buf))) > 0) {
    printf("Got body data %.*s\n", (int) nbytes, buf);
}
```

## Blocking

You should never block a fiber. Ioto only runs one fiber at a time. If you block a fiber, it will prevent other fibers from running. 

If you do need to sleep, use the **rSleep** API instead of the **sleep** function. This will yield the fiber and allow other fibers to run.

If you need to explicitly wait for a socket event, use **rSetWaitHandler** to define a wait handler to be invoked when the socket is ready. This will invoke the handler function when the socket is ready. 

When an Ioto socket is created and connected, it defines a wait object referenced by **sock->wait**. However, if you are creating the socket yourself, you will need to define your own wait object via **rAllocWait** and free with **rFreeWait**.

```c
rSetWaitHandler(sock->wait, myHandler, arg, R_READABLE, 0);
```

If you need to manually yield the fiber, use **rYieldFiber** to switch to another fiber. You must make alternate arrangements to resume the fiber via **rResumeFiber** when required.

## Main Program

When using the Ioto fiber coroutines, your main program typically performs little processing before calling **rInit** to create your first fiber. This fiber can then continue initialization and use the full fiber API.

While you can use many of the Safe Runtime (R) APIs from your main program (outside a fiber coroutine), you cannot call **rReadSocket**, **rWriteSocket** and **rConnectSocket** in your main program. It is best practice to call rInit as soon as possible and complete initialization inside a fiber.

If you must read and write from sockets before calling **rInit**, we provide the [rReadSocketSync](http://127.0.0.1:4000/ref/api/r.md#r_8h_1aa75ed2c407f881549fadace8ec56a3bc) and [rWriteSocketSync](http://127.0.0.1:4000/ref/api/r.md#r_8h_1a4a9bc1513a3f0a6f9ef8cd02a91a7041) APIs for that purpose.

## Stack Size

The size of fiber stacks is defined via the **limits.stack** property in the **ioto.json5** configuration file. Set this value to be sufficient for your application needs. 

In general, it is recommended that you limit the use of large stack-based allocations and use heap allocations instead. It is also advised to limit the use of recursive algorithms.

## Ioto I/O API

Ioto builds fiber support into the lowest layer of the "R" portable runtime. The following APIs support automatic fiber yielding:

* [rReadSocket](../ref/api/r.md#r_8h_1a5e68016e4b9381eb07d94855361e4a6d)
* [rWriteSocket](../ref/api/r.md#r_8h_1a59d42a597c69a42387f41d62f0e8c5b2)
* [rSleep](../ref/api/r.md#r_8h_1a35b19891b3c32f496ee52b157cae938a)

These APIs will automatically yield and resume as required.

Furthermore, if you are using TLS, the **rConnectSocket** API must only be called inside a fiber. This is because the handshaking exchange I/O is performed using fiber read/write primities internally.

## Fiber API

Ioto supports a low level fiber API so you can construct your own fiber-enabled primitives.

* [rYieldFiber](http://127.0.0.1:4000/ref/api/r.md#r_8h_1a531c892493b60bb2088705d7f4e447cb)
* [rResumeFiber](http://127.0.0.1:4000/ref/api/r.md#r_8h_1a059333256cfab39b5037149625e1133b)
* [rSpawnFiber](http://127.0.0.1:4000/ref/api/r.md#r_8h_1a116c72a151fb75665eaef53222bcae37)

Use **rYieldFiber** to yield the CPU and switch to another fiber. You must make alternate arrangements to call **rResumeFiber** when required.

Use **rSpawnFiber** to create a new fiber and immediately switch to it. For example:

```c
void myFiberFunction(void *arg) {
    //  code here runs inside a fiber
}
rSpawnFiber(myFiberFunction, arg);
```

## External Services

But what should you do if you need to invoke an external service that will block?

You have two alternatives:

1. Use Non-Blocking APIs
2. Use threads

### Non-Blocking

Ioto provides a flexible centralized eventing and waiting mechanism that can support any service that provides a select() compatible file descriptor.

If the external service has a non-blocking API and provides a file descriptor that is compatible with select or epoll, you can use the Ioto runtime **wait** APIs to be signaled when the external service is complete.

To wait for I/O on a file descriptor, call **rAllocWait** to create a wait object and **rSetWaitHandler** to nominate an event function to invoke.

For example:

```c
wait = rAllocWait(fd);
rSetWaitHandler(wait, fn, arg, R_READABLE);
```

The nominated function will be run on a fiber coroutine when I/O on the file descriptor (fd) is ready.


### Threads

The other option is to create a thread. However you must take care to properly yield the fiber first. The runtime provides a convenient **rSpawnThread** API that will do this for you. It will create a thread, yield the current fiber and then invoke your threadMain. When your threadMain exits and returns a result, it will automatically resume the fiber and pass the result as the return value from rSpawnThread.

For example:

```c
cchar *data = rSpawnThread(threadMain, arg);

static void threadMain(void *arg)
{
    //  Do not call runtime APIs here in this foreign thread
    data = getFromExternalService();
    return data;
}
```

:::warning
It is not safe to call any runtime API from a foreign (not runtime) thread except for: rStartEvent, rResumeFiber, rStartFiber and the thread locking primitives.
:::

If you need to invoke a runtime API from within a foreign thread, you should call rStartEvent to schedule a function that executes on a runtime fiber.

For example:

```c
rSpawnThread(threadMain, arg);

static void insideRuntime(void *arg)
{
    //  Safe to call runtime APIs here
}

static void threadMain(void *arg)
{
    //  This will schedule the "insideRuntime" function to run safely.
    rStartEvent(insideRuntime, arg, 0);
    //  Do not call runtime APIs here in this foreign thread  
    return 0;
}
```


## Manual Yield and Resume

Though unlikely, you may have a need to manually create fibers and yield and resume explicitly.

The APIs for this are: **rAllocFiber**, **rYieldFiber** and **rResumeFiber**.

See the [Runtime API](/agent/ref/api/r.md) for more details.
# Porting Ioto

While porting Ioto is not too difficult, porting any software is not for the novice. It requires skill to read another person's code and adapt it to a new environment. These instructions are intended for experienced developers who want to port Ioto to a new operating system or processor architecture.

Ioto has been written to maximize the ease of porting to a new environment. The O/S and processor-dependent code have been contained while the bulk of the code is cross-platform. Most of this dependent code is in the src/rLib.c file which represents the Safe Runtime (R).

## Steps in Porting to a New System

### Pick a Name for the O/S

If you are doing a port for a new operating system, you need to pick a symbolic name that will be used in conditional compilation, Makefiles, MakeMe files, and operating system specific directories. Some existing O/S names are: "linux", "windows", "freebsd", "freertos", "macosx" and "vxworks".

These names are used as upper-case pre-processor defines and in some cases as lower-case directory names.

### Select the base O/S to emulate

The easiest way to port to a new O/S is to find the closest existing supported O/S that the Ioto software already supports and use it as a base to modify. For example, if you are porting to QNX, you may want to use the Linux port as a base.

### Create the Makefile

Create the Makefile by copying the makefile for the similar O/S. i.e. in our example, Copy the projects/ioto-linux-default.mk Makefile to projects/ioto-qnx-default.mk. Then edit the appropriate compiler and linker switches. 

```bash
$ cp projects/ioto-linux-default.mk projects/ioto-qnx-default.mk
$ vi projects/ioto-qnx-default.mk
```

### Tailor the cross-platform O/S header.

To insulate most of the Ioto source code from the differences of various operating systems, the include/osdep.h header file wraps all the required O/S headers and publishes a consistent set of types and prototypes. None of the source files include normal O/S headers like <string.h>. While this does slow the build by including more headers than are required  it is barely noticeable on modern CPUs.

When porting the osdep.h, start by copying the sections in osdep.h that pertain to your base copied O/S. These will be protected by "#if BASEOS" defines. In the example of QNX, we would look for, and copy, any sections with "#if LINUX" and create "#if QNX" sections.

DO NOT introduce conditional code in other O/S sections. It is better to copy the entire contents from the base O/S and modify. It is better to isolate the code for each O/S.

### Test the Headers with a Hello World Program.

Don't use the make system yet. Just create an empty C hello world program and include "osdep.h". Compile it and shake out the issues.

### Port the Fiber Context Module

Ioto uses fiber coroutines that swap stacks to provide overlapped I/O and compute. Fibers solve the main problem with multi-threaded programming where multiple threads access the same data at the same time and require complex locking to safeguard data integrity. Fibers solve this problem by enabling a procedural straight line coding style.

The existing fiber code supports the CPU architectures: arm, arm64, itanium, mips, mips64, ppc, ppc64, riscv, riscv64, sparc, tidsp, sh, x86, x64 and xtensa. 

Other architectures are supported by emulating fibers over posix pthreads.

The fiber header **uctx-os.h** detects your CPU architecture by a set of conditional compilation tests and enables the appropriate CPU or PTHREAD fiber management code.

### Port the Safe Runtime Source Code

The Safe Portable Runtime (R) wraps the operating system services and exposes a portable, consistent interface for Ioto to utilize. So now is the time for the real work. You will need to modify the **lib/rLib.c** file to support your new platform. 

In rLib.c, you will see banners marking where the various sub-files have been catenated together. The main sections to modify will be socket.c, thread.c time.c and wait.c. Search for conditional code sections for your base O/S and copy/modify as appropriate.

### Test Compile the rLib

To start out, test compile just the R library.

    make NEWOS-ARCH-default/obj/rLib.o

At this stage of the porting effort, the make command will undoubtedly provoke a stream of errors. Use this to work out the bugs in r.h and rLib.c for your O/S.

### Compile the Rest

After the R library, it is more downhill. The rest of the code under **./lib** should compile and build more easily. It is quite cross-platform.

```bash
$ make
```

After building the library, you can port the **cmds/main.c** which is the default Ioto main program.

### Test Ioto

```bash
$ ioto -v
```

## Working with the Ioto Development Team

Once you have a basic port running, you should send it back for the team to look over. They can provide advice and suggestions. 

If you wish, you can contribute your changes back to EmbedThis to be merged back into the core Ioto code. This will make your task of assimilating new releases much easier. Contributed code must be provided under an MIT license so that changes can be shared with both open source and commercial users.

Good luck and have fun. Please give feedback to the development team at dev@embedthis.com.# Embedding Ioto

The Ioto agent is provided as library with a stand-alone command line program.

The Ioto agent can be embedded two ways:

1. Use your own main and code and link with the Ioto library.
2. Use the Ioto main and provide **ioStart** and **ioStop** functions that link to your code.

If you need to embed Ioto in your own main program, you will chose option (1). If you are running on a generic Linux system, you may find option (2) attractive.

## Building

Regardless of which option you choose, you will need to build the Ioto library.

To build Ioto, extract the Ioto source and build the Ioto library and select the **blank** option. This will build the Ioto library without any sample application.

```bash
tar xf ioto-<version>.tar.gz
mv ioto-* ioto
cd ioto
make APP=blank
```

This will build the Ioto library in the **ioto/build/bin** directory. The Ioto include headers are in the **ioto/include** directory.

## Configuration

Copy the **ioto/state** directory of files to your project. When you run your app or the ioto agent from your project directory, it will use the files in the **state** directory for configuration and state.

```bash
cp -r ioto/state state
```

You will probably want to edit the **state/config/device.json5** to define your Product ID.

## Embed in Your Main Program

The first way to integrate Ioto with your code is to create your own main program and link with the Ioto library. This method is desirable if you are using an RTOS like FreeRTOS and need to integrate Ioto into your main program.

To embed Ioto into your main program, you need to do the following things:

1. Add **#include "ioto.h"** to the relevant source files.
2. Provide a main().
3. Invoke **ioStartRuntime** and **ioRun** from your main().
4. Define an **ioStart** function that will be called by Ioto when it starts.
5. Build your app and reference the **libioto.a** library.
6. Edit the Ioto **ioto.json5** configuration file and other Ioto config files to suit your needs.

The following code demonstrates providing your own main().

```c
#include "ioto.h"

int main()
{
    ioStartRuntime(1);

    //  Service requests until told to stop
    ioRun(NULL);

    ioStopRuntime();
    return 0;
}

int ioStart()
{
    rInfo("sample", "Hello World\n");
    //  Your code here
    return 0;
}

void ioStop() {}
```

Note that your ioStart function should not block. If you need a long running task, you should spawn a fiber using **rStartFiber**. Read more about fibers at [Fibers](fiber.md).

```c
int ioStart(void) {
    rSpawnFiber("myFiber", (RFiberProc) longRunningTask, NULL);
    return 0;
}
```

You can also use **ioOnConnect** to start a task when the device connects to the cloud.

```c
ioOnConnect((RWatchProc) detect, 0, 1);
```

You can build this sample and link with the Ioto library and the OpenSSL library:

```bash
cc -o server -I ioto/build/include main.c ioto/build/bin/libioto.a main.c -lssl -lcrypto 
```

## Use the Ioto Command Program 

The second way to integrate Ioto is to use the Ioto main program and provide your own **ioStart** and **ioStop** functions. These functions are invoked by Ioto during startup and shutdown. 

To build with your start/stop functions you need to do the following things:

1. Add **#include "ioto.h"** to the relevant source files.
2. Provide **ioStart** and **ioStop** functions.
3. Add the libioto.a library to the build/link target in your Makefile.
4. Build your application.
4. Create or edit the Ioto **ioto.json5** and other Ioto config files to suit your needs.

### Embedding API

The following code demonstrates the Ioto embedding API.

```c
#include "ioto.h"

PUBLIC void ioStart(void *arg)
{
    rInfo("sample", "Hello World\n");
}
```

If this source is contained in a file called main.c, you can build this sample and link with the Ioto library:

```bash
cc -o server -I ioto/build/inc main.c ioto/build/bin/libioto.a -lssl -lcrypto 
```

If you are building on Mac OS, you will need to install openssl and provide a **-L /opt/homebrew/lib** library directory option.

```bash
brew install openssl
cc-o server -I .../build/inc main.c .../build/bin/libioto.a -L/opt/homebrew/lib -lssl -lcrypto
```

## Samples

The [link-agent-main](https://github.com/embedthis/ioto/tree/main/samples/agent/link-agent-main/README.md) sample demonstrates linking with the Ioto library.

The [own-main](https://github.com/embedthis/ioto/tree/main/samples/agent/own-main/README.md) sample demonstrates linking with your own main.

### More Details

For more details about the Ioto API, please consult the [Ioto APIs](../ref/api/ioto.md).
# Ioto Memory Allocator

Ioto provides a wrapper over the standard malloc memory allocator. This wrapper performs global memory allocation checking and is tailored to the needs of embedded applications.

## Memory Allocation

It is difficult and error-prone for programmers to check the result of every API call that can possibly fail due to memory allocation errors. Calls such as strdup and asprintf are often assumed to succeed, but they can, and do fail when memory is depleted.

A better approach is to proactively detect and handle memory allocation errors in one place. The Ioto allocator handles memory allocation errors globally. When Ioto detects a memory allocation failure, it invokes the global memory exception handler. This configurable handler can then decide what is the best course of recovery. The default action is to abort Ioto so that it can be cleanly restarted.

## Wrapper Routines

The safe runtime provides three memory allocation routines that wrap the standard libc routines.

* **rAlloc** &mdash; Allocate memory
* **rFree** &mdash; Free memory
* **rAllocType** &mdash; Allocate memory for a given type

The rAlloc routine allocates memory and checks for memory failures and invokes the global exception handler if the memory allocation fails.

The rFree routine frees memory and is NULL tolerant. This routine accepts memory allocated via rAlloc or malloc.

The rAllocType routine is a convenience function to allocate memory for a typed object. For example:

```c
mem = rAllocType(struct shape);
```

## Memory Error Handler

The default memory handler prints a message regarding the memory allocation error and aborts execution. 

In many cases, the best recovery is to log the error and quickly reboot the service to minimize down-time. If a slow memory leak is the culprit in your code, then this approach may be sufficient, though clearly not ideal!

You can replace the default handler to perform custom error recovery. Use the **rSetMemHandler** API to install your own memory handler.

```c
void myHandler(int cause, size_t size)
{
    fprintf(stderr, "Memory allocation error for %zd bytes", size);
    //  Try to recover
}

rSetMemoryHandler(myHandler);
```
# MQTT

MQTT is a messaging protocol for (IoT). It is designed as a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices with a small code footprint and minimal network bandwidth.

The Ioto MQTT support is an efficient MQTT client that is ideal for connecting to the cloud.

## MQTT Features

* MQTT 3.1.1 support
* Connect, publish, subscribe, ping and disconnect messages.
* TLS encryption with ALPN over port 443 to get through firewalls.
* Message quality of service for reliable delivery.
* Retained messages.
* High message throughput with exceptionally low overhead.
* Wait for delivery or acknowledgement options.
* Resilient reconnect on network interruptions.
* Automatic configuration after cloud provisioning.
* Parallelism via fiber coroutines. No ugly callbacks or complex threads.
* Tiny footprint of 8K code.

## MQTT Configuration

The Ioto MQTT connection is opened automatically based on the **ioto.json5** configuration settings:

```js
mqtt: {
    authority: 'certs/root.crt',
    client: 'my-device-client-id',
    endpoint: 'https://example.com',
    alpn: 'x-amzn-mqtt-ca',
    port: 443,
    timeout: '30secs',
},
tls: {
    certificate: 'certs/mqtt.crt',
    key: 'certs/mqtt.key',
}
```

These properties describe the MQTT endpoint, port, certificates and keys to use to establish communications with an MQTT broker.

When using a device cloud, your certificate, key and endpoint are automatically provisioned from the Builder. These are saved in the **config/provision.json5** and override the settings of the **mqtt** property collection.

## API Quick Tour

When using cloud-based management, Ioto will typically connect to the cloud once the device is claimed. The MQTT endpoint will be made available via:

```c
ioto->mqtt
```

This means you do not have to explicitly connect to the AWS IoT Core MQTT broker.

However, you can connect to any MQTT endpoint at any time via *mqttConnect* if you wish.

```c
Mqtt *mq = mqttAlloc("my-client-id", onEvents);

mqttConnect(Mqtt *mq, RSocket *sock, int flags, MqttWaitFlags waitFlags);
```
In this case, you create and connect the Socket "sock" using the Safe runtime socket APIs before connecting with MQTT.

## On-Demand Connections

Ioto will transparently connect and disconnect from the device cloud as required to minimize idle MQTT connections. The **mqtt.timeout** property defines the maximum idle time before Ioto will disconnect the MQTT connection.

If you require a permanent MQTT connection, set the **timeout** to "forever". It is best practice to not use permanent connections unless required.

## Publishing Messages

Publishing messages is done via the *mqttPublish* API:

Ioto creates a MQTT connection to the device cloud on startup. This connection is referenced via **ioto->mqtt**.

```c
mqttPublish(ioto->mqtt, "Initialized", 0, MQTT_QOS_1, MQTT_WAIT_NONE, "myDevice/init");
```

This will publish an "initialized" message with quality of service (1) which means "send at least once". The message will be published on the "myDevice/init" topic and this API call will not block for sending or acknowledgement of the message. The sending will happen in the background with any required re-transmissions.

## Subscribing for Messages

You can subscribe to receive incoming messages on a topic via the *mqttSubscribe* API:

```c
mqttSubscribe(ioto->mqtt, incoming, MQTT_QOS_1, MQTT_WAIT_NONE, "myDevice/change");
```

When messages are received on the "myDevice/change" topic, the function `incoming` will be invoked with the message.

The incoming callback will be passed the message response packet.

```c
static void incoming(MqttResp *rp)
{
    printf(stdout, "Received from topic %s: %s", rp->topic, rp->data);
}
```

The message topic will be a null terminated string in **rp->topic**.

The message data will be passed in **rp->data** and the size of the data will be defined in **rp->dataSize**. The data will always be null terminated which is useful when passing message strings.

## Unsubscribing

To unsubscribe from a topic, use the *mqttUnsubscribe* API:

```c
mqttUnsubscribe(ioto->mqtt, "myDevice/unsub", MQTT_WAIT_NONE);
```

## Waiting for Completion

The MQTT APIs can take a MQTT_WAIT argument that indicates if the API call should wait or not for completion.

With the MQTT_WAIT_NONE flag value, the API call will not wait and transmission will happen in the background. The MQTT_WAIT_SENT flag will cause the API to wait until the message has been fully sent from the client, i.e. it has been fully transmitted over the network. The MQTT_WAIT_ACK will cause the API to wait until an acknowledgement message has been received from the peer.

!!!Note
    Don't confuse this with MQTT quality of service levels which define whether a message is reliably delivered or not. In contrast, the WAIT flag determines how the API itself should block and wait.

## Parallelism

The MQTT API uses the Ioto underlying Fiber Coroutine support to implement parallelism. When an MQTT call needs to wait for an acknowledgement or for network I/O, it will resume other fibers in the application transparently. Ioto is single threaded, but can run any number of fibers simultaneously without needing any locks. See [Fiber Coroutines](./fiber.md) for more details.

## Responding to Events

When Ioto connects to AWS IoT core, it will issue a "mqtt:connect" event and when disconnected it will issue a "mqtt:disconnect" event.

These events can be monitored by calling the **rWatch** API. For example:

```c
static void disconnected(cvoid *data, cvoid *arg)
{
    printf("MQTT disconnected\n");
}

rWatch("mqtt:disconnect", disconnected, NULL);
```

The `data` argument is the value provided as the last parameter to rWatch. The `arg` argument is the argument provided when rSignal was called by Ioto, which in this case will be set to NUL.

## Ioto Key/Value Store

Many devices maintain simple device settings that can be sent to the cloud and stored in a key/value store.

An Ioto device cloud provides such a key/value store in the device database called the **Store**. Values can easily be written and read to/from the Store using the **ioSet** APIs.

```c
iotSet("model", "Acme Rocket");
iotSetNum("cpu", 55);
```

These values can be displayed in the device app and can be retrieved in the device via the **ioGet** APIs.

```c
char *model = iotSet("model");
double cpu = iotSetNum("cpu");
```

These APIs are simple wrappers over the mqttPublish and mqttRequest APIs.

## Creating Metrics

When you publish data to the Store, you can create a metric for the published data. This metric can then be displayed using graphical widgets in the device apps.

To enable metrics for your data, define your metrics under the **Store** processing definition in the Device schema and upload that schema to your manager. 

>Note: this is not available when using the `Eval` cloud.

For example:

```js
{
    Store: {
        enable: 'both',
        sync: 'up',
        notify: 'default',
        metrics: [
            {
                namespace: 'Embedthis/Device',
                fields: [{CPU: 'value'}],
                where: 'key == "cpu"',
                dimensions: [{Device: 'deviceId'}],
                buffer: {count: 5, elapsed: 10},
            },
        ],
    },
}
```

See [Database Metrics](../metrics/) for details.

<!--
To publish with metrics, use the lower level **mqttPublish** API.

```c
char msg[160];

SFMT(msg, "{" + 
          "\"key\":\"%s\"," +
          "\"value\":\"%s\"," + 
          "\"type\":\"string\" + 
          "\"metrics\":{\"namespace\" + name, + dimensions,...
          ""}", key, value);
mqttPublish(ioto->mqtt, msg, -1, 1, MQTT_WAIT_NONE,
            "$aws/rules/IotoDevice/ioto/service/%s/value/set", ioto->id);
```
-->

See the [MQTT API](/agent/ref/api/mqtt.md) for more details.

## Other Useful Routines

Use **mqttIsConnected** to test if the MQTT handle is currently connected to the MQTT broker.

## References

[MQTT Configuration Properties](../user/properties.md#mqtt)
[MQTT 3.1.1 spec](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html)
# Ioto Events

Ioto will signal important events and conditions using the Ioto runtime signal mechanism.

You can watch for certain conditions to happen and be notified when they do. For example, it can be useful to be notified when the network connects or disconnects to the cloud.

You can also use the signal mechanism to create your own conditions on which to watch and signal.

To watch for a condition:

```c
rWatch("mqtt:connect", fn, data);
```


This will invoke fn() when the condition occurs and will provide the watch data and the signal argument.

```c
void fn(void *data, void *arg) {
    //  Do something
}
```

## Event List

The list of triggered events:

Name|Description|Arguments
-|-|-
app:ready | When the Ioto app is fully initialized. | None 
cloud:ready | When cloud services are initialized. | None
db:change | When a database table value has changed. | A SyncChange structure with model, item, params and command that caused the change.
db:sync | When the database changes due to receiving a cloud sync update | The update message received from the cloud with the update.
db:sync:done | When a sync to the cloud has been completed and an acknowledgement has been received | None
db:syncup:done | When a syncup on device reboot is complete | None
device:keys | Triggered when AWS access credentials are rotated locally | None
device:registered | When the device has registered with the Builder | None
device:provisioned | When the device is claimed by a device cloud and provisioned for management | None
mqtt:connect | When the MQTT connection to the cloud is established | None
mqtt:disconnect | When the MQTT connection to the cloud is lost | None
mqtt:throttle | When the device is sending to much data to the cloud and further sending is delayed | None


To manually signal a condition, call:

```c
rSignal("mqtt:connect", arg);
```

To disable watching, call:

```c
rWatchOff("mqtt:connect", fn, data);
```

This will disable the watch registered with exactly the same arguments.
# Log File Exports

The Ioto agent can export O/S logs and files from the local device into AWS CloudWatch logs for secure cloud-side storage.

Ioto log capture offers two capabilities:

* Export and save the Ioto Log to CloudWatch
* Capture and export any device O/S log file to CloudWatch

## Enabling Cloud Logs

To enable exporting log files to the device cloud, set the **services.logs** property in the **ioto.json5** file to true.

```js
{
    services: {
        keys: true,
        logs: true
    }
}
```

To export logs, you must have the **keys** property set to true to enable generation of the IAM access keys that grant access to AWS CloudWatch.


## Exporting the Ioto Log

By default, the Ioto trace log is saved to /var/log/ioto.log.

To save this to the cloud, change the **log.path** property in the **ioto.json5** file to be set to "cloud".

```js
    log: {
        path: 'cloud'
        group: 'log-group-name',
        stream: 'log-stream-name',
    }
```

This will cause all messages sent to the Ioto log to be saved to the specified CloudWatch group and stream name. If the group and stream are unset, they default to: "Ioto" and "agent".


## Enabling O/S Log File Export

Ioto can monitor, capture and export any file to S3. Ioto will monitor the length of the file and if new data is written to the log, it will be efficiently captured and written to CloudWatch.

To configure log files for monitoring, define the log files in the **files** property of the **ioto.json5** configuration file. For example:

```js
{
    files: [
        { path: '/var/log/sys*log', group: 'ioto', stream: '${hostname}' }
    ],
}
```

The **files** property contains any number of log definitions. Each definition specifies the local filename and the destination CloudWatch group and stream name.

The file pathname may contain the wild cards "*" and "?". This is useful for log files that have a varying portion such as a date or version component in the name.

The **stream** property can use tokens such as "{hostname}" which is expanded at runtime with the local hostname of the device.
# Calling AWS APIs

If you are using a dedicated device cloud running in your AWS account, Ioto provides a convenience wrapper to make invoking AWS APIs using REST easier.

Without this wrapper, invoking AWS APIs requires using either the bulky AWS C SDK or manually using the AWS SigV4 REST API which is tedious at best.

The Ioto AWS API wrapper uses the SigV4 API but performs the SigV4 signing for you.

## Requirements

To use the AWS SigV4 API, you need to have AWS IAM access keys enabled in the device. See the section on [AWS IAM Access Keys](./keys.md) for details.


## API Quick Tour

To issue an AWS REST API, use the *aws* API:

```c
Url *up = urlAlloc();
int status = aws(up, "us-east-1", "logs", "Logs_20140328.PutLogEvents", data, dataLen, NULL);
```

This will issue a request to the specified AWS service (logs) in a region (us-east-1) and invoke the targeted service (Logs_20140328.PutLogEvents). This call will upload log data to CloudWatch logs.

Under the hood, the *aws* API is calling *awsSign* and *urlFetch*.

```c
char *signedHeaders = awsSign(region, service, target, "POST", "", NULL, body, bodyLen, headers);
char *url = sfmt("https://%s.%s.amazonaws.com/", service, region);
int status = urlFetch(up, "POST", url, body, bodyLen, signedHeaders);
```

The *awsSign* API will perform the required cryptographic signing of a request to be received by AWS.
# Provisioning

Device provisioning is the process of providing devices with the necessary certificates and credentials to securely connect with cloud-based services.

For devices to securely connect to the cloud, they require X.509 certificates so that they can be uniquely identified and authenticated by the cloud service. Once authorized, the certificates are used by the TLS protocol to securely encrypt all communications.

Ioto has an automated provisioning process that takes the pain out of device provisioning and certificate distribution for the user.

There are two primary provisioning patterns:

* User Claimed Devices
* Pre-Claimed Devices

### User Claimed Devices

User claimed devices will register with an Ioto cloud when manufactured and then wait for a user to "claim" the device from the device cloud.

### Pre-Claimed Devices

Pre-claimed devices are those that are configured and claimed by an Ioto device cloud during the device manufacturer. Pre-claimed devices are suitable for proprietary devices or projects where the devices are not distributed generally for resale.

Pre-claimed devices provisioned with certificates when manufactured or first configured.

## Provisioning Lifecycle

Ioto provisioning is accomplished in several phases during the device lifecycle.

* Device Serialization
* Device Registration
* Device Claiming
* Device Connection

![Ioto Provisioning](/images/ioto/provisioning.png){class="screen"}

## Device Serialization

For secure operation it is essential that each device can be uniquely identified. Most devices are created with a serial number that may include the product code, manufacturing batch number and individual serial number. However, while this serial number may be unique, it can be easily guessed because serial numbers typically follow a predictable format.

Instead of using the existing serial number, Ioto uses a random, unique claim ID (UCI) that is a random, 80-bit number that is not guessable and does not follow a predictable pattern. When paired with the product ID it is used as a unique claim ticket for users to claim devices for management.

```
JT08FFQXWQ
```

The 10 letter UCI results in over 1 quadrillion numbers (32^10). Ioto claim IDs can be any length, but we recommend at least 10 letters.

During manufacturer, each device should be given a UCI that identifies the device to the service and is saved in the **device.json5** configuration file on the device.

For User-Claimed devices, the UCI should be printed on the device label and be clearly identified as the **Claim ID**. The Claim ID can also be represented as a QR code if you choose to develop a mobile app for users to claim devices. (See [Claiming](#device-claiming) below).

![Device Label](/images/pics/label.png)

### Creating the UCI

You have two alternatives when creating the UCI depending on how you operate your production process. Regardless of which method you choose, the end result is the Ioto **device.json5** configuration file is updated with the UCI in the **id** property.

```js
{
    "id": "JT08FFQXWQ",
    "product": "01G8YJKKRNTHW213TRZYX3YH0M"
}
```

The **product** property in the device.json5 file is generated by the [Builder Site](https://admin.embedthis.com/) when you define your product.

There are several ways to create the UCI including:

* Manually configure the UCI in the device.json5
* Create unique firmware for each device
* Dynamically provision the UCI in each device

### Manually Creating the UCI

If you have a very small production run of devices, you can manually create the UCI with unique values for each device. You can simply edit the **device.json5** with the required values.

With any significant production volumes, you will want an automated process.

#### Unique Firmware

If you create unique firmware for each device, you can set the UCI in the **device.json5** when you create the firmware.

To create the UCI, you can either run the **ioto** process with the **--gen-id** argument or you can create a simple program that calls the **cryptID** API from the libioto library. See the **./factory/serialize.c** sample for an example.

#### Dynamic UCI

If you are using identical firmware for each device, you can provision the UCI by having the Ioto agent in your device, connect to a serialization service during manufacturer. The serialization service will generate and provide the UCI to the agent that will then persist it to the **device.json5** configuration file.

This generation should be integrated with your label creation process in manufacturer so that the UCI in the device.json5 matches that product label for the device.

The serialization service should listen for client requests on a HTTP endpoint and provide the UCI as the response. The address of the serialization service should be set in the Ioto agent **api.serialize** property in the **ioto.json5** configuration file.

The Ioto agent includes a sample serialization service in the **./factory/serialize.c** file.


## Device Registration

Before leaving the factory, when the device first powers on during system test, the Ioto agent will start and connect to the EmbedThis Ioto cloud service to register itself. This requires that your devices have an opening in the firewall to connect out to https://admin.embedthis.com.

The agent will send the contents of the device.json5 over an encrypted TLS connection to the Ioto cloud service. This registration request includes the device UCI and the product ID. Once received and validated, the Ioto cloud service will save the information in the Ioto device registration database.

If using User-claimed devices, the Ioto agent then awaits for a user to claim the device. If using Pre-claimed devices, the Ioto agent will skip the claiming step and proceed retrieve the required MQTT certificates and securely connect to the cloud.

## Device Claiming

After creating a device cloud, you can create a device app to manage your devices. The device app can be extensively customized with your logo, product name and device specific screens and panels.

When a user purchases or installs a device with the Ioto agent, they can "claim" the device to manage it.

The user claims their device by logging onto the device app and they claim the device using the UCI printed on the device label.

Users enter the device claim code into a form on device app. The cloud service then provisions the necessary X.509 certificates and AWS IoT resources required to support and manage the device.

## Device Connection

When the device is unclaimed, the Ioto agent will regularly check with the Ioto service to see if it has been claimed. In this state, it is "unmanaged" and awaiting orders.

The Ioto device agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay period up to a defined limit. If the device is rebooted, the polling process recommences.

After device claiming, when the device will be provided the X.509 certificate and keys when it next connects or polls the service. The device will save the certificates and keys, then connect to the device cloud. This completes the provisioning process.

## Pre-Claiming Devices

If you are using pre-claimed devices, the process is similar, except you claim the device from the Builder when the device is made. Otherwise the process is the same.
# Uploading Data to S3

If you are using a dedicated device cloud running in your AWS account, Ioto provides a convenience wrapper to make uploading data or files to S3 easier.

## Features

* Upload files to S3
* Upload dynamically generated data to S3


## API Quick Tour

### Uploading a File

To upload a file, use *awsPutFileTS3*:

```c
status = awsPutFileToS3("us-east-1", "MyBucket", "file.dat", "./file.data");
```

This call will upload the file "./file.data" to the bucket "MyBucket" on S3. The file will be saved in the bucket as "file.dat". The returned status will be a HTTP status code of 200 if successful.


### Uploading a Data Block

To upload a data block to AWS S3, use the *awsPutToS3* API.

```c
char data[1024];
int status = awsPutToS3("us-east-1", "MyBucket", "filename", data, sizeof(data));
```

This will upload the data buffer to the given "filename" in the "MyBucket" on S3. The returned status will be a HTTP status code of 200 if successful.

When executing, this call will block the current fiber, but other fibers continue to run. When complete, the call will return.
# Shadow State

The AWS IoT Device Shadow service stores device state in objects called "shadows".


Shadows are capable of handling intermittently connected devices. When a device is not connected, updates to the shadow state in the cloud are stored until the device is next connected. Then, once connected, the changes are sent to the device for action.

If you are using a dedicated device cloud running in your AWS account, you can utilize the AWS IoT shadow state storage. Ioto makes it easy to use shadow state by automatically connecting to the AWS IoT Shadow service and by providing an easy get/set API.

>Note: using the transparent [database synchronization](../database/replication.md) may be easier and more scalable than AWS Shadows.

## Features

* Local copy of AWS Iot Device Shadow in JSON tree
* Convenience API to get / set shadow state properties
* Controllable state synchronization with AWS IoT Shadows
* Local persistency of shadow state.

## Overview

The Ioto agent automatically initializes an AWS Shadow state connection and subscribes to the required MQTT topics for data synchronization.

When shadows updates are received from the cloud, the agent saves these in a local shadow state file called "shadow.json5". When the agent reboots, the local shadow state is read to be immediately available while the AWS cloud shadows are consulted for any updates.

## API Quick Tour

To get the value of a property from the device shadow state, call *ioGetShadow*.

```c
data = ioGetShadow("temperature", 0);
data = ioGetShadow("temperature", "101");
```

The last argument can be a default value to return if the property is not found

To set the value of a property and pass that update to AWS IoT Shadows, call *ioSetShadow*.

```c
ioSetShadow("temperature", "99", 0);
```

This will update the value and perform a lazy save to persistent store and publish to the cloud.

To force an immediate save and publish, set the last argument to 1.

```c
ioSetShadow("temperature", "99", 1);
```

Alternatively, call *ioSaveShadow*:

```c
ioSaveShadow();
```
# AWS Integration Guide

The Ioto agent is pre-integrated with a suite of AWS services to make the job of creating IoT enabled devices dramatically easier.

All these integrations are optional and can be enabled or disabled via the **ioto.json5** configuration file.

## Features

* Simply provision devices for management by AWS IoT.
* Send messages to AWS IoT and other services via MQTT.
* Easy publish data to the cloud via MQTT.
* Create metric from any data for graphical display.
* Replicate and synchronize structured data to AWS DynamoDB.

For device clouds hosted on your own AWS account, you gain direct access to additional AWS features:

* Generate IAM temporary access credentials to call AWS API services on the device.
* Use the compact AWS SigV4 REST APIs from the device.
* Upload data and files to AWS S3.
* Send control-plane data to AWS IoT Shadows.
* Store the Ioto log file in AWS CloudWatch.
* Capture device O/S logs and upload to AWS CloudWatch.
* Emit metrics to AWS CloudWatch metrics.
* Save an audit trail to AWS CloudTrail.
# Cloud Auditing

If you are using a dedicated device cloud in your own AWS account, it is best practice to enable [AWS CloudTrail](https://aws.amazon.com/cloudtrail/) on your AWS device cloud account to track user and API changes and activity on your account.

From the AWS Bible:

>AWS CloudTrail is an AWS service that helps you enable operational and risk auditing, governance, and compliance of your AWS account. Actions taken by a user, role, or an AWS service are recorded as events in CloudTrail. Events include actions taken in the AWS Management Console, AWS Command Line Interface, and AWS SDKs and APIs.

Visibility into your AWS account activity is a key aspect of security and operational best practices. You can use CloudTrail to view, search, download, archive, analyze, and respond to account activity across your AWS infrastructure. You can identify who or what took which action, what resources were acted upon, when the event occurred, and other details to help you analyze and respond to activity in your AWS account. Optionally, you can enable AWS CloudTrail Insights on a trail to help you identify and respond to unusual activity.

Ioto will automatically enable CloudTrail when creating a device cloud.

## S3 Bucket Name

Ioto will enable CloudTrail to log to an S3 bucket named: **ioto-cloudtrail-logs-UUID**
# CloudWatch Metrics

If you are using a dedicated device cloud running in your AWS account and capturing device logs into AWS CloudWatch, Ioto provides a convenience wrapper to make defining AWS cloudwatch metrics easier.

AWS CloudWatch is a monitoring and management service that provides data and actionable insights to monitor devices and get a unified view of operational health.

AWS CloudWatch offers metrics for monitoring specific aspects of your applications. However, AWS custom metrics can become costly when updated or queried frequently, with each custom metric costing up to **$3.60 per metric per year**, along with additional expenses for querying. If you have a significant number of metrics or high dimensionality in your metrics, this could result in a substantial CloudWatch Metrics bill.

>A better solution is to use the Ioto **CustomMetrics** support that offers a cost-effective alternative that is considerably more budget-friendly and efficient compared to standard CloudWatch metrics.

Read about [Ioto Custom Metrics](/ioto/metrics/).

## API Tour

To emit metrics to AWS CloudWatch, use the **rmetrics** API. This uses the CloudWatch EMF log format.

Note: Ioto provides more cost effective metrics via the [Ioto Metrics](/ioto/metrics/). It is generally preferable to use these metrics unless you have a hard requirements to use AWS CloudWatch.

```c
rmetrics("Fan Temperature", "Acme/Rocket", "Fan", "Temp", "int", 101, "Fan", "string", "fan-0", NULL);
```

This would emit the metric "fan-0" temperature is 101 degrees. After this call, CloudWatch or the EmbedThis builder UI can display the fan temperature graph over time.

### The rmetrics API

The arguments of the rmetrics API are:

```c
PUBLIC void rmetrics(cchar *message, cchar *namespace, cchar *dimensions, cchar *values, ...);
```

The **message** is any identifying message you like to emit. The **namespace** is the CloudWatch custom namespace name for your metrics.

The metric values are expressed as triples comprised of: Name, Type and Value.

The **name** is the metric name. The type can be "int", "int64", "boolean" or "string".

You can write multiple metrics with one call by repeating supplying multiple value triples.

The **dimensions** are vectors that qualify the metric. CloudWatch treats each unique combination of dimensions as a separate metric. Enter the dimensions as a comma separated list of dimensions. For example:

dimensions = "Process,Module"

The values of the dimensions must be added to your value triplets.

```c
rmetrics("Fan Temperature", "Acme/Rocket",
    "InFlowTemp", "int", 101,
    "OutFlowTemp", "int", 143,
    "Process", "int", 42,
    "Module", "string", "input",
    NULL);
```
}
# IAM Access Keys

Ioto can automatically generate and provision IAM access keys so you can interact with any AWS service from your device.

The IAM keys are temporary access keys that expire each hour. Ioto will automatically refresh these keys as required.

## Enabling IAM Keys

To enable generation of temporary IAM keys, set the `keys` property of the `services` property in the **ioto.json5** configuration file to true.

```js
{
    services: {
        keys: true
    }
}
```

When the **keys** property is set to true, Ioto will retrieve from your device cloud a set of temporary IAM credentials that can be used to sign AWS API requests using the Ioto **aws** APIs or to use with the [AWS C API SDK](https://github.com/aws/aws-iot-device-sdk-embedded-C).

Ioto saves these keys for you in the Ioto structure:

```c
struct Ioto {
    cchar *awsRegion;          /**< Default AWS region */
    cchar *awsAccess;          /**< AWS temp creds */
    cchar *awsSecret;          /**< AWS cred secret */
    cchar *awsToken;           /**< AWS cred token */
    Time awsExpires;           /**< AWS cred expiry */
}
```

These will be automatically refreshed 20 minutes before expiring -- so you can always rely on using these keys to be valid for 20 minutes.


## IAM Role

The generated keys are based on the Device Cloud IAM role in the device cloud. This defaults to the IAM role named: `IotoDeviceAccess`. However, you can change this using the [Builder Site](https://admin.embedthis.com) Cloud Edit panel to any custom role you choose.

You should follow the principle of least privilege and ensure you scope all privileges granted to your devices are scoped to specific resources and only granting access to AWS APIs that are absolutely required.


## API Quick Tour

To force a regeneration of the IAM access keys, use **ioGetKeys()**.

```c
ioGetKeys();
```
# Software Updates

It is highly desirable to be able to update and upgrade the software in your devices so you can deploy new features, patch security vulnerabilities and improve performance.

For Ioto devices, via the Builder, you can define software updates that will be managed and delivered Over-The-Air (OTA) to your devices.

Using the Builder OTA update manager, you can selectively deploy updates to any desired subset of your device population.

Updates can be published that will be applied to your devices according to a **distribution policy**. In this way, you can selectively update all your device or specific subsets as you require.

![Software Modify](/images/builder/software-edit.png){class="screen width-100"}

See [Builder Software Updates](/builder/software/) for details on how to configure software updates.

## Cloud-Based or Local-Based

You can use the Software Update facility whether you are managing your devices from the cloud or not. If you are not using cloud-based management, you still create a Device Cloud, but you do not need to create a device app, nor do you need to provision your device with MQTT certificates.

To enable software updates, set the **services.update** to true in the **ioto.json5** configuration file.

## Update Selection

At regular intervals, the Ioto agent will connect to the device cloud for an "update check". During this request, the agent will submit the **device.json** contents to the device cloud to see if an update is available for this device.

The device cloud will retrieve the most recent updates and check the updates in reverse version order and select the first matching update for the device.

The device cloud service will evaluate the distribution policy expression when the device checks-in and if the policy matches for the device, the URL for the update image will be returned to the Ioto agent. The agent will then fetch the update image and verify the integrity of the update image. If verified, the **scripts/update** script is invoked to apply the update. If you are running the Agent on an RTOS, without scripting, you will need to watch and react to the the event **device:update** using the rWatch API.


## Software Version

The current version for your device is defined via the **version** property in the **ioto.json5** configuration file. NOTE: your device is versioned separately to the Ioto agent itself which has its own version string.

The version numbers must be compatible with the [SemVer 2.0](https://semver.org/) version specification.

## Device Cloud

Update images are stored in AWS S3 in your device cloud AWS account. When defining updates, you select the relevant device cloud to store and apply the updates. If you have multiple clouds, you will need to define updates in each cloud.


## Checking for Updates

The Ioto agent will issue an **update** HTTP request to the device cloud to query if there are any relevant updates for the device. This request submits the **device.json5** file and receives back a URL that refers to the update image.

If there is an applicable update, Ioto will download the image, verify the contents and then signal that an update is ready.

Your embedded code can watch for "device:update" events via the **rWatch** API. Alternatively, you can customize the **scripts/update** shell script that will be passed the local filename containing the update.

## Controlling Updates

The **ioto.json5** configuration file has a set of properties that control how the Ioto agent will check, download and apply updates.

Note: these are in addition to the Builder update distribution policies and roll-out limits.

For example:

```js
{
    update: {
        schedule: '* * * * *',
        period: '24 hr',
        jitter: 0,
        throttle: 0,
        apply: '* * * * *',
    }
}
```

The **schedule** property defines the time window when the agent will check and download new updates. This is a [Cron-like](https://en.wikipedia.org/wiki/Cron) schedule string.

The **apply** property defines the time window to apply previously downloaded updates. This is useful to separate the impact of downloading updates vs applying updates. For example, you may wish to download updates during the day and only apply at night after business hours.

The **period** property defines the minimum delay in seconds before checking for a new software update.  The period can be a number of seconds or a string with suffixes like: "min", "hr", "day".  The period will be applied as well as the defined **schedule**. i.e. an update checkin will only happen during the specified schedule and no less then the defined period since the last checkin.

The **jitter** property defines a randomize time period in seconds to delay the scheduled software update check so that multiple devices will not all hit the service at once.

The **throttle** property defines a time in milliseconds to pause between reading 4K of a software download update. This delay is useful to lessen the CPU and network impact on the device due to downloading a software update. Set to zero for no delay.

# EmbedThis Ioto&reg; Agent Features

* HTTP/1.1 server.
* HTTP/1.1 client.
* MQTT/3.1.1 client.
* JSON/5 parser and query engine.
* Embedded database (like local DynamoDB)
* Transparent DynamoDB database cloud synchronization.
* AWS IoT Integration with IoT Core, Shadows, Events and Rules.
* AWS service integration with S3, Lambda, Kinesis and CloudWatch.
* Transport Layer Security (TLS/SSL) with ALPN support.
* Safe, secure runtime core.
* Easy provisioning.
* Over-the-air upgrading.
* Complete documentation.
* Extensive Samples.
* Full Source code.

## Feature Overview

### AWS IoT Integration

* AWS Iot Ready &mdash; Bring your own cloud.
* Capture device data and export to AWS.
* Send control plane data to AWS IoT shadows.
* Transparent database synchronization with AWS DynamoDB.
* Upload data and files to AWS S3 data lake.
* Store device logs, metrics in AWS CloudWatch.
* Generate and rotate IAM temporary access credentials.
* Call any AWS API via AWS SDK or more compact AWS REST SigV4 APIs.
* Keep an audit trail in CloudTrail.

### MQTT Client

* MQTT 3.1.1 support.
* On-demand connection management.
* TLS encryption with ALPN over port 443.
* Supports connect, publish, subscribe, ping and disconnect messages.
* Message quality of service for reliable delivery.
* Retained messages.
* Subscription pooling via master subscription topic.
* High message throughput with exceptionally low overhead.
* Wait for delivery or acknowledgement options.
* Auto reconnect.
* Scheduled connections and configurable timeouts and retries.
* Parallelism via fiber coroutines.


## DynamoDB Local Database

* High performance in-memory NoSQL document database.
* Red/black binary search indexes.
* JSON documents with in-memory query API.
* Controllable persistency locally and to the cloud on a per-table basis.
* Transparent bi-directional data synchronization with DynamoDB in the cloud. (like Global Tables).
* Unified data schema between device and cloud databases.
* Database triggers.
* Based on [DynamoDB OneTable](https://doc.onetable.io/) APIs and Schemas.


### HTTP Server

* HTTP/1.0, HTTP/1.1 support.
* TLS/SSL 1.3 and Alpn support.
* URL actions that bind URLs to C functions.
* Configurable request routes and redirections.
* Supports bi-directional transfer chunk encoding to preserve keep-alive.
* Cookie and session management.
* Authentication and user management.
* Fully streaming API for dynamic input and output.
* Request tracing for HTTP request and response headers.
* Sand-box resource limits.
* Runtime configurable via JSON config files.
* HTML helpers for encoding, decoding and escaping content.
* JSON parser and query engine.
* Single-threaded, parallel fiber coroutine event-based runtime.

### HTTP Client

* HTTP/1.0, HTTP.1.1 client.
* Fully streaming API for dynamic input and output.
* Convenience JSON API for interacting with REST services.
* Single-threaded, parallel fiber coroutine event-based runtime.
* TLS/SSL 1.3 with certificate verification controls.

### JSON Parser and Engine

* JSON and JSON/5 support.
* JSON parser and renderer.
* JSON query engine.


### Safe Runtime

* Fiber coroutines for non-blocking procedural programming model.
* Global memory error handler.
* Networking and TLS support.
* Logging framework  filter by source and/or message type.
* Safe strings, lists, hashing and buffer management.
* Safe, secure printf that is tolerant of null args.
* Portable, cross-platform O/S abstraction.

### Performance

* Tiny memory footprint. All-up is less than 200K code.
* Single-threaded fiber coroutines provide an elegant, non-blocking, procedural programming paradigm without resorting to ugly callbacks or complex threads.
* Web server request throughput (&gt; 9,300 requests per second on Raspberry PI 4).

### Security

* Sandbox limits.
* Safe portable runtime to protect against memory leaks and buffer overflows.
* Transport Layer Security (TLS/SSL).

### Developer Integration

* Stand-alone Ioto program
* Embeddable Ioto library
* Easy, intuitive programming model
* Extensive C API

### Documentation

* Full C API Documentation
* Cookbook of samples (cut and paste to get going)
* Tutorials

### Platform Support

* Linux (2.6+)
* MAC OS X (10.7+)
* FreeBSD (10.X+)
* FreeRTOS
* ESP32 
* Easily ported to new platforms

Ioto is portable and users may wish to port Ioto to other operating systems.
Support is available to assist in such efforts.

### Embedding Support

* Supports ARM, MIPS, X86, X64, PPC, RiscV, SH, Sparc processors
* Full cross-compilation support. Use Linux or Mac as build system
* Fine-grained control for conditional build and compilation

### Standards

* [MQTT 3.1.1](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html)
* [RFC 2616 HTTP/1.1](https://www.ietf.org/rfc/rfc2616.txt)
* [TLS 1.3](https://datatracker.ietf.org/doc/html/rfc8446)
* [RFC 1867 Multipart-mime upload](https://datatracker.ietf.org/doc/html/rfc1867)
* [OneTable Database Schema Specification](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md)
# HTTP Standards

The Standards guide contains references to the specifications that govern the HTTP protocol.

Topic|Description
-|-
The HTTP communications protocol specification|[HTTP/1.1](http://www.w3.org/Protocols/rfc2616/rfc2616.html)

Form-based file HTML upload specification | [File Upload](http://www.ietf.org/rfc/rfc1867.txt)
# Metric List

Metrics are created by the Builder and Ioto cloud services.

The following namespaces and locations are available:

Location | Namespace | Description
-|-|-
Builder | Embedthis/Admin | Builder admin service metrics
Builder | Embedthis/App | Customer device app metrics
Builder | Embedthis/Cloud | Software update metrics 
Builder | Embedthis/Ioto | Ioto cloud metrics
App | Embedthis/Device | Customer device specific metrics

Builder metrics are available in Builder dashboards. App metrics are available in device apps dashboards and pages.

## Metrics

The following metrics are available:

Location | Namespace | Metric | Description
-|-|-|-
App | Embedthis/Device | Customer Defined | Customer defined 
Builder | Embedthis/Admin | DevicesMade | Number of devices manufactured
Builder | Embedthis/Admin | DevicesRemoved | Number of devices manufactured 
Builder | Embedthis/Admin | SupportHours | Number of developer support hours consumed
Builder | Embedthis/Admin | SupportTickets | Number of support tickets opened
Builder | Embedthis/App | Registrations | Customer user registrations
Builder | Embedthis/App | UserSessions | Customer user sessions
Builder | Embedthis/Cloud | UpdateRequests | Number of device update requests
Builder | Embedthis/Cloud | UpdateDevices | Number of devices updated
Builder | Embedthis/Cloud | UpdateDeferred | Number of deferred update requests
Builder | Embedthis/Cloud | UpdateStarted | Number of device updates attempted
Builder | Embedthis/Cloud | UpdateSuccess | Number of successful updates
Builder | Embedthis/Cloud | UpdateFailure | Number of failed updates
Builder | Embedthis/Ioto | Bans | Number of devices temporarily banned from the cloud
Builder | Embedthis/Ioto | Devices | Number of devices using a device cloud
Builder | Embedthis/Ioto | DevicesClaimed | Number of devices claimed for cloud-based management
Builder | Embedthis/Ioto | DevicesConnected | Number of devices connecting to the cloud this month
Builder | Embedthis/Ioto | DevicesProvisioned | Number of devices provisioned for connecting to the cloud
Builder | Embedthis/Ioto | DevicesReleased | Number of devices manufactured 
Builder | Embedthis/Ioto | Download | Size in MB of assets downloaded from the cloud
Builder | Embedthis/Ioto | MsgIn | Number of messages received by the cloud
Builder | Embedthis/Ioto | MsgOut | Number of messages sent by the cloud
Builder | Embedthis/Ioto | Storage | Number of devices manufactured 
Builder | Embedthis/Ioto | Throttles | Number of times a device sending too much data was throttled
Builder | Embedthis/Ioto | Transfer | Number of developer support hours consumed
Builder | Embedthis/Ioto | SyncIn | Number of database synchronization messages sent to the cloud
Builder | Embedthis/Ioto | SyncOut | Number of database synchronziation messages sent to devices
Builder | Embedthis/Ioto | Upload | Size in MB of assets uploaded to the cloud
<!--
Builder | Embedthis/Builder | Devices | Number of devices using a device cloud
Builder | Embedthis/Builder | Hubs | Number of device clouds
Builder | Embedthis/Builder | Load | Load per device cloud
Builder | Embedthis/Builder | Storage | Storage per device cloud
Builder | Embedthis/Builder | Tenants | Number of device cloud tenants
Builder | Embedthis/Builder | Transfer | Transfer per device cloud
-->
# Metrics

Device Metrics refer to data points and measurements that provide insights into the performance, availability, and efficiency of your devices and device cloud. Metrics are essential for monitoring and managing your devices and ensuring the overall health of your device pool. 

The Ioto service provides a set of standard metrics and you can create custom metrics based on your device specific data.

Using device data that is synchronized to the cloud from your devices, you can automatically create custom metrics from the data stream. 

## Metric Timespans

When the Ioto service creates metrics, it keeps the current live value and stores the historical metric values so you can monitor historical trends.  Ioto metrics maintains statistics for the last "5 minutes", "hour", "day", "week" "month", or "year". Each of these ranges contain 10-12 data points. 

When querying metrics, you can provide any data range and the relevant underlying metric data will be returned. You can also specify a date range start time and duration for metrics from any point in time.

These metrics can then be monitored and displayed by device apps as a single metric value or as set of values over time as a graph.

## Metric Statistics

For each timespan, you can query the average, minimum, maximum or sum value for the metric. 

## Metric Naming

Metrics are scoped via a set of naming properties including:

* namespace 
* metric name
* dimensions

The **namespace** is a global name to group related metrics. Currently, this must be set to `Embedthis/Device`.

The **metric** name is the specific metric name. For example: a device's `temperature`.

The **dimensions** select specific instances of a metric. For example, each device may have a `temperature` metric and we may also have an overall device pool average `temperature` metric.
Ioto treats each unique combination of dimensions as a separate metric. Enter the dimensions as a comma separated list of dimensions. For example:

dimensions = "Process,Module"

## Defining Metrics

Metrics can be created three ways:

* Via Builder automation actions that create metrics based upon trigger condidtions and values.
* Via the Database schema definition
* Via the Ioto Agent ioMetric API

See [Automations](../../builder/automations/index.md) for more information on how to create Builder automations.

## Database Schema Metrics

Metrics can be created via the device database schema definition. In the **process** section for a schema model, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:

```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

This will automatically create a `Temperature` metric in the `Embedthis/Device` namespace based upon the database item's `temp` attribute whenever the temperature value changes.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| buffer | `map` | Metric buffering directives. Defaults to null|.
| dimensions | `array` | Array of metric dimensions. Defaults to null|.
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| where | `string` | Conditional expression to select items for which to create metrics. |

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.


The `dimensions` property contains an array of dimensions that scope the metric. The elements of the dimensions array can be either field names or objects that map field names into a dimension name. If the values are quoted, they are used as literal values. If unquoted, they are regarded as database item field names.

For example:

```js
process: {
    Fault:   { 
        sync: 'up' 
        metrics: [{
            namespace: 'Embedthis/Device',
            fields: ['temperature'],
            dimensions: [{}, {Device: 'deviceId'}]
        }]
    }
}
```

## Where Expressions

The `where` property can be used to select matching device database items (rows) from which to create the metric.

The `where` query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

will select those items which have the `error` attribute set to "critical" and the `component` attribute set to "PS1".

For example:

```js
{
    Store: {
        enable: 'both',
        sync; 'up',
        notify: 'default',
        metrics: [
            {
                namespace: 'Embedthis/Device',
                fields: [{CPU: 'value'}],
                where: 'key == "cpu"',
                dimensions: [{Device: 'deviceId'}],
                buffer: {count: 5, elapsed: 10},
            }
        ]
    }
}
```

See [Expressions](../../apps/config/expressions.md) for more information on the expression syntax.


## Metric API

Metrics can also be created in the Embedthis/Device namespace by using the Ioto Agent **ioSetMetric** API.

For example:

```c
ioSetMetric("Temperature", 30.5, NULL, 0);
```

Then to read the metric in the agent:

```c
double temp = ioGetMetric("Temperature", NULL, "average", 3660);
```

## Displaying Metrics

Device apps can display metric data via graphical widgets

![Manager](/images/manager/home.png){class="screen"}

You can select from the following widget types:

* gauge
* graph
* table
* progress
* number
* leds

When creating or modifying a widget, you can select the data source to be either a database table item or a metric.

When selecting a metric, you enter the metric name, statistic and resource dimensions.

When selecting data directly from the database, you enter the database table model name, the model field (attribute) and a row selection expression.

![Manager Widget Edit](/images/manager/widget-edit.png){class="screen"}

## Standard Metrics List

See the [Metric List](list.md) for a complete list of metrics.

## Custom Metrics

Custom metrics created from device data streams are created using the **Embedthis/Device** namespace.# Device Table Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-table basis.

## Databases

The Ioto service creates an AWS DynamoDB database table called **ioto** in each device cloud. The **ioto** database table contains the device data and cloud management data for all connected devices in that cloud.

Similarly, the Ioto device agent creates a local embedded database to hold structured data for the device.

These two databases are connected and Ioto replicates changes between device and cloud to keep them in sync.

## Why Synchronization?

The Ioto Database Synchronization service dramatically eases the task of centralizing the data management of a pool of devices. Each device can store data locally and it will be transparently, efficiently and automatically replicated to the cloud. Once in the cloud, it can be easily interrogated and queried for analytics, operational control and intelligence.

Each side has fast, predictable local access to the data. Coupled with reliable replication semantics you can work locally while Ioto takes care of the replication.

## How It Works

To replicate cloud-side data, the Ioto service uses AWS DynamoDB streams to capture modifications made to the cloud-side table data. The stream is connected to a Lambda function that encodes and sends the updates via MQTT messages to a special message topic that is only known to the specific device.

The Ioto device agent subscribes to this topic and receives MQTT messages containing the changed data. The agent then applies those changes to the local database.

In reverse, the Ioto agent registers a database trigger that is called whenever local changes are made to the device's database. When the trigger is invoked, the agent sends an MQTT message with the changes to the Ioto service that updates the cloud database.

Ioto keeps track of the last update sent and received and will retransmit lost updates.

When a device is rebooted after being offline, it sends a "sync" message to the Ioto service to retrieve all changes made to the cloud database since the last change notification was received from the cloud. In this way, changes made while the device is offline or disconnected are not lost.

## Controlling Replication

The cloud-side Ioto DynamoDB table (ioto) and the Ioto agent database both use a [OneTable](https://doc.onetable.io/) schema that defines application data entities, how items are stored, what indexes are used and how to process table data. For example:

```js
const DeviceSchema = {
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault: {sync: 'up'},
    },
    models: {},
}
```

The **"process"** property of the schema defines how to process table data and how tables are synchronized between the device and cloud.

For each database item type in the schema, you can create an entry in the "process" property that specifies where items of that type should be stored and how they should be synchronized.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for item types that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Requirements

Any model that defines a **sync** direction of "up" or "down" must include the following properties in the model definition:

Property | Definition | Description
-|-|-
updated | {type: 'date', readonly: true} | Timestamp for when the item was last updated
_source | {type: 'string', hidden: true} | The source of the last update

The **updated** timestamp property is used to determine the set of updates that have been made to the database since the device last connected to the device cloud. The **_source** property is used to determine the direction of synchronization for an item.

The **bin/make-schema** script that is used when building the Ioto agent and apps will automatically add these properties for synchronized models.# Database Processing

The **schema.process** is a map of properties that control how data is stored in the database and how the data is processed. 

The `process` definitions define the following attributes:

* Where the database item will be stored: device / cloud / both.
* In what direction the database syncronization will flow: to-device / to-cloud / both.
* What metrics should be created from the data stream.

For each item type, you may define an entry in the **process** collection. For example:

```js
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

Each map entry may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| enable | `string` | Control where the item is stored. Set to 'cloud' for in the cloud, 'device' for on the device and 'both' if in both locations. Defaults to 'both'. |
| sync | `string` | Define the direction of the data synchronization. Set to 'down' for down to the device, 'up' for up to the cloud, or 'both' for bi-directional. Defaults to null. |
| metrics | `Array` | Array of metric definitions. See below for details.|
| notify | `boolean` | Issue an AWS EventBridge notification event for matching data. Defaults to false.|

## Database Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-item basis.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

>To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for items that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Metrics

For data that is synchronized to the cloud, you can create custom metrics from the data stream. These metrics can then be displayed or graphed in the device app.

These metrics can be created by creating a Builder Automation action to trigger when specific data values are encountered.

<!--
In the **process** section for an item, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:
```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

This will create a `temperature` metric from the item's `temp` attribute.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| buffer | `map` | Metric buffering directives. Defaults to null.|
| dimensions | `array` | Array of metric dimensions. Defaults to null.|
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| where | `string` | Conditional expression to select items for which to create metrics. |

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.

The `dimensions` property contains an array of dimensions that scope the metric. The elements of the dimensions array can be either field names or objects that map field names into a dimension name. If the values are quoted, they are used as literal values. If unquoted, they are regarded as database item field names.

For example:

```js
process: {
    Fault:   { 
        sync: 'up' 
        metrics: [{
            namespace: 'Embedthis/Device',
            fields: ['temperature'],
            dimensions: [{}, {Device: 'deviceId'}]
        }]
    }
}
```
#### Where Expressions

The `where` property can be used to select matching items for which to create metrics. `Where` expressions use a query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

See [Database Metrics](/ioto/metrics/) for details.
-->

## Event Notification

For dedicated device clouds, you can issue AWS EventBridge events for matching database items via the **notify** property.  The `notify` property is set to the EventBridge bus name. It can be set to "default" or any custom EventBridge bus name.

The database item will be passed to the EventBridge bus as the event context data using the `Embedthis/Ioto` as the event **Source**.

For example:

```js
{
    Store: {
        enable: 'both',
        sync: 'up',
        notify: 'default',
    }
}
```
# Model Attributes

The database schema supports the following attribute properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| default | `string` | Default value to use when creating model items or when reading items without a value.|
| generate | `string|boolean` | Set to 'ulid' or 'uuid' to automatically create a new ID value for the attribute when creating new items.|
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. If unset, the field will use the table default value for isoDates. Default to the schema params value. |
| nulls | `boolean` | Set to true to store null values or false to remove attributes set to null. Default false. |
| required | `boolean` | Set to true if the attribute is required. |
| schema | `object` | Nested schema. |
| ttl | `boolean` | When set to true for date fields, the date value will define when the item should be transparently removed. |
| type | `Type or string` | Field data type. |
| value | `string` | Template to derive the value of the attribute. These attributes are "hidden" by default. |


If the **default** property defines the default value for an attribute. If no value is provided for the attribute when creating a new item, the **default** value will be used.

If the **isoDates** property is defined and not-null, it will override the table isoDates value. Set to true to store the field date value as an ISO date string. Set to false to store the date as a Unix epoch date number.

The **schema** property permits nested field definitions. The parent property must be an Object as the type of items in arrays are defined using the **items** property.

The **type** properties defines the attribute data type. Valid types include: String, Number, Boolean, Date, Object, Null, Array, Buffer (or Binary) and Set. The object type is mapped to a **map**, the array type is mapped to a **list**. Dates are stored as Unix numeric epoch date stamps unless the **isoDates** parameter is true, in which case the dates are store as ISO date strings. Binary data is supplied via **buffer** types and is stored as base64 strings in DynamoDB.

The **value** property defines a literal string template that is used to compute the attribute value. This is useful for computing key values from other properties, creating compound (composite) sort keys or for packing fields into a single DynamoDB attribute when using GSIs.

String templates are similar to JavaScript string templates. The template string may contain **${name}** references to other fields defined in the entity model. If any of the variable references are undefined when an API is called, the computed field value will be undefined and the attribute will be omitted from the operation.

If you call **find** or any query API and do not provide all the properties needed to resolve the complete value template, such as if some of the ${var} references are unresolved, OneTable will take the resolved leading portion and create a **begins with** key condition for that portion of the value template.
# Database Schemas

Ioto uses database schemas to define what are the database data entities and how these will be stored in the database.

A schema specifies the application item types called models. If you are from a SQL background, think "tables". The schema also defines the item fields, indexes and other data access and replication parameters.

Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) schema format, implementing the [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).

The same schema is used for the cloud side AWS DynamoDB table and for the device side embedded database.

## Schema Definition

Schemas look like this:

```js
const DeviceSchema = {
    format: 'onetable:1.1.0',
    version: '0.0.1',
    indexes: {
        primary: {hash: 'pk', sort: 'sk'},
    },
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault:   { 
            sync: 'up',
            triggers: true,
        },
    },
    //  These are the database tables
    models: {
        Status: {
            pk: {type: 'string', value: 'status#'},
            sk: {type: 'string', value: 'status#'},
            parameters: {type: 'object'},
            version: {type: 'string'},
            updated: {type: 'date'},
        },
        Fault: {
            pk: {type: 'string', value: 'device#${deviceId}'},
            sk: {type: 'string', value: 'fault#${id}'},
            deviceId: {type: 'string', required: true},
            id: {type: 'string', generate: 'ulid'},
            timestamp: {type: 'date', required: true},
            source: {type: 'string', required: true},
            severity: {
                type: 'string',
                required: true,
                enum: ['info', 'warn', 'error', 'critical', 'fatal'],
            },
            subject: {type: 'string', required: true},
            message: {type: 'string', required: true},
        },
    },
    params: {
        isoDates: true,
        timestamps: true,
    },
}
```

## Schema Purpose

AWS DynamoDB can operate most efficiently at scale when using a single table with multiple application entities stored in the one table. To make this design pattern easy to implement, application data schemas such as the one used by [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) provide the mapping between application level entities and raw database items.

Ioto uses the OneTable schema in both the DynamoDB table and in the Ioto agent database.

When coupled with a high-level database API such as that offered by OneTable and by the Ioto Agent Database, accessing and managing device data is both performant and straightforward.

## DynamoDB Schema

In Device Clouds, Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) NodeJS library for all access to the **ioto** DynamoDB table. This library has an extensive suite of features beyond those implemented by the Ioto device agent database.

Please consult the [OneTable](https://github.com/sensedeep/dynamodb-onetable) library and [OneTable Documentation](https://doc.onetable.io/) for background.

## Schema Properties

The valid properties of the **schema** object are:

| Property |  Type  | Description                                                                                  |
| -------- | :----: | -------------------------------------------------------------------------------------------- |
| format   | string | Reserved. Must be set to **onetable:1.1.0**                                                  |
| indexes  | object | Hash of indexes used by the table.                                                           |
| models   | object | Hash of item types describing the item keys, indexes and attributes.                    |
| params   | object | Hash of properties controlling how data is stored in the table.                              |
| process  | object | Hash of items describing where the items should be stored and how they should be replicated. |
| version  | string | A SemVer compatible version string.                                                          |

The **format** property specifies the schema format version and must be set to **onetable:1.1.0**.

The **indexes** property specifies the key structure for the primary, local and secondary indexes.

The **models** property contains one or more database item types with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties.

The **params** property defines additional parameters for table data formats.

The **process** map defines how database items should be processed, stored, replicated and whether metrics should be calculated from the data stream.

The **version** property defines a version for your Database design. It must be a [SemVer](https://semver.org/) compatible version string. The version string is used by tools and consumers of the schema to understand compatibility constraints for the schema and stored data.

## Schema Models

The schema defines the database item types as models. For example, consider a music example:

```js
models: {
    album: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        songs:  { type: 'number' },
    },
    artist: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        address: {
            type: Object, schema: {
                street: { type: 'string' },
                city: { type: 'string' },
                zip: { type: 'string' },
            },
        },
    }
}
```

For each item type, all the entity fields are defined by specifying the field type, validations and other operational characteristics (uniqueness, IDs and templates).

The valid types are: array, binary, boolean, date, number, object, and string.

The database will automatically add an item type property via the **\_type** attribute. This is set to the name of the model. You can modify this via the **params.typeField** setting.

## Value Templates

The value of a field can be computed based on the value of other fields and a formatting "value template". This is useful for decoupling your key structure from your entity fields.

The value template is like a Javascript string literal where the value of fields are expressed in a "${field}" format. At runtime, the field references are expanded with the item's value for the named field.

In the example above, the primary key "pk" is calculated from the entity type **\_type** and the **name** field by using the value template: **${_type}:${name}**.

## Nested Schemas

For object attributes, you can define a nested schema for the object properties, as in the example above (repeated below).

A nested schema uses the **schema** property to define a nested map of attributes. Schemas can be nested to an arbitrary depth.

```js
address: {
    type: Object, schema: {
        street: { type: 'string' },
        city: { type: 'string' },
        zip: { type: 'string' }
    }
}
```

## Database Indexes

Schema indexes are defined using the **schema.indexes** property.

The **indexes** property can contain one or more indexes and must contain the **primary** key. Additional indexes will be treated as secondary Indexes.

!!!Note
    Ioto currently only supports the primary index.

```js
const MySchema = {
    indexes: {
        primary: {
            hash: 'pk',         //  Schema property name of the hash key
            sort: 'sk',         //  Schema property name of the sort key
        },
        //  Zero or more global secondary or local secondary indexes
        gs1: {
            hash: 'gs1pk',
            sort: 'gs1sk',
        }
    }
}
```

## Schema Params

The **schema.params** is a map of properties that control how data is stored in the database. It may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| createdField | `string` | Name of the "created" timestamp attribute. Defaults to "created". |
| hidden | `boolean` | Hides templated (value) attributes in Javascript properties. Default true. |
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. Default false. |
| nulls | `boolean` | Store nulls in database attributes vs remove attributes set to null. Default false. |
| timestamps | `boolean | string` | Make "created" and "updated" timestamps in items. Set to true to create both. Set to 'create' for only "created" timestamp and set to "update" for only an "updated" timestamp. See also: "updatedField" and "createdField" properties. Default false. |
| typeField | `string` | Name of the "type" attribute. Default "_type". |
| updatedField | `string` | Name of the "updated" timestamp attribute. Default "updated". |

For example:

```js
const MySchema = {
    params: {
        isoDates: true,
        timestamps: true,
    }
}
```


## References

- [DynamoDB OneTable Overview](https://www.sensedeep.com/blog/posts/2021/dynamodb-onetable-tour.html)
- [DynamoDB with OneTable Schemas](https://www.sensedeep.com/blog/posts/2021/dynamodb-schemas.html)
- [Data Modeling for DynamoDB](https://www.sensedeep.com/blog/posts/2021/dynamodb-singletable-design.html)
- [SenseDeep DynamoDB Data Browser](https://www.sensedeep.com/blog/posts/series/dynamodb-studio/data-browser.html)
- [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).
# Device Tables Overview

Ioto Device Tables is a global, replicated, multi-active database solution that transparently synchronizes data between devices and the cloud.

Similar to AWS DynamoDB Global Tables for replicating data between AWS regions, Ioto Device Tables connects a cloud-side AWS DynamoDB database to a device-resident Ioto embedded database.

Device Tables take the pain out of replicating data between devices and the cloud. Without additional code, it will automatically and transparently synchronize data and state between your devices and the cloud.

Device Tables delivers fast, predictable local read and write access while offering automatic replication of changes.

## Database Replication Features

* Transparent replication between cloud and devices.
* Bi-directional synchronization.
* Per-table synchronization control.
* Resilient catch-up should the device or cloud go offline.
* Database triggers for notification when state data changes.
* Automatic creation of CustomMetrics from the device data stream.

## Challenge

>Aggregating device data in the cloud is not a simple problem.

To centralize device state typically requires several crucial steps:

* State must be captured in the device.
* State must be sent reliably to the cloud despite network disconnections.
* State must be stored and managed in the cloud.
* Conflicts with simultaneous updates must be resolved.
* State updates from the cloud must be sent to the device reliably despite devices being offline.

These factors combine to make centrally aggregating device data decidedly non-trivial.

>Ioto Device Tables solves these issues for you, so you can focus on your device specific logic and value.

## Ioto Agent Embedded Database

The Ioto agent embedded database is an ultra high performance NoSQL database for embedded applications. It supports fast, in-memory, local data access and optional transparent synchronization of data to and from the cloud. The Ioto agent embedded database is designed to be compatible with AWS DynamoDB so that it can easily replicate structured device data to the cloud. It is modeled after [AWS DynamoDB](https://aws.amazon.com/dynamodb/) and the [OneTable](https://doc.onetable.io/) access library.

The database uses Red/black binary search indexes and has controllable local persistence to disk and to the cloud on a per-table basis.

## JSON documents

The database stores items as JSON documents that are a nested collection of properties to arbitrary depth. As JSON is one of the most prevalent data exchange formats, storing data in JSON greatly reduces data replication and API transmission costs.

Ioto includes a powerful JSON query engine that you can use to query and manipulate JSON documents.

## Database Features

* High performance NoSQL management document database.
* JSON document items with flexible query API.
* Efficient import and export of database items.
* Red/black binary search indexes.
* Simple, non-waiting API.
* Controllable persistence with change triggers.
* Transparent bi-directional data synchronization with the cloud.
* Unified data schema between device and cloud databases.
* Based on AWS DynamoDB and DynamoDB OneTable.

# Authentication

The Ioto service provides different authentication methods for two use cases:

Authentication Method | Source | Roles | Purpose
-|-|-|-
[CloudAPI Token](#admin-tokens) | Utility | Owner | Admin utilities running in the cloud or on-premises 
[Login Access Token](#login-access-tokens) | Browser | User, Admin | A logged in user from a web browser app 

For logged in users, Ioto offers **Login Access Tokens** which are granted when a user logs into the Ioto service. These tokens grant access according to the user's authorized role. All actions using Login Access tokens are limited in scope by the user's role and to resources owned by the logged in user.

For utility service commands, Ioto offers **CloudAPI Tokens** that provide full access to the device cloud and the all resources in the cloud. These tokens offer access to all user accounts utilizing the device cloud.

## CloudAPI Tokens

CloudAPI Tokens are used by utility commands and services for full administrative access to the resources of the device cloud. 

CloudAPI Tokens have flexible lifespans and can be managed to set their lifespan or to suspend, resume, revoke or replace the token. You can have one or more CloudAPI tokens active at a time. This is useful to deploy a new token and then subsequently revoke the old token.

To authorize requests using a CloudAPI Token, you need to obtain a **CloudAPI** token from the [Builder](https://admin.embedthis.com). The **CloudAPI** token grants administrator privilege via the **"owner"** role to the caller when accessing Ioto device cloud APIs.

Tokens can be accessed and managed from the [Builder Token list](https://admin.embedthis.com/tokens) or from the Cloud/Edit panel.

### HTTP Request Paths

When using CloudAPI tokens, the request URLs are modified to include a **"/tok"** URL prefix before the URL path.


## Token Authentication Example

Here is an example to issue a request from the command line using `curl` or the Ioto **url** command using a **CloudAPI** token:

::: code-group
```curl
curl -X POST https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/generic/find \
     -H 'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
     -H 'Content-Type: application/json' \
     -d '{"deviceId": "ZXXXXXXXXX", "_type": "Store"}'
```
```url
url https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/generic/find \
    'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
    '{deviceId: "ZXXXXXXXXX", _type: "Store"}'
```
:::

Note: the `url` command is a utility command that is installed with the Ioto agent. It can automatically sense the arguments as either headers, or body data. JSON body data can be passed as JSON5 (like JS) and can thus omit quotes on property keys.


## Login Access Tokens

A Login Access Token may be obtained by logging into the Ioto service with a user email address and password and utilizing the **AccessToken** provided in the response with subsequent Ioto API calls.

The Login request is a single HTTP POST request to the Ioto Cognito authentiction endpoint.


### Login Request

The login request authenticates the user's credentials and exchanges them for a time-limited access token. The access token will be valid for a period of 60 minutes and can be refreshed using a **RefreshToken** contained in the response. The RefreshToken is valid for a period of 30 days.

The request endpoint will vary depending on the AWS region used by the device cloud. 


**Endpoint** 

```
POST https://cognito-idp.${REGION}.amazonaws.com/${USER_POOL_ID}
```

You can obtain the login **Endpoint**, **ClientId** and **UserPoolId** for the device cloud from the Builder's Cloud / Edit panel under **API Access**.

**Request Headers**

```
X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth
Content-Type: application/x-amz-json-1.1
Origin: myapp.ioto.me
```

**Request Body**

```json
{
   "AuthParameters" : {
      "USERNAME" : "yourusername@example.com",
      "PASSWORD" : "yourpassword"
   },
   "AuthFlow" : "USER_PASSWORD_AUTH",
   "ClientId" : "5xxxxxxxxxxxxxxxxxxxxxxxxx"
}
```

The **ClientId** and **UserPoolId** can be obtained from the Builder's Cloud / Edit panel under **API Access**.

**Response**

If the request is successful, you will receive a payload response that contains an **AccessToken**, **RefreshToken** and **ExpiresIn** duration. 

The AccessToken should be used in an **Authorization** HTTP header with subsequentIoto API calls. The **RefreshToken** can be used to refresh the access token before it expires. The **ExpiresIn** property defines how long (in seconds) the access token will be valid before expiring.

```json
{
    "AuthenticationResult":{
        "AccessToken": "...",
        "IdToken": "....",
        "RefreshToken": "....",
        "TokenType": "Bearer",
        "ExpiresIn": 3600
    }
} 
```

**Example**

The following example uses the Ioto `curl` utility to issue an authentication request based on the authentication credentials in a **./creds.json** file. 

::: code-group
```curl
curl -X POST \
  -H 'X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth' \
  -H 'Content-Type: application/x-amz-json-1.1' \
  --data @creds.json \
  https://cognito-idp.us-east-1.amazonaws.com/
```
```url
$ url https://cognito-idp.us-east-1.amazonaws.com/ \
    'X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth' \
    'Content-Type: application/x-amz-json-1.1' \
    @creds.json
```
:::

### Roles

When user accounts are created in the device app, the user is authorized with an access role that determines the scope of access for the user. The following three roles are supported:

Role | Capabilties
-|-
user | Ability to view but not modify service depending resources.
admin | Ability to modify all resources and fully administer the account.
owner | Ability to close the device app account and delete all users and resources.

The Builder will utilize an **owner** role for the **CloudAPI** authentication token. This gives the ability to manage multiple accounts and devices over all users.


## Refreshing Login Tokens

Access tokens expire after 60 minutes. However, you can refresh the access token without requiring the user to re-login by using the **RefreshToken** that was returned when first logging in. Refresh tokens expire after 30 days.

**Endpoint**

```
POST https://cognito-idp.REGION.amazonaws.com/
```

The **REGION** can obtain the endpoint from the Builder's Cloud / Edit panel under **API Access**.

**Request Headers**

```
X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth
Content-Type: application/x-amz-json-1.1
```

**Request Body**

```json
{
   "AuthParameters" : {
      "REFRESH_TOKEN": "...",
   },
   "AuthFlow" : "REFRESH_TOKEN_AUTH",
   "ClientId" : "5g3qt5mitfa4q1jlrlibeviedn"
}
```

The **ClientId** can obtain the endpoint from the Builder's Cloud / Edit panel under **API Access**.

**Response**

If the request is successful, you will receive the following payload response. The AccessToken should be used in an **Authorization** HTTP header with Ioto API calls . The RefreshToken should be used to refresh the access token before it expires. The ExpiresIn property defines how long the token will be valid.

```json
{
    "AuthenticationResult":{
        "AccessToken": "...",
        "IdToken": "....",
        "RefreshToken": "....",
        "TokenType": "Bearer",
        "ExpiresIn": 3600
    }
} 
```

### Logout

There is not an explicit sesion logout API. To logout, discard and erase the access and refresh tokens from any local storage and remove any browser session state associated with the tokens.
# Dashboard

Manage UI Dashboards.

## Create
Create a new dashboard.

**Endpoint**

```HTTP
POST /dashboard/create
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Default | Notes |
| - | - | - | - | - |
| css | array |  |  | CSS styles for the dashboard. |
| emulate | string |  |  | Emulate device type when designing. |
| fixed | boolean |  |  | Prevent runtime changes to the dashboard. |
| framed | boolean |  |  | Show a frame around dashboard widgets. |
| layout | string |  | grid |  |
| live | boolean |  |  | Enable live data updates. |
| name | string | yes |  | Dashboard name. |
| range | object |  |  | Override time range for the dashboard. |
| refresh | number |  |  | Refresh rate in seconds. |
| toolbar | boolean |  |  | Show a toolbar on the dashboard. |
| type | string |  |  | Board type: "page" or "dashboard". |
| widgets | array |  |  | Widgets. |
| widgetCss | array |  |  | CSS styles for dashboard widgets. |

**Widgets** 

| Field | Type | Default | Notes |
| - | - | - | - |
| actions | array |  | Widget actions. |
| accept | string |  | File input accept type. |
| anchor | object | {} | Anchor side. |
| axes | object |  | Graph axes. |
| cloudId | string |  | Cloud ID. |
| columns | array |  | Table columns to display. |
| css | array |  | CSS styles. |
| datetime | string |  | Date input datetime. |
| defaultValue | string |  | Default value. |
| dimensions | object | {} | Metric and data dimensions. |
| field | string |  | Database data field. |
| fields | array |  | Database fields to fetch. |
| fixed | boolean |  | Lock down changes. |
| form | string |  | Input form name. |
| formField | string |  | Input form field. |
| footer | string |  | Widget footer. |
| format | string |  | Text and numeric format. |
| framed | boolean |  | Widget has a frame. |
| header | string |  | Widget header text. |
| height | string |  | Widget height in pixels. |
| id | string |  | Unique widget UUID within the dashboard only. |
| icon | string |  | Icon to display. |
| input | string |  | Input type. |
| items | string |  | Input items (JSON). |
| label | string |  | Input label. |
| legend | object |  | Widget legend. |
| left | string |  | Fraction of viewport (0-1) or "rest". |
| limit | number |  | Item limit. |
| max | number |  | Maximum data value. |
| min | number |  | Minimum data value. |
| metric | string |  | CloudWatch Metric. |
| model | string |  | Database model. |
| multiple | boolean |  | Multiple selection. |
| namespace | string |  | Metric namespace. |
| options | object |  | Custom options. |
| pageSize | number |  | Table page size. |
| pivot | string |  | Table pivot column. |
| placeholder | string |  | Input placeholder. |
| prefix | string |  | Value prefix. |
| presentation | string |  | Presentation style. |
| range | object | {} | Time range. |
| region | string |  | Region for metrics. |
| rows | number |  | Text area rows. |
| show | string |  | Show expression. |
| statistic | string |  | Math stat. |
| subtitle | string |  | Table subtitle. |
| suffix | string |  | Value suffix. |
| text | string |  | Static widget value. |
| ticks | number |  | Number of ticks. |
| timezone | string |  | Date input timezeon. |
| title | string |  | Widget title. |
| top | string |  | Top position. |
| type | string |  | Widget type. |
| units | string |  | Metric units. |
| url | string |  | Resource URL. |
| validate | string |  | RegExp validation. |
| width | string |  | Fraction of viewport (0-1). |
| z | number |  | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type | Default |
| - | - | - |
| anchor | string | relative |
| start | date |  |
| period | number | 2419200 |
| refresh | number | 60 |
| override | boolean | false |
| timezone | string | local |



**Query String Options** 

| Field | Type | Default | Role | Notes |
| - | - | - | - | - |
| index | string |  | owner | Database index name: primary or gs1. |
| limit | number |  |  | Number of items to retrieve. |
| next | object |  |  | Pagination token for the next page. |
| prev | object |  |  | Pagination token for the previous page. |

**Response** 

Dashboard Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| css | array | CSS styles for the dashboard. |
| emulate | string | Emulate device type when designing. |
| fixed | boolean | Prevent runtime changes to the dashboard. |
| framed | boolean | Show a frame around dashboard widgets. |
| id | string | Unique dashboard ID. |
| layout | string | Dashboard layout. |
| live | boolean | Enable live data updates. |
| name | string | Dashboard name. |
| range | object | Time range for the dashboard. |
| refresh | number | Refresh rate in seconds. |
| toolbar | boolean | Show a toolbar on the dashboard. |
| type | string | Dashboard type. |
| widgetCss | array | CSS styles for dashboard widgets. |
| widgets | array | Widgets. |

**Range** 

Time range for the dashboard.

| Field | Type | Notes |
| - | - | - |
| anchor | string | Anchor type to be "absolute" or "relative". |
| start | date | Start date. |
| period | number | Time period in seconds. |
| refresh | number | Refresh rate in seconds. |
| override | boolean | Override the dashboard user selected time range. |
| timezone | string | Timezone to display the data in. |


**Widgets** 

| Field | Type | Notes |
| - | - | - |
| actions | array | Widget actions. |
| accept | string | File input accept type. |
| anchor | object | Anchor side. |
| axes | object | Graph axes. |
| cloudId | string | Cloud ID. |
| columns | array | Table columns to display. |
| css | array | CSS styles. |
| datetime | string | Date input datetime. |
| defaultValue | string | Default value. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database data field. |
| fields | array | Database fields to fetch. |
| fixed | boolean | Lock down changes. |
| form | string | Input form name. |
| formField | string | Input form field. |
| footer | string | Widget footer. |
| format | string | Text and numeric format. |
| framed | boolean | Widget has a frame. |
| header | string | Widget header text. |
| height | string | Widget height in pixels. |
| id | string | Unique widget UUID within the dashboard only. |
| icon | string | Icon to display. |
| input | string | Input type. |
| items | string | Input items (JSON). |
| label | string | Input label. |
| legend | object | Widget legend. |
| left | string | Fraction of viewport (0-1) or "rest". |
| limit | number | Item limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model. |
| multiple | boolean | Multiple selection. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pageSize | number | Table page size. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string | Value prefix. |
| presentation | string | Presentation style. |
| range | object | Time range. |
| region | string | Region for metrics. |
| rows | number | Text area rows. |
| show | string | Show expression. |
| statistic | string | Math stat. |
| subtitle | string | Table subtitle. |
| suffix | string | Value suffix. |
| text | string | Static widget value. |
| ticks | number | Number of ticks. |
| timezone | string | Date input timezeon. |
| title | string | Widget title. |
| top | string | Top position. |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Resource URL. |
| validate | string | RegExp validation. |
| width | string | Fraction of viewport (0-1). |
| z | number | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Find
Find dashboards by matching properties and query parameters.

**Endpoint**

```HTTP
POST /dashboard/find
```

**Authorized User Role**

```
user
```

**Response** 

Dashboard Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| css | array | CSS styles for the dashboard. |
| emulate | string | Emulate device type when designing. |
| fixed | boolean | Prevent runtime changes to the dashboard. |
| framed | boolean | Show a frame around dashboard widgets. |
| id | string | Unique dashboard ID. |
| layout | string | Dashboard layout. |
| live | boolean | Enable live data updates. |
| name | string | Dashboard name. |
| range | object | Time range for the dashboard. |
| refresh | number | Refresh rate in seconds. |
| toolbar | boolean | Show a toolbar on the dashboard. |
| type | string | Dashboard type. |
| widgetCss | array | CSS styles for dashboard widgets. |
| widgets | array | Widgets. |

**Range** 

Time range for the dashboard.

| Field | Type | Notes |
| - | - | - |
| anchor | string | Anchor type to be "absolute" or "relative". |
| start | date | Start date. |
| period | number | Time period in seconds. |
| refresh | number | Refresh rate in seconds. |
| override | boolean | Override the dashboard user selected time range. |
| timezone | string | Timezone to display the data in. |


**Widgets** 

| Field | Type | Notes |
| - | - | - |
| actions | array | Widget actions. |
| accept | string | File input accept type. |
| anchor | object | Anchor side. |
| axes | object | Graph axes. |
| cloudId | string | Cloud ID. |
| columns | array | Table columns to display. |
| css | array | CSS styles. |
| datetime | string | Date input datetime. |
| defaultValue | string | Default value. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database data field. |
| fields | array | Database fields to fetch. |
| fixed | boolean | Lock down changes. |
| form | string | Input form name. |
| formField | string | Input form field. |
| footer | string | Widget footer. |
| format | string | Text and numeric format. |
| framed | boolean | Widget has a frame. |
| header | string | Widget header text. |
| height | string | Widget height in pixels. |
| id | string | Unique widget UUID within the dashboard only. |
| icon | string | Icon to display. |
| input | string | Input type. |
| items | string | Input items (JSON). |
| label | string | Input label. |
| legend | object | Widget legend. |
| left | string | Fraction of viewport (0-1) or "rest". |
| limit | number | Item limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model. |
| multiple | boolean | Multiple selection. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pageSize | number | Table page size. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string | Value prefix. |
| presentation | string | Presentation style. |
| range | object | Time range. |
| region | string | Region for metrics. |
| rows | number | Text area rows. |
| show | string | Show expression. |
| statistic | string | Math stat. |
| subtitle | string | Table subtitle. |
| suffix | string | Value suffix. |
| text | string | Static widget value. |
| ticks | number | Number of ticks. |
| timezone | string | Date input timezeon. |
| title | string | Widget title. |
| top | string | Top position. |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Resource URL. |
| validate | string | RegExp validation. |
| width | string | Fraction of viewport (0-1). |
| z | number | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Get
Get a matching dashboard.

**Endpoint**

```HTTP
POST /dashboard/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Dashboard ID. |
| name | string | Dashboard name. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| css | array | CSS styles for the dashboard. |
| emulate | string | Emulate device type when designing. |
| fixed | boolean | Prevent runtime changes to the dashboard. |
| framed | boolean | Show a frame around dashboard widgets. |
| id | string | Unique dashboard ID. |
| layout | string | Dashboard layout. |
| live | boolean | Enable live data updates. |
| name | string | Dashboard name. |
| range | object | Time range for the dashboard. |
| refresh | number | Refresh rate in seconds. |
| toolbar | boolean | Show a toolbar on the dashboard. |
| type | string | Dashboard type. |
| widgetCss | array | CSS styles for dashboard widgets. |
| widgets | array | Widgets. |

**Range** 

Time range for the dashboard.

| Field | Type | Notes |
| - | - | - |
| anchor | string | Anchor type to be "absolute" or "relative". |
| start | date | Start date. |
| period | number | Time period in seconds. |
| refresh | number | Refresh rate in seconds. |
| override | boolean | Override the dashboard user selected time range. |
| timezone | string | Timezone to display the data in. |


**Widgets** 

| Field | Type | Notes |
| - | - | - |
| actions | array | Widget actions. |
| accept | string | File input accept type. |
| anchor | object | Anchor side. |
| axes | object | Graph axes. |
| cloudId | string | Cloud ID. |
| columns | array | Table columns to display. |
| css | array | CSS styles. |
| datetime | string | Date input datetime. |
| defaultValue | string | Default value. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database data field. |
| fields | array | Database fields to fetch. |
| fixed | boolean | Lock down changes. |
| form | string | Input form name. |
| formField | string | Input form field. |
| footer | string | Widget footer. |
| format | string | Text and numeric format. |
| framed | boolean | Widget has a frame. |
| header | string | Widget header text. |
| height | string | Widget height in pixels. |
| id | string | Unique widget UUID within the dashboard only. |
| icon | string | Icon to display. |
| input | string | Input type. |
| items | string | Input items (JSON). |
| label | string | Input label. |
| legend | object | Widget legend. |
| left | string | Fraction of viewport (0-1) or "rest". |
| limit | number | Item limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model. |
| multiple | boolean | Multiple selection. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pageSize | number | Table page size. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string | Value prefix. |
| presentation | string | Presentation style. |
| range | object | Time range. |
| region | string | Region for metrics. |
| rows | number | Text area rows. |
| show | string | Show expression. |
| statistic | string | Math stat. |
| subtitle | string | Table subtitle. |
| suffix | string | Value suffix. |
| text | string | Static widget value. |
| ticks | number | Number of ticks. |
| timezone | string | Date input timezeon. |
| title | string | Widget title. |
| top | string | Top position. |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Resource URL. |
| validate | string | RegExp validation. |
| width | string | Fraction of viewport (0-1). |
| z | number | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Remove
Remove a dashboard.

**Endpoint**

```HTTP
POST /dashboard/remove
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Dashboard ID. |

## Update
Update a dashboard.

**Endpoint**

```HTTP
POST /dashboard/update
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Default | Notes |
| - | - | - | - | - |
| css | array |  |  | CSS styles for the dashboard. |
| emulate | string |  |  | Emulate device type when designing. |
| fixed | boolean |  |  | Prevent runtime changes to the dashboard. |
| framed | boolean |  |  | Show a frame around dashboard widgets. |
| id | string | yes |  | Dashboard ID. |
| layout | string |  |  | Dashboard layout. |
| live | boolean |  |  | Enable live data updates. |
| name | string |  |  | Dashboard name. |
| range | object |  |  | Override time range for the dashboard. |
| refresh | number |  |  | Refresh rate in seconds. |
| toolbar | boolean |  |  | Show a toolbar on the dashboard. |
| type | string |  |  | Board type: "page" or "dashboard". |
| widgets | array |  |  | Widgets. |
| widgetCss | array |  |  |  |

**Widgets** 

| Field | Type | Default | Notes |
| - | - | - | - |
| actions | array |  | Widget actions. |
| accept | string |  | File input accept type. |
| anchor | object | {} | Anchor side. |
| axes | object |  | Graph axes. |
| cloudId | string |  | Cloud ID. |
| columns | array |  | Table columns to display. |
| css | array |  | CSS styles. |
| datetime | string |  | Date input datetime. |
| defaultValue | string |  | Default value. |
| dimensions | object | {} | Metric and data dimensions. |
| field | string |  | Database data field. |
| fields | array |  | Database fields to fetch. |
| fixed | boolean |  | Lock down changes. |
| form | string |  | Input form name. |
| formField | string |  | Input form field. |
| footer | string |  | Widget footer. |
| format | string |  | Text and numeric format. |
| framed | boolean |  | Widget has a frame. |
| header | string |  | Widget header text. |
| height | string |  | Widget height in pixels. |
| id | string |  | Unique widget UUID within the dashboard only. |
| icon | string |  | Icon to display. |
| input | string |  | Input type. |
| items | string |  | Input items (JSON). |
| label | string |  | Input label. |
| legend | object |  | Widget legend. |
| left | string |  | Fraction of viewport (0-1) or "rest". |
| limit | number |  | Item limit. |
| max | number |  | Maximum data value. |
| min | number |  | Minimum data value. |
| metric | string |  | CloudWatch Metric. |
| model | string |  | Database model. |
| multiple | boolean |  | Multiple selection. |
| namespace | string |  | Metric namespace. |
| options | object |  | Custom options. |
| pageSize | number |  | Table page size. |
| pivot | string |  | Table pivot column. |
| placeholder | string |  | Input placeholder. |
| prefix | string |  | Value prefix. |
| presentation | string |  | Presentation style. |
| range | object | {} | Time range. |
| region | string |  | Region for metrics. |
| rows | number |  | Text area rows. |
| show | string |  | Show expression. |
| statistic | string |  | Math stat. |
| subtitle | string |  | Table subtitle. |
| suffix | string |  | Value suffix. |
| text | string |  | Static widget value. |
| ticks | number |  | Number of ticks. |
| timezone | string |  | Date input timezeon. |
| title | string |  | Widget title. |
| top | string |  | Top position. |
| type | string |  | Widget type. |
| units | string |  | Metric units. |
| url | string |  | Resource URL. |
| validate | string |  | RegExp validation. |
| width | string |  | Fraction of viewport (0-1). |
| z | number |  | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type | Default |
| - | - | - |
| anchor | string | relative |
| start | date |  |
| period | number | 2419200 |
| refresh | number | 60 |
| override | boolean | false |
| timezone | string | local |



**Query String Options** 

| Field | Type | Default | Role | Notes |
| - | - | - | - | - |
| index | string |  | owner | Database index name: primary or gs1. |
| limit | number |  |  | Number of items to retrieve. |
| next | object |  |  | Pagination token for the next page. |
| prev | object |  |  | Pagination token for the previous page. |

**Response** 

Dashboard Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| css | array | CSS styles for the dashboard. |
| emulate | string | Emulate device type when designing. |
| fixed | boolean | Prevent runtime changes to the dashboard. |
| framed | boolean | Show a frame around dashboard widgets. |
| id | string | Unique dashboard ID. |
| layout | string | Dashboard layout. |
| live | boolean | Enable live data updates. |
| name | string | Dashboard name. |
| range | object | Time range for the dashboard. |
| refresh | number | Refresh rate in seconds. |
| toolbar | boolean | Show a toolbar on the dashboard. |
| type | string | Dashboard type. |
| widgetCss | array | CSS styles for dashboard widgets. |
| widgets | array | Widgets. |

**Range** 

Time range for the dashboard.

| Field | Type | Notes |
| - | - | - |
| anchor | string | Anchor type to be "absolute" or "relative". |
| start | date | Start date. |
| period | number | Time period in seconds. |
| refresh | number | Refresh rate in seconds. |
| override | boolean | Override the dashboard user selected time range. |
| timezone | string | Timezone to display the data in. |


**Widgets** 

| Field | Type | Notes |
| - | - | - |
| actions | array | Widget actions. |
| accept | string | File input accept type. |
| anchor | object | Anchor side. |
| axes | object | Graph axes. |
| cloudId | string | Cloud ID. |
| columns | array | Table columns to display. |
| css | array | CSS styles. |
| datetime | string | Date input datetime. |
| defaultValue | string | Default value. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database data field. |
| fields | array | Database fields to fetch. |
| fixed | boolean | Lock down changes. |
| form | string | Input form name. |
| formField | string | Input form field. |
| footer | string | Widget footer. |
| format | string | Text and numeric format. |
| framed | boolean | Widget has a frame. |
| header | string | Widget header text. |
| height | string | Widget height in pixels. |
| id | string | Unique widget UUID within the dashboard only. |
| icon | string | Icon to display. |
| input | string | Input type. |
| items | string | Input items (JSON). |
| label | string | Input label. |
| legend | object | Widget legend. |
| left | string | Fraction of viewport (0-1) or "rest". |
| limit | number | Item limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model. |
| multiple | boolean | Multiple selection. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pageSize | number | Table page size. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string | Value prefix. |
| presentation | string | Presentation style. |
| range | object | Time range. |
| region | string | Region for metrics. |
| rows | number | Text area rows. |
| show | string | Show expression. |
| statistic | string | Math stat. |
| subtitle | string | Table subtitle. |
| suffix | string | Value suffix. |
| text | string | Static widget value. |
| ticks | number | Number of ticks. |
| timezone | string | Date input timezeon. |
| title | string | Widget title. |
| top | string | Top position. |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Resource URL. |
| validate | string | RegExp validation. |
| width | string | Fraction of viewport (0-1). |
| z | number | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



# Metric

API to manage metrics including the ability to get and set metrics, and to get a list of available metrics.<br><br>            The Ioto service creates metrics for device and service data. It stores the current live and historical metric values. Metrics are calculated for for the last "5 minutes", hour, day, week, month, and year. Statistics are kept for the average, min, max, count and the sum of metric values.<br>            <br>            Metrics are named and grouped into [Namespaces](/ioto/metrics/#metric-naming) with metric [Dimensions](/ioto/metrics/#metric-naming) selecting instances of a metric for a specific resoure.

**See Also**

* [Metrics](/ioto/metrics/)

## Fetch
Fetch metric values.<br>                    <br>                    This API fetches multiple metric values in a single request.

**Endpoint**

```HTTP
POST /metric/fetch
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| items | array | yes | Array of metric requests. |
| deviceId | string | yes | Device ID owning the metrics. |

**Metric Request** 

| Field | Type | Required | Default | Notes |
| - | - | - | - | - |
| accumulate | boolean |  |  | Accumulate result into a single result. |
| cloudId | string |  |  | Device Cloud ID. |
| dimensions | object |  |  | Dimensions for metric. |
| field | string |  |  | Database field name. |
| limit | number |  |  | Number of items to fetch. |
| metric | string |  |  | Metric name. |
| model | string |  |  | Database model name. |
| namespace | string | yes |  | Must be set to Embedthis/Device. |
| period | number |  | 300 | Metric timespan period. |
| start | number |  |  | Metric range start. |
| statistic | string | yes | avg | Metric statistic. Select from: avg, min, max, count, sum. |


**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of devices owned by the user. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Metric** 

| Field | Type | Notes |
| - | - | - |
| dimensions | object | Dimensions for the metric. |
| error | string | Error message. |
| metric | string | Metric name. |
| namespace | string | Always set to Embedthis/Device. |
| owner | string | The service owning the metric. |
| period | number | Metric timespan period. |
| points | array | Array of data points (see below). |
| samples | number | Number of data points in the period. |
| * | any |  |

**Dimensions** 

Dimensions for the metric.

| Field | Type |
| - | - |
| * | any |


**Point** 

| Field | Type | Notes |
| - | - | - |
| value | number | Metric value. |
| timestamp | number | Last update to the metric value in seconds since Jan 1, 1970. |
| count | number | Number of data values contributing to the metric value. |


## Get
Get an accumulated metric. <br><br>                    This API is used by devices to retrieve a metric statistic over the MQTT protocol.<br>                    <br>                    To get metrics over REST HTTP, use the **fetch** API.

**Protocol**

```
MQTT
```

**Endpoint**

```
mqtt: /metric/get
```

**Authorized User Role**

```
device
```

**Request Body** 

| Field | Type | Default | Notes |
| - | - | - | - |
| dimensions | object |  | Dimensions for metric. |
| metric | string |  | Metric name. |
| period | number | 300 | Metric timespan period. |
| statistic | string | avg | Metric statistic. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Metric** 

| Field | Type | Notes |
| - | - | - |
| dimensions | object | Dimensions for the metric. |
| metric | string | Metric name. |
| namespace | string | Always set to Embedthis/Device. |
| owner | string | The service owning the metric. |
| period | number | Metric timespan period. |
| points | array | Array of data points. |
| samples | number | Number of data points in the period. |

**Dimensions** 

Dimensions for the metric.

| Field | Type |
| - | - |
| * | any |


**Point** 

| Field | Type | Notes |
| - | - | - |
| value | number | Metric value. |
| timestamp | number | Last update to the metric value in seconds since Jan 1, 1970. |
| count | number | Number of data values contributing to the metric value. |


## GetDeviceSchema
Get a device schema.

**Endpoint**

```HTTP
POST /metric/getDeviceSchema
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |

**Response** 

Schema definition.


## GetMetricList
Get a list of available metrics.

**Endpoint**

```HTTP
POST /metric/getMetricList
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Role | Notes |
| - | - | - | - | - |
| cloudId | string | yes | owner | Override, device cloud containing the metrics. |
| namespace | string |  |  | Metric namespace. If not provided, the API returns a list of namespaces. |
| metric | string |  |  | Metric name. If not provided, returns a list of available metrics. |
| model | string |  |  | Database model. |

**Query String Options** 

| Field | Type | Default | Role | Notes |
| - | - | - | - | - |
| index | string |  | owner | Database index name: primary or gs1. |
| limit | number |  |  | Number of items to retrieve. |
| next | object |  |  | Pagination token for the next page. |
| prev | object |  |  | Pagination token for the previous page. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| namespaces | array | Returns the requested namespace. If not provided, returns a list of available namespaces. |
| metrics | array | If a namespace is provided, returns a list of available metrics. |
| dimensions | array | If a namespace and metric are provided, returns a list of available metric dimensions. |

## Set
Set a metric value.<br><br>                    This API is used by devices to emit a metric value. It is sent over MQTT rather than via REST.

**Protocol**

```
MQTT
```

**Endpoint**

```
mqtt: /metric/set
```

**Authorized User Role**

```
device
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| metric | string | Metric name. |
| value | number | Metric value. |
| dimensions | array | Array of dimensions for metric. |
| buffer | object | Metric buffering options. |

# Provision

Device provisioning and management APIs.<br><br>    These APIs provide devices with the necessary provisioning APIs to manage communications with a device cloud.

## GetCerts
Provision a device with MQTT certificates.<br><br>    After a device has been claimed for management by a user into a device cloud, the device can call "getCerts" to request provisioning of MQTT certificates to secure communications.<br><br>    This call returns the certificate, private key and communications endpoint to use for secure MQTT communications with the device cloud.

**Endpoint**

```HTTP
POST /provision/getCerts
```

**Authorized User Role**

```
device
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

MQTT certificate and endpoints for device communications.

| Field | Type | Notes |
| - | - | - |
| accountId | string | App Account ID. |
| certificate | string | X.509 certificate. |
| endpoint | string | MQTT host endpoint for communciations. |
| id | string | Device ID. |
| key | string | X.509 certificate key. |
| port | number | MQTT TCP/IP port number. |
| thing | string | AWS IoT Core thing name for the device. |

## Update
**Device update.**

Check for software updates.<br>                <br>                Returns a message if no update is available. Otherwise, returns a download URL, version, update ID and checksum.

**Endpoint**

```HTTP
POST /provision/update
```

**Authorized User Role**

```
upgrade
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device ID. |
| product | string | yes | Product name. |
| version | string | yes | Version to update to. |
| test | boolean |  | Device is a test device. |
| * | any |  | Any other fields. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| checksum | string | Download checksum. |
| version | string | Version to update to. |
| message | string | Message. |
| url | string | Download URL for the software update. |
| update | string | Selected update ID. |

## UpdateReport
**Device update report.**

Post update status.

**Endpoint**

```HTTP
POST /provision/updateReport
```

**Authorized User Role**

```
upgrade
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device ID. |
| update | string | yes | Update status. |
| success | boolean | yes | Update success. |

# File

File Storage Management API.<br><br>    The File Storage Management API provides a way to store and retrieve files for devices and apps.

## Get
Get a file.

**Endpoint**

```HTTP
POST /file/get
```

**Authorized User Role**

```
view
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| filename | string | yes | Desired file pathname. |
| accountId | string |  | App Account ID. |

**Response** 

File data.


## GetSignedUrl
Get a signed URL to upload or download a file for the device.

**Endpoint**

```HTTP
POST /file/getSignedUrl
```

**Authorized User Role**

```
view
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | App Account ID. |
| command | string | File command to execute (get/put/delete). |
| filename | string | File name. |
| mimeType | string | MIME type. |
| size | number | File size in bytes. |

**Response** 

A signed URL string.


## List
Get a list of matching files filtered by matching properties.

**Endpoint**

```HTTP
POST /file/list
```

**Authorized User Role**

```
view
```

**Request Body** 

| Field | Type |
| - | - |
| * | any |

**Response** 

TBD.


## Put
Put a file to storage.

**Endpoint**

```HTTP
POST /file/put
```

**Authorized User Role**

```
edit
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| filename | string | File name. |
| mimeType | string | MIME type. |
| data | string | File data in base64 format. |

**Response** 

TBD.


## Remove
Remove a file.

**Endpoint**

```HTTP
POST /file/remove
```

**Authorized User Role**

```
view
```

**Request Body** 

| Field | Type |
| - | - |
| * | any |

# Manager

Manage Apps.

## Get
Get an app by ID.

**Endpoint**

```HTTP
POST /manager/get
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type |
| - | - |
| id | string |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| certArn | string | Certificate ARN for CloudFront. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Device cloud ID. |
| custom | boolean | Custom domain. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Owner account ID. |
| priorDomain | string | Prior domain. |
| provisioned | date | When the manager was provisioned. |
| region | string | Region. |
| title | string | Manager title. |
| type | string | Manager type. |
| users | array | User allow list. |
| version | string | App version. |

## GetSignedUrl
Get a signed URL to upload or download an app file.

**Endpoint**

```HTTP
POST /manager/getSignedUrl
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Manager ID. |
| clean | boolean | Clean the app site of old files. |
| command | string | File command to execute (get/put/delete). |
| filename | string | File name. |
| mimeType | string | MIME type. |
| size | number | File size in bytes. |

**Response** 

A signed URL string.


## Provision
Provision an app.

**Endpoint**

```HTTP
POST /manager/provision
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Manager ID. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| certArn | string | Certificate ARN for CloudFront. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Device cloud ID. |
| custom | boolean | Custom domain. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Owner account ID. |
| priorDomain | string | Prior domain. |
| provisioned | date | When the manager was provisioned. |
| region | string | Region. |
| title | string | Manager title. |
| type | string | Manager type. |
| users | array | User allow list. |
| version | string | App version. |

## Update
Update an app.

**Endpoint**

```HTTP
POST /manager/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |
| custom | boolean | Custom domain. |
| domain | string | Domain name. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Owner email address. |
| priorDomain | string | Prior domain name. |
| region | string | Region. |
| title | string | Manager title. |
| users | array | User allow list. |
| version | string | Manager version. |
| versionCurrent | string | Current version. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| certArn | string | Certificate ARN for CloudFront. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Device cloud ID. |
| custom | boolean | Custom domain. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Owner account ID. |
| priorDomain | string | Prior domain. |
| provisioned | date | When the manager was provisioned. |
| region | string | Region. |
| title | string | Manager title. |
| type | string | Manager type. |
| users | array | User allow list. |
| version | string | App version. |

## UpdateDisplay
Update an app display.

**Endpoint**

```HTTP
POST /manager/updateDisplay
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |
| display | string | Display file contents. |
| id | string | Manager ID. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| certArn | string | Certificate ARN for CloudFront. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Device cloud ID. |
| custom | boolean | Custom domain. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Owner account ID. |
| priorDomain | string | Prior domain. |
| provisioned | date | When the manager was provisioned. |
| region | string | Region. |
| title | string | Manager title. |
| type | string | Manager type. |
| users | array | User allow list. |
| version | string | App version. |

# Alert

Manage Alerts.

## Find
Find alerts by matching properties and query parameters.

**Endpoint**

```HTTP
POST /alert/find
```

**Authorized User Role**

```
user
```

**Request Body** 

None.

**Query String Options** 

| Field | Type | Default | Role | Notes |
| - | - | - | - | - |
| index | string |  | owner | Database index name: primary or gs1. |
| limit | number |  |  | Number of items to retrieve. |
| next | object |  |  | Pagination token for the next page. |
| prev | object |  |  | Pagination token for the previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Action records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Alert** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| cloudId | string | Owning device cloud ID. |
| context | object | Alert context. |
| count | number | Count of alerts for this sequence. |
| id | string | Unique alert ID. |
| message | string | Text message regarding alert. |
| name | string | Action name generating the alert. |
| seq | string | Unique sequence string for the alert type. |
| severity | string | Alert severity. |
| subject | string | Alert subject. |
| resolved | boolean | Set to true when alert is resolved. |
| timestamp | date | When the alert was created. |

## Get
Get a matching alert for a cloud.

**Endpoint**

```HTTP
POST /alert/get
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Alert ID. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| cloudId | string | Owning device cloud ID. |
| context | object | Alert context. |
| count | number | Count of alerts for this sequence. |
| id | string | Unique alert ID. |
| message | string | Text message regarding alert. |
| name | string | Action name generating the alert. |
| seq | string | Unique sequence string for the alert type. |
| severity | string | Alert severity. |
| subject | string | Alert subject. |
| resolved | boolean | Set to true when alert is resolved. |
| timestamp | date | When the alert was created. |

## Remove
Remove an alert.

**Endpoint**

```HTTP
POST /alert/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Alert ID. |

## Update
Update an alert.

**Endpoint**

```HTTP
POST /alert/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Alert ID. |
| resolved | boolean | Resolved status. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| cloudId | string | Owning device cloud ID. |
| context | object | Alert context. |
| count | number | Count of alerts for this sequence. |
| id | string | Unique alert ID. |
| message | string | Text message regarding alert. |
| name | string | Action name generating the alert. |
| seq | string | Unique sequence string for the alert type. |
| severity | string | Alert severity. |
| subject | string | Alert subject. |
| resolved | boolean | Set to true when alert is resolved. |
| timestamp | date | When the alert was created. |

# Account

**Account Management**

Account APIs operate on the user account utilized when obtaining the login AccessToken. If using a CloudAPI token, which provides the **owner** role capability, the target account can be provided via the **accountId** request property to most APIs.<br>                <br>                Accounts are created by the User.login API when a new user first logs in.

## Close
**Close account.**

Close an account and remove all allocated resources.  This will remove all users, devices, dashboards, and the account itself.  This operation cannot be reversed. <br>                    <br>                    This API can be invoked by a user closing their app account. It can also be invoked to close any user account if caller has the **owner** role via the CloudAPI token.

**Endpoint**

```HTTP
POST /account/close
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | If specified, close this account vs close own account. |

## Get
**Get account.**

Get an account that matches the supplied properties. If no email or id provided, return the logged in account.

**Endpoint**

```HTTP
POST /account/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Query by account ID. |
| email | string | owner | Query by email. |

**Query String Options** 

| Field | Type | Role | Notes |
| - | - | - | - |
| index | string | owner | Database index name: primary or gs1. |

**Response** 

Account Record.

| Field | Type | Notes |
| - | - | - |
| activity | date | Last activity date. |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

## Find
**Find accounts.**

Find a list of accounts that match the supplied properties. If no email or id provided, return list of accounts.

**Endpoint**

```HTTP
POST /account/find
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | admin | Query by account ID. |
| email | string | admin | Query by email address. |

**Query String Options** 

| Field | Type | Default | Role | Notes |
| - | - | - | - | - |
| index | string |  | owner | Database index name: primary or gs1. |
| limit | number |  |  | Number of items to retrieve. |
| next | object |  |  | Pagination token for the next page. |
| prev | object |  |  | Pagination token for the previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Account** 

| Field | Type | Notes |
| - | - | - |
| activity | date | Last activity date. |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

## UpdateIdentity
Update the account name and email address. If the role of "owner" is used, the account name and email address can be updated for any account. If the role of "user" is used, the account name and email address can only be updated for the logged in account.

**Endpoint**

```HTTP
POST /account/updateIdentity
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Account ID. |
| email | string |  | Account email address. |
| name | string |  | Account or company name. |

**Response** 

Updated account record.

| Field | Type | Notes |
| - | - | - |
| activity | date | Last activity date. |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

# API Access

The EmbedThis Ioto API is a [REST API](https://www.redhat.com/en/topics/api/what-is-a-rest-api)
to allow you to interact with the backend Ioto cloud service.

The Ioto API provides calls to:

* Claim and release devices
* Access device database data
* Create and access metric data
* Provision devices with certificates and credentials
* Manage devices
* Invoke automated actions

The Ioto API can be used from browser-based UI apps or from utility service commands running in the cloud or on-prem.

## Authentication

Requests to the Ioto service are authenticated by checking an authentication token included with the request. Ioto  provides two different authentication methods for two use cases:

Authentication Method | Source | Description
-|-|-
[CloudAPI Token](authentication.md#admin-tokens) | Utility | An admin service running in the cloud or on-premises 
[Login Access Token](authentication.md#login-access-tokens) | Browser | A logged in user from a web browser app 

For logged in users, Ioto offers **Login Access Tokens** which are granted when a user logs into the service.  For utility service commands, Ioto offers **CloudAPI Tokens** which provide administrative access to the device cloud and the resources in the cloud. 

An authentication token must be included in the HTTP headers for Ioto API requests.

## API Endpoint

The Ioto API endpoint is unique per device cloud. You can see the API endpoint in the [Builder Cloud/Edit](https://admin.embedthis.com/clouds/) panel under the API Access section.

![API Access](/images/builder/api-endpoint.png){class="screen width-75"}

The Endpoint is of the form: SITE/PATH

For example:

```bash
https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/user/find
```

## HTTP Methods

All HTTP API requests use the **POST** method for consistency and simplicity. 

## HTTP Request Paths

When using Authentication tokens, the request URLs are modified to include a **"/tok"** URL prefix before the URL path.

For example:

```bash
https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/user/find
```


## HTTP Headers

To authorize your request, include the authentication token as an **Authentication** HTTP header with your request. All API requests use a HTTP Content-Type of **application/json** for both requests and responses.

If using login access tokens, you must also include an **Origin** header that is set to the domain name for your device app.

For example:

```
Authorization: 1234567990X0C3B0ABF3CF81DZ....
Content-Type: application/json
```

## Request Responses

### Successful Responses

Successful requests will return a HTTP status code of 200 and a response body containing a JSON object with the following properties:

* `data` - The response data

If the response contains an array of data, the response will also contain the following properties:

* `next` - The next page of results
* `prev` - The previous page of results
* `paged` - Set to true if the response is paged

### Errors

REST HTTP calls will return a HTTP status code of 200 for success, 403 for authentication errors, 400 for bad requests, and 500 for service errors. When a request is unsuccessful, the content type will be set to "text/plain" and the body will contain a text error message.

## Example

Here is an example to issue a request from the command line using `curl` or the Ioto **url** command using a **CloudAPI** token:

::: code-group
```curl
curl -X POST https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/generic/find \
     -H 'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
     -H 'Content-Type: application/json' \
     -d '{"deviceId": "ZXXXXXXXXX", "_type": "Store"}'
```
```url
url https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/generic/find \
    'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
    '{deviceId: "ZXXXXXXXXX", _type: "Store"}'
```
:::

Note: the `url` command is a utility command that is installed with the Ioto CLI. It can automatically sense the arguments as either headers, or body data. JSON body data can be passed as JSON5 (like JS) and can thus omit quotes on property keys and setting the Content-Type header.

## Read More

* [API Authentication](authentication.md)

## Ioto APIs

Controller | Description
-|-
[Account](account.md) | Account API
[Action](action.md) | Action API
[Alert](alert.md) | Alert API
[Dashboard](dashboard.md) | Dashboard API
[Device](device.md) | Device API
[Generic](generic.md) | Generic Data Access API
[Metric](metric.md) | Metric API
[Provision](provision.md) | Device Provisioning API
[Store](store.md) | Key/Value Store API
[User](user.md) | User API

<!--
| [Account](builder/account.md) | Account API |
| [Cloud](builder/cloud.md) | Cloud API |
| [Product](builder/product.md) | Product API |
| [User](builder/user.md) | User API |
| [Card](builder/card.md) | Card API |
| [Dashboard](builder/dashboard.md) | Dashboard API |
| [Invoice](builder/invoice.md) | Invoice API |
| [Metrics](builder/metrics.md) | Metrics API |
| [Notice](builder/notice.md) | Notice API |
| [Notification](builder/notification.md) | Notification API |
| [Post](builder/post.md) | Post API |
| [Software](builder/software.md) | Software API |
| [Support](builder/support.md) | Support API |
| [Ticket](builder/ticket.md) | ticket API |
| [Token](builder/token.md) | Token API |
-->
# Store

This API provides MQTT messages to get/set values from the key/value Store.<br>            <br>                If you need a REST API, use the Generic API with the **_type** set to 'Store'.

## Get
**Get data from the store.**

**Protocol**

```
MQTT
```

**Endpoint**

```
mqtt: /store/get
```

**Authorized User Role**

```
device
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| key | string | Data item unique key. |

**Response** 

Store Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string |  |
| created | date |  |
| deviceId | string |  |
| key | string |  |
| role | string | Role that can access this item. |
| value | object |  |
| type | string |  |
| updated | date |  |
| expires | date |  |
| _source | string |  |

## Set
**Set data in the store.**

**Protocol**

```
MQTT
```

**Endpoint**

```
mqtt: /store/set
```

**Authorized User Role**

```
device
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| key | string | Data item unique key. |
| expires | number | Date when to expire. Set to number of milliseconds since Jan 1, 1970. Date.getTime(). |
| value | object | Set to a number or string. |
| type | string | Set to "number" or "string". |

# User

User Management.

## Create
Create a new user and optionally send an email invitation to join the service. When the user follows the invitation and registers, their email address wil be confirmed before they are logged into the service.

**Endpoint**

```HTTP
POST /user/create
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| email | string | yes | User email address. |
| role | string | yes | Authorized role. Select from "user", "admin" or "owner". |
| sendInvite | boolean |  | Send an email invitation. |

**Response** 

A user record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | Last activity date. |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Find
Find users by ID or email.

**Endpoint**

```HTTP
POST /user/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| email | string | admin | Email address. |
| id | string | admin | User ID. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**User** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | Last activity date. |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Get
Get a user by ID or email.

**Endpoint**

```HTTP
POST /user/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| email | string | admin | Email address. |
| id | string | admin | User ID. |

**Response** 

User Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | Last activity date. |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## GetRoles
Get the roles for the authenticated user.

**Endpoint**

```HTTP
POST /user/getRoles
```

**Authorized User Role**

```
admin
```

**Response** 

Object Record.


## Login
**Login the authenticated user.**

Login the authenticated user. It is expected that the user has already been authenticated by logging into the Cognito service using the details provided by the Builder Cloud/Edit panel under the "API access" section.

**Endpoint**

```HTTP
POST /user/login
```

**Authorized User Role**

```
public
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| invite | string | Invitation ID. |
| register | boolean | Register the user. |
| social | boolean | Social login. |

**Response** 

Account and user records with useful cached data.

| Field | Type | Notes |
| - | - | - |
| account | object | The account record for the authenticated user. |
| manager | object | The manager (app) record for the authenticated user. |
| roles | object | Roles object. |
| schema | object | Device Schema. |
| user | object | The user record for the authenticated user. |

**Account** 

The account record for the authenticated user.

| Field | Type | Notes |
| - | - | - |
| activity | date | Last activity date. |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |


**Manager** 

The manager (app) record for the authenticated user.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| certArn | string | Certificate ARN for CloudFront. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Device cloud ID. |
| custom | boolean | Custom domain. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Owner account ID. |
| priorDomain | string | Prior domain. |
| provisioned | date | When the manager was provisioned. |
| region | string | Region. |
| title | string | Manager title. |
| type | string | Manager type. |
| users | array | User allow list. |
| version | string | App version. |


**User** 

The user record for the authenticated user.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | Last activity date. |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |


## Remove
Remove a user.

**Endpoint**

```HTTP
POST /user/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| email | string | Email address. |
| id | string | User ID. |

## Update
Update a user identity.

**Endpoint**

```HTTP
POST /user/update
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| email | string | User email address. |
| first | string | User first name. |
| id | string | User ID. |
| last | string | User last name. |
| preferences | object | User preferences. |

**Response** 

User Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | Last activity date. |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## UpdateRole
Update a user role.

**Endpoint**

```HTTP
POST /user/updateRole
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string |  | User ID. |
| role | string | admin | User role. |
| sendInvite | boolean |  | Send an email invitation. |

**Response** 

User Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | Last activity date. |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

# Action

**Manage Automated Actions**

Actions implement automated responses for specific device and cloud conditions. Actions are invoked by triggers to respond and implement a specific remedy or notification.

## Find
Find actions by matching properties and query parameters.

**Endpoint**

```HTTP
POST /action/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| cloudId | string | yes | Filter by cloud ID. |
| type | string |  | Filter by action type. Valid types are: alert, builder-alert, builder-metric, database, delay, device, email, eventbridge, http, lambda, metric, mqtt, and sms. |

**Query String Options** 

| Field | Type | Default | Role | Notes |
| - | - | - | - | - |
| index | string |  | owner | Database index name: primary or gs1. |
| limit | number |  |  | Number of items to retrieve. |
| next | object |  |  | Pagination token for the next page. |
| prev | object |  |  | Pagination token for the previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Action records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string | Action description. |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean | Enable or disable the action. |
| error | string | Error message from last invocation. |
| expression | string | Trigger expression. |
| format | string | Message format. |
| id | string | Unique action ID. |
| name | string | Action name. |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string | Alert severity. |
| trigger | string | Source of action trigger. |
| type | string | Action type. |

## Get
Get a matching action for a cloud.

**Endpoint**

```HTTP
POST /action/get
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string |  | Action ID. |
| cloudId | string | yes | Filter by cloud ID. |
| type | string | yes | Filter by action type. Valid types are: alert, builder-alert, builder-metric, database, delay, device, email, eventbridge, http, lambda, metric, mqtt, and sms. |

**Response** 

Action record.

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string | Action description. |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean | Enable or disable the action. |
| error | string | Error message from last invocation. |
| expression | string | Trigger expression. |
| format | string | Message format. |
| id | string | Unique action ID. |
| name | string | Action name. |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string | Alert severity. |
| trigger | string | Source of action trigger. |
| type | string | Action type. |

## Invoke
Invoke an automated action by ID or name.

**Endpoint**

```HTTP
POST /action/invoke
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Action ID. |
| name | string | Action name if ID not provided. |
| context | object | Context for the action. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| error | string | Error message if the action failed. |
| name | string | Action name. |
| context | object | Context for the action. |

**Example**

Invocation using curl to invoke an action by name.

```curl
curl -X POST \
        https://xrp7t2deqh.execute-api.ap-southeast-1.amazonaws.com/tok/action/invoke \
        -H 'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
        -H 'Content-Type: application/json' \
        -d '{"name":"myAction", "context":{"deviceId": "ZXXXXXXXXX"}}'
```

# Test

Test the API interface.

## Ping
**Ping device cloud.**

Simple ping request.

**Endpoint**

```HTTP
POST /test/ping
```

**Authorized User Role**

```
public
```

**Response** 

The string "pinged" with a new line appended.


# Device

Device Management API.<br><br>    When devices are initialized with the Ioto agent, they will register with the Builder service using their device ID (ClaimID) at https://admin.embedthis.com/api. The device registration API is part of the Builder API. See [Device Registration](/ioto/provisioning/registration.md).<br><br>    Once registered, the device then remains under the management of the Builder until it is **"claimed"** by a user for management using the "Device Claim" API.  When claimed, the device is redirected to the device cloud when it next invokes the "register" API.

## Claim
Claim a device for management by a device cloud.<br><br>    Once a device has registered itself with the builder, a user can claim the device for management.<br>    The claim ID would typically be printed on the device label during manufacturer.<br><br>    A claim request may specify the device as a test device where it will not be counted towards the subscription device count.

**Endpoint**

```HTTP
POST /device/claim
```

**Authorized User Role**

```
claimDevice
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

The claimed device.

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Find
Find matching devices filtered by matching properties.

**Endpoint**

```HTTP
POST /device/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string |  | Device Claim ID. |
| accountId | string | owner | App account ID. Required if using CloudAPI token. |
| productId | string |  | Product registration ID from the Builder product list. |

**Query String Options** 

| Field | Type | Default | Role | Notes |
| - | - | - | - | - |
| index | string |  | owner | Database index name: primary or gs1. |
| limit | number |  |  | Number of items to retrieve. |
| next | object |  |  | Pagination token for the next page. |
| prev | object |  |  | Pagination token for the previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of devices owned by the user. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Device** 

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Get
The Get API will fetch a device by its ID. If you have the "owner" role, you can fetch the device for any account by providing an account ID. Otherwise, it will fetch the device for the authenticated account.

**Endpoint**

```HTTP
POST /device/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Role | Notes |
| - | - | - | - | - |
| id | string | yes |  | Device Claim ID. |
| accountId | string |  | owner | App account ID. |

**Response** 

Device Record.

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## GetCreds
**Get IAM credentials.**

Get credentials for use in the device that is hosted in a dedicated cloud.<br><br>    This will create temprorary IAM credentials based on the configured Cloud.deviceRole (default IotoDeviceRole). These credentials can be used with appropriate AWS SDK or Ioto AWS Sigv4 APIs.

**Endpoint**

```HTTP
POST /device/getCreds
```

**Authorized User Role**

```
device
```

**Response** 

A set of AWS IAM credentials that can be used with AWS APIs.

| Field | Type | Notes |
| - | - | - |
| accessKeyId | string | AWS access key ID. |
| secretAccessKey | string | AWS secret access key. |
| sessionToken | string | AWS credentials session token. |
| expires | date | When the credentials expire. |
| region | string | AWS region. |

## GetSignedUrl
Get a signed URL to upload or download a file for the device.

**Endpoint**

```HTTP
POST /device/getSignedUrl
```

**Authorized User Role**

```
device
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Device claim ID. |
| command | string | File command to execute (get/put/delete). |
| filename | string | File name. |
| mimeType | string | MIME type. |
| size | number | File size in bytes. |

**Response** 

A signed URL string.


## Provision
Provision a device with MQTT certificates.<br><br>    After a device has been claimed for management by a user into a device cloud, the device can call "getCerts" to request provisioning of MQTT certificates to secure communications.<br><br>    This call returns the certificate, private key and communications endpoint to use for secure MQTT communications with the device cloud.

**Endpoint**

```HTTP
POST /device/provision
```

**Authorized User Role**

```
device
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

MQTT certificate and endpoints for device communications.

| Field | Type | Notes |
| - | - | - |
| accountId | string | App Account ID. |
| certificate | string | X.509 certificate. |
| endpoint | string | MQTT host endpoint for communciations. |
| id | string | Device ID. |
| key | string | X.509 certificate key. |
| port | number | MQTT TCP/IP port number. |
| thing | string | AWS IoT Core thing name for the device. |
| error | string |  |
| delay | number | Delay in seconds until the device block will be lifted. |

## Release
Release a device from management by a device cloud. Releasing a device returns it to the builder to be available for claiming by another cloud.

**Endpoint**

```HTTP
POST /device/release
```

**Authorized User Role**

```
releaseDevice
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

Device Record.

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

# Secure Token Storage

Storing access tokens safely is crucial for maintaining the security of applications, devices and protecting sensitive information. Here are some best practices for storing access tokens:

**Use Secure Storage Mechanisms**: Always store tokens in secure storage mechanisms. 

>Never commit access tokens to source repositories such as GitHub without first encrypting. 

**Log Files and Backups**: Ensure that access tokens are not printed in service log files and are not included in backups (especially dev backups).

**Use Environment Variables for Server-side Applications**: When storing tokens in server-side applications, use environment variables or encrypted configuration files. This approach keeps tokens out of the source code and reduces the risk of accidental exposure.

**Encryption**: Encrypt tokens at rest to add an additional layer of security. This way, even if an attacker gains access to the storage, decrypting the tokens will be another hurdle for them.

**Minimize Token Lifespan**: Use tokens with a short expiration time. This minimizes the potential damage in case a token is compromised. Implement token refresh mechanisms to maintain sessions without requiring the user to log in again.

**Secure Transmission**: Always transmit tokens over secure channels. Use HTTPS to encrypt the data in transit, preventing man-in-the-middle attacks.

**Regular Audits and Rotation**: Regularly audit token usage and have mechanisms in place for token rotation and revocation. This helps in identifying suspicious activities and mitigating potential risks promptly.

**Access Control and Monitoring**: Implement strict access control policies for the storage and handling of tokens. Only allow necessary applications and personnel to access them (Need to know). Additionally, monitor access and usage patterns to detect anomalies.

**Use API Access Signatures**: Use API access signatures to verify the authenticity of requests to your API. This way, you can ensure that only legitimate requests are processed and that the data is not tampered with during transmission.

By following these best practices, you can significantly reduce the risks associated with storing and managing access tokens, helping to protect your applications and users from unauthorized access and potential security breaches.# Generic

Generic Access to Database Data.<br>                <br>            The Generic controller provides "generic" access to database items without requiring specific database models for different database items. By providing the database item "_type" and the required item properties, you can query and modify database items.

## Create
Create a generic data item.

**Endpoint**

```HTTP
POST /generic/create
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. This must be a deviceId claimed by the app account of the authenticated user. |
| * | any |  | Item attributes to create. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |

**Response** 

The created item.

| Field | Type | Notes |
| - | - | - |
| _type | string | Database item type. |
| * | any | Item attributes. |

## Find
Find data items from a database table.

**Endpoint**

```HTTP
POST /generic/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Optional item attributes to filter selected items. |

**Query String Options** 

| Field | Type | Default | Role | Notes |
| - | - | - | - | - |
| index | string |  | owner | Database index name: primary or gs1. |
| limit | number |  |  | Number of items to retrieve. |
| next | object |  |  | Pagination token for the next page. |
| prev | object |  |  | Pagination token for the previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of devices owned by the user. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Item** 

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

::: code-group
```curl
curl -X POST ${CLOUD_ENDPOINT}/tok/generic/find \
    -H 'Authorization: ${CLOUDAPI_TOKEN}' \
    -H 'Content-Type: application/json' \
    -d '{"_type": "Device"}'
```
```url
url ${CLOUD_ENDPOINT}/tok/generic/find \
    'Authorization: ${CLOUDAPI_TOKEN}' \
    '{_type: "Device"}'
```
:::

## Get
Get a data item from a database table.

**Endpoint**

```HTTP
POST /generic/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Optional item attributes to filter the selected item. |

**Response** 

The retrieved item.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

::: code-group
```curl
curl -X POST ${CLOUD_ENDPOINT}/tok/generic/get \
    -H 'Authorization: ${CLOUDAPI_TOKEN}' \
    -H 'Content-Type: application/json' \
    -d '{"_type": "Device", "deviceId": "DEV0123456"}'
```
```url
url ${CLOUD_ENDPOINT}/tok/generic/get \
    'Authorization: ${CLOUDAPI_TOKEN}' \
    '{_type: "Device", deviceId: "DEV0123456"}'
```
:::

## Remove
Remove a data item.

**Endpoint**

```HTTP
POST /generic/remove
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Other item attributes sufficient to identify the item. |

## Update
Update a data item.

**Endpoint**

```HTTP
POST /generic/update
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Other item attributes sufficient to identify the item. |

**Response** 

The updated data item.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

# Device Provisioning

Provisioning is the process of providing devices with the necessary certificates and credentials to securely connect with cloud-based services.

For devices to securely connect to the cloud, they require X.509 certificates so that they can be uniquely identified, authenticated and authorized by the cloud service. Once authorized, the certificates are used by the TLS protocol to securely encrypt all communications.

## Ioto Provisioning

Ioto has an automated provisioning process that takes the pain out of device provisioning and certificate distribution for the user.

There are two primary provisioning patterns:

* User Claimed Devices
* Pre-Claimed Devices

## User Claimed Devices

User claimed devices will register with an Ioto cloud when manufactured and then wait for a user to "claim" the device from the device cloud.

## Pre-Claimed Devices

Pre-claimed devices are those that are configured and claimed by an Ioto device cloud during the device registration when manufactured. Pre-claimed devices are suitable for proprietary devices or projects where the devices are not distributed for resale.

Pre-claimed devices are provisioned with certificates when manufactured or first configured.

## Ioto Provisioning

![Ioto Provisioning](/images/ioto/provisioning.png){class="screen"}

Ioto provisioning is accomplished in several phases during the device lifecycle.


* [Device Serialization](serialize.md)
* [Device Registration](registration.md)
* [Device Claiming](claiming.md)# Device Serialization

For secure operation it is essential that each device can be uniquely identified. Most devices are created with a serial number that may include the product code, manufacturing batch number and individual serial number. However, while this serial number may be unique, it can be easily guessed because serial numbers typically follow a predictable format.

Instead of using the existing serial number, Ioto uses a random, unique claim ID (UCI) that is a random, 80-bit number that is not guessable and does not follow a predictable pattern. When paired with the product ID it is used as a unique claim ticket, allowing users to claim devices for management.

```
JT08FFQXWQ
```

The 10 letter UCI results in over 1 quadrillion possible combinations (32^10).

During manufacturing, each device is given a UCI that identifies the device to the service and is used by the user to "claim" the device after purchase or installation.

For User-Claimed devices, the UCI should be printed on the device label and be clearly identified as the **Claim ID**. The Claim ID can also be represented as a QR code if you choose to develop a mobile app for users to claim devices. (See [Claiming](#device-claiming) below).

![Device Label](/images/pics/label.png)

## Creating the UCI

There are several ways to create the UCI depending on how you operate your production process.

* Manually configure the UCI in the device.json5
* Have the Ioto Agent generate a UCI on startup.
* Create unique firmware for each device.
* Factory allocate the UCI in each device during manufacturing.

Regardless of which method you choose, the end result is the Ioto **device.json5** configuration file is updated with the UCI in the **id** property.

```js
{
    "id": "JT08FFQXWQ",
    "product": "01G8YJKKRNTHW213TRZYX3YH0M"
}
```

The **product** property in the device.json5 is generated by the [Builder Site](https://admin.embedthis.com/) when you define your product.

### Manually Creating the UCI

If you have a very small production run of devices, you can manually create the UCI with unique values for each device. You can simply edit the **device.json5** with the required values.

With any significant production volumes, you will want an automated process.

### Agent Generated UCI

If you set the **services.serialize** property in the **config.json5** to **"auto"**, Ioto will automatically generate a UCI and save it to the **device.json5** file.

```js
{
    services: {
        cloud: {
            serialize: "auto"
        }
    }
}
```

### Unique Firmware

If you create unique firmware for each device, you can set the UCI in the **device.json5** when you create the firmware.

To generate a UCI, you can either run the **ioto** process with the **--id** argument or you can create a simple program that calls the **cryptID** API from the **libioto** library. See the **./factory/serialize.c** sample for an example.

### Factory UCI

If you are using identical firmware for each device, you can allocate the UCI by having the Ioto device agent connect to a factory serialization service during manufacturing. The serialization service will generate and provide the UCI to the agent, which will then persist it to the **device.json5** configuration file.

This generation should be integrated with your label creation process during manufacturing so that the UCI in the device.json5 matches that product label affixed to the device.

The serialization service should listen for client requests on a HTTP endpoint and provide the UCI as the response.

To enable factory UCI generation, set the **services.serialize** property to **"factory"** and define the address of the serialization HTTP endpoint in the **api.serialize** property in the **config.json5** configuration file.


```js
{
    api: {
        serialize: "http://localhost:1234/ioto/serialize"
    },
    services: {
        cloud: {
            serialize: "factory"
        }
    }
}
```


The Ioto agent includes a sample serialization service in the **./factory/serialize.c** file.
# Device Registration

Before leaving the factory, when the device first powers on during system test, the Ioto agent will start and connect to the EmbedThis Ioto cloud service to register itself.

During registration, the Ioto agent will send the **device.json5** contents over an encrypted TLS connection to the Ioto cloud service. This registration request includes the device UCI and the product ID.

Once received and validated, the Ioto cloud service will save the device information in the Ioto cloud registration database.

If using User-claimed devices, the Ioto agent then awaits for a user to claim the device. If using Pre-claimed devices, the Ioto agent will skip the claiming step and proceed retrieve the required MQTT certificates and securely connect to the cloud.


## Firewall

Registration requires that your factory firewall have an outbound port opened to connect out to https://admin.embedthis.com on port 443. This is a single outbound request only.
# Claiming Devices

After creating a device cloud, the Builder can create a device app to manage your devices. Device apps can be extensively customized with your logo, product name and device specific screens and panels.

## Agent Registration

When a device with the Ioto agent first powers-up, it will register with the Ioto service. If the device is 
claimed, it will receive management instructions and be redirected to the relevant device cloud for ongoing management and the provisioning process is complete.

If unclaimed, the Ioto agent will wait and regularly check with the Ioto service to see if it has been claimed. The Ioto agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay period up to a defined limit. If the device is rebooted, the polling process recommences.

## User Claiming

When a user purchases or installs a device with the Ioto agent, they can "claim" the device using the device app. The user claims their device using the UCI printed on the device label.

![Device Label](/images/pics/label.png)

The user enters the 10 letter code **Claim ID** code into a claim form via the device app.

When the Ioto cloud service receives that request, it provisions the necessary X.509 certificates and AWS IoT resources required to support and manage the device.

When the device is unclaimed, the Ioto agent in the device will regularly check with the Ioto service to see if it has been claimed. In this state, it is "unmanaged" and awaiting orders.

The Ioto device agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay period up to a defined limit. If the device is rebooted, the polling process recommences.


After device claiming, when the device will be provided the X.509 certificate and keys when it next connects or polls the service. The device will save the certificates and keys, then connect to the device cloud. This completes the provisioning process.

## Pre-Claiming Devices

If you are using pre-claimed devices, the process is similar, except you claim the device from the Builder when the device is made. Otherwise the process is the same.

## Device Connection

When the device is unclaimed, the Ioto agent in the device will regularly check with the Ioto service to see if it has been claimed. While unclaimed, it is "unmanaged" and awaiting orders.

The Ioto agent will check the Ioto service immediately on power-on, and then every 5 seconds with an exponentially increasing delay period up to a defined limit. If the device is rebooted, the polling process recommences.

Once claimed, when the agent next polls the Ioto service, it will receive management instructions and will be redirected to the relevant device cloud for ongoing management and the provisioning process is complete.
# Software and Over The Air Updates

It is highly desirable to be able to update and upgrade the software in your devices so you can deploy new features, patch security vulnerabilities and improve performance over time.

Via the Builder, you can define software updates for devices that will be managed and delivered Over-The-Air (OTA) to your devices.

![Software Modify](/images/builder/software-edit.png){class="screen"}

## Configuring Updates 

Using the Builder OTA update manager, you can selectively deploy updates to any desired subset of your device population. Updates can be published that will be applied to your devices according to a **distribution policy**. In this way, you can selectively update all your devices or specific subsets as you require.

To configure a software update, you supply the following parameters:

* Product
* Update version
* Update description
* Distribution policy
* Device Cloud
* Update image
* GitHub commit reference


## Update Selection

Each day, the device or update agent will connect to the device cloud for a "checkin". During this request, the agent will submit its update request to see if an update is available for this device.

The service will retrieve the most recent updates and check the updates in reverse version order and select the first matching update for the device.

The device cloud service will evaluate the distribution policy expression when the device checks-in and determine if the policy matches for the device.

## Update Limits

Implementing a gradual update strategy can help minimize load and risk. Updating a large number of devices simultaneously can impose an excessive burden on your service, so staggering the rollout can distribute the load more evenly.

Despite thorough testing, some updates might still be considered "risky." To minimize this risk, you can update a small subset of your device population first to see if the update causes any issues.

The update service provides update limits and gradual rollout factors that allow you to control the rate of updates.

* **Max device limit** and **device percentage** limits define the maximum number of devices that can be updated. Once either limit is reached, further updates are prevented.

* For gradual rollouts, you can set a **max updates per period**, which limits the number of updates to a specified number over a defined period. For example, you could set a limit of 1000 updates per hour (3600 seconds).

If a device meets the distribution policy and rollout limits, the URL for the update image will be returned to the update agent. The agent will then fetch the update image and verify its integrity. If the image is verified, the **scripts/update** script is invoked to apply the update. If you are running the agent on an RTOS without scripting, you will need to monitor and respond to the **device:update** event using the rWatch API.

## Product

When defining an update, select the product for which the software update applies. A device cloud may be managing many different products and the product selection in conjunction with the distribution policy defines the subset of devices that are eligible to receive the update.

You should define multiple product definitions if the different devices consistently require different firmware.

## Software Version

The version number is your software release version number identifying this software release. The version numbers are compatible with the [SemVer 2.0](https://semver.org/) version specification.

If you are using the Ioto agent, the current version for your device is defined via the **version** property in the config.json5 configuration file. NOTE: your device is versioned separately to the Ioto agent itself which has its own version string.

## Software Release Description

The description is an informative description for your purposes.

## Software Distribution Policy

The distribution policy is a simple Javascript-like expression that is evaluated at runtime to determine if the update is relevant for a specific device. If you leave the policy blank, then all devices whoes version is less than the software release version will be updated.

Here is a sample policy expression:

    major >= 1 && minor >= 1 && patch >= 5 && memory >= 256 && ports == 32

The properties contained in the device.json5 configuration file are made available as variables. In this case, the "memory" and "ports" variables are supplied in the device.json5 file. 

The full device version is accessible as the varible "version" and the software update version is provided via the "newVersion" variable. 

The device version string is also split into SemVer components:

* major
* minor
* patch

See [Expressions](../../apps/config/expressions.md) for more information on the expression syntax.


## Opt-in Updates

Devices can implement an opt-in update strategy by defining variables in the device context that are passed with the update checkin request. These variables can be examined by the distribution policy expression. If a variable is set only when a device/user opts-in, then the distribution policy can target only those devices.

For example, say a device defined an opt-in field called **try-beta-features** that was set to "1" when users toggled a UI checkbox to signify they wished to receive beta features. The device would then pass this field with the update checkin request and the distribution policy could test that value.

    try-beta-features == 1

## Rollback Updates

You can rollback errant updates by defining an update that has a distribution policy pinned to the errant version. For example, say the update **1.2.3** was bad and you wished to rollback devices to the prior **1.2.2** version. You would first disable the 1.2.3 bad update by deselecting the **Enable** checkbox for that update. Then, you would define an update 1.2.2 that had a distribution policy like this:

    version == '1.2.3'

This would target only the 1.2.3 devices and roll them back to version 1.2.2. 

## Device Cloud

Update images are stored in AWS S3 in your device cloud AWS account. When defining updates, you select the relevant device cloud to store and apply the updates. If you have multiple clouds, you will need to define updates in each cloud.

## Applying Updates

When the update is downloaded to the device and verified, the update agent will save the update in a temporary file. Your device can be notified of an update by one of two means:

* The "./script/update" shell script will be invoked and passed the filename of the update.
* Ioto will indicate an update is available via the "device:update" signal. See rSignal/rWatch for details.

## Enable

You can selectively enable or disable a release at any time via the Builder.# Get Started with Ioto&reg;

Watch a **Getting Started** video below or read the [Getting Started Guide](https://www.embedthis.com/blog/ioto/cloud/start/cloud-based-device-management.html). 

If you want to jump right in, go to the [Builder Site](https://admin.embedthis.com/) and register. The [Builder](https://www.embedthis.com/doc/builder/) is our one-stop-site for you to evaluate Ioto and build smart devices.   

<iframe src="https://www.youtube.com/embed/eIG5z-DcrIo?rel=0" width="800" height="600" frameborder="0" allowfullscreen></iframe>
# Best Practices in IoT Solutions

Implementing an efficient data communication design is crucial for successful IoT solutions. When managing a large pool of devices, excessive cloud communication can result in high costs, poor performance, and scalability issues.

The Ioto cloud solution offers powerful communication mechanisms such as MQTT messaging and transparent database synchronization. However, if used indiscriminately by sending excessive or redundant data to the cloud, it can compromise your solution and lead to throttling.

To protect your devices, customers, and the service, Ioto enforces data limits. If a device or group of devices sends too much data, Ioto will throttle (slow down) incoming data from those devices. Persistent overuse can result in the offending devices being disconnected from the network.

Follow these best practices to ensure a successful IoT strategy:

1. **Only send necessary data to the cloud**: Limit cloud communication to data that is required at the cloud. Don't send data that is never accessed by the cloud.
2. **Send only changed data**: Avoid redundant data transmission by sending updates only when data changes. If a data item has only one changed field, consider splitting into fixed and changing data items.
3. **Separate configuration data from runtime statistics**: Define database entities to differentiate between the two. Configuration data changes infrequently and can be synchronized to the cloud when updated. Statistics can be buffered and can be sent less frequently.
5. **Utilize automatic metric creation**: Take advantage of automated metrics for efficient monitoring. Ioto can transparently create metrics from database data that can be graphically displayed or used for automated actions.
6. **Synchronize database tables in one direction only**: Ensure that synchronized tables are not bidirectional to prevent conflicts. Split tables to be synchronized up to the cloud, or down to the device, not both.
7. **Avoid messaging loops**: Implement safeguards to prevent loops in your messaging system.
7. **Monitor throttle messages**: Listen for Ioto throttle messages and adjust your device behavior accordingly.# Dedicated Device Clouds

Dedicated device clouds are created in an AWS account that you own and control. As such, you have full access to all AWS services in your account.

The Ioto service provides additional capabilities for dedicated clouds:

* Uploading device log files to AWS CloudWatch
* Storing state in AWS IoT shadows
* Executing server-side processing logic in response to AWS EventBridge events triggered by device data or metrics.
* Use a custom domain to address a device app.
* Unlimited message traffic.
* Ability to invoke AWS services directly from the device.

When you create a dedicated device cloud, the Builder and Ioto will create the following AWS resources in your AWS account:

* An AWS DynamoDB database registry of your devices.
* An AWS DynamoDB database exclusively for your device data.
* AWS DynamoDB streams to replicate device data to and from the cloud.
* An AWS API Gateway to authorize remote API access to device data.
* An AWS Cognito User Pool to authenticate user access.
* An AWS CloudFront and S3 site for device apps.
* AWS Route53 domain for device apps.
* AWS Lambda functions for cloud-side device management.
* IAM Roles to restrict remote access.
* AWS IoT Core policies and message routing rules.
* AWS IoT Things to model your devices in the cloud.


## Enabling IAM Keys

To interact with AWS services, the Ioto agent must be configured to request IAM access keys. This is enabled by setting the **services.cloud.keys** property in the **device.json5** configuration file.

```js
{
    services: {
        cloud: {
            keys: true
        }
    }
}
```

When the agent starts, it will retrieve from the Ioto service a set of IAM access keys to sign AWS API requests. 

## Data Lake

Amazon S3 is an object storage service offering scalable data storage with strong data availability and security guarantees.

The Ioto agent provides convenience APIs to make uploading data or files to S3 efficient and easy.

To upload a file in the Ioto agent, use **awsPutFileTS3** API:

```c
status = awsPutFileToS3("us-east-1", "MyBucket", "file.dat", "./file.data");
```

This call will upload the file "./file.data" to the bucket "MyBucket" on S3. The file will be saved in the bucket as "file.dat". The returned status will be a HTTP status code of 200 if successful.

## CloudWatch Logs

Ioto can export logs from the local device into CloudWatch Logs for secure cloud-side storage.

Ioto Log capture offers two capabilities:

* Export and save the Ioto Log to CloudWatch
* Capture and export any device O/S log file to CloudWatch

### Enabling Cloud Logs

To enable exporting log files to the device cloud, set the **services.logs** property in the **config.json5** file to true.

```js
{
    services: {
        cloud: {
            keys: true,
            logs: true
        }
    }
}
```

To export logs, you must have the **keys** property set to true to enable generation of the IAM access keys that grant access to AWS CloudWatch.

### Exporting the Ioto Log

By default, the Ioto trace log is saved to /var/log/ioto.log.

To save this to the cloud, change the **trace.path** property in the **config.json5** file to be set to "cloud".

```js
    trace: {
        path: 'cloud'
        group: 'log-group-name',
        stream: 'log-stream-name',
    }
```

This will cause all messages sent to the Ioto log to be saved to the specified CloudWatch group and stream name. If the group and stream are unset, they default to: "Ioto" and "agent".

### Enabling O/S Log File Export

Ioto can monitor, capture and export any file to S3. Ioto will monitor the length of the file and if new data is written to the log, it will be efficiently captured and written to CloudWatch.

To configure log files for monitoring, define the log files in the **logs.files** property of the **config.json5** configuration file. For example:

```js
{
    logs: {
        files: [
            { path: '/var/log/sys*log', group: 'ioto', stream: '{hostname}' }
        ],
    }
}
```

The **files** property contains any number of log definitions. Each definition specifies the local filename and the destination CloudWatch group and stream name.

The file pathname may contain the wild cards "*" and "?". This is useful for log files that have a varying portion such as a date or version component in the name.

The **stream** property can use tokens such as "{hostname}" which is expanded at runtime with the local hostname of the device.

## AWS IoT Shadow State

The AWS IoT Device Shadow service offers convenient storage for small device state (up to 8K). 

Shadows are capable of handling limited state for intermittently connected devices. When a device is not connected, updates to the shadow state in the cloud are stored until the device is next connected. Then, once connected, the changes are sent to the device for action.

Ioto makes it easy to use shadow state by automatically connecting to the AWS IoT Shadow service and by providing an easy get/set API on the device.

The Ioto agent automatically initializes an AWS Shadow state connection and subscribes to the required MQTT topics for data synchronization.

When shadows updates are received from the cloud, the agent saves these in a local shadow state file called **shadow.json5**. When the agent reboots, the local shadow state is read to be immediately available while the AWS cloud shadows are consulted for any updates.

We recommend using synchronized database tables rather than AWS Shadows as they offer increased data storage and more flexibility in accessing device data.

### Features

* Local copy of AWS IoT Device Shadow on device.
* Convenience device API to get / set shadow state properties.
* Controllable state synchronization with AWS IoT Shadows.
* Local persistence of shadow state.


## Cloud Auditing

When using a dedicated device cloud, it is best practice to enable [AWS CloudTrail](https://aws.amazon.com/cloudtrail/) on your AWS device cloud account to track user and API changes and activity on your account.

From the AWS Docs:

>AWS CloudTrail is an AWS service that helps you enable operational and risk auditing, governance, and compliance of your AWS account. Actions taken by a user, role, or an AWS service are recorded as events in CloudTrail. Events include actions taken in the AWS Management Console, AWS Command Line Interface, and AWS SDKs and APIs.

Visibility into your AWS account activity is a key aspect of security and operational best practices. You can use CloudTrail to view, search, download, archive, analyze, and respond to account activity across your AWS infrastructure. You can identify who or what took which action, what resources were acted upon, when the event occurred, and other details to help you analyze and respond to activity in your AWS account. Optionally, you can enable AWS CloudTrail Insights on a trail to help you identify and respond to unusual activity.

<!--
Ioto will automatically enable CloudTrail when creating a device cloud.

## S3 Bucket Name

Ioto will enable CloudTrail to log to an S3 bucket named: **ioto-cloudtrail-logs-UUID**.
-->


# IAM Access Keys

Ioto can automatically generate and distribute IAM access keys to devices so the device can interact with the Device Cloud or AWS services.

The IAM keys are temporary access keys that expire each hour. The Ioto agent will automatically refresh these keys as required.

## Enabling IAM Keys

To enable generation of temporary IAM keys, set the `keys` property of the `services.cloud` property in the Ioto agent **config/ioto.json5** configuration file to true.

```js
{
    services: {
        cloud: {
            keys: true
        }
    }
}
```

When the **keys** property is set to true, the Ioto agent will retrieve from your Device Cloud a set of temporary IAM credentials that can be used to sign AWS API requests using the Ioto agent **aws** APIs or to use with the [AWS C API SDK](https://github.com/aws/aws-iot-device-sdk-embedded-C).

These keys will be automatically refreshed 20 minutes before expiring, so you can rely on using these keys to be valid for 20 minutes.

## IAM Role

The generated keys are based on the Device Cloud IAM role in the device cloud. This defaults to the IAM role named: `IotoDeviceAccess`. However, you can change this using the [Builder Site](https://admin.embedthis.com) to any custom role you choose.

You should follow the principle of least privilege and ensure all privileges granted to your devices are scoped to specific resources. They should only grant access to AWS APIs that are absolutely required.# Device Cloud Limits

Ioto defines data limits to protect you, your devices, customers and the service. If a device or devices send too much data to the cloud, Ioto protects you and your customers by throttling (slowing) incoming data from offending devices. 

Depending on your Device Cloud plan these limits and enforcement policies may vary. 

## Data Traffic

The amount of data you send to the device cloud is measured as the number of KBytes sent on average per device per hour. This traffic is then compared with the limit for your device cloud.

As you connect more devices, your data limit scales automatically with the number of devices connecting to the cloud. What is measured is the average data traffic over your entire pool of connecting devices.

For example, if you have 100 devices and a limit of 60 messages per device per hour, this means that your pool of devices can send up to 6,000 messages to the cloud per hour. 

Ioto supports short-term burst traffic above the limit, but if your sustained, aggregate traffic exceeds your limit, the offending devices will have their sending rate throttled.

## Data Limits

The data limits vary depending your your device cloud type and plan. 

For Hosted device clouds and the Evaluation device cloud, data limits ensure the cloud infrastructure is not monopolized by any one device, set of devices or users.

The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It has higher limits, as it is typically used with few devices and consequently lower aggregate device pool limits.

For a Dedicated cloud, you are the sole user of the cloud running in your own AWS account. In this case limits are advisory and can be increased if required. Contact support if you need a limit increase.

### Cloud Limits

Device Cloud| Limit
-:|:-
Eval Cloud | 60 messages (1K) per device per hour
Hosted Cloud | 10 messages (1K) per device per hour
Dedicated Cloud | 100 messages (1K) per device per hour

## Terms

Please see the [Terms of Use](https://www.embedthis.com/about/terms.html) for acceptable use terms.# Ioto&reg; Cloud Service

The Ioto cloud service enables you to centrally operate and manage one or millions of devices. The Ioto cloud service stores device data, manages communications with your devices and provides a device management application to manage devices. By aggregating critical device data in one place, you can easily manage your devices and extract important data analytics and intelligence from your devices.

![Ioto IoT Framework](/images/ioto/framework.avif){class="screen"}


## Device Cloud Services

The Ioto device cloud service provides:

* Cloud-based device database store for centralized management and analytics.
* Provisioning Ioto-based devices with certificates for secure communications.
* Secure management of device communications with denial-of-service protection.
* Automatic creation of device metrics based on device data.
* Management of over the air device updates.
* Device apps for managing a single devices or a large fleet of devices.
* Huge scale supporting 10,000,000+ devices per device cloud.

## Device Cloud Types

Ioto supports three types of device clouds:

* Eval Cloud
* Cloud hosted by EmbedThis 
* Dedicated cloud in your own AWS account

When creating a device cloud, the Builder will create all the necessary resources for IoT management. This process results in a configured, complete, integrated and live IoT cloud capability.

## Eval Cloud

The Eval cloud will probably be your first experience with Ioto device clouds. The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It enables you to connect a device running the Ioto agent to the cloud and to receive device data and manage the device.

The Eval cloud is free to use for a few devices for a short period of time for evaluation purposes.

## Hosted Device Clouds

A hosted device cloud is a device cloud for your devices and customers that is hosted by EmbedThis on secure AWS IoT infrastructure. You do not need to have or manage your own AWS account to use a hosted device cloud. Hosted device clouds are limited to 1,000 devices. If you expect to exceed this number of devices over the lifetime of your product, you should use a dedicated device cloud for your production deployment.

Device data goes directly from your devices to the device cloud in the region you select when creating the device cloud. Data does not transit other regions or third-party services.  This is important as governments and authorities are increasingly requiring that data only be stored, processed and managed locally.

Unlike other IoT services, Ioto provides decreased latency by locating device data in a region close to you. This lowers cost and boosts performance of your cloud-based management solution.

A hosted device cloud provides:

* An AWS DynamoDB database exclusively for your device data.
* AWS DynamoDB streams to replicate device data to and from the cloud.
* An AWS API Gateway to authorize remote API access to device data.
* An AWS Cognito User Pool to authenticate user access.
* An AWS CloudFront and S3 site for device apps.
* AWS Route53 domain for device apps.
* AWS Lambda functions for cloud-side device management.
* AWS IoT Core policies and message routing rules.
* AWS IoT Things to model your devices in the cloud.

## Dedicated Device Clouds

A dedicated device cloud is created in your AWS account so you have the ultimate in the control and privacy of your device data. With a dedicated device cloud, device data goes directly from your devices to the device cloud in your AWS account. The device data is not sent through EmbedThis servers. The data is encrypted throughout and you have total control.

Dedicated clouds support an enhanced set of AWS services beyond those available with hosted device clouds. These include:

* Device log file capture and storage in AWS CloudWatch logs
* Audit operations via AWS CloudTrail
* Device AWS keys to initiate AWS API operations from the device

## Device Apps

For each device cloud, you can create one or more apps with which to manage your devices. 

Device management apps are based upon the `DevCore` UI Framework which is a flexible UI framework that can be uniquely configured for your devices. It can be completely customized with your logo, product name, device data and device specific screens and custom logic.

Device apps are hosted by EmbedThis on a domain of your choice that reflects your company or product's brand. 


![Builder Dashboard](/images/manager/dashboard.png){class="screen"}

## Device Certificates

Devices require X.509 certificates to securely connect and communicate with the cloud. The certificates are used to uniquely identify and authenticate devices and then to encrypt communications to prevent tampering or eavesdropping.

Ioto will automatically create and distribute the unique per-device certificates. This eliminates the pain of certificate creation and distribution and effectively isolates the security of each device and prevents the compromise of one device's certificate from impacting other devices.

## Device Messaging

During device provisioning, the Ioto service will setup the necessary AWS resources to enable secure efficient messaging via AWS IoT core using the MQTT protocol.  MQTT is a messaging protocol for IoT. It is a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices.

## Device Data Aggregation

Collecting, aggregating and sending device data to a central management store can be complex and costly. Ioto takes the hassle out of exporting device data to the cloud by synchronizing the Ioto device agent database with an AWS DynamoDB database in your device cloud.

Data written on the device to the management database will be transparently exported to the cloud as required. Similarly, data written to the cloud database will be distributed to the appropriate devices as required. No programming is required.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-device and per-table basis. Performance can be optimized by buffering and aggregating changes to reduce message overhead.

This replication capability is similar to AWS DynamoDB Global Tables, but instead of acting inside AWS between AWS regions, it is between an AWS region and a device.

This replicated device database is unique to Ioto and dramatically simplifies the creation of IoT solutions.

## Device Access Keys

For dedicated device clouds, Ioto can optionally create and manage AWS IAM access keys for your devices. AWS uses IAM access keys to authenticate and authorize actors on AWS resources. The Ioto device cloud can create specific IAM keys to enable devices to directly issue requests to the device cloud and AWS services.

The Ioto generated temporary IAM access keys have tightly controlled access permissions. The keys are automatically reissued as required.

## Device Logging

For dedicated device clouds, device logs and files can be captured and sent to AWS CloudWatch logs for storage, governance and analysis.

The Ioto agent can be configured without coding, to capture any O/S log or program output and send it to CloudWatch Logs. 

## Device Metrics and Analytics

Ioto provides a comprehensive, scalable metric service. Metrics can be transparently created from device data changes. The Ioto metrics are dramatically less expensive and more scalable than AWS CloudWatch metrics.

Using these Ioto metrics, you can create detailed device analytics and dashboards to focus on any aspect of your device or fleet performance.

<!--
## Account Audit

For dedicated device clouds, Ioto configures and enables CloudTrail, which captures an audit trail of **all** activity on your account and device cloud.  This records a complete log to AWS S3 so you can reliably audit operations and determine root cause of any security incidents.
--># MQTT Messaging

The MQTT messaging protocol is a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices with a small code footprint and minimal network bandwidth to the cloud.

MQTT is used by Ioto for general device communications and for transporting the device state to the cloud.

## Configuring

As devices are provisioned by the Builder into a Device Cloud, the Ioto service will create and distribute the necessary device X.509 certificates, keys and resources to configure secure cloud communications over MQTT.

The device-specific certificates and keys are provided to the Ioto device agent as part of the device provisioning, registration/claiming process. The device agent will save these on the device.

## Ioto Key/Value Store

Many devices require simple device settings that can be managed by the cloud. In addition to the general Ioto device database, Ioto provides provides a simple **key/value** store in the device database called the **Store**. This key/value store is ideal for a small set of simple device settings. If you have more elaborate device settings and state, they are best stored directly in the device database.

Values can easily be written and read to/from the Store using the device agent **ioSet** APIs.

```c
iotSet("model", "Acme Rocket");
iotSetNum("cpu", 55);
```

These values can be displayed in device app and can be retrieved in the device via the **ioGet** APIs.

```c
char *model = iotSet("model");
int64 cpu = iotSetNum("cpu");
```

These APIs are simple wrappers over the mqttPublish and mqttRequest APIs.

## Ioto Device Agent

The Ioto device agent provides an efficient MQTT client that is ideal for connecting to the cloud. It supports:

* MQTT 3.1.1
* Connect, publish, subscribe, ping and disconnect messages.
* TLS encryption with ALPN over port 443 to get through firewalls.
* Message quality of service for reliable delivery.
* Retained messages.
* High message throughput with exceptionally low overhead.
* Wait for delivery or acknowledgement options.
* Resilient reconnect on network interruptions.
* Automatic configuration after cloud provisioning.
* Parallelism via fiber coroutines. No ugly callbacks or complex threads.
* Tiny footprint of 8K code.

See the [Ioto MQTT Documentation](/agent/dev/mqtt.html) for details about the Ioto Agent MQTT API with examples.

## MQTT Reconnecting

The Ioto service will reliably maintain an MQTT connection to devices. If the network connection fails, Ioto will automatically reconnect to the cloud service. 

## Throttling

Ioto defines data limits to protect you, your devices, customers and the service. If a device or devices send too much data to the cloud, Ioto protects you and your customers by throttling (slowing) incoming data from offending devices. 

## Data Traffic

The amount of data you send to the device cloud is measured as the number of KBytes sent on average per device per hour. This traffic is then compared with the limit for your device cloud.

As you connect more devices, your data limit scales automatically with the number of devices connecting to the cloud. What is measured is the average data traffic over your entire pool of connecting devices.

For example, if you have 100 devices and a limit of 60 messages per device per hour, this means that your pool of devices can send up to 6,000 messages to the cloud per hour. 

Ioto supports short-term burst traffic above the limit, but if your sustained, aggregate traffic exceeds your limit, the offending devices will have their sending rate throttled.

## Throttling

When devices in a cloud cloud exceed the data limit, the offending devices will receive a throttle message and the device's Ioto agent will automatically slow down the rate of sending to the cloud. 

Upon receiving a throttle message, Ioto will implement an exponential backoff strategy and will slow down the rate of sending. Messages can still be received and Ioto will be fully functional. However, the rate of sending will be reduced until the throttled condition is alleviated. This protects your account and your customer's quality of service. It also protects you against rogue devices that have been compromised.

If a device continues to exceed the limit for a device cloud, the device will be disconnected (released) from the device cloud and its communication certificates will be revoked. The device will then need to be reclaimed to join the device cloud.

Ioto measures your device traffic rate every 30 seconds and will throttle a device that is exceeding your traffic limit over a 1 minute period.

Please see [Device Cloud Limits](../clouds/limits.md) for limit details.

## Terms

Please see the [Terms of Use](https://www.embedthis.com/about/terms.html) for acceptable use terms.---
# https://vitepress.dev/reference/default-theme-home-page
layout: home
hero:
  name: "EmbedThis Ioto"
  text: "Documentation"
  tagline: Build your next smart device here
  actions:
    - theme: brand
      text: Why EmbedThis Ioto?
      link: /builder/what-is-ioto.md
    - theme: alt
      text: Get Started
      link: /ioto/getting-started.md
  image:
    src: '/circuit-8.avif'
    alt: 'EmbedThis'

features:
  - icon: 
    title: Device Builder
    details: One-stop-shop for building smart devices. Download device agents softare, create device clouds, monitor devices and update device firmware.
    link: '/builder/'
  - icon: 
    title: Ioto Cloud
    details: Device cloud service for Ioto devices. Device data capture, storage, metrics and analysis.
    link: '/ioto/'
  - icon: 
    title: Iot Device Agent
    details: Blazing fast, compact device agent with local embedded web server and remote cloud-based management.
    link: '/agent/'
  - icon:  
    title: Device Management Apps
    details: Create apps to manage your devices using the low-code, visual app designer to create mobile and desktop management apps.
    link: '/apps/'

---

<style>
:root {
  --vp-home-hero-name-color: transparent;
  --vp-home-hero-name-background: linear-gradient(-45deg, #445aff 50%, #6d8ae2c7 50%);
  was: -webkit-linear-gradient(120deg,rgb(189, 52, 254) 30%, #41d1ff);

  --vp-home-hero-image-background-image: linear-gradient(-45deg, #445aff 50%, #6d8ae2c7 50%);
  old: linear-gradient(-45deg, #bd34fe 50%, #47caff 50%);
  --vp-home-hero-image-filter: blur(44px);
}

@media (min-width: 640px) {
  :root {
    __--vp-home-hero-image-filter: blur(56px);
  }
}

@media (min-width: 960px) {
  :root {
    __--vp-home-hero-image-filter: blur(68px);
  }
}

.VPImage.image-src {
  max-width: 300px !important;
  max-height: 300px !important;
}
</style># Creating Dashboards

You can create any number of dashboards from the Builder dashboard list.

![Dashboard List](/images/builder/dash-list.png){class="screen width-100"}

From the Dashboard list you can click the `Add` button to create a new dashboard or click on the `Edit` icon to modify an existing dashboard. When clicked, the dashboard configuration panel will be displayed.

The `Design` icon is used to launch the dashboard designer so you can modify the dashboard, content layout and styling.  While the `Show` icon is used to display the dashboard. 

## Modifying Dashboards

![Dashboard](/images/builder/dash-edit.png){class="screen width-50"}

Using the dashboard configuration panel, you can create, delete and manage dashboards to control dashboard operation, layout, and styling.

When you have finished creating or editing your dashboard, you can `Save` to persist your changes. You can rename a dashboard by entering a new name and clicking Save. 

Click the `Copy` button to copy an existing dashboard to a new dashboard. The `Apply` button saves your changes without dismissing the edit panel. Dashboards can be deleted via the `Delete` button.

## Dashboard Name

Each dashboard is given a unique name that is displayed in the dashboard list.

## Dashboard Layout

Dashboards have the choice of using one of two layout engines:

Name | Description
-|-
Grid | Layout widgets on a grid
Exact | Layout widgets with exact positioning

### Grid Layout

The **Grid** layout will align widgets on a 20 pixel grid and ensure that widgets do not overlap.

### Exact Layout

The **Exact** layout engine will position and size widgets wherever you place and configure them with per-pixel resolution. Widgets can overlap and cover widgets behind them. The exact layout does not use a grid.  The exact layout is useful to create composite pages where widget boundaries are not visible (using frameless widgets).


## Live Data

By default, dashboards will automatically update widget data based on the defined **Refresh Period**. You can disable **Live Data** update which can help you to focus on styling and arranging widgets without any display updates to break your concentration. 

## Framed Widgets

Widgets can be framed with a thin border. If you are creating a dashboard with a grid of data graphs, gauges and metrics, you typically frame the widgets with a consistent border.

![Framed Widgets](/images/builder/framed-widgets.avif){class="screen"}

If you are creating a composite page, you may wish to combine widgets so that the boundaries between widgets are less visible. In this case, disabling widget frames can assist to create a cohesive single page interface. For example, the EcoHouse app combines widgets to create a single page dashboard.

![Eco House](/images/eco/eco-home.avif){class="screen width-50"}

In this case, it is typically helpful to enable frames while you are designing a page and then disable frames when you are complete.

## Full Screen

When full screen mode is enabled, the top-level application navbar is hidden:

![Nav Bar](/images/builder/full-screen.avif){class="screen"}

This is useful for mobile displays and for production desktop dashboards.

## Show Toolbar

If the `Show Toolbar` option is enabled, a toolbar is displayed at the top of the dashboard. The toolbar can be used to select dashboards, change the data date range, refresh data, and modify dashboard and widget configuration. You can also click a `designer` icon to quickly return to the designer for more significant changes to the dashboard.

![Widget Toolbox](/images/builder/dashboard-toolbar.avif){class="screen width-80"}

## Refresh Period

You can define the default refresh rate for metrics and data widgets. Set the refresh rate to your desired update period in seconds. However, do not set needlessly low as this will impose increased load on your service.

## Device Emulation

When designing pages for a mobile app, it can be helpful to perform your design on a desktop PC and emulate the mobile device. Selecting a **mobile** device to be emulated will resize the dashboard to be that of an iPhone 15 Pro Max.

Dashboards are responsive and should scale up and down as browser windows are resized or when run on mobile devices of differing dimensions.

### Time Range

You can define an absolute or relative time period to use for metric data supplied to your widgets.
A relative time range may be set to the most recent number of minutes, hours, days, weeks, months or years. An absolute time range can specify a fixed start and end date.

If the dashboard has a **toolbar** widget, users can change the time range at any time.

### Dashboard CSS Properties

Dashboards can be styled with any valid CSS property. For example, you can set the background to red and foreground color to blue via:

Name | Value
-|-
background | red
color | blue

### Default Widget CSS Properties

Simlarly to Dashboard CSS properties, you can define default widget properties that are applied to all widgets. These can be overridden per-widget in the Widget edit panel. You can display a color picker by clicking the pencil icon in the table.

## Exporting and Importing Dashboards

You can export a dashboard to a JSON file by selecting the dashboard and clicking the `Export` option under `Actions`. You can import a dashboard from a JSON file by clicking the `Import` action.

## Selecting Dashboards

You can create multiple dashboards that focus on different service aspects. For example, you may want a dashboard that features service load graphs and metrics and another dashboard to focus on outages and errors.

You can easily switch between dashboards by clicking on the name of the dashboard in the Dashboard toolbar. You can also create enable a "dashboard switch" action on a button widget that lets you rapidly switch to another dashboard by clicking the button widget in the dashboard.# Dashboards

![Dashboard](/images/builder/dashboard.png){class="screen"}

Builder dashboards provide interactive, graphical interfaces for monitoring and managing your account and IoT clouds. They serve as a real-time window into the state of your service.

Dashboards are composed of interactive widgets, allowing you to create tailored information interfaces focused on specific aspects of your service or operations.

## Key Features

- **Graphical Widgets:** Include graphs, gauges, numeric displays, text displays, and more.
- **No-Code Designer:** A drag-and-drop interface for creating and customizing dashboards and widgets.
- **Flexible Layouts:** Adjustable widget positioning and sizing to fit your requirements.
- **Responsive Design:** Dashboards adapt seamlessly to various screen sizes.
- **Multiple Dashboards:** Support for creating and managing multiple dashboards for different service aspects.
- **Widget and Data Source Gallery:** Access to additional pre-designed widgets and data integrations.
- **Configuration Sharing:** Save and share dashboard setups with team members.

These features enable efficient monitoring and management of device and cloud performance.

## Widgets

Widgets are UI components that display data within a dashboard. They pull data from the Builder service, Ioto service, or your custom device metrics. You can add, remove, style, position, and resize widgets to meet your specific needs.

Builder dashboards support 30 widget types, including gauges, graphs, numeric displays, text displays, images, data tables, and input widgets.

Key capabilities of widgets include:

- **Dynamic Styling:** Customize colors, backgrounds, fonts, and overall presentation.
- **Composite Displays:** Combine multiple widgets to create cohesive, intuitive visualizations of device and cloud states.
- **Interactive Input:** Widgets like buttons and switches can trigger actions, such as device commands (e.g., rebooting) or cloud operations (e.g., updating a database or sending alerts).

By combining flexibility and interactivity, Builder dashboards provide a powerful tool for managing the operational state of your devices and services.

The Builder dashboard is based upon the low-code, visual [App Designer] used for EmbedThis device management. It uses the [Boards](/apps/boards/) component as the foundation for dashboards and widgets.

Please consult the documentation for:

* [Boards](/apps/boards/)
* [Layouts](/apps/boards/layouts.html)
* [Widgets](/apps/widgets/)
* [Toolbar](/apps/boards/toolbar.html)# Authentication

The Builder service provides different authentication methods for two use cases:

Authentication Method | Source | Roles | Purpose
-|-|-|-
[BuilderAPI Token](#admin-tokens) | Utility | Admin | Admin utilities running in the cloud or on-premises 
[Login Access Token](#login-access-tokens) | Browser | User, Admin | A logged in user from a web browser app 

For logged in users, Builder offers **Login Access Tokens** which are granted when a user logs into the Builder service. These tokens grant access according to the user's authorized role. All actions using Login Access tokens are limited in scope by the user's role and to resources owned by the logged in user.

For utility service commands, Builder offers **BuilderAPI Tokens** that provide full access to the device cloud and the all resources in the cloud. These tokens offer access to all user accounts utilizing the device cloud.

## BuilderAPI Tokens

BuilderAPI Tokens are used by utility commands and services for full administrative access to the resources of the device cloud. 

BuilderAPI Tokens have flexible lifespans and can be managed to set their lifespan or to suspend, resume, revoke or replace the token. You can have one or more BuilderAPI tokens active at a time. This is useful to deploy a new token and then subsequently revoke the old token.

To authorize requests using a BuilderAPI Token, you need to obtain a **BuilderAPI** token from the [Builder](https://admin.embedthis.com). The **BuilderAPI** token grants administrator privilege via the **"admin"** role to the caller when accessing the Builder service.

Tokens can be accessed and managed from the [Builder Token list](https://admin.embedthis.com/tokens).

### HTTP Request Paths

When using BuilderAPI tokens, the request URLs are modified to include a **"/tok"** URL prefix before the URL path.


## Token Authentication Example

Here is an example to issue a request from the command line using `curl` or the Ioto **url** command using a **BuilderAPI** token:

::: code-group
```curl
curl -X POST https://api.admin.embedthis.com/api/tok/user/get \
     -H 'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
     -H 'Content-Type: application/json' \
     -d '{"id": "ZXXXXXXXXX"}'
```
```url
url https://api.admin.embedthis.com/api/tok/user/get \
    'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
    '{id: "ZXXXXXXXXX"}'
```
:::

Note: the `url` command is a utility command that is installed with the Ioto agent. It can automatically sense the arguments as either headers, or body data. JSON body data can be passed as JSON5 (like JS) and can thus omit quotes on property keys.


## Login Access Tokens

A Login Access Token may be obtained by logging into the Builder service with a user email address and password and utilizing the **AccessToken** provided in the response with subsequent Builder API calls.

The Login request is a single HTTP POST request to the Builder Cognito authentiction endpoint.


### Login Request

The login request authenticates the user's credentials and exchanges them for a time-limited access token. The access token will be valid for a period of 60 minutes and can be refreshed using a **RefreshToken** contained in the response. The RefreshToken is valid for a period of 30 days.

**Endpoint** 

```
POST https://cognito-idp.us-east-1.amazonaws.com/us-east-1_W9auNFejR
```

**Request Headers**

```
X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth
Content-Type: application/x-amz-json-1.1
Origin: myapp.ioto.me
```

**Request Body**

```json
{
   "AuthParameters" : {
      "USERNAME" : "yourusername@example.com",
      "PASSWORD" : "yourpassword"
   },
   "AuthFlow" : "USER_PASSWORD_AUTH",
   "ClientId" : "5g3qt5mitfa4q1jlrlibeviedn"
}
```

**Response**

If the request is successful, you will receive a payload response that contains an **AccessToken**, **RefreshToken** and **ExpiresIn** duration. 

The AccessToken should be used in an **Authorization** HTTP header with subsequentIoto API calls. The **RefreshToken** can be used to refresh the access token before it expires. The **ExpiresIn** property defines how long (in seconds) the access token will be valid before expiring.

```json
{
    "AuthenticationResult":{
        "AccessToken": "...",
        "IdToken": "....",
        "RefreshToken": "....",
        "TokenType": "Bearer",
        "ExpiresIn": 3600
    }
} 
```

**Example**

The following example uses the Ioto `curl` utility to issue an authentication request based on the authentication credentials in a **./creds.json** file. 

::: code-group
```curl
curl -X POST \
  -H 'X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth' \
  -H 'Content-Type: application/x-amz-json-1.1' \
  --data @creds.json \
  https://cognito-idp.us-east-1.amazonaws.com/
```
```url
$ url https://cognito-idp.us-east-1.amazonaws.com/ \
    'X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth' \
    'Content-Type: application/x-amz-json-1.1' \
    @creds.json
```
:::

### Roles

When user accounts are created in the device app, the user is authorized with an access role that determines the scope of access for the user. The following three roles are supported:

Role | Capabilties
-|-
user | Ability to view but not modify service depending resources.
admin | Ability to modify all resources and fully administer the account.

The Builder will utilize an **admin** role for the **BuilderAPI** authentication token. This gives the ability to manage multiple accounts and devices over all users.


## Refreshing Login Tokens

Access tokens expire after 60 minutes. However, you can refresh the access token without requiring the user to re-login by using the **RefreshToken** that was returned when first logging in. Refresh tokens expire after 30 days.

**Endpoint**

```
POST https://cognito-idp.us-east-1.amazonaws.com/us-east-1_W9auNFejR
```

**Request Headers**

```
X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth
Content-Type: application/x-amz-json-1.1
```

**Request Body**

```json
{
   "AuthParameters" : {
      "REFRESH_TOKEN": "...",
   },
   "AuthFlow" : "REFRESH_TOKEN_AUTH",
   "ClientId" : "5g3qt5mitfa4q1jlrlibeviedn"
}
```


**Response**

If the request is successful, you will receive the following payload response. The AccessToken should be used in an **Authorization** HTTP header with Ioto API calls . The RefreshToken should be used to refresh the access token before it expires. The ExpiresIn property defines how long the token will be valid.

```json
{
    "AuthenticationResult":{
        "AccessToken": "...",
        "IdToken": "....",
        "RefreshToken": "....",
        "TokenType": "Bearer",
        "ExpiresIn": 3600
    }
} 
```

### Logout

There is not an explicit sesion logout API. To logout, discard and erase the access and refresh tokens from any local storage and remove any browser session state associated with the tokens.
# Product

Manage Products.

## Download
Download device agent software.

**Endpoint**

```HTTP
POST /product/download
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| image | string | yes | Image name. |
| planId | string |  | Plan ID. |

**Response** 

The download URL for the requested image.


## Find
Get a list of products.

**Endpoint**

```HTTP
POST /product/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Product records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Product** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| description | string | Product description. |
| id | string | Product ID. |
| name | string | Product name. |
| planId | string | Owning plan ID. |
| suspended | boolean | Product suspended. |
| url | string | Product URL. |

## Get
Get a product definition by ID.

**Endpoint**

```HTTP
POST /product/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Product ID. |

**Response** 

Product Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| description | string | Product description. |
| id | string | Product ID. |
| name | string | Product name. |
| planId | string | Owning plan ID. |
| suspended | boolean | Product suspended. |
| url | string | Product URL. |

## Update
Update a product definition.

**Endpoint**

```HTTP
POST /product/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| advance | boolean | Payment in advance. |
| align | boolean | Align billing with plan period. |
| agent | string | Licensed agent. |
| approved | boolean | Suscription requires user approval. |
| created | date | Created. |
| description | string | Product description. |
| id | string | Product ID. |
| end | date | End of plan period. |
| license | string | License type. |
| name | string | Unique simple name without spaces. |
| notify | array | Email addresses for product alerts. |
| period | string | Plan period. |
| planId | string | Plan ID. |
| scope | string | License scope: product, family, business. |
| start | date | Start of subscription plan. |
| type | string | License type: volume, subscription, business, agreement. |
| units | number | Number of devices for volume limited scriptions. |
| url | string | Company website URL. |

**Response** 

Product Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| description | string | Product description. |
| id | string | Product ID. |
| name | string | Product name. |
| planId | string | Owning plan ID. |
| suspended | boolean | Product suspended. |
| url | string | Product URL. |

# Dashboard

Manage Builder UI Dashboards.

## Create
Create a dashboard.

**Endpoint**

```HTTP
POST /dashboard/create
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Default | Notes |
| - | - | - | - | - |
| css | array |  |  | CSS styles. |
| emulate | string |  |  | Emulate. |
| fixed | boolean |  |  | Fixed. |
| framed | boolean |  |  | Framed. |
| layout | string |  |  | Layout. |
| live | boolean |  |  | Live. |
| name | string | yes |  | Name. |
| range | object |  |  | Range. |
| refresh | number |  |  | Refresh. |
| toolbar | boolean |  |  | Toolbar. |
| type | string |  |  | Type. |
| widgets | array |  | [] | Widgets. |
| widgetCss | array |  |  | Widget CSS. |

**Widgets** 

| Field | Type | Default | Notes |
| - | - | - | - |
| actions | array |  | Widget actions. |
| accept | string |  | File input accept type. |
| anchor | object | {} | Anchor side. |
| axes | object |  | Graph axes. |
| cloudId | string |  | Cloud ID. |
| columns | array |  | Table columns to display. |
| css | array |  | CSS styles. |
| datetime | string |  | Date input datetime. |
| defaultValue | string |  | Default value. |
| dimensions | object | {} | Metric and data dimensions. |
| field | string |  | Database data field. |
| fields | array |  | Database fields to fetch. |
| fixed | boolean |  | Lock down changes. |
| form | string |  | Input form name. |
| formField | string |  | Input form field. |
| footer | string |  | Widget footer. |
| format | string |  | Text and numeric format. |
| framed | boolean |  | Widget has a frame. |
| header | string |  | Widget header text. |
| height | string |  | Widget height in pixels. |
| id | string |  | Unique widget UUID within the dashboard only. |
| icon | string |  | Icon to display. |
| input | string |  | Input type. |
| items | string |  | Input items (JSON). |
| label | string |  | Input label. |
| legend | object |  | Widget legend. |
| left | string |  | Fraction of viewport (0-1) or "rest". |
| limit | number |  | Item limit. |
| max | number |  | Maximum data value. |
| min | number |  | Minimum data value. |
| metric | string |  | CloudWatch Metric. |
| model | string |  | Database model. |
| multiple | boolean |  | Multiple selection. |
| namespace | string |  | Metric namespace. |
| options | object |  | Custom options. |
| pageSize | number |  | Table page size. |
| pivot | string |  | Table pivot column. |
| placeholder | string |  | Input placeholder. |
| prefix | string |  | Value prefix. |
| presentation | string |  | Presentation style. |
| range | object | {} | Time range. |
| region | string |  | Region for metrics. |
| rows | number |  | Text area rows. |
| show | string |  | Show expression. |
| statistic | string |  | Math stat. |
| subtitle | string |  | Table subtitle. |
| suffix | string |  | Value suffix. |
| text | string |  | Static widget value. |
| ticks | number |  | Number of ticks. |
| timezone | string |  | Date input timezeon. |
| title | string |  | Widget title. |
| top | string |  | Top position. |
| type | string |  | Widget type. |
| units | string |  | Metric units. |
| url | string |  | Resource URL. |
| validate | string |  | RegExp validation. |
| width | string |  | Fraction of viewport (0-1). |
| z | number |  | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type | Default |
| - | - | - |
| anchor | string | relative |
| start | date |  |
| period | number | 2419200 |
| refresh | number | 60 |
| override | boolean | false |
| timezone | string | local |



**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Dashboard Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| css | array | CSS styles. |
| emulate | string | Emulate device. |
| fixed | boolean | Prevent runtime changes. |
| framed | boolean | Dashboard has a frame. |
| id | string | Dashboard ID. |
| layout | string | Dashboard layout. |
| live | boolean | Dashboard should update data in real time. |
| name | string | Dashboard name. |
| range | object | Dashboard time range. |
| refresh | number | Dashboard refresh rate (seconds). |
| toolbar | boolean | Dashboard has a toolbar for widget actions. |
| type | string | Dashboard type: "page" or "dashboard". |
| widgetCss | array | Widget CSS styles. |
| widgets | array | Widgets. |

**Range** 

Dashboard time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

| Field | Type | Notes |
| - | - | - |
| actions | array | Widget actions. |
| accept | string | File input accept type. |
| anchor | object | Anchor side. |
| axes | object | Graph axes. |
| cloudId | string | Cloud ID. |
| columns | array | Table columns to display. |
| css | array | CSS styles. |
| datetime | string | Date input datetime. |
| defaultValue | string | Default value. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database data field. |
| fields | array | Database fields to fetch. |
| fixed | boolean | Lock down changes. |
| form | string | Input form name. |
| formField | string | Input form field. |
| footer | string | Widget footer. |
| format | string | Text and numeric format. |
| framed | boolean | Widget has a frame. |
| header | string | Widget header text. |
| height | string | Widget height in pixels. |
| id | string | Unique widget UUID within the dashboard only. |
| icon | string | Icon to display. |
| input | string | Input type. |
| items | string | Input items (JSON). |
| label | string | Input label. |
| legend | object | Widget legend. |
| left | string | Fraction of viewport (0-1) or "rest". |
| limit | number | Item limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model. |
| multiple | boolean | Multiple selection. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pageSize | number | Table page size. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string | Value prefix. |
| presentation | string | Presentation style. |
| range | object | Time range. |
| region | string | Region for metrics. |
| rows | number | Text area rows. |
| show | string | Show expression. |
| statistic | string | Math stat. |
| subtitle | string | Table subtitle. |
| suffix | string | Value suffix. |
| text | string | Static widget value. |
| ticks | number | Number of ticks. |
| timezone | string | Date input timezeon. |
| title | string | Widget title. |
| top | string | Top position. |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Resource URL. |
| validate | string | RegExp validation. |
| width | string | Fraction of viewport (0-1). |
| z | number | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Find
Find matching dashboards.

**Endpoint**

```HTTP
POST /dashboard/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| name | string | Dashboard name. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Dashboard records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Dashboard** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| css | array | CSS styles. |
| emulate | string | Emulate device. |
| fixed | boolean | Prevent runtime changes. |
| framed | boolean | Dashboard has a frame. |
| id | string | Dashboard ID. |
| layout | string | Dashboard layout. |
| live | boolean | Dashboard should update data in real time. |
| name | string | Dashboard name. |
| range | object | Dashboard time range. |
| refresh | number | Dashboard refresh rate (seconds). |
| toolbar | boolean | Dashboard has a toolbar for widget actions. |
| type | string | Dashboard type: "page" or "dashboard". |
| widgetCss | array | Widget CSS styles. |
| widgets | array | Widgets. |

**Range** 

Dashboard time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

| Field | Type | Notes |
| - | - | - |
| actions | array | Widget actions. |
| accept | string | File input accept type. |
| anchor | object | Anchor side. |
| axes | object | Graph axes. |
| cloudId | string | Cloud ID. |
| columns | array | Table columns to display. |
| css | array | CSS styles. |
| datetime | string | Date input datetime. |
| defaultValue | string | Default value. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database data field. |
| fields | array | Database fields to fetch. |
| fixed | boolean | Lock down changes. |
| form | string | Input form name. |
| formField | string | Input form field. |
| footer | string | Widget footer. |
| format | string | Text and numeric format. |
| framed | boolean | Widget has a frame. |
| header | string | Widget header text. |
| height | string | Widget height in pixels. |
| id | string | Unique widget UUID within the dashboard only. |
| icon | string | Icon to display. |
| input | string | Input type. |
| items | string | Input items (JSON). |
| label | string | Input label. |
| legend | object | Widget legend. |
| left | string | Fraction of viewport (0-1) or "rest". |
| limit | number | Item limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model. |
| multiple | boolean | Multiple selection. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pageSize | number | Table page size. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string | Value prefix. |
| presentation | string | Presentation style. |
| range | object | Time range. |
| region | string | Region for metrics. |
| rows | number | Text area rows. |
| show | string | Show expression. |
| statistic | string | Math stat. |
| subtitle | string | Table subtitle. |
| suffix | string | Value suffix. |
| text | string | Static widget value. |
| ticks | number | Number of ticks. |
| timezone | string | Date input timezeon. |
| title | string | Widget title. |
| top | string | Top position. |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Resource URL. |
| validate | string | RegExp validation. |
| width | string | Fraction of viewport (0-1). |
| z | number | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Get
Get a dashboard by ID or name.

**Endpoint**

```HTTP
POST /dashboard/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Dashboard ID. |
| name | string | Dashboard name. |

**Response** 

Dashboard Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| css | array | CSS styles. |
| emulate | string | Emulate device. |
| fixed | boolean | Prevent runtime changes. |
| framed | boolean | Dashboard has a frame. |
| id | string | Dashboard ID. |
| layout | string | Dashboard layout. |
| live | boolean | Dashboard should update data in real time. |
| name | string | Dashboard name. |
| range | object | Dashboard time range. |
| refresh | number | Dashboard refresh rate (seconds). |
| toolbar | boolean | Dashboard has a toolbar for widget actions. |
| type | string | Dashboard type: "page" or "dashboard". |
| widgetCss | array | Widget CSS styles. |
| widgets | array | Widgets. |

**Range** 

Dashboard time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

| Field | Type | Notes |
| - | - | - |
| actions | array | Widget actions. |
| accept | string | File input accept type. |
| anchor | object | Anchor side. |
| axes | object | Graph axes. |
| cloudId | string | Cloud ID. |
| columns | array | Table columns to display. |
| css | array | CSS styles. |
| datetime | string | Date input datetime. |
| defaultValue | string | Default value. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database data field. |
| fields | array | Database fields to fetch. |
| fixed | boolean | Lock down changes. |
| form | string | Input form name. |
| formField | string | Input form field. |
| footer | string | Widget footer. |
| format | string | Text and numeric format. |
| framed | boolean | Widget has a frame. |
| header | string | Widget header text. |
| height | string | Widget height in pixels. |
| id | string | Unique widget UUID within the dashboard only. |
| icon | string | Icon to display. |
| input | string | Input type. |
| items | string | Input items (JSON). |
| label | string | Input label. |
| legend | object | Widget legend. |
| left | string | Fraction of viewport (0-1) or "rest". |
| limit | number | Item limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model. |
| multiple | boolean | Multiple selection. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pageSize | number | Table page size. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string | Value prefix. |
| presentation | string | Presentation style. |
| range | object | Time range. |
| region | string | Region for metrics. |
| rows | number | Text area rows. |
| show | string | Show expression. |
| statistic | string | Math stat. |
| subtitle | string | Table subtitle. |
| suffix | string | Value suffix. |
| text | string | Static widget value. |
| ticks | number | Number of ticks. |
| timezone | string | Date input timezeon. |
| title | string | Widget title. |
| top | string | Top position. |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Resource URL. |
| validate | string | RegExp validation. |
| width | string | Fraction of viewport (0-1). |
| z | number | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Remove
Remove a dashboard by ID.

**Endpoint**

```HTTP
POST /dashboard/remove
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Dashboard ID. |

## Update
Update a dashboard.

**Endpoint**

```HTTP
POST /dashboard/update
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| accountId | string |  | Account ID. |
| css | array |  | CSS styles. |
| emulate | object |  | Emulate. |
| fixed | boolean |  | Fixed. |
| framed | boolean |  | Framed. |
| id | string | yes | Dashboard ID. |
| layout | string |  | Layout. |
| live | boolean |  | Live. |
| name | string | yes | Dashboard name. |
| range | object |  | Range. |
| refresh | number |  | Refresh. |
| toolbar | boolean |  | Toolbar. |
| type | string |  | Type: "page" or "dashboard". |
| widgets | array |  | Widgets. |
| widgetCss | array |  | Widget CSS. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Dashboard Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| css | array | CSS styles. |
| emulate | string | Emulate device. |
| fixed | boolean | Prevent runtime changes. |
| framed | boolean | Dashboard has a frame. |
| id | string | Dashboard ID. |
| layout | string | Dashboard layout. |
| live | boolean | Dashboard should update data in real time. |
| name | string | Dashboard name. |
| range | object | Dashboard time range. |
| refresh | number | Dashboard refresh rate (seconds). |
| toolbar | boolean | Dashboard has a toolbar for widget actions. |
| type | string | Dashboard type: "page" or "dashboard". |
| widgetCss | array | Widget CSS styles. |
| widgets | array | Widgets. |

**Range** 

Dashboard time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

| Field | Type | Notes |
| - | - | - |
| actions | array | Widget actions. |
| accept | string | File input accept type. |
| anchor | object | Anchor side. |
| axes | object | Graph axes. |
| cloudId | string | Cloud ID. |
| columns | array | Table columns to display. |
| css | array | CSS styles. |
| datetime | string | Date input datetime. |
| defaultValue | string | Default value. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database data field. |
| fields | array | Database fields to fetch. |
| fixed | boolean | Lock down changes. |
| form | string | Input form name. |
| formField | string | Input form field. |
| footer | string | Widget footer. |
| format | string | Text and numeric format. |
| framed | boolean | Widget has a frame. |
| header | string | Widget header text. |
| height | string | Widget height in pixels. |
| id | string | Unique widget UUID within the dashboard only. |
| icon | string | Icon to display. |
| input | string | Input type. |
| items | string | Input items (JSON). |
| label | string | Input label. |
| legend | object | Widget legend. |
| left | string | Fraction of viewport (0-1) or "rest". |
| limit | number | Item limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model. |
| multiple | boolean | Multiple selection. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pageSize | number | Table page size. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string | Value prefix. |
| presentation | string | Presentation style. |
| range | object | Time range. |
| region | string | Region for metrics. |
| rows | number | Text area rows. |
| show | string | Show expression. |
| statistic | string | Math stat. |
| subtitle | string | Table subtitle. |
| suffix | string | Value suffix. |
| text | string | Static widget value. |
| ticks | number | Number of ticks. |
| timezone | string | Date input timezeon. |
| title | string | Widget title. |
| top | string | Top position. |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Resource URL. |
| validate | string | RegExp validation. |
| width | string | Fraction of viewport (0-1). |
| z | number | Z order. |

**Actions** 

| Field | Type | Notes |
| - | - | - |
| type | string | Action type. |
| target | string | Action target. |
| conditions | array | Automation Action Conditions. |


**Range** 

Time range.

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



# Metric

Manage Metrics.

## Fetch
Fetch device and service metrics from a device cloud.

**Endpoint**

```HTTP
POST /metric/fetch
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| items | array | yes | Array of metric requests. |

**Item Object** 

| Field | Type | Required | Default | Notes |
| - | - | - | - | - |
| accumulate | boolean |  |  | Accumulate result into a single result. |
| cloudId | string |  |  | Device Cloud ID. |
| dimensions | object |  |  | Dimensions for metric. |
| field | string |  |  | Database model field name. |
| limit | number |  |  | Number of items to fetch. |
| metric | string |  |  | Metric name. |
| model | string |  |  | Database model name. |
| multiple | boolean |  |  | Multiple dimensions requested. |
| namespace | string | yes |  | Must be set to Embedthis/Device. |
| period | number |  | 300 | Metric timespan period. |
| start | number |  |  | Metric range start. |
| statistic | string | yes | avg | Metric statistic. Select from: avg, min, max, count, sum. |


**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of metrics each containing an array of metric with the following properties. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Metric** 

| Field | Type | Notes |
| - | - | - |
| dimensions | object | Dimensions for the metric. |
| metric | string | Metric name. |
| namespace | string | Always set to Embedthis/Device. |
| owner | string | The service owning the metric. |
| period | number | Metric timespan period. |
| points | array | Array of data points. |
| samples | number | Number of data points in the period. |
| * | any |  |

**Dimensions** 

Dimensions for the metric.

| Field | Type |
| - | - |
| * | any |


**Points** 

| Field | Type | Notes |
| - | - | - |
| value | number | Metric value. |
| timestamp | number | Last update to the metric value in milli-seconds since Jan 1, 1970. |
| count | number | Number of data values contributing to the metric value. |


## GetMetricList
Get a list of metrics available for a device cloud.

**Endpoint**

```HTTP
POST /metric/getMetricList
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type |
| - | - |
| cloudId | string |
| namespace | string |
| metric | string |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| namespaces | array | Returns the requested namespace. If not provided, returns a list of available namespaces. |
| metrics | array | If a namespace is provided, returns a list of available metrics. |
| dimensions | array | If a namespace and metric are provided, returns a list of available metric dimensions. |

## GetDeviceSchema
Get the device data schema for a device cloud.

**Endpoint**

```HTTP
POST /metric/getDeviceSchema
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |

**Response** 

Device schema object.


# Card

Manage Billing Cards.

## Create
**Add a credit card.**

Cards must be added via the UI which uses the entered CVC and obtains a Stripe token. The last 4 digits of the number are saved.

**Endpoint**

```HTTP
POST /card/create
```

**Authorized User Role**

```
owner
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| current | boolean |  | Current card. |
| name | string | yes | Card name. |
| number | string | yes | Card number. |
| month | string | yes | Card month. |
| year | string | yes | Card year. |
| stripeToken | string | yes | Stripe token. |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| current | boolean |
| error | string |
| failures | number |
| id | string |
| name | string |
| number | string |
| month | string |
| submitted | date |
| year | string |

## Find
**Get a list of all the cards added.**

**Endpoint**

```HTTP
POST /card/find
```

**Authorized User Role**

```
admin
```

**Request Body** 

None.

**Query String Options** 

| Field | Type |
| - | - |
| filter | string |
| hidden | boolean |
| index | string |
| limit | number |
| log | boolean |
| next | object |
| prev | object |
| where | string |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | A list of cards. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Card** 

| Field | Type |
| - | - |
| accountId | string |
| current | boolean |
| error | string |
| failures | number |
| id | string |
| name | string |
| number | string |
| month | string |
| submitted | date |
| year | string |

## Get
**Get a card by ID.**

**Endpoint**

```HTTP
POST /card/get
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Card ID. |

**Response** 

The requested card.

| Field | Type |
| - | - |
| accountId | string |
| current | boolean |
| error | string |
| failures | number |
| id | string |
| name | string |
| number | string |
| month | string |
| submitted | date |
| year | string |

## Remove
**Endpoint**

```HTTP
POST /card/remove
```

**Authorized User Role**

```
owner
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Card ID. |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| current | boolean |
| error | string |
| failures | number |
| id | string |
| name | string |
| number | string |
| month | string |
| submitted | date |
| year | string |

## UpdateCurrent
**Endpoint**

```HTTP
POST /card/updateCurrent
```

**Authorized User Role**

```
owner
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Card ID. |
| current | boolean |  | Current card. |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| current | boolean |
| error | string |
| failures | number |
| id | string |
| name | string |
| number | string |
| month | string |
| submitted | date |
| year | string |

## GetStripe
**Endpoint**

```HTTP
POST /card/getStripe
```

**Authorized User Role**

```
admin
```

**Response** 

None.

# Manager

App Management.

## CheckDomain
Check if a domain is available for an app.

**Endpoint**

```HTTP
POST /manager/checkDomain
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| domain | string | yes | Domain. |

**Response** 

Boolean Record.


## Create
Create an app.

**Endpoint**

```HTTP
POST /manager/create
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |
| custom | boolean | Custom flag. |
| domain | string | Domain. |
| name | string | Name. |
| owner | string | Owner. |
| region | string | Region. |
| title | string | Title. |
| users | array | User allow list. |
| version | string | Version. |
| versionCurrent | string | Version current. |

**Response** 

A app/manager object.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Owning cloud ID. |
| custom | boolean | Custom app.zip. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Manager error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Manager owner. |
| priorDomain | string | Prior domain. |
| provisioned | date | When provisioned. |
| region | string | Manager region. |
| title | string | Manager title. |
| type | string | Cloud type. |
| users | array | User allow list. |
| version | string | Manager version. |
| versionCurrent | string | Current app version. |

## Find
Get a list of apps.

**Endpoint**

```HTTP
POST /manager/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | App ID. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of App/Manager records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**App/Manager** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Owning cloud ID. |
| custom | boolean | Custom app.zip. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Manager error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Manager owner. |
| priorDomain | string | Prior domain. |
| provisioned | date | When provisioned. |
| region | string | Manager region. |
| title | string | Manager title. |
| type | string | Cloud type. |
| users | array | User allow list. |
| version | string | Manager version. |
| versionCurrent | string | Current app version. |

## Get
Get an app/manager by ID.

**Endpoint**

```HTTP
POST /manager/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | App/Manager ID. |

**Response** 

An app/manager object.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Owning cloud ID. |
| custom | boolean | Custom app.zip. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Manager error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Manager owner. |
| priorDomain | string | Prior domain. |
| provisioned | date | When provisioned. |
| region | string | Manager region. |
| title | string | Manager title. |
| type | string | Cloud type. |
| users | array | User allow list. |
| version | string | Manager version. |
| versionCurrent | string | Current app version. |

## GetSignedUrl
Get a signed URL to download or upload a file to the app site.

**Endpoint**

```HTTP
POST /manager/getSignedUrl
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | App/Manager ID. |
| command | string | Command. |
| filename | string | Filename. |
| mimeType | string | Mime type. |
| size | number | File size. |

**Response** 

A signed URL string.


## Provision
Provision an app site and files.

**Endpoint**

```HTTP
POST /manager/provision
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | App/Manager ID. |
| preserve | boolean |  | Preserve existing theme assets. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| invoke | string | Invoke command. |

**Response** 

An app/manager object.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Owning cloud ID. |
| custom | boolean | Custom app.zip. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Manager error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Manager owner. |
| priorDomain | string | Prior domain. |
| provisioned | date | When provisioned. |
| region | string | Manager region. |
| title | string | Manager title. |
| type | string | Cloud type. |
| users | array | User allow list. |
| version | string | Manager version. |
| versionCurrent | string | Current app version. |

## Remove
Remove an app.

**Endpoint**

```HTTP
POST /manager/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | App/Manager ID. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| invoke | string | Invoke command. |

## Update
Update an app.

**Endpoint**

```HTTP
POST /manager/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |
| custom | boolean | Custom flag. |
| domain | string | Domain. |
| id | string | App/Manager ID. |
| name | string | Name. |
| owner | string | Owner. |
| priorDomain | string | Prior domain. |
| region | string | Region. |
| title | string | Title. |
| users | array | User allow list. |
| version | string | Version. |
| versionCurrent | string | Version current. |

**Response** 

An app/manager object.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Owning cloud ID. |
| custom | boolean | Custom app.zip. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Manager error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Manager owner. |
| priorDomain | string | Prior domain. |
| provisioned | date | When provisioned. |
| region | string | Manager region. |
| title | string | Manager title. |
| type | string | Cloud type. |
| users | array | User allow list. |
| version | string | Manager version. |
| versionCurrent | string | Current app version. |

## UpdateDisplay
Update an app display file.

**Endpoint**

```HTTP
POST /manager/updateDisplay
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |
| display | string | Display file contents. |
| id | string | App/Manager ID. |

**Response** 

An app/manager object.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| cloudFront | string | CloudFront distribution ID. |
| cloudId | string | Owning cloud ID. |
| custom | boolean | Custom app.zip. |
| distributionId | string | CloudFront distribution ID. |
| domain | string | Manager domain. |
| error | string | Manager error message. |
| id | string | Manager ID. |
| name | string | Manager name. |
| owner | string | Manager owner. |
| priorDomain | string | Prior domain. |
| provisioned | date | When provisioned. |
| region | string | Manager region. |
| title | string | Manager title. |
| type | string | Cloud type. |
| users | array | User allow list. |
| version | string | Manager version. |
| versionCurrent | string | Current app version. |

# Usage

Manage usage metrics.

# Alert

Manage Alerts.

## Find
Find alerts by cloud ID.

**Endpoint**

```HTTP
POST /alert/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Alert records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Alert** 

| Field | Type | Notes |
| - | - | - |
| seq | string | Alert sequence number to uniquely identify the type of alert. |
| accountId | string | Owning account ID. |
| context | object | Alert context of extra information. |
| count | number | Count of triggered alerts with same context. |
| id | string | Alert ID. |
| name | string | Alert name. |
| message | string | Alert message. |
| severity | string | Alert severity. |
| subject | string | Alert subject. |
| resolved | boolean | Alert has been resolved. |
| timestamp | date | Alert timestamp. |

## Get
Get an alert by ID.

**Endpoint**

```HTTP
POST /alert/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Alert ID. |

**Response** 

Alert Record.

| Field | Type | Notes |
| - | - | - |
| seq | string | Alert sequence number to uniquely identify the type of alert. |
| accountId | string | Owning account ID. |
| context | object | Alert context of extra information. |
| count | number | Count of triggered alerts with same context. |
| id | string | Alert ID. |
| name | string | Alert name. |
| message | string | Alert message. |
| severity | string | Alert severity. |
| subject | string | Alert subject. |
| resolved | boolean | Alert has been resolved. |
| timestamp | date | Alert timestamp. |

## Remove
Remove an alert by ID.

**Endpoint**

```HTTP
POST /alert/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Alert ID. |

## Update
Update an alert's resolved property by ID.

**Endpoint**

```HTTP
POST /alert/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Alert ID. |
| resolved | boolean | Resolved flag. |

**Response** 

Alert Record.

| Field | Type | Notes |
| - | - | - |
| seq | string | Alert sequence number to uniquely identify the type of alert. |
| accountId | string | Owning account ID. |
| context | object | Alert context of extra information. |
| count | number | Count of triggered alerts with same context. |
| id | string | Alert ID. |
| name | string | Alert name. |
| message | string | Alert message. |
| severity | string | Alert severity. |
| subject | string | Alert subject. |
| resolved | boolean | Alert has been resolved. |
| timestamp | date | Alert timestamp. |

# Invoice

Manage Invoices.

## Download
**Endpoint**

```HTTP
POST /invoice/download
```

**Authorized User Role**

```
owner
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Invoice ID. |

**Response** 

A PDF binary string.


## Get
**Endpoint**

```HTTP
POST /invoice/get
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Invoice ID. |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| amount | number |
| date | date |
| description | string |
| due | date |
| items | array |
| id | string |
| memo | string |
| nextReminder | date |
| number | string |
| order | string |
| paid | number |
| pdf | string |
| receipt | string |
| submitted | date |
| tax | number |
| terms | number |
| total | number |

## Find
**Endpoint**

```HTTP
POST /invoice/find
```

**Authorized User Role**

```
admin
```

**Request Body** 

None.

**Query String Options** 

| Field | Type |
| - | - |
| filter | string |
| hidden | boolean |
| index | string |
| limit | number |
| log | boolean |
| next | object |
| prev | object |
| where | string |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Invoice records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Invoice** 

| Field | Type |
| - | - |
| accountId | string |
| amount | number |
| date | date |
| description | string |
| due | date |
| items | array |
| id | string |
| memo | string |
| nextReminder | date |
| number | string |
| order | string |
| paid | number |
| pdf | string |
| receipt | string |
| submitted | date |
| tax | number |
| terms | number |
| total | number |

## FindOutstanding
**Endpoint**

```HTTP
POST /invoice/findOutstanding
```

**Authorized User Role**

```
owner
```

**Request Body** 

None.

**Query String Options** 

| Field | Type |
| - | - |
| filter | string |
| hidden | boolean |
| index | string |
| limit | number |
| log | boolean |
| next | object |
| prev | object |
| where | string |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Invoice records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Invoice** 

| Field | Type |
| - | - |
| accountId | string |
| amount | number |
| date | date |
| description | string |
| due | date |
| items | array |
| id | string |
| memo | string |
| nextReminder | date |
| number | string |
| order | string |
| paid | number |
| pdf | string |
| receipt | string |
| submitted | date |
| tax | number |
| terms | number |
| total | number |

## Reissue
**Endpoint**

```HTTP
POST /invoice/reissue
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Invoice ID. |

**Response** 

A PDF binary string.


# Account

Manage Account.

## Get
Get an account given the account ID.<br>                <br>                Can also get account by email if using the gs1 index in the URL query.

**Endpoint**

```HTTP
POST /account/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Account ID. |
| email | string | Email address. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Account Record.

| Field | Type | Notes |
| - | - | - |
| activity | date | Most recent account activity. |
| closed | boolean | Account has been closed. |
| email | string | Billing email. |
| id | string | Account ID. |
| name | string | Account name. |

::: code-group
```curl
curl -X POST https://api.admin.embedthis.com/api/tok/account/get \
    -H 'Authorization: ${BUILDER_TOKEN}' \
    -H 'Content-Type: application/json' \
    -d '{"id": "01GC5Z9SS9NC3VXXXXXXXXXXXX"}'
```
```url
url https://api.admin.embedthis.com/api/tok/account/get \
    'Authorization: ${BUILDER_TOKEN}' \
    '{id: "01GC5Z9SS9NC3VXXXXXXXXXXXX"}'
```
:::

## UpdateIdentity
Update account name and email.

**Endpoint**

```HTTP
POST /account/updateIdentity
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Account ID. |
| email | string |  | Email address. |
| name | string |  | Account name. |

**Response** 

An account object.

| Field | Type | Notes |
| - | - | - |
| activity | date | Most recent account activity. |
| closed | boolean | Account has been closed. |
| email | string | Billing email. |
| id | string | Account ID. |
| name | string | Account name. |

# Software

Software update management.

## Create
Create a software update.

**Endpoint**

```HTTP
POST /software/create
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Default | Notes |
| - | - | - | - | - |
| attachment | object | yes |  | Uploaded software image. |
| cloudId | string | yes |  | Cloud ID. |
| description | string | yes |  | Software description. |
| enable | boolean |  | true | Enable. |
| image | string |  |  | Image name. |
| limit | number |  |  | Number of devices to update. |
| percentage | number |  |  | Percentage of devices to update. |
| period | number |  |  | Rate period in seconds. |
| policy | string |  |  | Distribution policy expression. |
| productId | string | yes |  | Product ID. |
| rate | number |  |  | Number of updates per period. |
| size | number |  |  | Size of the software image. |
| version | string | yes |  | Software version. |

**Response** 

Software Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| created | date | Software creation date. |
| checksum | string | Software checksum. |
| cloudId | string | Owning cloud ID. |
| description | string | Software description. |
| id | string | Software ID. |
| enable | boolean | Software enabled. |
| limit | number | Count of devices to update. |
| image | string | Software image. |
| percentage | number | Perentage of devices to update. |
| period | number | Rate period in seconds. |
| productId | string | Owning product ID. |
| policy | string | Software distribution policy expression. |
| rate | number | Number of updates per period. |
| size | number | Software size. |
| version | string | Software version. |

## Find
Get a list of software updates.

**Endpoint**

```HTTP
POST /software/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| productId | string | Product ID. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Software records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Software** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| created | date | Software creation date. |
| checksum | string | Software checksum. |
| cloudId | string | Owning cloud ID. |
| description | string | Software description. |
| id | string | Software ID. |
| enable | boolean | Software enabled. |
| limit | number | Count of devices to update. |
| image | string | Software image. |
| percentage | number | Perentage of devices to update. |
| period | number | Rate period in seconds. |
| productId | string | Owning product ID. |
| policy | string | Software distribution policy expression. |
| rate | number | Number of updates per period. |
| size | number | Software size. |
| version | string | Software version. |

## Get
Get a software update by ID.

**Endpoint**

```HTTP
POST /software/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Software ID. |

**Response** 

Software Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| created | date | Software creation date. |
| checksum | string | Software checksum. |
| cloudId | string | Owning cloud ID. |
| description | string | Software description. |
| id | string | Software ID. |
| enable | boolean | Software enabled. |
| limit | number | Count of devices to update. |
| image | string | Software image. |
| percentage | number | Perentage of devices to update. |
| period | number | Rate period in seconds. |
| productId | string | Owning product ID. |
| policy | string | Software distribution policy expression. |
| rate | number | Number of updates per period. |
| size | number | Software size. |
| version | string | Software version. |

## GetSignedUrl
Get a signed URL to upload the software image.

**Endpoint**

```HTTP
POST /software/getSignedUrl
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Software ID. |
| checksum | string | File checksum. |
| command | string | Command. |
| filename | string | Filename. |
| mimeType | string | Mime type. |
| size | number | File size. |

**Response** 

A signed URL string.


## Remove
Remove a software update.

**Endpoint**

```HTTP
POST /software/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Software ID. |

## Update
Update a software update.

**Endpoint**

```HTTP
POST /software/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| attachment | object |  | Uploaded software image. |
| cloudId | string |  | Cloud ID. |
| description | string |  | Software description. |
| enable | boolean |  | Enable. |
| limit | number |  | Number of devices to update. |
| image | string |  | Image name. |
| id | string | yes | Software ID. |
| percentage | number |  | Percentage of devices to update. |
| period | number |  | Rate period in seconds. |
| productId | string |  | Product ID. |
| policy | string |  | Distribution policy expression. |
| rate | number |  | Number of updates per period. |
| size | number |  | Size of the software image. |
| version | string |  | Software version. |

**Response** 

Software Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| created | date | Software creation date. |
| checksum | string | Software checksum. |
| cloudId | string | Owning cloud ID. |
| description | string | Software description. |
| id | string | Software ID. |
| enable | boolean | Software enabled. |
| limit | number | Count of devices to update. |
| image | string | Software image. |
| percentage | number | Perentage of devices to update. |
| period | number | Rate period in seconds. |
| productId | string | Owning product ID. |
| policy | string | Software distribution policy expression. |
| rate | number | Number of updates per period. |
| size | number | Software size. |
| version | string | Software version. |

# Issue

Manage Issues.

## Get
Get an issue by ID.

**Endpoint**

```HTTP
POST /issue/get
```

**Authorized User Role**

```
anyone
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Issue ID. |

**Response** 

An issue object.

| Field | Type | Notes |
| - | - | - |
| attachments | array | Attachments. |
| cve | string | CVE number. |
| date | date | Issue date. |
| description | string | Issue description. |
| id | string | Issue ID. |
| impacted | string | Impacted product. |
| notify | boolean | Notify subscribers. |
| priority | string | Issue priority. |
| public | boolean | Issue is public. |
| recommend | string | Recommended to apply this update. |
| release | string | Release version. |
| status | string | Issue status. |
| subject | string | Issue subject. |
| tags | array | Issue tags. |
| title | string | Issue title. |
| type | string | Issue type. |

## Find
Find matching issues.

**Endpoint**

```HTTP
POST /issue/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| public | boolean | Filter only public issues. |
| subject | string | Subject. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Issue records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Issue** 

| Field | Type | Notes |
| - | - | - |
| attachments | array | Attachments. |
| cve | string | CVE number. |
| date | date | Issue date. |
| description | string | Issue description. |
| id | string | Issue ID. |
| impacted | string | Impacted product. |
| notify | boolean | Notify subscribers. |
| priority | string | Issue priority. |
| public | boolean | Issue is public. |
| recommend | string | Recommended to apply this update. |
| release | string | Release version. |
| status | string | Issue status. |
| subject | string | Issue subject. |
| tags | array | Issue tags. |
| title | string | Issue title. |
| type | string | Issue type. |

# Token

Manage Access Tokens.

## Action
Perform a token action: delete, new, resume, revoke, suspend.

**Endpoint**

```HTTP
POST /token/action
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| action | string | Action: delete, new, resume, revoke, suspend. |
| tokens | array | Tokens to act on. |

## Create
Create a new token.

**Endpoint**

```HTTP
POST /token/create
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |
| description | string | Description. |
| enable | boolean | Enable. |
| expires | date | Expires. |
| role | string | Authorized role granted by token. |
| type | string | Token type: BuilderAPI, CloudAPI, CloudToBuilder, DeviceToCloud, ProductID. |

**Response** 

Token Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| description | string | Token description. |
| enable | boolean | Token enabled. |
| expires | date | Token expiration date. |
| id | string | Token ID. |
| owner | string | Token owner. |
| role | string | Token role. |
| type | string | Token type. |

## Find
Find matching tokens.

**Endpoint**

```HTTP
POST /token/find
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Token ID. |
| cloudId | string | Cloud ID. |
| enable | boolean | Enable. |
| type | string | Token type: BuilderAPI, CloudAPI, CloudToBuilder, DeviceToCloud, ProductID. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | A token object. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Token** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| description | string | Token description. |
| enable | boolean | Token enabled. |
| expires | date | Token expiration date. |
| id | string | Token ID. |
| owner | string | Token owner. |
| role | string | Token role. |
| type | string | Token type. |

## Get
Get a token by ID.

**Endpoint**

```HTTP
POST /token/get
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Token ID. |
| cloudId | string | Cloud ID. |
| enable | boolean | Enable. |
| type | string | Token type: BuilderAPI, CloudAPI, CloudToBuilder, DeviceToCloud, ProductID. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Token Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| description | string | Token description. |
| enable | boolean | Token enabled. |
| expires | date | Token expiration date. |
| id | string | Token ID. |
| owner | string | Token owner. |
| role | string | Token role. |
| type | string | Token type. |

## Remove
Remove a token.

**Endpoint**

```HTTP
POST /token/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |
| id | string | Token ID. |

## Update
Update a token.

**Endpoint**

```HTTP
POST /token/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| cloudId | string | Cloud ID. |
| description | string | Description. |
| enable | boolean | Enable. |
| expires | date | Expires. |
| id | string | Token ID. |
| role | string | Authorized role granted by token. |
| type | string | Token type: BuilderAPI, CloudAPI, CloudToBuilder, DeviceToCloud, ProductID. |

**Response** 

Token Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| description | string | Token description. |
| enable | boolean | Token enabled. |
| expires | date | Token expiration date. |
| id | string | Token ID. |
| owner | string | Token owner. |
| role | string | Token role. |
| type | string | Token type. |

# Cloud

Manage Device Clouds.

## Find
Get a list of device clouds.

**Endpoint**

```HTTP
POST /cloud/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Cloud ID. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | A list of cloud records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Cloud** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| api | string | Hub (Device cloud) API endpoint. |
| apiGateway | string | Manager API Gateway ID. |
| awsAccount | string | AWS account ID. |
| connected | boolean | Cloud connected and has passed tests. |
| deviceRole | string | IAM role for device keys. |
| enable | boolean | Cloud enable flag. |
| error | string | Cloud error. |
| host | string | Cloud host for hosted clouds. |
| hubs | number | Number of cloud hubs for this host. |
| id | string | Cloud ID. |
| iotPolicy | string | IoT policy for device keys. |
| limits | object | Cloud limits. |
| load | number | Cloud load. |
| name | string | Cloud name. |
| open | boolean | Host cloud is open for new tennants. |
| planId | string | Plan ID. |
| provisioned | date | Provisioned date. |
| quota | object | Cloud quota. |
| region | string | Cloud region. |
| roles | object | Cloud roles. |
| schema | object | Cloud schema. |
| shadows | boolean | Cloud has IoT device shadows. |
| stack | string | CloudFormation stack. |
| status | string | CloudFormation stack status. |
| storagePlan | string | Cloud storage plan ID. |
| suspended | boolean | Cloud is suspended. |
| sync | boolean | Cloud supports device database synchronization. |
| tenants | number | Number of cloud hub tenants. |
| trailBucket | string | Cloud trail bucket. |
| transferPlan | string | Cloud transfer plan ID. |
| type | string | Cloud type. |
| version | number | Cloud version (for schema compatibility). |
| userPoolId | string | Cognito user pool ID. |
| userPoolClient | string | Cognito user pool Client ID. |

## Get
Get a cloud object.

**Endpoint**

```HTTP
POST /cloud/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Cloud ID. |

**Response** 

A cloud object.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| api | string | Hub (Device cloud) API endpoint. |
| apiGateway | string | Manager API Gateway ID. |
| awsAccount | string | AWS account ID. |
| connected | boolean | Cloud connected and has passed tests. |
| deviceRole | string | IAM role for device keys. |
| enable | boolean | Cloud enable flag. |
| error | string | Cloud error. |
| host | string | Cloud host for hosted clouds. |
| hubs | number | Number of cloud hubs for this host. |
| id | string | Cloud ID. |
| iotPolicy | string | IoT policy for device keys. |
| limits | object | Cloud limits. |
| load | number | Cloud load. |
| name | string | Cloud name. |
| open | boolean | Host cloud is open for new tennants. |
| planId | string | Plan ID. |
| provisioned | date | Provisioned date. |
| quota | object | Cloud quota. |
| region | string | Cloud region. |
| roles | object | Cloud roles. |
| schema | object | Cloud schema. |
| shadows | boolean | Cloud has IoT device shadows. |
| stack | string | CloudFormation stack. |
| status | string | CloudFormation stack status. |
| storagePlan | string | Cloud storage plan ID. |
| suspended | boolean | Cloud is suspended. |
| sync | boolean | Cloud supports device database synchronization. |
| tenants | number | Number of cloud hub tenants. |
| trailBucket | string | Cloud trail bucket. |
| transferPlan | string | Cloud transfer plan ID. |
| type | string | Cloud type. |
| version | number | Cloud version (for schema compatibility). |
| userPoolId | string | Cognito user pool ID. |
| userPoolClient | string | Cognito user pool Client ID. |

## GetHosts
Get a list of matching hosts.

**Endpoint**

```HTTP
POST /cloud/getHosts
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| open | boolean | Open for tennants. |
| region | string | Region. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Host records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Host** 

| Field | Type | Notes |
| - | - | - |
| name | string | Host name. |
| region | string | Region. |

## Remove
Remove a cloud.

**Endpoint**

```HTTP
POST /cloud/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Cloud ID. |

**Query String Options** 

| Field | Type |
| - | - |
| invoke | string |

## Update
Update a cloud.

**Endpoint**

```HTTP
POST /cloud/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| align | boolean | Align flag. |
| attachments | object | Attachments. |
| deviceRole | string | Device role. |
| enable | boolean | Enable flag. |
| erase | object | Erase object. |
| error | string | Error. |
| id | string | Cloud ID. |
| iotPolicy | string | IoT policy. |
| name | string | Cloud name. |
| open | boolean | Open for tennants. |
| period | string | Period. |
| region | string | Region. |
| roles | object | Roles. |
| schema | object | Schema. |
| shadows | boolean | Enable AWS IoT shadows. |
| sync | boolean | Sync flag. |
| type | string | Cloud type. |
| units | number | Device units. |
| storage | number | Storage units. |
| transfer | number | Transfer units. |

**Response** 

A cloud object.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| api | string | Hub (Device cloud) API endpoint. |
| apiGateway | string | Manager API Gateway ID. |
| awsAccount | string | AWS account ID. |
| connected | boolean | Cloud connected and has passed tests. |
| deviceRole | string | IAM role for device keys. |
| enable | boolean | Cloud enable flag. |
| error | string | Cloud error. |
| host | string | Cloud host for hosted clouds. |
| hubs | number | Number of cloud hubs for this host. |
| id | string | Cloud ID. |
| iotPolicy | string | IoT policy for device keys. |
| limits | object | Cloud limits. |
| load | number | Cloud load. |
| name | string | Cloud name. |
| open | boolean | Host cloud is open for new tennants. |
| planId | string | Plan ID. |
| provisioned | date | Provisioned date. |
| quota | object | Cloud quota. |
| region | string | Cloud region. |
| roles | object | Cloud roles. |
| schema | object | Cloud schema. |
| shadows | boolean | Cloud has IoT device shadows. |
| stack | string | CloudFormation stack. |
| status | string | CloudFormation stack status. |
| storagePlan | string | Cloud storage plan ID. |
| suspended | boolean | Cloud is suspended. |
| sync | boolean | Cloud supports device database synchronization. |
| tenants | number | Number of cloud hub tenants. |
| trailBucket | string | Cloud trail bucket. |
| transferPlan | string | Cloud transfer plan ID. |
| type | string | Cloud type. |
| version | number | Cloud version (for schema compatibility). |
| userPoolId | string | Cognito user pool ID. |
| userPoolClient | string | Cognito user pool Client ID. |

# API Access

The EmbedThis Builder API is a [REST API](https://www.redhat.com/en/topics/api/what-is-a-rest-api) to allow you to interact with the Builder cloud service.

The Builder API provides calls to:

* Manage Builder accounts and users
* Manage device clouds
* Manage apps
* Manage device software updates
* Manage products
* Manage access tokens

The Builder API can be used from browser-based UI apps or from utility service commands running in the cloud or on-prem.

## Authentication

Requests to the Builder service are authenticated by checking an authentication token included with the request. Ioto provides two different authentication methods for two use cases:

Authentication Method | Source | Description
-|-|-
[BuilderAPI Token](authentication.md#admin-tokens) | Utility | An admin service running in the cloud or on-premises 
[Login Access Token](authentication.md#login-access-tokens) | Browser | A logged in user from a web browser app 

For logged in users, the Builder offers **Login Access Tokens** that are granted when a user logs into the service.  For utility service commands, the **BuilderAPI Tokens** provide administrative access to the service.

An authentication token must be included in the HTTP headers for Builder API requests.

## API Endpoint

The Builder API endpoint is constant for all users and consists of the path: 

```bash
https://api.admin.embedthis.com/api/
```

After this path prefix, API calls are of the form:

```
CONTROLLER/ACTION
```

For example:

```bash
https://api.admin-qa.embedthis.com/api/user/login
```

## HTTP Methods

All HTTP API requests use the **POST** method for consistency and simplicity. 

## HTTP Request Paths

When using Authentication tokens, the request URLs are modified to include a **"/tok"** URL prefix before the URL path.

For example:

```
https://api.admin-qa.embedthis.com/api/tok/user/find
```


## HTTP Headers

To authorize your request, include the authentication token as an **Authentication** HTTP header with your request. All API requests use a HTTP Content-Type of **application/json** for both requests and responses.

If using login access tokens, you must also include an **Origin** header that is set to the domain name for your device app.

For example:

```
Authorization: 1234567990X0C3B0ABF3CF81DZ....
Content-Type: application/json
```

## Request Responses

### Successful Responses

Successful requests will return a HTTP status code of 200 and a response body containing a JSON object with the following properties:

* `data` - The response data

If the response contains an array of data, the response will also contain the following properties:

* `next` - The next page of results
* `prev` - The previous page of results
* `paged` - Set to true if the response is paged

### Errors

REST HTTP calls will return a HTTP status code of 200 for success, 403 for authentication errors, 400 for bad requests, and 500 for service errors. When a request is unsuccessful, the content type will be set to "text/plain" and the body will contain a text error message.

## Example

Here is an example to issue a request from the command line using `curl` or the Ioto **url** command using a **BuilderAPI** token:

::: code-group
```curl
curl -X POST https://api.admin-qa.embedthis.com/api/tok/user/get \
     -H 'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
     -H 'Content-Type: application/json' \
     -d '{"id": "ZXXXXXXXXX"}'
```
```url
url https://api.admin-qa.embedthis.com/api/tok/user/get \
    'Authorization: 1234567990XXXXXXXXXXXXXXXX' \
    '{id: "ZXXXXXXXXX"}'
```
:::

Note: the `url` command is a utility command that is installed with the Ioto CLI. It can automatically sense the arguments as either headers, or body data. JSON body data can be passed as JSON5 (like JS) and can thus omit quotes on property keys and setting the Content-Type header.

## Read More

* [API Authentication](authentication.md)

## Ioto APIs

Controller | Description
-|-
[Account](account.md) | Account API
[Action](action.md) | Action API
[Alert](alert.md) | Alert API
[Cloud](cloud.md) | Alert API
[Dashboard](dashboard.md) | Dashboard API
[Device](device.md) | Device API
[Issue](issue.md) | Product Issue API
[App/Manager](manager.md) | App/Manager API
[Metric](metric.md) | Metrics API
[Product](product.md) | Product API
[Software](software.md) | Software Update API
[Token](token.md) | Token Management API
[User](user.md) | User API

# Post

Support case post management.

## Create
Create a support ticket post.

**Endpoint**

```HTTP
POST /post/create
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Default | Notes |
| - | - | - | - | - |
| attachments | array |  |  | Attachments. |
| author | string |  |  | Author. |
| created | date |  |  | Created. |
| message | string |  |  | Message. |
| ticketId | string | yes |  | Ticket ID. |

**Response** 

Post Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| attachments | array | Attachments. |
| author | string | Post author. |
| created | date | Post creation date. |
| message | string | Post message. |
| id | string | Post ID. |
| ticketId | string | Owning ticket ID. |

## Download
Download a support ticket post attachment.

**Endpoint**

```HTTP
POST /post/download
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Post ID. |
| key | string | yes | Attachment key. |

**Response** 

A download URL.


## Find
Get a list of support ticket posts.

**Endpoint**

```HTTP
POST /post/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Post ID. |
| ticketId | string | Ticket ID. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Post records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Post** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| attachments | array | Attachments. |
| author | string | Post author. |
| created | date | Post creation date. |
| message | string | Post message. |
| id | string | Post ID. |
| ticketId | string | Owning ticket ID. |

## Get
Get a support ticket post by ID.

**Endpoint**

```HTTP
POST /post/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Post ID. |
| ticketId | string |  | Ticket ID. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Post Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| attachments | array | Attachments. |
| author | string | Post author. |
| created | date | Post creation date. |
| message | string | Post message. |
| id | string | Post ID. |
| ticketId | string | Owning ticket ID. |

# Ticket

Support case management.

## Create
**Endpoint**

```HTTP
POST /ticket/create
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required |
| - | - | - |
| created | date |  |
| cc | string |  |
| productId | string |  |
| subject | string | yes |
| severity | string | yes |
| status | string | yes |
| updated | date | yes |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| assigned | string |
| cc | string |
| created | date |
| hours | number |
| id | string |
| productId | string |
| subject | string |
| severity | string |
| status | string |
| updated | date |
| work | array |

**Work** 

| Field | Type |
| - | - |
| date | date |
| description | string |
| hours | number |


## Get
**Endpoint**

```HTTP
POST /ticket/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| owner | string |  |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| assigned | string |
| cc | string |
| created | date |
| hours | number |
| id | string |
| productId | string |
| subject | string |
| severity | string |
| status | string |
| updated | date |
| work | array |

**Work** 

| Field | Type |
| - | - |
| date | date |
| description | string |
| hours | number |


## Find
**Endpoint**

```HTTP
POST /ticket/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type |
| - | - |
| id | string |
| status | string |

**Query String Options** 

| Field | Type |
| - | - |
| filter | string |
| hidden | boolean |
| index | string |
| limit | number |
| log | boolean |
| next | object |
| prev | object |
| where | string |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Ticket records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Ticket** 

| Field | Type |
| - | - |
| accountId | string |
| assigned | string |
| cc | string |
| created | date |
| hours | number |
| id | string |
| productId | string |
| subject | string |
| severity | string |
| status | string |
| updated | date |
| work | array |

**Work** 

| Field | Type |
| - | - |
| date | date |
| description | string |
| hours | number |


## Update
**Endpoint**

```HTTP
POST /ticket/update
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required |
| - | - | - |
| cc | string |  |
| id | string | yes |
| productId | string |  |
| subject | string | yes |
| severity | string | yes |
| status | string | yes |
| updated | date | yes |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| assigned | string |
| cc | string |
| created | date |
| hours | number |
| id | string |
| productId | string |
| subject | string |
| severity | string |
| status | string |
| updated | date |
| work | array |

**Work** 

| Field | Type |
| - | - |
| date | date |
| description | string |
| hours | number |


# Plan

Subscription plan management.

## Create
**Endpoint**

```HTTP
POST /plan/create
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| agent | string | Agent. |
| align | boolean | Align. |
| end | date | End. |
| interest | array | Interest. |
| pending | boolean | Pending. |
| period | string | Period. |
| scope | string | Scope. |
| start | date | Start. |
| type | string | Type. |
| units | number | Units. |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| id | string |
| advance | boolean |
| agent | string |
| align | boolean |
| count | number |
| current | object |
| discount | number |
| end | date |
| fixed | boolean |
| interest | array |
| lastBilled | date |
| license | string |
| memo | string |
| nextReminder | date |
| notify | array |
| override | object |
| pending | boolean |
| period | string |
| prepay | boolean |
| purchases | array |
| start | date |
| scope | string |
| sliding | boolean |
| test | number |
| type | string |
| units | number |

**Current** 

| Field | Type |
| - | - |
| count | number |
| end | date |
| license | string |
| period | string |
| price | number |
| scope | string |
| start | date |
| units | number |
| upfront | number |


**Purchases** 

| Field | Type |
| - | - |
| date | date |
| units | number |
| expired | number |


## Get
**Endpoint**

```HTTP
POST /plan/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Plan ID. |
| type | string | Type. |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| id | string |
| advance | boolean |
| agent | string |
| align | boolean |
| count | number |
| current | object |
| discount | number |
| end | date |
| fixed | boolean |
| interest | array |
| lastBilled | date |
| license | string |
| memo | string |
| nextReminder | date |
| notify | array |
| override | object |
| pending | boolean |
| period | string |
| prepay | boolean |
| purchases | array |
| start | date |
| scope | string |
| sliding | boolean |
| test | number |
| type | string |
| units | number |

**Current** 

| Field | Type |
| - | - |
| count | number |
| end | date |
| license | string |
| period | string |
| price | number |
| scope | string |
| start | date |
| units | number |
| upfront | number |


**Purchases** 

| Field | Type |
| - | - |
| date | date |
| units | number |
| expired | number |


## Find
**Endpoint**

```HTTP
POST /plan/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| type | string | Type. |

**Query String Options** 

| Field | Type |
| - | - |
| filter | string |
| hidden | boolean |
| index | string |
| limit | number |
| log | boolean |
| next | object |
| prev | object |
| where | string |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Plan records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Plan** 

| Field | Type |
| - | - |
| accountId | string |
| id | string |
| advance | boolean |
| agent | string |
| align | boolean |
| count | number |
| current | object |
| discount | number |
| end | date |
| fixed | boolean |
| interest | array |
| lastBilled | date |
| license | string |
| memo | string |
| nextReminder | date |
| notify | array |
| override | object |
| pending | boolean |
| period | string |
| prepay | boolean |
| purchases | array |
| start | date |
| scope | string |
| sliding | boolean |
| test | number |
| type | string |
| units | number |

**Current** 

| Field | Type |
| - | - |
| count | number |
| end | date |
| license | string |
| period | string |
| price | number |
| scope | string |
| start | date |
| units | number |
| upfront | number |


**Purchases** 

| Field | Type |
| - | - |
| date | date |
| units | number |
| expired | number |


## Remove
**Endpoint**

```HTTP
POST /plan/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Plan ID. |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| id | string |
| advance | boolean |
| agent | string |
| align | boolean |
| count | number |
| current | object |
| discount | number |
| end | date |
| fixed | boolean |
| interest | array |
| lastBilled | date |
| license | string |
| memo | string |
| nextReminder | date |
| notify | array |
| override | object |
| pending | boolean |
| period | string |
| prepay | boolean |
| purchases | array |
| start | date |
| scope | string |
| sliding | boolean |
| test | number |
| type | string |
| units | number |

**Current** 

| Field | Type |
| - | - |
| count | number |
| end | date |
| license | string |
| period | string |
| price | number |
| scope | string |
| start | date |
| units | number |
| upfront | number |


**Purchases** 

| Field | Type |
| - | - |
| date | date |
| units | number |
| expired | number |


## Update
**Endpoint**

```HTTP
POST /plan/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| align | boolean | Align. |
| end | date | End. |
| id | string | Plan ID. |
| interest | array | Interest. |
| nextReminder | date | Next reminder. |
| pending | boolean | Pending. |
| prepay | boolean | Prepay. |
| period | string | Period. |
| scope | string | Scope. |
| start | date | Start. |
| type | string | Type. |
| units | number | Units. |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| id | string |
| advance | boolean |
| agent | string |
| align | boolean |
| count | number |
| current | object |
| discount | number |
| end | date |
| fixed | boolean |
| interest | array |
| lastBilled | date |
| license | string |
| memo | string |
| nextReminder | date |
| notify | array |
| override | object |
| pending | boolean |
| period | string |
| prepay | boolean |
| purchases | array |
| start | date |
| scope | string |
| sliding | boolean |
| test | number |
| type | string |
| units | number |

**Current** 

| Field | Type |
| - | - |
| count | number |
| end | date |
| license | string |
| period | string |
| price | number |
| scope | string |
| start | date |
| units | number |
| upfront | number |


**Purchases** 

| Field | Type |
| - | - |
| date | date |
| units | number |
| expired | number |


# User

User management.

## Find
Find matching users.

**Endpoint**

```HTTP
POST /user/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| email | string | admin | Email address. |
| id | string | admin | User ID. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of User records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**User** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | User activity date. |
| email | string | User email address. |
| first | string | User first name. |
| id | string | User ID. |
| invite | string | Invite code. |
| last | string | User last name. |
| preferences | object | User preferences. |
| role | string | User role. |
| state | string | User state. |

## Get
Get a user by ID.

**Endpoint**

```HTTP
POST /user/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| email | string | admin | Email address. |
| id | string | admin | User ID. |

**Response** 

User Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | User activity date. |
| email | string | User email address. |
| first | string | User first name. |
| id | string | User ID. |
| invite | string | Invite code. |
| last | string | User last name. |
| preferences | object | User preferences. |
| role | string | User role. |
| state | string | User state. |

## GetRoles
Get the roles for the authenticated user.

**Endpoint**

```HTTP
POST /user/getRoles
```

**Authorized User Role**

```
admin
```

**Response** 

Object Record.


## Login
Login the authenticated user.

**Endpoint**

```HTTP
POST /user/login
```

**Authorized User Role**

```
public
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| invite | string | Invite code. |
| register | boolean | Register. |
| social | boolean | Social login. |

**Response** 

A user object.

| Field | Type | Notes |
| - | - | - |
| account | object | Account object. |
| user | object | User object. |

## Remove
Remove a user.

**Endpoint**

```HTTP
POST /user/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| email | string | Email address. |
| id | string | User ID. |

## Update
Update a user.

**Endpoint**

```HTTP
POST /user/update
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| email | string | Email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Last name. |
| preferences | object | Preferences. |

**Response** 

User Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | User activity date. |
| email | string | User email address. |
| first | string | User first name. |
| id | string | User ID. |
| invite | string | Invite code. |
| last | string | User last name. |
| preferences | object | User preferences. |
| role | string | User role. |
| state | string | User state. |

## UpdateRole
Update a user role.

**Endpoint**

```HTTP
POST /user/updateRole
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string |  | User ID. |
| role | string | admin | Authorized role. |
| sendInvite | boolean |  | Send invite email. |

**Response** 

User Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date | User activity date. |
| email | string | User email address. |
| first | string | User first name. |
| id | string | User ID. |
| invite | string | Invite code. |
| last | string | User last name. |
| preferences | object | User preferences. |
| role | string | User role. |
| state | string | User state. |

# Action

Manage Actions.

## Create
Create an automated action.

**Endpoint**

```HTTP
POST /action/create
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| args | object |  | Action arguments. |
| buffer | object |  | Metric action buffering controls.<br>                            { sum: number, count: number, elapsed: number, force: boolean}<br>                             Where "sum" is the total of metric values, "count" is the number of triggered actions, "elapsed" it the time in seconds to buffer the metric and "force" will force a write of the buffer metric data, . |
| cloudId | string | yes | Cloud ID. |
| context | object |  | Action context. |
| description | string |  | Action description. |
| destination | string |  | Action destination. |
| enable | boolean |  | Action enable flag. |
| error | string |  | Action error. |
| expression | string |  | Action expression. |
| format | string |  | Action format. |
| message | string |  | Action message. |
| name | string | yes | Action name. |
| poll | number |  | Action polling interval. |
| rearm | number |  | Action rearming interval. |
| severity | string |  | Action severity. |
| trigger | string | yes | Action trigger. |
| type | string | yes | Action type. |

**Response** 

Action Record.

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string | Action description. |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean | Enable or disable the action. |
| error | string | Error message from last invocation. |
| expression | string | Trigger expression. |
| format | string | Message format. |
| id | string | Unique action ID. |
| name | string | Action name. |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string | Alert severity. |
| trigger | string | Source of action trigger. |
| type | string | Action type. |

## Find
Find actions by cloud ID and optional type.

**Endpoint**

```HTTP
POST /action/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| cloudId | string | yes | Cloud ID. |
| type | string |  | Action type. |

**Query String Options** 

| Field | Type | Default | Notes |
| - | - | - | - |
| index | string |  | Index name: primary or gs1. |
| limit | number |  | Limit number of results. |
| next | object |  | Token for next page. |
| prev | object |  | Token for previous page. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of matching actions. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string | Action description. |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean | Enable or disable the action. |
| error | string | Error message from last invocation. |
| expression | string | Trigger expression. |
| format | string | Message format. |
| id | string | Unique action ID. |
| name | string | Action name. |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string | Alert severity. |
| trigger | string | Source of action trigger. |
| type | string | Action type. |

## Get
Get an action by cloud ID and action ID.

**Endpoint**

```HTTP
POST /action/get
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Action ID. |
| cloudId | string | yes | Cloud ID. |
| type | string | yes | Action type. |

**Response** 

Action Record.

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string | Action description. |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean | Enable or disable the action. |
| error | string | Error message from last invocation. |
| expression | string | Trigger expression. |
| format | string | Message format. |
| id | string | Unique action ID. |
| name | string | Action name. |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string | Alert severity. |
| trigger | string | Source of action trigger. |
| type | string | Action type. |

## Remove
Remove an action by cloud ID and action ID.

**Endpoint**

```HTTP
POST /action/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Action ID. |
| cloudId | string | yes |  |

## Update
Update an action by cloud ID and action ID.

**Endpoint**

```HTTP
POST /action/update
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| args | object |  | Action arguments. |
| buffer | object |  | Action buffering controls. |
| cloudId | string | yes | Cloud ID. |
| context | object |  | Action context. |
| description | string |  | Action description. |
| destination | string |  | Action destination. |
| enable | boolean |  | Action enable flag. |
| error | string |  | Action error. |
| expression | string |  | Action expression. |
| format | string |  | Action format. |
| id | string | yes | Action ID. |
| message | string |  | Action message. |
| name | string |  | Action name. |
| poll | number |  | Action polling interval. |
| rearm | number |  | Action rearming interval. |
| severity | string |  | Action severity. |
| trigger | string |  | Action trigger. |
| type | string |  | Action type. |

**Response** 

Action Record.

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string | Action description. |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean | Enable or disable the action. |
| error | string | Error message from last invocation. |
| expression | string | Trigger expression. |
| format | string | Message format. |
| id | string | Unique action ID. |
| name | string | Action name. |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string | Alert severity. |
| trigger | string | Source of action trigger. |
| type | string | Action type. |

# Test

Create test data.

## Exception
**Endpoint**

```HTTP
POST /test/exception
```

**Authorized User Role**

```
public
```

**Response** 

None.

## Success
**Endpoint**

```HTTP
POST /test/success
```

**Authorized User Role**

```
public
```

**Response** 

None.

## Echo
**Endpoint**

```HTTP
POST /test/echo
```

**Authorized User Role**

```
public
```

**Request Body** 

| Field | Type |
| - | - |
| * | any |

**Response** 

None.

## Empty
**Endpoint**

```HTTP
POST /test/empty
```

**Authorized User Role**

```
public
```

**Request Body** 

| Field | Type |
| - | - |
| * | any |

**Response** 

None.

# Notification

Manage User Notifications.

## Find
**Endpoint**

```HTTP
POST /notification/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| type | string | Type. |

**Query String Options** 

| Field | Type |
| - | - |
| filter | string |
| hidden | boolean |
| index | string |
| limit | number |
| log | boolean |
| next | object |
| prev | object |
| where | string |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Notification records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Notification** 

| Field | Type |
| - | - |
| accountId | string |
| channel | string |
| data | string |
| destination | string |
| enable | boolean |
| format | string |
| headers | object |
| id | string |
| method | string |
| name | string |
| region | string |

## Get
**Endpoint**

```HTTP
POST /notification/get
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Notification ID. |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| channel | string |
| data | string |
| destination | string |
| enable | boolean |
| format | string |
| headers | object |
| id | string |
| method | string |
| name | string |
| region | string |

# Notice

Manage User Notice Bulletins.

# Device

The Device API manages device registation with the Builder.<br><br>When devices are first booted, they will "register" with the builder using their device ID (ClaimID). The device then remains under the management of the Builder until it is "claimed" by a user for management using the "claim" API.<br><br>    When claimed, the device is redirected to the device cloud when it next invokes the "register" API.

## Get
The Get API will fetch a device record by its ID (ClaimID).

**Endpoint**

```HTTP
POST /device/get
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device Claim ID. |

**Response** 

Device Record.

| Field | Type | Notes |
| - | - | - |
| id | string | Device ID. |
| accountId | string | Owning account ID. |
| managerAccountId | string | App account ID. |
| cloudId | string | Owning cloud ID. |
| productId | string | Owning product ID. |
| test | boolean | Device is a test device. |

## Find
Find matching devices.

**Endpoint**

```HTTP
POST /device/find
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Device Claim ID. |
| cloudId | string | Cloud ID. |
| productId | string | Product ID. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| limit | number |  |
| next | object |  |
| prev | object |  |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of Device records. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Device** 

| Field | Type | Notes |
| - | - | - |
| id | string | Device ID. |
| accountId | string | Owning account ID. |
| managerAccountId | string | App account ID. |
| cloudId | string | Owning cloud ID. |
| productId | string | Owning product ID. |
| test | boolean | Device is a test device. |

## Lookup
Lookup a productId.

**Endpoint**

```HTTP
POST /device/lookup
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| product | string | yes | Product claim token. |

**Response** 

Product Record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| description | string | Product description. |
| id | string | Product ID. |
| name | string | Product name. |
| planId | string | Owning plan ID. |
| suspended | boolean | Product suspended. |
| url | string | Product URL. |

## Register
Register a device when manufactured.<br><br>    When devices are first booted during manufacturing test, the Ioto device agent will "register" with the builder using its device ID (ClaimID). If the device has been claimed by a user, the API will return a response containing the API address of the managing device cloud and an access token. If the device has not been claimed, the "registered" field will be set to true in the response (alone).<br><br>    To register, supply the device claim ID and the product token ID. If the device is a test device only, set the "test" field to true<br>    so that the device will not count toward your Ioto agent subscription count.<br>    .

**Endpoint**

```HTTP
POST /device/register
```

**Authorized User Role**

```
public
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device Claim ID. |
| account | string |  | Manager Account ID if auto claiming. |
| cloud | string |  | Cloud ID if auto claiming. |
| product | string | yes | Product ID Token. |
| test | boolean |  | Set to true for test devices. |
| * | any |  |  |

**Response** 

Object Record.

| Field | Type | Notes |
| - | - | - |
| api | string | API endpoint for the device cloud that claimed the device. |
| token | string | Access token for requests to the device cloud. |
| registered | boolean | Set to true when registered. |
| cloudType | string | Type of cloud hosting. |
| cloudName | string | Cloud name. |
| cloudRegion | string | Cloud geographical region. |

## Release
Release a device from management by an app.

**Endpoint**

```HTTP
POST /device/release
```

**Authorized User Role**

```
user
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

## Remove
Remove a device from the builder.<br><br>    If the device has been claimed by a device cloud, it should be released before being removed.

**Endpoint**

```HTTP
POST /device/remove
```

**Authorized User Role**

```
admin
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

## RemoveAll
Remove all devices.

**Endpoint**

```HTTP
POST /device/removeAll
```

**Authorized User Role**

```
owner
```

**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| productId | string | yes | Product ID. |

**Response** 

Number Record.



![Ioto](/images/logos/ioto-reg.png)

# EmbedThis Ioto&reg;

>**The smallest, fastest, most capable device agent**

The Ioto agent is our newest embedded agent for device management. It includes a HTTP web server, AWS IoT cloud integration, embedded database, MQTT client, HTTP client, JSON parsing, easy provisioning and OTA upgrading.

Ioto is cloud ready  just bring your own AWS cloud account. Ioto provides data synchronization to AWS IoT core, rules, and shadows. It exports and synchronizes structured device data with AWS DynamoDB. It also captures logs into CloudWatch Logs, integrates with CloudWatch Metrics, and offers data and file upload to AWS S3.

## Stand-alone Device Management

If you only want an embedded web server, Ioto is easily configured to enable just the modules you need. You can configure Ioto to include only the web server, or just the MQTT protocol or full cloud management integration.

## Highly Optimized

Ioto is blazing fast and yet has a tiny memory footprint of only 200K of code. It is especially effective in reducing per-request CPU and memory overhead.

Ioto is optimized for embedded device management via an evolved, high performance management runtime that delivers exceptional throughput and effective memory utilization.

## Elegant Programming Model

Ioto eliminates the ugliness of event callbacks and the complexity of threads by using fiber coroutines.
This makes programming with Ioto simple and reliable and avoids difficult downstream debugging due to overly complex designs.

## Extensive Features

Ioto has a strong set of features and protocols, including: MQTT, HTTP/1, TLS/SSL, user authentication, embedded database, JSON parser and query engine, JSON config files, sandbox resource limits, flexible logging, request tracing, and extensive conditional configuration and compilation controls.

With these features, Ioto is designed to make remotely managing and controlling embedded devices painless.

It is ideal for Linux and FreeRTOS systems and is easily ported to other platforms. Ioto dramatically cuts the time, cost, and risk of creating manageability for devices.


## Deployed Widely

Ioto draws from our code base at Embedthis, where we have decades of experience in providing the most widely deployed embedded web servers. Our software has been deployed in hundreds of millions of devices in networking equipment, telephones, mobile devices, and consumer and office equipment worldwide.

## Applications

The Ioto Agent source distribution includes several sample management applications that are integrated with Ioto.

The management apps are browser-based [VueJS](https://vuejs.org/) apps that communicate with either the local Ioto web server or with the cloud-based Ioto service.

## Components

Ioto provides the following components:

* HTTP/1.1 server with dynamic rendering, authentication, cookies, sessions and file upload
* HTTP/1.1 client
* MQTT/3.1.1 client
* Embedded database
* JSON/5 parser and query engine
* Transport Layer Security (TLS/SSL) with ALPN support
* AWS IoT integration with IoT Core, Shadows, Events, and Rules.
* AWS service integration with S3, Lambda, Kinesis and CloudWatch
* Transparent database syncronization to AWS DynamoDB (like Global Tables)
* Safe, secure runtime core
* Easy provisioning
* OTA upgrading
* User authentication
* Complete documentation
* Extensive Samples
* Full Source code

# Embedthis Ioto&reg; Features

* HTTP/1.1 server with dynamic rendering, authentication, cookies, sessions and file upload.
* HTTP/1.1 client.
* MQTT/3.1.1 client.
* Embedded database (like local DynamoDB).
* Transparent DynamoDB database cloud synchronization.
* JSON/5 parser and query engine.
* AWS IoT integration with IoT Core, Shadows, Events and Rules.
* AWS service integration with S3, Lambda, Kinesis and CloudWatch.
* Transparent database synchronization with DynamoDB.
* Transport Layer Security (TLS/SSL) with ALPN support.
* Safe, secure runtime core.
* State persistence to JSON configuration files.
* Easy provisioning.
* OTA upgrading.
* Complete documentation.
* Extensive Samples.
* Full Source code.


## Feature Overview


### Management Applications

The Ioto Agent source distribution includes several sample management applications that are integrated with Ioto.

The management apps are browser-based [VueJS](https://vuejs.org/) apps that communicate with either the local Ioto web server or with the cloud-based Ioto service.

### AWS IoT Integration

* AWS IoT Ready &mdash; Bring your own cloud.
* Capture device data and export to AWS.
* Send control plane data to AWS IoT shadows.
* Transparent database synchronization with AWS DynamoDB.
* Stream bulk device data to AWS S3 data lake or Kinesis.
* Store device logs, metrics in AWS CloudWatch.
* Keep an audit trail in CloudTrail.


### MQTT Client

* MQTT 3.1.1 support.
* TLS encryption with ALPN over port 443.
* Supports connect, publish, subscribe, ping and disconnect messages.
* Message quality of service for reliable delivery.
* Retained messages.
* High message throughput with exceptionally low overhead.
* Wait for delivery or acknowledgement options.
* Auto reconnect.
* Parallelism via fiber coroutines.


## Embedded Database

* High performance in-memory NoSQL management document database (DynamoDB lite).
* Red/black binary search indexes.
* JSON documents with in-memory query API.
* Controllable persistence locally and to the cloud on a per-table basis.
* Transparent bidirectional data synchronization with the cloud. (like Global Tables).
* Unified data schema between device and cloud databases.
* Based on [DynamoDB OneTable](https://doc.onetable.io/) API.


### HTTP Server

* HTTP/1.0, HTTP/1.1 support.
* TLS/SSL 1.3 and ALPN support.
* URL actions that bind URLs to C functions.
* Configurable request routes and redirections.
* Supports transfer chunk encoding to preserve keep-alive.
* Cookie and session management.
* Authentication and user management.
* Request tracing for HTTP request and response headers.
* Sand-box resource limits.
* Runtime configurable via JSON config files.
* HTML helpers for encoding, decoding and escaping content.
* JSON parser and query engine.
* Single-threaded, fiber coroutine event-based runtime.


### Safe Runtime

* JSON parser and renderer.
* JSON query engine.
* Fiber coroutines for non-blocking procedural programming model.
* Global memory error handler.
* Logging framework  filter by source and/or message type.
* Safe strings, lists, hashing and buffer management.
* Portable, cross-platform O/S abstraction.


### Performance

* Tiny memory footprint. Web server component is 25K code. Total is 96K code.
* Single-threaded fiber coroutines provide an elegant, non-blocking, procedural programming paradigm without resorting to clumsy callbacks or complex threads.
* Web server request throughput (&gt; 9,300 requests per second on Raspberry Pi 4).


### Security

* Sandbox limits.
* Safe portable runtime to protect against memory leaks and buffer overflows.
* Transport Layer Security (TLS/SSL).



### Developer Integration

* Run supplied Ioto program or embed Ioto library.
* Shared and static libraries supported.
* Easy, intuitive programming model.
* Extensive C API.


### Documentation

* Full C API Documentation.
* Cookbook of samples (cut and paste to get going).
* Tutorials.


### Platform Support

* Linux 
* MAC OS X
* FreeBSD
* FreeRTOS (pending)
* RIOT (pending)


### Embedding Support

* Supports ARM, MIPS, X86, X64, PPC, SH, Sparc processors.
* Full cross-compilation support. Use Windows, Linux or Mac as build system.
* Fine-grained control for conditional build and compilation.


### Standards

* [MQTT 3.1.1](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html)
* [RFC 2616 HTTP/1.1](https://www.ietf.org/rfc/rfc2616.txt)
* [TLS 1.3](https://datatracker.ietf.org/doc/html/rfc8446)
* [RFC 1867 Multipart-mime upload](https://datatracker.ietf.org/doc/html/rfc1867)
* [OneTable Database Schema Specification](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md)
# Embedthis Appweb&trade; and GoAhead&trade;

Our Appweb and GoAhead web servers are provided for existing customers who have existing products incorporating these web servers.

!!! Ioto Device Agent
    All new device builders are encouraged to use the Ioto device agent &mdash; even if you only need an embedded web server.

    The Ioto agent includes our most advanced embedded web server. It is a fraction the size of comparable embedded web servers (including our own) and it boast impressive throughput and efficiency scores.

For more information, please consult:

* [Device Agents Compared](https://www.embedthis.com/ioto/comparison.html)
* [Appweb Web Site](https://www.embedthis.com/appweb/)
* [Appweb Documentation](https://www.embedthis.com/appweb/doc/)
* [GoAhead Web Site](https://www.embedthis.com/goahead/)
* [GoAhead Documentation](https://www.embedthis.com/goahead/doc/)
# Creating Products

The first step when creating connected devices with the **Builder** is to define the product (device) that you wish to manage. In this process:

* Specify the product name.
* Provide a description of the product.
* Select the device agent software you wish to embed in your product.
* Choose the scope of the license you wish to purchase.
* Enter email or phone numbers to use for important security alerts.

The Builder will pre-create product definitions for to evaluate Ioto and for the Builder and Device Cloud services. These definitions can be selected to display the relevant product security center information for the relevant service.

## Product Definitions

You can create product definitions for each device type that you wish to deploy and manage. The product definition describes your product, the device agent you wish to deploy, and its license scope.

![Product List](/images/builder/product-list.png){class="screen"}

A product definition includes:

* Product name
* Description
* Selected Device Agent
* License Plan
* License Type
* License Scope
* Email or phone for security alerts

![Product Add](/images/builder/product-add.png){class="screen"}

## Multiple Product Definitions

You can create one or more product definitions to best describe the (many) devices you offer.

If you are using the Ioto device agent, you should create a different product definition for each device type that will require different firmware. When you configure over-the-air software updates for your devices, it is helpful to be able to target different products with the appropriate firmware. When using OTA software upgrades, each product can have a unique firmware configuration. So you will want to configure a different Ioto product definition for each device that requires a different firmware image.

For Appweb and GoAhead based devices, you should create a product definition for each product described in your Embedthis license agreement. This may have already been created for you. If you require assistance, please contact [support@embedthis.com](mailto:support@embedthis.com).

## Product Name

The product name is a unique, one-line, descriptive name of your choosing.

## Product Description

This description is for your records and for licensing scopes. Please fully and uniquely describe your product. (Can be multiple sentences).

## Device Agent

When defining your product, you can select to embed one of three device agents:

* Ioto Device Agent
* GoAhead Web Server
* Appweb Web Server

We recommend choosing the Ioto cloud agent for all new devices, even if they are not connected to the cloud, as Ioto has the most efficient and secure embedded web server. Please read the [Web Server Comparison](https://www.embedthis.com/ioto/comparison.html) for details.

The Ioto agent includes our most advanced embedded web server. It is a fraction the size of comparable embedded web servers (including our own) and it boast impressive throughput and efficiency scores.

Our Appweb and GoAhead web servers are provided for existing customers who have embedded these web servers in existing product designs.

## License Plan

Next, you can select your desired product plan from the list:

* Evaluation
* Project Maker
* Commercial Device Builder

Free evaluations are offered for a limited time, commercial evaluation of the software. 

The Project Maker plan is for up for individual and non-commercial projects to utilize the device agent software for free for up to 10 devices. 

A Commercial Device Builder plan allows for the commerical deployment of any number of devices utilizing the software.

## License

If the Project Maker plan is selected, you can then select a commercial license or an open source GPLv2 license for the agent software. Note: The GPL License does not generally permit incorporating this software into non-open source programs. Use this license only for non-commercial, private or full open source firmware projects.

## License Scope

If you select the Commercial Device Builder for your plan, you next select a license scope from the list:

* By Device Volume
* Single Product
* Family of Products
* Business Line

The **By Device Volume** licence is based on the total installed base of devices that embed the device agent.

The **Single Product** license is limited to a single product and its direct product replacements. This license provides unlimited device unit volume. Multiple model numbers are permitted, provided the models vary only in branding, appearance, packaging or scale and not otherwise in functionality.

The **Product Family** license is limited to related products that share the same functional purpose and have the same public product family name.

The **Business Line** license permits multiple Product Families within a single business unit and single market segment.

These licenses are annual subscriptions and include software updates and upgrades through the year. 
While your license subscription is active, you can include the device agent software in your products. You may access and apply security updates and upgrades for new and existing devices.

For these license subscriptions, you are billed either yearly in advance.

## Ioto Products

When using a License Scope of "**By Device Volume**" you must enter the total number of installed devices using the software in the **Total Devices** field.  This is the cumulative number of devices that you have shipped to date using Ioto including those that you will manufacture during the billing period.

The Ioto service can automatically meter devices as they are manufactured. This involves the Ioto device agent sending a single registration request during creation to the Builder service. This is an automated process and it relieves you of the burden of counting and estimating device unit volumes. The current count of registered devices is displayed in the label for the **Total Devices** field.

Ioto is billed monthly at the end of the month based on the number of devices manufactured during the month. Ioto subscriptions are calculated on a sliding scale where the price decreases the more devices you deploy. The price is < $0.30 when making more than 1,000 devices per month.

You can evaluate Ioto without cost by using the Evaluation plan.

## Intended Purpose

You can help us to better understand your intended goals by selecting how you plan to utilize the agent. 

## Product Alert Recipients

You can enter one or more email addresses or phone numbers to be notified in the event of important security updates. When relevant releases or security updates are issued, you can be proactively notified by mail or phone so you can quickly take the appropriate action. 

Separate entries with commas and use fully qualified phone numbers with international dialing prefixes.

## Creating New Products

To configure a new product, select the **Add Product** button from the product list. This will display the slide out product panel.

![Product Add](/images/builder/product-add.png){class="screen"}

Enter a unique product name and accurate product description. Then select the relevant EmbedThis licensed product you wish to embed. Choose from:

* Ioto Cloud Agent
* GoAhead Web Server
* Appweb Web Server

Depending on the licensed product, you will have different subscription options.
# Product Security Center

Below the product list is the product security center that provides product news, relevant articles and product release and security issues.

The product list displays your configured products and also has entries for the Builder portal, Device Cloud and DevCore UI framework.

For each product entry, a list of product issues and events is displayed below the news and information cards.

![Product List](/images/builder/product-list.png){class="screen"}

## Product News and Articles

Recent news items will be displayed with links to the relevant documentation or Blog articles.
For all the news, go to the [Embedthis Blog](https://www.embedthis.com/blog/).

Helpful articles will be listed in the **Learn About** card.

### Product Issues and Events

The product issue list documents product bugs, features, releases and security issues. 

The issue list displays the following table columns:

Field|Description
-|-
Opened | When the issue entry was opened and documented
Type | Type of issue: Bug, Discussion, Feature, or Release 
Title | Issue subject title
Impacted | Versions impacted by the issue
Priority | [CVSS](https://www.balbix.com/insights/understanding-cvss-scores/) priority rating
Action | Recommended action
Status | Issue status: Open, Closed or Fixed
Tags | Categorization tags

Click on an issue to display the Issue panel

## View an Issue

![Product Issue](/images/builder/issue-edit.png){class="screen"}

The issue panel displays the following issue fields:

|Field|Description|
-|-
Type | Type of issue: Bug, Discussion, Feature, or Release 
Date | When the issue entry was opened and documented
Title | Issue subject title
Description | Full issue description and discussion
Subject | The product that is the subject of the issue
Impacted | Versions impacted by the issue
Status | Issue status: Open, Closed or Fixed
Resolved | Release the issue is corrected and resolved
Priority | [CVSS](https://www.balbix.com/insights/understanding-cvss-scores/) priority rating
CVE | Assigned [CVE](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures) if any
Action | Recommended action
Tags | Categorization tags

## Reporting an Issue

If you have an issue or bug to report, use the Builder Support Case tool to report the issue.

With an active support plan, you can use the integrated Builder support center to open support cases and track them to conclusion.

![Support Cases](/images/builder/support-case.png){class="screen"}

When opening a support case, you supply:

* A short case issue subject
* A detailed issue description
* The relevant product experiencing the issue
* Attach relevant files or logs
* The issue severity
* A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and complete description of what the issue is. Please explain in sufficient detail. Most people are too brief in the description and it results in delays addressing issues as support staff go back and forth with questions. Please spend some time writing a complete description.

If you can, please include a link to a gist or repository containing a test case or sample that reproduces your issue. Reproductions should be short, correct, self-contained and should not contain code that isn't relevant to the issue. Please do NOT just paste code from your project. Explaining how to reproduce the issue alone is typically insufficient.

### Issue Severity

You can set the issue severity which helps EmbedThis staff understand the impact of your issue. Set to low, medium, high or critical. Please do not overstate the issue severity. NOTE: the severity does not equate to a priority with which your issue will be addressed.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.
# Downloading the Device Agent

You can download the latest version of the device agent software from the [Builder Product List](https://admin.embedthis.com/product) via the download link.

EmbedThis continually updates the service and regularly publishes upgrades and security updates for the device agent software.

![Product List](/images/builder/product-list.png){class="screen"}


## Evaluation Use

If your product is based on Ioto, you can download the software to evaluate the service on one device. When you are ready, you can create your own device cloud and connect and manage more devices. This requires adding a billing card and purchase.

If your product is based on Appweb or GoAhead, you can download the limited evaluation software for free. This evaluation software can be used on any number of devices. When you are ready to use the full release software, you will need to add a billing card and purchase.

## Downloaded Image

The downloaded device agent is in Gzipped Tar format and includes everything you need to build the software from source.

![Product List](/images/builder/download.png){class="screen"}

Consult the relevant agent documentation for details.

* [Ioto Agent Documentation](/agent/)
* [Appweb Documentation](https://www.embedthis.com/appweb/doc/)
* [GoAhead Documentation](https://www.embedthis.com/goahead/doc/)

## License Terms

Please read the [EmbedThis License Terms](https://www.embedthis.com/about/terms.html).
# Licenses

The EmbedThis Ioto cloud management service is provided under the [EmbedThis Terms of Service](https://www.embedthis.com/about/terms.html).

EmbedThis distributes device agent software under three licenses. You can choose which license you wish to use depending on your other licensing terms.

* [Embedthis Commercial License](https://www.embedthis.com/about/terms.html)
* [Embedthis Evaluation License](eval.md)
* [GPL License](http://www.gnu.org/licenses/gpl-2.0.html)

### Commercial License Overview

The [Commercial License](https://www.embedthis.com/about/terms.html) provides businesses with the flexibility and rights needed to integrate the software into proprietary products and services. Key features of the commercial license include:

- **Right to Create Integrated Products**: The license allows users to compile, modify, and use the device agent software to create Integrated Products and keep their source code private and confidential. 

- **Distribution Rights**: Businesses can distribute, market, and sell Integrated Products, including the ability to provide cloud-based remote access to those products.

- **Support for Contract Manufacturers**: The license permits distributing the agent software in source code form to contract manufacturers.

- **Service Integration**: Users can interact with the EmbedThis cloud-based management service to manage their devices.

- **Developer Support**: Access to dedicated support services for assistance in designing and implementing Integrated Products.

Please read the full [Embedthis Commercial License](https://www.embedthis.com/about/terms.html).

### Eval License Overview

The [EmbedThis Eval License](eval.md) is for short term commercial evaluations. 

### Open Source License Overview

EmbedThis also provides its device agent software, including Ioto, Appweb, and GoAhead, under an alternate GPLv2 license. The GPLv2 license is particularly suitable for individual maker projects and some commercial evaluations. 

However, it is important to note that the GPL license has strict requirements regarding its use. If you use the GPLv2 license, you are still required to abide by the general [EmbedThis Terms of Service](https://www.embedthis.com/about/terms.html).

The [GNU General Public License](http://www.gnu.org/licenses/gpl-2.0.html#SEC1)is a widely recognized open-source license that ensures users have the freedom to run, study, share, and modify software. Key provisions of the GPLv2 license include:

- **Open Source Requirement**: Software distributed under the GPL license must remain open source. This means that any derivative works or modifications to the software must also be released under the GPL license if distributed.
- **Non-Compatible with Proprietary Software**: GPL-licensed software cannot be incorporated into proprietary software unless the entire project is released under the GPL.
- **Obligation to Share Modifications**: If you modify GPL-licensed software and distribute those modifications, you must make the modified source code publicly available and accessible to all others under the same license.
- **Compliance**: By utilizing the GPL-licensed software, you are legally bound to fully comply with all its terms. Failure to do so may result in a violation of the license agreement.


### Choosing the Right License

You can choose the commercial license or the open source GPL license depending on your individual or business needs.

- **Commercial License**: For businesses requiring the flexibility to incorporate EmbedThis software into proprietary or closed-source applications, the commercial license is the best choice. This option provides professional support, customization, and the ability to integrate with non-open source programs.

- **GPL License**: Ideal for open-source enthusiasts, makers, or those evaluating the software for non-commercial purposes. The GPL License does not generally permit incorporating the agent software into non-open source programs.

Your use of the software or access to the cloud service constitutes acceptance of the relevant license terms. 

# Volume-Based Device Agent Pricing

The volume-based subscriptions licenses you to embed the device agent for the total installed base of your devices. It provides the right to update and apply security patches to your existing devices while your subscription is active.

The reason we use an installed-base model is that it provides ongoing maintenance and support for all the installed devices -- even if you don't make any new devices.

The volume-based subscriptions are billed yearly in advance and offer a lower-cost of entry for smaller device volumes.

See also details about the [Royalty Free Agent Pricing](royalty-free.md).

## Free Evaluation

Your first device is free and you can evaluate device agents for free by using the evaluation agent downloads. The eval software is a recent release, but does not include the latest patches and features. The eval license includes the ability to embed the agent in one device.

## Device Volume

The volume-based subscription fee is based on the total installed base of devices that embed the device agent (not the number of devices made per year). The price is calculated via a sliding scale where the per-device price decreases with increased volume. The more you build, the lower the subscription per device.

You enter and maintain the total installed base of devices for your subscription via the Builder site on the Product page. 

## Volume Price Brackets

The following price table shows the device subscription price brackets at increasing volume levels. The first device is free.

The price column shows the subscription per-device price once that number of manufactured devices been reached. Subscription prices are per year.

Volume|Price
-:|-:
1-10 | Free
11-100 | $8.80
101-1,000 | $2.20
1,001-10,000 | $.55
10,001-100,000 | $.14
100,001+ | $.05

## Billing Period

The volume-based subscriptions are billed yearly in advance.

## Discontinuing the Subscription

If you discontinue your agent subscription, you need to cease shipping new products that include the device agent. You can continue to use existing devices that contain the device agent or the Ioto cloud service. You won't be abel to download security updates or maintenance updates. An active subscription is required to download or apply new software updates or security patches.

## Pricing Example

For example: If you have 1001 devices manufactured, the calculation would be as follows:

* Devices 1 to 10 -- free
* Devices 11 to 100 -- $8.80 each
* Devices 101 to 1,000 - $2.20 each
* Device 1,001 -- $0.55

So the annual device subscription would be: $8.80 x 90 + $2.20 x 900 + $0.55 * 1

Annual Total: $2,772.55

The monthly subscription would then be: ~$231

See the price calculator at the [Price Calculator](https://www.embedthis.com/pricing.html)# Embedthis Software Evaluation License

This is a License Agreement between Embedthis Software LLC. ("Embedthis") and you ("You"), the Licensee.

PLEASE READ THESE TERMS AND CONDITIONS CAREFULLY BEFORE INSTALLING OR USING THE SOFTWARE. YOUR USE OF THE SOFTWARE INDICATES YOUR FULL ACCEPTANCE AND YOU ARE AGREEING TO BE BOUND BY ALL THE TERMS AND CONDITIONS IN THIS AGREEMENT. FAILURE TO COMPLY WITH THE TERMS OF THIS AGREEMENT VOIDS THE AGREEMENT, DISALLOWS LICENSEE USE OF THE SOFTWARE AND MAY GIVE RISE TO UNSPECIFIED DAMAGES.

### Definitions

**"Integrated Product"** means a single product that incorporate(s) the Software in binary form only, together with other hardware or software of significant value-add.

**"Software"** means the Embedthis Ioto agent software including source code, headers, documentation and data files.

### 1\. License to Use

1.1. You are hereby granted a limited, non-exclusive, non-transferable right to use, compile and modify the evaluation version of the Software for non-commercial purposes when creating Integrated Products.

1.2. You are prohibited from distributing, selling, renting or providing remote access to Integrated Products containing any portion of the Software. You acknowledge that a separate Embedthis license is required for further development after this Agreement has terminated or for the distribution and selling Integrated Products.

### 2\. Copyright and Ownership

2.1. The Software is owned by Embedthis and is protected by international copyright, trademark and any other applicable laws. You must comply with the terms of the copyright notice in the Software and must never remove any notice or product identification from the Software or the accompanying documentation. You acknowledge that the copyright, patent, trade secret and all other intellectual property rights in the Software shall remain the exclusive property of Embedthis. You also acknowledge that Embedthis owns the Embedthis, Appweb, Ioto and Embedthis GoAhead trademarks and logos.

### 3\. Warranties and Limitations

3.1. Embedthis DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, RELATED TO THE Software, ITS USE OR ANY INABILITY TO USE IT, THE RESULTS OF ITS USE AND THIS Agreement. The Software and any accompanying written materials are supplied "AS IS", without warranty of any kind. Embedthis does not warrant, guarantee or make any representations regarding the use of or the results of the use of the Software or as to its correctness, accuracy, reliability, currentness or otherwise. You assume the entire risk as to the results and performance of the Software.

### 4\. Notices

4.1. Embedthis may, at its sole discretion, terminate this Agreement at any time without notice.

### 5\. Applicable Law

5.1. This Agreement will be governed by the laws of the State of Washington, USA and the parties submit to the non-exclusive jurisdiction of the courts of that state.

Last revised Dec 20, 2024.# Billing

The billing center page displays your billing cards and issued invoices and page will be enabled if you are an "owner" of the Builder account. You become an owner by having a member role set to "owner".

![Billing](/images/builder/billing.png){class="screen"}

## Payment Cards

Your billing cards will be displayed and the current card will be shown as the default card to use for payment. Click "Add Card" to enter a new card. Click on an existing card to modify, delete or designate a card as the default card to use for billing.

For your security, only the last 4 digits of the card number are stored for verification purposes.

## Invoices

As you are billed, invoices are created and stored. You will be emailed the invoice PDF and you can download invoiced from the invoice table.

## Invoice Address

To change the company name or billing address on your invoices, click on the **Invoice Address** button and enter the required details.

## Reissue Invoice

If you change the invoice address, you can click **Reissue** to re-generate the invoice with the updated invoice address.
# Support Plans

The EmbedThis Builder Support Center is the place for you to can tailor your support plan and open support issue tickets and track them to resolution.

EmbedThis offers two types of support:

* Basic Support
* Developer Support

## Basic Support

Basic support provides guidance covering installation and operational usage of the product.

The basic support subscription can be paid monthly or yearly in advance.

Basic support is $720 USD per year and is a 10% discount over the monthly price of $67 per month. Basic support is required if you utilize Developer support.

## Developer Support

Developer support assists with design and implementation challenges, encompassing embedded development, cloud-based device management, coding, debugging, and support for legacy software versions.

The service is priced at $250 USD per hour with a mandatory minimum of two hours. Activation of basic support is a prerequisite. Payments for developer support must be made in advance.

Your purchased support hours are consumed by EmbedThis staff as they tackle issues you submit via the Builder support portal. These hours cover activities such as identifying, diagnosing, and debugging problems, as well as providing guidance and collaborative efforts to resolve your issues. The time spent by EmbedThis support staff is meticulously tracked and deducted from your developer support balance.

Given that the EmbedThis device agent software is embedded and tailored within customer devices, support hours are spent regardless of the root cause of the issueeven if it stems from a bug in the device agent software.

## Support Cases

With an active support plan, you can use the integrated Builder support portal to open support cases and track them to conclusion.

![Support Cases](/images/builder/case.png){class="screen"}

When opening a support case, you supply:

* A short case issue subject
* A detailed issue description
* The relevant product experiencing the issue
* Attach relevant files or logs
* The issue severity
* A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and complete description of what the issue is. Please explain in sufficient detail. Most people are too brief in the description and it results in delays addressing issues as support staff go back and forth with questions. Please spend some time writing a complete description.

If you can, please include a link to a gist or repository containing a test case or sample that reproduces your issue. Reproductions should be short, correct, self-contained and should not contain code that isn't relevant to the issue. Please do NOT just paste code from your project. Explaining how to reproduce the issue alone is typically insufficient.

### Issue Severity

You can set the issue severity which helps EmbedThis staff understand the impact of your issue. Set to low, medium, high or critical. Please do not overstate the issue severity. NOTE: the severity does not equate to a priority with which your issue will be addressed.
center

### Upload Attachments

You can upload log files, screen shots or other assets that can assist EmbedThis to understand and diagnose your support issues. Each asset must be less than 10 MB in size.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.

## Close Case

When an issue is closed to your satisfaction, click the close case button.
# Device Cloud Pricing

Device Cloud pricing is a subscription fee for connecting a device to a device cloud. 

Subscriptions are based on the total number of devices that connect to the device cloud and you only pay for the devices that actually connect to the cloud. The permits you or your users to decide on a per-device basis whether cloud-based management is required.

Billing is performed either monthly or per year. For the first billing period, the price will be calculated pro rata.

Dedicated device clouds have a base fee in addition to the per-device fee. See below.

The device cloud subscription is in addition to the [Device Agent Pricing](index.md).

## Free Ioto Evaluation

Your first device is free, so you can evaluate Ioto without charge.  This includes the ability to embed Ioto in one device, create and connect to a device cloud and create a device app from which you can manage your device.

You can also test Ioto for free using the pre-created Eval cloud. 

## Volume Scale

Device clouds have a per-device subscription fee. This is calculated according to a sliding scale where the per-device price decreases with increasing numbers of devices connecting to the cloud. The first device is free.

The following price table shows the device subscription price brackets at increasing device volume levels.

The indicated price is the subscription price is the price per device per year once that volume level has been reached for the month.

Volume|Price
-:|-:
1-10 | Free
11-100 | $8.80
101-1,000 | $2.20
1,001-10,000 | $.55
10,001-100,000 | $.14
100,001+ | $.05

## Dedicated Clouds

Dedicated device clouds run the device cloud in your own AWS account. 
Dedicate clouds offer the ultimate in security and control and provide a suite of additional AWS services and customization together with the highest tier support.

If you expect to create more than 1,000 devices over the lifetime of your product, you should use a dedicated device cloud for your production deployment as hosted device clouds are limited to 1,000 devices.

Dedicated clouds have a flat $1,000/month fee in addition to the per-device fee.

## Pricing Example

For example: If you have 1001 devices connecting to the cloud in a month, the calculation for a hosted cloud would be as follows:

* Devices 1 to 10 -- free
* Devices 11 to 100 -- $8.80 each
* Devices 101 to 1000 - $2.20 each
* Device 1001 -- $0.55

So the annual cloud subscription would be: $8.80 x 90 + $2.20 x 900 + $0.29 * 1

Annual Total: $2,772.29

The monthly subscription would then be: ~$231

See the price calculator at:

[Price Calculator](https://www.embedthis.com/pricing.html)# Device Cloud Data Limits

Based on your Device Cloud plan, Ioto sets data limits to safeguard you, your customers, and the service.

If a device or multiple devices exceed these limits, Ioto ensures protection by throttling the incoming data from the devices responsible.

## Data Traffic

The amount of data you send to the device cloud is measured as the average number of KBytes transferred per device per hour. This traffic is then compared with the limit for your device cloud.

As you connect more devices, your data limit scales automatically with the number of devices connecting to the cloud. What is measured is the average data traffic over your entire pool of connecting devices. For example, if you have 100 devices and a limit of 60 messages per device per hour, this means that your pool of devices can send up to 6,000 messages to the device cloud per hour. 

Ioto supports short-term burst traffic above the limit, but if your sustained, aggregate traffic exceeds your limit, the offending devices will have their sending rate throttled. Which means their sending rate will be reduced until the aggregate traffic is below the limit.

## Throttling

When devices in a cloud cloud exceed the data limit, the offending devices will receive a throttle message and the device's Ioto agent will automatically slow down the rate of sending to the cloud. 

Upon receiving a throttle message, Ioto will implement an exponential backoff strategy and will slow down the rate of sending. Messages can still be received and Ioto will be fully functional. However, the rate of sending will be reduced until the throttled condition is alleviated. This protects your account and your customer's quality of service. It also protects you against rogue devices that have been compromised.

Ioto measures your device traffic rate every 30 seconds and will throttle a device that is exceeding 4 times your traffic limit over a 1 minute period. If your traffic load over the prior 5 minutes is light (< 50% of your limit) a device can burst up to 8 times the limit.

If the burst limit is exceeded for the past minute, the device will be throttled.

If a device continues to exceed the limit for a device cloud, the device will be disconnected (released) from the device cloud and its communication certificates will be revoked. The device will then need to be reclaimed to join the device cloud.

## Data Limits

The data limits vary depending your your device cloud type. 

For Hosted device clouds and the Evaluation device cloud, data limits ensure the cloud infrastructure is not monopolized by any device, set of devices or users.

The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It has higher limits, as it is typically used with few devices and consequently lower aggregate device pool limits.

For a Dedicated cloud, you are the sole user of the cloud running in your own AWS account. In this case limits are advisory and can be increased if required.

For hosted clouds, you can purchase increased data limits. If you require this, please contact sales@embedthis.com.

### Cloud Limits

Device Cloud| Limit
-:|:-
Eval Cloud | 60 messages (1K) per device per hour
Hosted Cloud | 1 message (1K) per device per hour
Dedicated Cloud | 1K message per device per hour

## Terms

Please see the [Terms of Use](https://www.embedthis.com/about/terms.html) for acceptable use terms.
# EmbedThis Builder Plans

EmbedThis provides subscription plans for device agents, cloud-based management services and support and services.

* **[Maker Projects](#maker-project-subscriptions)**
* **[Royalty-free Device Agents](#royalty-free-subscriptions)**
* **[Volume-based Device Agents](#volume-based-device-agents)**
* **[Cloud-based Management](#cloud-based-management)**

Device Agent subscription plans provide the agent source code, license to embed, documentation, samples and ongoing upgrades and security updates.

## Maker Project Subscriptions

For individual device makers, builders and commercial evaluations we offer a free subscription for up to 10 devices. This includes the ability to embed the Ioto agent in your device and create device clouds to manage your devices. This subscription is ideal for individual project maketers or commercial evaluations to easily prototype a device management solution with Ioto.

## Royalty-free Device Agents

Royalty-free subscriptions offer an annual renewable license to embed the device agent in new devices and to update existing devices.

Royalty-free subscriptions are based on a license scope that defines the scale and number of products that utilize the device agent software. The supported scopes allow unlimited device volume shipments within that scope.

The **Single Product** scope is limited to a single product model and its direct successor product replacements with unlimited device unit volume. Multiple model numbers are permitted, provided the models vary only in branding, appearance, packaging or scale and **not otherwise in functionality**.

The **Product Family** scope is limited to related Single Products that share the same functional purpose and have the same public product family name.

The **Business Line** scope permits multiple Product Families within a single business unit and single market segment.

The royalty-free subscriptions are paid yearly in advance.

For more details, please see: [Royalty-free Pricing](royalty-free.md).

## Volume-Based Device Agents

The volume-based subscriptions calculate a fee based on the total number of devices that have been manufactured. i.e. on your total installed base of devices and not the number of devices made per year. The fee is calculated on a sliding scale where the per-device price decreases the more devices you create. The incremental price for each device after 1,000 devices is $0.55 per device and after 10,000 devices is $0.14 per device.

The reason we use an installed-base model is that it provides ongoing maintenance and support for all the installed devices -- even if you don't make any new devices.

The volume-based subscriptions offer a lower-cost of entry for smaller device volumes than the scope based licenses. The volume-based subscriptions are billed yearly in advance. 

For more details, see: [Volume-Based Pricing](volume.md).

## Cloud-Based Management

If using cloud-based management, the subscription plans are based on two components:

* Ioto Device agent subscription (either volume-based or royalty-free)
* Cloud management subscription

The cloud management subscription is a per-connecting device fee. It is based on the number of devices that connect to the cloud for management and is paid monthly in arrears. You only pay for the devices that actually use the cloud-management service.

Cloud subscriptions are calculated on a sliding scale where the price decreases the more devices you connect and manage. The price is < $0.20 with more than 1,000 devices connecting each month.

For more details, see: [Cloud Pricing](cloud.md).

## Upgrading and Downgrading

If you are downgrading or upgrading a device agent from one plan to another, where possible, the Builder will credit the existing plan toward the cost of a new plan. 

## Support Plans

Embedthis offers two levels of support:

* Basic Support
* Developer Support

Support programs are paid for immediately upon enabling the program.

### Basic support

Basic support provides advice and guidance covering basic usage of the service and the device agent that does not require engineering support. Basic support is $775 USD per year or $71 per month.

### Developer Support

Developer support provides support for design and implementation issues that require engineering support staff. This covers embedded development, cloud-based device management, developer coding and debugging issues with the software including support for legacy software versions.

Developer support is priced at $275 USD per hour. Developer support requires a minimum of two hours and that basic support be also enabled.

## Terms

Please see the [Terms of Use](https://www.embedthis.com/about/terms.html) for terms.
# Royalty Free Device Agent Pricing

Royalty-free subscriptions offer an annual renewable license to embed the device agent in new devices without a device volume limit. It also provides the right to update and apply security patches to all your existing devices while your subscription is active.

## License Scopes

Royalty free subscriptions are based on a license scope:

* Evaluation
* Single Product
* Family of Products
* Business Line

The **Evaluation** scope provides a limited version of the software for you to complete your evaluation. This software is not suitable for production and will not contain the latest upgrades and security fixes. But is it ideal for evaluating Embedthis device agents.

The **Single Product** license is limited to a single product model and its direct successor product replacements with unlimited device unit volume. Multiple model numbers are permitted, provided the models vary only in branding, appearance, packaging or scale and **not otherwise in functionality**.

The **Product Family** license is limited to related products that share the same functional purpose and have the same public product family name.

The **Business Line** license permits multiple Product Families within a single business unit and single market segment.

## Pricing

The following price table shows the annual subscription price for each license scope. This price includes the right to embed the software, ship products that include the software and apply any software upgrades and security updates to new or existing licensed products.

Volume|Price
-:|-:
Product | $7,280
Family | $12,095
Business Line | $34,995

## Billing Period

The royalty free subscriptions are billed yearly in advance.

If you discontinue your subscription, you need to cease using the software or shipping new products that include the software.

## Legacy Agreement Licenses

If you have an existing agreement license, your yearly subscription will be for annual Maintenance that provides for upgrades and security updates.
# Managing Subscriptions

The Builder Account / Subscription page displays your current and pending subscriptions including your products, clouds and support plans and will be enabled if you are an "owner" of the Admin account. You become an owner by having an account membership role of "owner".

![Subscription](/images/builder/subscription.png){class="screen"}

The subscription page displays two panels:

* Active Subscriptions
* Cart Purchases

## Current Subscriptions

This Active subscriptions panel displays your existing subscriptions that are active.

## Cart Purchases

The Cart panel shows the pending subscriptions that require your approval and purchase before billing and activation.

## Subscription Panels

Each panel displays a table of your products, support programs and device clouds.

The Active Subscriptions table includes columns for the following items:

* Date &mdash; When the subscription is due.
* Type &mdash; The type of the subscription.
* Description &mdash; Details about the subscription.
* Quantity &mdash; The number of devices, clouds or support hours.
* Period &mdash; The activation period for the subscription.
* Status &mdash; If the subscription is active or expired.

## Approval

Subscriptions must be approved by you before purchase.  Once approved, subscriptions will automatically renew until you cancel them (except Developer support hours). If you are on a legacy Agreement plan, you may need to approve renewals each year.

Note that some subscriptions are billed in arrears, whereas others are paid upfront.

## Cart Actions

Once you select one or more cart items, you can choose one of the Action buttons:

* Add Card &mdash; click to define an online card for billing.
* Purchase &mdash; approve and immediately purchase the selected items.
* Download Quote &mdash; if you are setup for invoicing, you can download a quote for the selected items.
* Remove Items &mdash; remove the subscription for the selected items. This does not impact current (active) subscriptions.
* Order Details &mdash; enter your order details including a purchase order.

You can click the **Purchase** button to immediately purchase the selected items.

If you are authorized to pay via Bank Transfer, you can click on the **Download Quote** button to generate a PDF quotation for the selected items. To define your Invoice company name, billing address and purchase order number, click on the **Order Details** button. You can also enter an email address and email subject that will be used to email the Invoice to a destination of your choice. Once a purchase order number is entered, you can click on **Purchase** to complete your purchase.
# Glossary of Terms

Here is a list of terms used by the Device Build documentation

Term | Description | Link
-|-|-
AWS IAM Device Role | IAM role used by the Device Cloud when creating IAM keys for use inside the device. | [/builder/clouds/creating.html#device-keys-iam-role](https://www.embedthis.com/doc/builder/clouds/creating.html#iam-role)
AWS IAM Role | An AWS IAM identity that enable specific permissions for the owner. | [/builder/clouds/creating.html#device-keys-iam-role](https://www.embedthis.com/doc/builder/clouds/creating.html#device-keys-iam-role)
Builder | The EmbedThis Device Builder Site. | https://admin.embedthis.com/
Claim Device | When an end-user purchases a device and claims it for them to manage. | [/ioto/provisioning/claiming/](https://www.embedthis.com/doc/ioto/provisioning/claiming.html)
Device Agent | The embedded agent providing device management services. | [https://admin.embedthis.com/products/](https://admin.embedthis.com/products/)
Device Cloud | A management hub from which to centrally operate and manage a set of devices | [/builder/products/](https://www.embedthis.com/doc/builder/products/)
Device Provisioning | The process of providing devices with X.509 certificates and credentials to securely connect with cloud-based services. | [/ioto/provisioning/](https://www.embedthis.com/doc/ioto/provisioning/)
Device Tables | Ioto Device Tables is a global, replicated database that transparently synchronizes data between devices and the cloud. | [/ioto/database/](https://www.embedthis.com/doc/ioto/database/)
IoT Policy | An AWS IoT policy used to configure the permissions granted to incoming MQTT messages from the device. | [/builder/clouds/creating.html#iot-policy](https://www.embedthis.com/doc/builder/clouds/creating.html#iot-policy)
Ioto Service | The cloud-side AWS application providing the EmbedThis Ioto cloud-based management service. | [/ioto/](https://www.embedthis.com/doc/ioto/)
MQTT | A lightweight, publish/subscribe messaging protocol primarily used by IoT. | https://en.wikipedia.org/wiki/MQTT
Register Device | The process of connecting the device to the Builder during manufacturing, creating a record that the device was produced. | [/ioto/provisioning/registration/](https://www.embedthis.com/doc/ioto/provisioning/registration.html)
Standard Device App | A browser-based device management application. | [/apps/samples/standard/](https://www.embedthis.com/doc/apps/samples/standard/)
X.509 Certificate | A public key certificate used by TLS to verify the identity of a provider and to use as the basis for encrypted communications. | https://en.wikipedia.org/wiki/X.509
# What is EmbedThis<sup>&reg;</sup> Ioto?

At EmbedThis, we're on a mission to dramatically simplify device connectivity and management, enabling makers and equipment builders to swiftly develop exceptional products that are easy to manage and accessible from anywhere.

[EmbedThis Ioto](https://www.embedthis.com/ioto/) (pronounced "eye-oh-toe") is a comprehensive, end-to-end [IoT Meta-Platform](https://www.embedthis.com/blog/iot/what-is-an-iot-meta-platform.html) for managing devices, whether via the cloud or directly on the device. Ioto is a complete solution and not just a set of building blocks. Ioto includes a device builder portal, on-device agent, cloud-based device management, and a low-code app designer. It provides all the necessary tools to rapidly create, configure, and deploy secure IoT environments and applications.

## What is a Meta-Platform?

![What is a Meta Platform](/images/blog/t-what-is-an-iot-meta-platform.avif){class="screen width-50 left"} 

Instead of introducing another [IoT platform](https://www.embedthis.com/blog/iot/what-is-an-iot-platform.html), we have focused on delivering a complete solution that fully leverages and extends the existing and leading [AWS IoT platform](https://aws.amazon.com/iot-core/). 

An [IoT Meta-Platform](https://www.embedthis.com/blog/iot/what-is-an-iot-meta-platform.html) is a software layer that extends a foundational IoT platform to deliver a complete, end-to-end IoT solution. It adds missing services such as device cloud creation, streamlined provisioning, data modeling, automation workflows, and low-code builders for rapidly developing IoT device apps.

The AWS IoT platform offers a robust set of building blocks that include device provisioning, connectivity, messaging, data routing and storage. **Ioto** builds upon these AWS IoT capabilities by providing a Device Builder Studio, compact embedded device agent, transparent device data synchronization, analytics, OTA updates and a low-code device app designer. This comprehensive approach accelerates and enhances the underlying AWS platform's functionalities, allowing you to create, configure, and deploy secure IoT environments and applications in minutes rather than months.

:::info
**Ioto dramatically lowers IoT project cost and accelerates the time to completion while lowering project risk.**
:::

## Components of Ioto

![Ioto Solution](/images/ioto/framework.png){.screen}

**EmbedThis Ioto** is comprised of the following components:

- **Device Builder Portal** - Create and configure devices in minutes.
- **Device Agent** - Management agent to embed in devices to control communications with the cloud.
- **Based Device Management** - IoT services to manage device provisioning, messaging, and data storage.
- **Device Apps** - Low-code app designer to create and configure device apps in minutes.

## Key Features of Ioto

- Device builder portal to create, configure and manage devices
- Regional device clouds to manage devices in different locations
- Embedded device agent for local and remote management
- Automated actions and device commands including support for offline devices
- Low-code app designer to create mobile and desktop device apps
- Over-the-air updates
- Device data storage
- Transparent device data synchronization with the cloud
- Device data analytics and metrics
- Device data visualization with dashboards and graphical widgets
- Device data security, privacy, and compliance
- User access control
- Leverage and integrate with AWS IoT services
- Online support portal and extensive documentation

## Getting Started

Watch a **Getting Started** video below or read the [Getting Started Guide](https://www.embedthis.com/blog/ioto/cloud/start/cloud-based-device-management.html){:target="_blank"}.

<iframe src="https://www.youtube.com/embed/eIG5z-DcrIo?rel=0" width="800" height="600" frameborder="0" allowfullscreen></iframe># Account Settings

The account settings page displays and manages your account name and billing email address.

The settings page will be enabled if you are an "owner" of the Builder account. You become an owner by having a member role of "owner".

## Name

Your account name was defined when you created your Builder account. You can change your account name here if you require.

You can also change your corporate name and billing address that will be used for invoices on the Invoice Address option on the Account Billing Page.

## Billing Email

Each Builder account has an email address that is designated as the primary contact for the account. This email address will be used for billing and critical account communications. It will not be used for other notifications.

The billing email is by default the email address of the user who created the account. You can change this email address to the valid email address of any admin user.

## Account ID

Your Builder account ID is shown on the settings page and this may be requested by support staff should you need assistance in resolving an issue.
# Account Users

You can invite and add team members to your account and designate their role in your EmbedThis Builder account.

Administrative users can add, remove or modify organization members.

![Invite User](/images/builder/invite-member.png){class="screen"}

## Inviting Users

To add a user to a Builder account, invite them via the "Add Member" button on the Member List page.

When invited, the user is sent an invitation email with instructions. When clicking or entering the link provided, the user can register and login to your account.

## User Role

When inviting a user or later when modifying the user's configuration, a user can be assigned a role. This role may be:

* user
* admin
* owner

User role members can view information but not change product, subscription or organization configuration. Users can view and open support issues and download software.

In addition to user roles capabilities, admin members can perform constructive or destructive operations on the organization. Admin users can create product definitions, configure subscriptions and confirm purchases.

In addition to the admin role, owners can control the entire account. They can add and modify billing cards and close the account.

## Remove User

Clicking this button will remove the user from your Builder account and from all your organizations. The user will lose all access to Builder and your assets.
# Personal Profile

The personal profile displays your login information including your login information and personal preferences.

![Profile](/images/builder/profile.avif){class="screen"}

## Changing Name

If you have logged in using an email address and password, you can change your personal profile including your first and last name.

## Social Media Login

If you have logged on via a social media account such as Google, Amazon or Facebook, and you wish to change your profile, you need to do that via your social media account.

## Account ID

Your Builder account ID is shown on the profile page and this may be requested by support staff should you need assistance in resolving an issue.

## Guide Hints

The Guide hint toggle controls the display of UI sign-posts that guide your use of the Builder site. While you can dismiss the guide posts individually on their respective pages, you can also turn off the Guide Hints toggle to turn off all sign-posts. If you decide to enable again in the future, you can select **Re-Enable** which will redisplay all posts including those you have individually dismissed.

## Dark Mode

You can change your default dark mode setting here. Set to **auto** to have your dark mode change automatically with the time of day.# For Cloud Engineers

> Head in the clouds and feet on the ground. A cloud engineer has to connect the devices of yesterday with the cloud of tomorrow using what is available today.

The work flow for creating cloud-managed devices with the Builder includes:

-   Selecting the device agent for your product.
-   Gaining access to device software.
-   Creating device clouds.
-   Registering and claiming devices.
-   Gaining access to support programs and communicating with EmbedThis support.
-   Monitoring and analyzing device performance.

## EmbedThis Ioto

EmbedThis Ioto is a cloud-based management service for embedded devices connected to the Internet.

It is comprised of five components:

-   Device Builder
-   Ioto Service
-   Ioto Device Clouds
-   Ioto Device Agent
-   Ioto Device Apps

The **EmbedThis Device Builder** web site helps you to:

-   Define, configure, and control your products.
-   Manage your device clouds.
-   Tailor software upgrades to your needs.
-   Manage your subscription and billing for EmbedThis products and services.

The **Ioto Service** is a cloud application. It provides services for the EmbedThis Builder and manages the provision of devices into Device Clouds.

**Ioto Device Clouds** are cloud-based hubs that run in a region of your chosing. They manage routine communications and management for your devices.

The **Ioto Device Agent** is a cloud-ready embedded agent for remote device management. It includes an embedded web server, embedded database, HTTP client, MQTT client and extensive AWS IoT cloud integration. The agent communicates with the Ioto Service and Device Clouds for management. See [Ioto Agent Documentation](/agent/) for in-depth details about the Ioto Agent.

**Ioto Device Apps** are web apps that you can customize to suit your exact management needs. They can be extensively customized to manage your devices with your logo, product name, color and font theme, device data and device specific screens and interfaces.


## Work Flow

The work flow for creating cloud managed devices is outlined below.

### Creating a Product Definition

For each product type that you wish to manage from the cloud, you need to create a product definition that describes your device and nominates the device agent you wish to utilize.

### Downloading the Ioto Device Agent

Next, download the Ioto device agent from the Builder product list by clicking the **download** icon in the product list.

When building the Ioto device agent, you can select to also build the cloud-based device management application. This is included with the Ioto agent and can serve as the basis for a bespoke management user interface.

To help you evaluate Ioto, your first device is free. Thereafter, a subscription is required.

### Customizing Device Specific Logic

Embed the Ioto agent into your device hardware and add your device specific logic. There is extensive documentation available:

-   [Ioto Agent Doc](/agent/).

### Creating a Device Cloud

When your device has Ioto embedded and is ready to communicate with the cloud, you need to create a **Device Cloud** that will be the central hub for managing your devices.

A Device Cloud is created in an AWS account with a region of your choice. You can have multiple device clouds if you require, though most users will require only one cloud for their devices.

### Device Cloud Privacy

The Device Cloud is created in your AWS account so you have total control and privacy regarding your device data. Your device data goes directly from your devices to the device cloud in your account. The device data is not sent through EmbedThis servers or other AWS accounts. This is important as jurisdictions are increasingly requiring that data only be stored, processed and managed locally.

When creating device clouds, the builder will create the necessary resources, including a DynamoDB device database and service Lambda function in your AWS account.

### Registering Devices

Once a device cloud is created, you can register a device with the Builder service.

See [Ioto Provisioning](/ioto/provisioning/) for more details.

### Claiming Devices

When registered, you can "claim" the device for a user.

During development, you can claim devices from the Builder cloud list.

See [Device Claiming](/ioto/provisioning/claiming.md) for more details.

Once registered and claimed, the device is under management by the Ioto service. Management commands can be sent from the cloud to the device and device data can be sent upstream from the device to the cloud.

In production, users will claim devices using a bespoke management application that best implements an effective operational interface for your product and devices.

### Creating Device Apps

After creating a device cloud, you can create one or more device apps to manage your devices. These apps are created by the build and are hosted by EmbedThis on a sub-domain of your choosing.

Device apps can be uniquely configured using the low-code app designer. The app can be extensively customized to manage your devices with your logo, product name, color and font theme, device data and device specific screens and interface including browser-based and cloud-side custom logic.

You can customize device apps by changing:

- The app name and title
- The logo with your company logo
- A Device data schema
- A UI Skin

You can also use the low-code app designer to create custom pages and navigation for your app.

Device apps leverage the DevCore UI framework which is a responsive, [Single Page](https://en.wikipedia.org/wiki/Single-page_application) web framework authored using [VueJS](https://vuejs.org). Device apps consumes data from the Ioto cloud APIs and sends device commands to your devices as required.

Alternatively, you can create your own device app using a framework of your choosing and the Ioto APIs.  

### Ioto APIs

Ioto provides a comprehensive suite of API interfaces for you to create your device management application. These APIs cover the following areas:

-   Builder HTTP REST API &mdash; for managing products, device clouds and software upgrades.
-   DynamoDB schema &mdash; for querying structured device data.
-   Event API &mdash; for receiving event notifications over AWS EventBridge.
-   MQTT Topic API &mdash; for sending and receiving device commands, data and notifications.

## Support

As you progress with your design and development, you will probably require support.

EmbedThis offers two types of support:

-   Basic Support
-   Developer Support

Basic support provides basic guidance covering installation and operational usage of the product.

Developer support provides comprehensive developer help for design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues, and support for legacy software versions.

You can purchase support via the Builder interface under the Support menu option. You can also raise and track support issues with the EmbedThis support staff.

## Support Issues

With an active support plan, you can use the integrated Builder support center to open support cases and track them to conclusion.

![Support Cases](/images/builder/support-case.png){class="screen"}

When opening a support case, you supply:

-   A short case issue subject
-   A detailed issue description
-   The relevant product experiencing the issue
-   Attach relevant files or logs
-   The issue severity
-   A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and thorough description of what the issue is. Please explain in sufficient detail. If your description is too brief, support staff cannot resolve the issue as quickly and will have to contact you to obtain any missing information. Please spend some time writing a complete description.

If you can, please include a link to a repository containing a test case that reproduces your issue. Reproductions should be short, correct, self-contained. They should not contain code that isn't relevant to the issue, so do NOT simply paste code from your project. Explaining how to reproduce the issue without including a test case is typically insufficient and will result in delays resolving your support issue.

### Issue Severity

Selecting an option for severity informs EmbedThis staff of the level of urgency of your issue. You may categorise an issue as low, medium, high, or critical severity. Please do not overstate the issue severity. NOTE: the severity does not equate to a priority with which your issue will be addressed.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.

## Close Case

When an issue is closed to your satisfaction, click the close case button.

### Product Issues

The Builder is used to track issues and security notices.

Go to the [Builder Products List](https://admin.embedthis.com/product) to see the product list and product security center.

To open a bug report, use the [Builder Support Center](https://admin.embedthis.com/support) to open
a case ticket.

## Feedback

If you have suggestions for how the Builder could make your role easier, please let us know at: [feedback@embedthis.com](mailto:feedback@embedthis.com).
# For Product Managers

>As a product manager, you identify customer needs and business objectives that your product will fulfill. You define product success criteria and rally your team to turn that vision into reality.

The EmbedThisDevice builder supports these requirements by helping you manage EmbedThis device agents, subscriptions, and support services.

The work flow for managing products with the Builder includes:

* Selecting the device agent for your product.
* Providing access to device software and patches.
* Creating and configuring device clouds.
* Managing software and service subscriptions.
* Gaining access to support programs and communication with EmbedThis support.
* Organizing your team.

## Creating a Product Definition

For each device that you wish to manage, you need to create a product definition that describes your device and nominates the device agent you wish to utilize.

The product definition includes the product name, description, and web page URL.

## Subscriptions

Depending on the device agent, there are varying subscription plans.

If you select the Ioto cloud agent, you can choose to automatically meter device volume as you manufacture.

For Appweb and GoAhead device agents, you select a license scope based on the volume and number of products you wish to support. You also select your payment frequency. 

For more detail, please see the [Builder Plans](../plans/) page.

## Download the Software

Once subscribed, you can download the device agent software from the Builder product list. Click on the download icon from the product table.

If you are evaluating the platform, you will be able to download an evaluation version of the software. If you have a paid subscription, you can download any current or prior version of the software.

## Device Specific Logic

Once downloaded, your engineers can begin embedding the device agent in your device hardware and adding your device specific logic. There is extensive documentation for the device agents:

* [Ioto Agent Doc](/agent/)
* [Appweb Doc](https://www.embedthis.com/appweb/doc/)
* [GoAhead Doc](https://www.embedthis.com/goahead/doc/)

## Support

As your team progresses with design and development, they may require support.

EmbedThis offers two support programs:

* Basic Support
* Developer Support

**Basic support** provides basic guidance covering installation and operational usage of the product.

**Developer support** provides comprehensive support with design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues, and support for legacy software versions.

Support can be purchased via the Builder interface. Payment can be made in advance, or each time support is needed. With a support subscription, your team can raise and track support issues with the EmbedThis support staff.

## Billing

You can complete payment for subscriptions via online card. Enter your online card from the Account/Billing page.

If you are authorized to pay by bank transfer, you can download PDF quotations from the Account/Subscription page and then enter your purchase order number in the **Order Details** panel.

After purchasing, you will be emailed an invoice. You can download past invoices from the Billing page.

## Renewals

Subscription plans renew automatically. If you are on an Agreement plan, you will need to confirm the renewal each year. Don't worry, we'll remind you via email when it is due.

To subscribe for additional products, device clouds, or more support, go to the Account/Subscription page. Review your subscription, then click Confirm to purchase.

## Organizing Your Team

You can invite any number of team members to register and login to your Builder account. This is useful so that team members can utilize the Builder directly and:

* Open and track support issues
* Download software
* Download software patches
* Create and configure device clouds
* Claim and test devices
* Monitor device cloud performance

When inviting a user or later when modifying the user's configuration, a user can be assigned a role. This role may be:

* user
* admin
* owner

**User** members can view information but not change product, subscription or organization configuration. Users can view and open support issues and download software.

In addition to user capabilities, **admin** members can perform constructive or destructive operations on the organization. Admin users can create product definitions, configure subscriptions and confirm purchases.

In addition to the admin role, **owners** can control the entire account. They can add and modify billing cards and close the account.

## Feedback

If you have suggestions for how the Builder could make your role easier, please let us know at: [feedback@embedthis.com](mailto:feedback@embedthis.com).
# Create an Account

To use the EmbedThis Builder site, you need to register and create an account. This is a simple, one-time task that will take you just a few minutes.

If you have been invited to an account by a co-worker, please click on the link in the invite email. That will ensure you become a member of the account that invited you.

To register, navigate to the Builder site at [https://admin.embedthis.com](https://admin.embedthis.com) and click on the Register tab.

All use of the EmbedThis Builder service and the device agent software is governed by the [Embedthis Terms of Use](https://www.embedthis.com/about/terms.html).

## Register

When you navigate to the admin site, you will see the login / registration dialog.

![Register](/images/builder/login.png){class="screen width-50"}

You may register using an email address and password or you may use a social media account from Amazon, Facebook, or Google. If you register by email and password, you will be sent a confirmation code to validate your email address. This code will come from the domain sender: no-reply@verificationemail.com.

If this is a new account, you will also be asked to enter an account name to identify your account.

Once registered, you will be automatically logged in to the Builder site.
Later, you can invite team members to join you on your account.
# Stand-Alone Devices

To create stand-alone managed devices, you typically integrate an embedded web server and create an embedded device management application that resides on the device.

The **EmbedThis Ioto Device Agent** includes a first-class embedded web server. We also offer two legacy embedded web servers for historical reasons.

* [Ioto](https://www.embedthis.com/ioto/)
* [Appweb](https://www.embedthis.com/appweb/)
* [GoAhead](https://www.embedthis.com/goahead/)

>Our legacy Appweb and GoAhead web servers are provided for existing customers who have embedded these web servers in existing product designs. We recommend that all customers transition to Ioto for new designs and devices.

The **Ioto Device Agent** can be used as a stand-alone embedded web server without any cloud management features enabled.

Ioto includes our most advanced embedded web server and is a fraction the size of comparable embedded web servers (including our own). It boasts impressive throughput and efficiency scores.

We recommend choosing the Ioto device agent for all new devices, even if they are not connected to the cloud, as Ioto has the most efficient and secure embedded web server. Please read the [Device Agent Comparison](https://www.embedthis.com/ioto/comparison.html) for details.


**GoAhead** is a simple, secure embedded web server that is perhaps the world's most popular embedded web server. Originally designed in 1998, GoAhead was present at the foundation of the Internet of Things. It is compact, secure and simple to use. GoAhead is deployed in hundreds of millions of devices.

**Appweb** is a high-end, secure embedded web server for hosting complex embedded web management applications. Appweb offers HTTP/2, HTTP proxy, extensive security controls, sandboxing and defensive counter-measures.

The work flow for creating stand-alone managed devices is outlined below. The entire process can take a significant amount of time due to the need to customize device-specific logic and adapt to the specific capabilities of each device.

## Create a Product Definition

For each product or product family, you need to:

* Create a product definition that describes your device. This definition should nominate the device agent you wish to utilize.

* Select your subscription options. Depending on your licensed agent, you will have different subscription options.

## Download the device agent

Next, download the device agent from the Builder product list.

If you have purchased a subscription, you can download the full software. Otherwise, you will be able to download an evaluation version.

## Customize device specific logic

Once downloaded, you can begin the task of embedding the agent in your device hardware and adding your device-specific logic.

## Create the Embedded Web App

Creating the embedded web management application can be very time consuming. It is often one of the most challenging tasks when creating device management software.

To accelerate your development cycle, the Ioto solution provides a suite of pre-built apps for local and cloud-based device management. 

For example, the [Kickstart App](/apps/samples/kickstart/) sample device management application emulates a simple smart switch. Kickstart can act as the starting point for your device user interface. It employs best practices for dynamic, responsive device management. 

The Ioto apps are part of the Ioto agent software and can be downloaded from the Builder by clicking **download** on an Ioto product entry. 

Read more at [Kickstart](https://www.embedthis.com/ioto/kickstart.html).

## Support

As you progress with your design and development, you will probably require support.

EmbedThis offers two types of support:

* Basic Support
* Developer Support

Basic support provides basic guidance covering installation and operational usage of the product.

Developer support provides in-depth developer help for design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues, and support for legacy software versions.

You can purchase support via the Builder interface under the Support menu option. You can also raise and track support issues with the EmbedThis support staff.

## Subscribe

To Subscribe for additional devices, create device clouds, or purchase support, go to the Account/Subscription menu option. Review your subscription, then click Confirm to purchase. You can enter a billing card on the Account/Billing page.

You can read more about subscriptions at: [Subscriptions](../plans/).
# Creating Cloud Managed Devices

EmbedThis Ioto is a cloud-based management service for embedded devices connected to the Internet.

It is comprised of five components:

* Device Builder
* Ioto Service
* Ioto Device Clouds
* Ioto Device Apps
* Ioto Device Agent

The **EmbedThis Device Builder** web site helps you to:

* Define, configure, and control your products.
* Manage your device clouds.
* Tailor software upgrades to your needs.
* Manage your subscription and billing for EmbedThis products and services.

The **Ioto Service** is a cloud application. It provides services for the EmbedThis Builder and manages the assignment of devices into Device Clouds.

**Ioto Device Clouds** are cloud-based hubs that run in a region of your chosing. They manage routine communications and management for your devices.

**Ioto Device Apps** are custom device apps created for your device cloud. You and your customers can claim and manage individual devices and fleets of devices.

The **Ioto Device Agent** is a cloud-ready embedded agent for remote device management. It includes an embedded web server, embedded database, HTTP client, MQTT client and extensive AWS IoT cloud integration. The agent communicates with the Ioto Service and Device Clouds for management. See [Ioto Agent Documentation](/agent/) for in-depth details about the Ioto Agent.

The work flow for creating cloud managed devices begins with the Builder. The Builder is used to define and configure your products and device clouds.

## Creating a Product Definition

For each product type that you wish to manage from the cloud, you need to create a product definition that describes your device and nominates the device agent you wish to utilize.

## Downloading the Ioto Device Agent

Next, you download the Ioto device agent from the Builder product list.

To help you evaluate Ioto, your first device is free. Thereafter, a subscription is required.

## Customizing Device Specific Logic

Embed the Ioto agent in your device hardware and add your device specific logic. There is extensive documentation available: [Ioto Agent Doc](/agent/).

## Connecting to the Eval Cloud

If you are evaluating Ioto, you can connect to the eval cloud at **eval.ioto.me**. To connect to the eval cloud, define the **product** property in the Ioto device.json5 configuration file. Set it to the value the Builder evaluation product ID from the product list. 

## Creating a Device Cloud

When you are ready, you can create your own **Device Cloud** for your own private use.

A Device Cloud is created in an AWS region of your choice. This is important as jurisdictions are increasingly requiring that data only be stored, processed and managed locally.

When you create a device cloud, the Builder creates a private device database for your devices. Your data is always private and is never shared with any other third-parties.

You can have multiple device clouds if you require, though most users will need only one cloud for their devices.

## Device Cloud Privacy

For the ultimate in privacy and security, you can create a dedicated device cloud in your AWS account. With a dedicated device cloud, your device data goes directly from your devices to the device cloud in your AWS account. The device data is not sent through the EmbedThis cloud. 

## Registering Devices

Once a device cloud is created, you can register a device with the Builder service using the Builder Product ID and a per-device ID.

See [Device Registration](/ioto/provisioning/registration.md) in the [Ioto Agent Documentation](/agent/) for more details. When registered, you can "claim" the device for a user. See [Device Claiming](/ioto/provisioning/claiming.md) for details.

Once registered and claimed, the device is under management by the Ioto service. Management commands can be sent from the cloud to the device and device data can be sent upstream from the device to the cloud.

## Device Apps

> Perhaps the largest task in creating cloud-based managed products is creating this device management application. The size of this task as it is probably the largest single task and expense when creating IoT managed devices.

After a device cloud is created, you can create and configures a device app for your devices.

Ioto device apps can be extensively customized with your logo, product name and device specific data, screens and panels.

Using the Builder, you can configure the Ioto device apps by defining device specific components, including:

* Logo
* display.json5
* schema.json5
* Extension VueJS Components (for dedicated clouds)

The schema describes your device entities and their data properties and data types. From this, device apps are able to dynamically construct a user interface when guided by the Display.json file.

## Management App

Ioto device apps are extremely flexible, however, there are limits, and you may want to create your own app that uses the Ioto APIs to provide a bespoke management experience for your devices.

Such a management app should ideally be a [Single Page](https://en.wikipedia.org/wiki/Single-page_application) web application authored using [VueJS](https://vuejs.org) or [React](https://https://reactjs.org/). This app will consume data from the Ioto cloud APIs and send device commands to Ioto for relaying to the relevant devices.


## Ioto APIs

Ioto provides a comprehensive suite of API interfaces for you to create your device management application. These APIs cover the following areas:

* Builder HTTP REST API &mdash; for managing products, device clouds and software upgrades.
* DynamoDB schema &mdash; for querying structured device data.
* Event API &mdash; for receiving event notifications over AWS EventBridge.
* MQTT Topic API &mdash; for sending and receiving device commands, data and notifications.

## Support

As you progress with your design and development, you will probably require support.

EmbedThis offers two types of support:

* Basic Support
* Developer Support

Basic support provides basic guidance covering installation and operational usage of the product.

Developer support provides in-depth developer help for design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues and support for legacy software versions.

You can purchase support via the Builder interface under the Support menu option. You can also raise and track support issues with the Embedthis support staff.

## Subscribe

To Subscribe for additional devices, create device clouds or purchase support, go to the Account/Subscription menu option and review your subscription, then click Confirm to purchase. You can enter a billing card on the Account/Billing page.
# For Embedded Engineers

>An embedded software engineer has to bridge the divide between hardware reality and business vision using software alone.

The work flow for creating connected devices with the Builder includes:

* Selecting the device agent for your product.
* Gaining access to device software.
* Gaining access to support programs and communication with EmbedThis support.
* Monitoring security vulnerabilities and security patches.

## Selecting the Device Agent

To create stand-alone managed devices, you typically integrate an embedded web server and create an embedded device management application that resides on the device.

The **Ioto Device Agent** is a cloud-enabled device agent, but it also includes a first-class embedded web server. Ioto can also be used as a stand-alone embedded web server without any cloud management features enabled.

Ioto includes our most advanced embedded web server and is a fraction the size of comparable embedded web servers (including our own). It boasts impressive throughput and efficiency scores.

We recommend choosing the Ioto device agent for all new devices, even if they are not connected to the cloud, as Ioto has the most efficient and secure embedded web server. Please read the [Device Agent Comparison](https://www.embedthis.com/ioto/comparison.html) for details.

We also offer two legacy embedded web servers:

* [Appweb](https://www.embedthis.com/appweb/)
* [GoAhead](https://www.embedthis.com/goahead/)

>Our legacy Appweb and GoAhead web servers are provided for existing customers who have embedded these web servers in existing product designs. We recommend that all customers transition to Ioto for new designs and devices.


**GoAhead** is a simple, secure embedded web server that is perhaps the world's most popular embedded web server. Originally designed in 1998, GoAhead was present at the foundation of the Internet of Things. It is compact, secure and simple to use. GoAhead is deployed in hundreds of millions of devices.

**Appweb** is a high-end, secure embedded web server for hosting sophisticated embedded web management applications. Appweb offers HTTP/2, HTTP proxy, extensive security controls, sandboxing and defensive counter-measures.


## Creating a Product Definition

For each product or product family, you need to create a Builder product definition that describes your device and selects the device agent you wish to utilize.

Depending on your licensed agent, you will have different subscription options.

![Product Edit](/images/builder/product-add.png){class="screen"}

## Downloading the Device Agent

Next, download the device agent from the Builder product list.

If you have purchased a subscription, you can download the full software or any historical version. You may download an evaluation version without purchasing a subscription.

![Download Software](/images/builder/product-list.png){class="screen"}

## Adding Device Specific Logic

Once downloaded, you can begin embedding the device agent into device hardware and adding device specific logic. There is extensive documentation for the device agents:

* [Ioto Agent Doc](/agent/)
* [Appweb Doc](https://www.embedthis.com/appweb/doc/)
* [GoAhead Doc](https://www.embedthis.com/goahead/doc/)


## Creating the Embedded Web App

Creating the embedded web management application can be very time consuming. It is often one of the most challenging tasks when creating device management software.

To accelerate your development cycle, the Ioto solution provides a suite of pre-built apps for local and cloud-based device management. 

For example, the [Kickstart App](/apps/samples/kickstart/) sample device management application emulates a simple smart switch. Kickstart can act as the starting point for your device user interface. It employs best practices for dynamic, responsive device management. 

The Ioto apps are part of the Ioto agent software and can be downloaded from the Builder by clicking **download** on an Ioto product entry. 

Read more at [Kickstart](https://www.embedthis.com/ioto/kickstart.html).

## Accessing Support

As you progress with your design and development, you will probably require support.

EmbedThis offers two types of support:

* Basic Support
* Developer Support

Basic support provides basic guidance covering installation and operational usage of the product.

Developer support provides comprehensive help with design and implementation issues. This includes embedded development, cloud-based device management, developer coding, debugging issues, and support for legacy software versions.

You can purchase support via the Builder interface under the Support menu option. You can also raise and track support issues with the EmbedThis support staff.

## Support Issues

With an active support plan, you can use the integrated Builder support center to open support cases and track them to conclusion.

![Support Cases](/images/builder/support-case.png){class="screen"}

When opening a support case, you supply:

* A short case issue subject
* A detailed issue description
* The relevant product experiencing the issue
* Relevant files or logs
* The issue severity
* A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and thorough description of what the issue is. Please explain in sufficient detail. If your description is too brief, support staff cannot resolve the issue as quickly and will have to contact you to obtain any missing information. Please spend some time writing a complete description.

If you can, please include a link to a repository containing a test case that reproduces your issue. Reproductions should be short, correct, self-contained. They should not contain code that isn't relevant to the issue, so do **not** simply paste code from your project. Explaining how to reproduce the issue without including a test case is typically insufficient and will result in delays resolving your support issue.

### Issue Severity

Selecting an option for severity informs EmbedThis staff of the level of urgency of your issue. You may categorize an issue as low, medium, high, or critical severity. Please do not overstate the issue severity.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.

## Close Case

When an issue is resolved to your satisfaction, click the close case button.

### Product Issues

The Builder is used to track issues and security notices.

Go to the [Builder Products List](https://admin.embedthis.com/product) to see the product list and product security center.

To open a bug report, use the [Builder Support Center](https://admin.embedthis.com/support) to open
a case ticket.

## Feedback

If you have suggestions for how the Builder could make your role easier, please let us know at: [feedback@embedthis.com](mailto:feedback@embedthis.com).
# For Purchasing

>Purchasing must identify business requirements for goods and services, and find reliable suppliers to meet those requirements. Nothing is concluded without purchasing connecting the dots.

The Builder provides an intuitive subscription and billing system. It offers:

* Subscription management and configuration.
* Payment by online card.
* Optional payment by bank transfer.
* Generation of quotation PDF orders.
* Generation of subscription PDF invoices.
* Configurable invoice addressing and details.
* Automatic mailing of invoices to accounts payable.

## Managing Subscriptions

Once the desired product and support subscriptions have been defined, your subscription information is collected and presented from the Account/Subscription page.

![Subscription](/images/builder/subscription.png){class="screen"}


To review your subscription, login to [Builder Subscription](https://admin.embedthis.com/account/subscription) and click on the Account/Subscription menu option.

The subscription page displays your current, pending, and due subscriptions. It includes your products, clouds, and support plans. It provides an overview of your EmbedThis subscriptions and future renewals.


## Existing Agreement Customers

If you have an existing agreement, your licensed product definitions and support plans will already be entered. These will have been setup to continue your previously renewed subscription items. However, you can review and tailor the software maintenance options and support plan to suit your current needs.

## Current Subscriptions

Your current subscriptions are those that you have purchased previously and are still active.

The table will display products, clouds, and support subscriptions including the period for which the subscription is active.

## Confirming Subscriptions

Your subscriptions to confirm are those items that are due for renewal but you have not yet confirmed the purchase.

The table will display the products, clouds, and support subscriptions along with the price for each item.

Click the **Confirm** button to confirm the renewal and authorize the transaction. If you are authorized to pay by bank transfer, you will need to first enter a purchase order number via the **Order Details** panel.

## Upcoming Subscriptions

Your upcoming subscriptions are those you have created but are not yet due. For example, Ioto subscriptions are due at the end of each month. Before the end of the month has been reached, the subscription will appear in this section.

The table will display the products, clouds and support subscriptions and the estimated price for each item.


## Download a Quote

If your business processes require a quote PDF, you can click **Download Quote** to generate and download a quotation for the displayed items.

When you are ready, click the Confirm button to purchase. You can enter a billing card on the Account/Billing page.

## Billing

The billing center page displays your billing cards and issued invoices.

![Billing](/images/builder/billing.png){class="screen"}

## Payment Cards

Your billing cards will be displayed and the current card will be shown as the default card to use for payment. Click **Add Card** to enter a new card. Click on an existing card to modify, delete or designate a card as the default card to use for billing.

For your security, only the last 4 digits of the card number are stored for verification purposes.

## Invoices

As you are billed, invoices are created and stored. You will be emailed the invoice PDF and you can download past invoices from the invoices table.

## Invoice Details

To change the company name or billing address on your invoices, click on the **Invoice Address** button and enter the required details.

If you change the invoice address, you can click **Reissue** to re-generate the invoice with the updated invoice address.

## Renewal Reminders

The account owner will be automatically emailed renewal reminders before your subscriptions expires.

## Feedback

If you have suggestions for how the Builder could make your role easier, please let us know at: [feedback@embedthis.com](mailto:feedback@embedthis.com).
# Software Updates

Today, it's essential to regularly **update and upgrade** the software on your devices to fix security vulnerabilities, introduce new features, and enhance overall performance.

With the [EmbedThis Builder](https://www.embedthis.com/builder/), you can create, deploy, manage and monitor software updates that are delivered Over-The-Air (OTA) to keep your devices secure and up-to-date.

Using the Builder OTA update manager, you can selectively deploy updates to any desired subset of your device population. Updates can be published that will be applied to your devices according to a **distribution policy**. In this way, you can selectively update all your device or specific subsets as you require.

## Device Agent Support 

Using the Builder, you can deploy updates to any device, regardless of the device agent you utilize. The Ioto, GoAhead, Appweb device agents pre-integrate software update capability. If your device does not have one of these device agents, you can incorporate update capability device using the stand-alone [Embedthis Updater](https://github.com/embedthis.updater).

## Configuring Updates

![Software Modify](/images/builder/software-edit.png){class="screen"}

To configure a software update, you supply the following parameters:

* Product
* Update version
* Update description
* Distribution policy
* Device Cloud
* Update image


## Update Selection

Each day, the updater agent will typically connect to the device cloud for a "checkin". During this request, the agent will submit the update request to the device cloud to see if an update is available for this device.

The device cloud will retrieve the most recent updates and check the updates in reverse version order and select the first matching update for the device.

The device cloud service will evaluate the distribution policy expression when the device checks-in and if the policy matches for the device, the URL for the update image will be returned to the device agent. The agent will then fetch the update image and verify the integrity of the update image. If verified, the **scripts/update** script is invoked to apply the update. 

If you are running the Ioto agent on an RTOS, without scripting, you will need to watch and react to the the event **device:update** using the rWatch API.

## Update Limits

Implementing a gradual update strategy can help minimize load and risk. Updating a large number of devices simultaneously can impose an excessive burden on your service, so staggering the rollout can distribute the load more evenly.

Despite thorough testing, some updates might still be considered "risky." To minimize this risk, you can update a small subset of your device population first to see if the update causes any issues.

The update service provides update limits and gradual rollout factors that allow you to control the rate of updates.

* **Max device limit** and **device percentage** limits define the maximum number of devices that can be updated. Once either limit is reached, further updates are prevented.

* For gradual rollouts, you can set a **max updates per period**, which limits the number of updates to a specified number over a defined period. For example, you could set a limit of 1000 updates per hour (3600 seconds).

If a device meets the distribution policy and rollout limits, the URL for the update image will be returned to the update agent. The agent will then fetch the update image and verify its integrity. If the image is verified, the **scripts/update** script is invoked to apply the update. If you are running the agent on an RTOS without scripting, you will need to monitor and respond to the **device:update** event using the rWatch API.

## Product

When defining an update, select the product for which the software update applies. A device cloud may be managing many different products and the product selection in conjunction with the distribution policy defines the subset of devices that are eligible to receive the update.

You should define multiple product definitions if the different devices consistently require different firmware.

## Software Version

The version number is your software release version number identifying this software release. The version numbers are compatible with the [SemVer 2.0](https://semver.org/) version specification.

If you are using the Ioto agent, the current version for your device is defined via the **version** property in the **ioto.json5** configuration file. NOTE: your device is versioned separately to the Ioto agent itself which has its own version string.

## Software Release Description

The description is an informative description for your purposes.

## Software Distribution Policy

The distribution policy is a simple Javascript-like expression that is evaluated at runtime to determine if the update is relevant for a specific device. If you leave the policy blank, then all devices whoes version is less than the software release version will be updated.

Here is a sample policy expression:

    major >= 1 && minor >= 1 && patch >= 5 && memory >= 256 && ports == 32

The properties contained in the device.json5 configuration file are made available as variables. In this case, the "memory" and "ports" variables are supplied in the device.json5 file. 

The full device version is accessible as the varible "version" and the software update version is provided via the "newVersion" variable. 

The default policy is uses the inbuilt function **semver** which compares two version strings. This default policy compares if the current version is earlier than the new update version.

    semver(version, "<", newVersion)

The device version string is also split into SemVer components:

* major
* minor
* patch

See [Expressions](../../apps/config/expressions.md) for more information on the expression syntax.


## Opt-in Updates

Devices can implement an opt-in update strategy by defining variables in the device context that are passed with the update checkin request. These variables can be examined by the distribution policy expression. If a variable is set only when a device/user opts-in, then the distribution policy can target only those devices.

For example, say a device defined an opt-in field called **try-beta-features** that was set to "1" when users toggled a UI checkbox to signify they wished to receive beta features. The device would then pass this field with the update checkin request and the distribution policy could test that value.

    try-beta-features == 1

## Rollback Updates

You can rollback errant updates by defining an update that has a distribution policy pinned to the errant version. For example, say the update **1.2.3** was bad and you wished to rollback devices to the prior **1.2.2** version. You would first disable the 1.2.3 bad update by deselecting the **Enable** checkbox for that update. Then, you would define an update 1.2.2 that had a distribution policy like this:

    version == '1.2.3'

This would target only the 1.2.3 devices and roll them back to version 1.2.2. 

## Device Cloud

Update images are stored in AWS S3 and distributed globally using the AWS CDN. When defining updates, you select the relevant device cloud to store and apply the updates. If you have multiple clouds, you will need to define updates in each cloud.

## Applying Updates

When the update is downloaded to the device and verified, the update agent will save the image in a temporary file. Your device can be notified of an update by one of two means:

* The "./script/update" shell script will be invoked and passed the update image filename.
* Ioto will indicate an update is available via the "device:update" signal. See rSignal/rWatch for details.

## Enable

You can selectively enable or disable a release at any time via the Builder.# Creating Device Clouds

To create a device cloud, navigate to the Cloud list from the side nav bar and click the **Add Cloud*  button. This will display the "Add Cloud" panel.

![Cloud Configure](/images/builder/cloud-add.png){class="screen width-60"}

A device cloud is created in a specific region so you have control and privacy over your device data. 

## Evaluating Ioto

If you are evaluating Ioto, you can skip this step and connect to the pre-built Eval cloud at **eval.ioto.me**. The evaluation cloud is perfect for quickly connecting Ioto devices to the cloud to test the platform.

To connect to the eval cloud, define the **product** property in the Ioto **device.json5** configuration file. Set it to the value the Builder evaluation product ID from the product list. The default Ioto source code download has this property already defined in the device.json5 file. 

## Data Privacy

When you are ready, you can create one or more device clouds to segment your products and devices.  A single device cloud can be created for all your devices or you can segment your devices into fleets, each with their own device cloud.

For privacy and governance, you may need to separate the device data for specific users into separate fleets. These can have a dedicated device cloud to ensure total data isolation for those users.

## Creating a Device Cloud

When creating a device cloud, you specify a cloud name and select an AWS region to locate your device data.

## Cloud Name

Choose a unique name to identify the cloud configuration within your account.

Enter the appropriate AWS cloud region that is closest to the location of your devices. For example, if your devices are on the US east coast, consider using the US East region and enter: "us-east-1".


## Device Clouds

You can create two types of device clouds:

* Hosted by EmbedThis
* Dedicated in your own AWS account

A hosted device cloud is a device cloud for your devices and customers that is hosted by EmbedThis on secure AWS IoT infrastructure. You do not need to have or manage your own AWS account to use a hosted device cloud.

A dedicated device cloud is created in your AWS account so you have the ultimate in the control and privacy of your device data. With a dedicated device cloud, device data goes directly from your devices to the device cloud in your AWS account. The device data is not sent through EmbedThis servers. 

A dedicated cloud has additional capabilities including:

* Full access to AWS services
* No data storage or I/O limits
* Enhanced security
* Custom cloud-side logic
* Fully bespoke device app with custom components

## Dedicated Device Clouds

A dedicated device cloud requires that you have your own AWS account. We recommend you use a fresh account without any other applications or AWS resources.

When creating a dedicated device cloud, you can optionally control the permissions used in your AWS account via the following AWS roles and policies:

* AWS IAM Role
* Device IAM Role
* IoT Policy

# App Data Schema

Device clouds use a database schema to define what device specific data should be stored in the cloud and what are the device entities to manage.

The schema describes the device entities (components) and their data properties and types. From this, apps are able to dynamically construct a user interface when guided by the display.json5 file.

The Builder defines a default schema when you create the device cloud. This schema supports a generic key/value store, and a device command queue. Initially, you can use the default schema, but as you progress, you may wish to define your own data entities to store device specific data.

The device schema is fixed per device cloud and is common across all apps for that device cloud. You can modify the device schema via the **Cloud Modify** panel.

![Cloud Modify](/images/builder/cloud-modify-schema.avif){class="screen width-60"}

For more information about the device schema, See the Ioto service documentation:

* [Device Tables / Database Schemas](/ioto/database/schemas/)
* [Database Replication](/ioto/database/replication.html)


## IAM Role

EmbedThis controls access to your AWS account via an AWS IAM role. This role grants limited access to your account for EmbedThis Builder.

The IAM role is created in your account via an AWS CloudFormation template. The template creates the necessary IAM role and resources to enable Builder services in your account.

Once your cloud account is connected, Builder will create the necessary cloud resources in your account, including a device DynamoDB database and service Lambda.

## Device Keys IAM Role

The device cloud can create and manage AWS IAM access keys for your devices that can be used to enable devices to issue requests to the device cloud and directly to AWS services.

When creating the cloud, you can specify the name of a custom IAM role that defines the permissions for the access keys given to devices.

The device cloud will generate temporary IAM access keys based on this role.

## IoT Policy

Most device communications with the cloud are performed using the MQTT protocol. When Ioto provisions the device, it initializes the MQTT channel using an IoT policy that controls what resources the device can access and what commands the device can initiate.

You can specify the name of a custom IoT policy to precisely control what capabilities the device will have via MQTT.# Cloud Account

When you create a device cloud, the Builder will create the required cloud resources in an AWS account.

If you are creating a **hosted** device cloud, Ioto will create the cloud in an AWS account owned and operated by EmbedThis for you in a region of your chosing, close to your location.

If you are creating a **dedicated** device cloud, Ioto will create the cloud in your existing AWS account. It is best practice to create a dedicated AWS account for each device cloud you create and not use a pre-existing AWS account that is used for other purposes.  This helps isolate problems and errors and can make issues much simpler.

>If you expect to create more than 1,000 devices over the lifetime of your product, you should use a dedicated device cloud for your production deployment as hosted device clouds are limited to 1,000 devices.

## Cloud Regions

The Ioto Device Cloud is created in the geographical region that you select. For efficiency, you should select a region that is closest to the majority of your devices. Another consideration is where do you want the device data to be stored.

Ioto stores device data in the region you nominate so you have total control and privacy regarding your device data. Device data goes directly from your devices to your device database in the device cloud in your region. The device data does not transit other third-parties services.

## Dedicated Device Clouds

When you create a dedicated device cloud in your AWS account, the Builder and Ioto will create the following cloud resources:

* An AWS DynamoDB database registry of your devices.
* An AWS DynamoDB database exclusively for your device data.
* AWS DynamoDB streams to replicate device data to and from the cloud.
* An AWS API Gateway to authorize remote API access to device data.
* An AWS Cognito User Pool to authenticate user access.
* An AWS CloudFront and S3 site for device apps.
* AWS Route53 domain for device apps.
* AWS Lambda functions for cloud-side device management.
* IAM Roles to restrict remote access.
* AWS IoT Core policies and message routing rules.
* AWS IoT Things to model your devices in the cloud.

## AWS Pre-requisites

When you create an AWS account, AWS may not immediately grant you permission to create some resources that are required to support a device cloud. It is best to be proactive and immediately after creating the AWS account, ask AWS to increase the following limits:

* Ability to create an AWS CloudFront web site
* Ability to send emails from AWS SES

Ioto requires these abilities to complete creation of the device cloud and to create device apps.  These approvals may take up to a few days. 

When asking to increase your AWS SES limit, AWS will ask you several questions. The following FAQ will help you answer their form questions.

Q: Tell us how often you send email,

A: Emails will be sent by the Ioto cloud service when a user registers to create a new account or has account issues. The estimated rate will be per customer 1-2 times per month.

Q: How you maintain your recipient lists,

A: Customer sign up for our service and the customer gets a record in Cognito. The user list is managed in Cognito.

Q: How you manage bounces, complaints, and unsubscribe requests.

A: Customers must maintain a valid email address in their account as part of the TOS. CloudWatch metrics are used to track SES bound metrics.

Q: Provide examples of the email you plan to send so we can ensure that you are sending high-quality content.

```
PRODUCT NAME Welcome</h1>
Your NAME user account has been setup.

Please follow this link now and set your password:

LINK

This link will expire in 24 hours.

You recieved this message because ${email} was listed as the contact address
       when requesting the Embedthis Builder invite.
```
# Device Clouds

Device clouds are management hubs from which you can centrally operate and manage one more more devices.

A device cloud stores device data, manages communications with your devices and provides a device management application to manage devices. By aggregating critical device data in the cloud, you can easily manage your devices and extract important data analytics and intelligence from your devices.

You can create one or more device clouds to segment the management of your products and devices.


![Builder Dashboard](/images/builder/dashboard.png){class="screen"}

## Device Cloud Services

The Ioto device cloud performs the following services:

* Create and configure the necessary cloud resources for device management.
* Automatically provision Ioto-based devices with certificates for secure communications.
* Setup MQTT communications between devices and the cloud.
* Create and maintain a cloud-based device database store for centralized management and analytics.
* Create a secure device app for managing single devices or fleets of devices.

## Device Cloud Types

Ioto supports three types of device clouds:

Type | Description
-|-
eval | Cloud for evaluating Ioto 
hosted | Cloud hosted in an EmbedThis AWS account
dedicated | Cloud hosted in your own AWS account

When creating a device cloud, the Builder will create all the necessary resources for IoT management. This process results in a configured, complete, integrated and live IoT cloud capability.

## Eval Cloud

The Eval cloud will probably be your first experience with Ioto device clouds.

The evaluation cloud is a shared device cloud that is intended for the short term evaluation of a few devices. It enables you to connect a device running the Ioto agent to the cloud and to receive device data and manage the device.

The Eval cloud is free to use for a few devices for a short period of time for evaluation purposes.

## Hosted Device Clouds

A hosted device cloud is a device cloud for your devices and customers that is hosted by EmbedThis on secure AWS IoT infrastructure. You do not need to have or manage your own AWS account to use a hosted device cloud.

Device data goes directly from your devices to the device cloud in the region you select when creating the device cloud. Data does not transit other regions or third-party services.  This is important as jurisdictions are increasingly requiring that data only be stored, processed and managed locally.

Unlike other IoT services, Ioto provides decreased latency by locating device data in a region close to you. This lowers cost and boosts performance of your cloud-based management solution.

Hosted device clouds are limited to a maximum of 1,000 devices. If you expect to exceed this number of devices over the lifetime of your product, you should use a dedicated device cloud for your production deployment.

A hosted device cloud provides:

* AWS DynamoDB database exclusively for your device data.
* AWS DynamoDB streams to replicate device data to and from the cloud.
* AWS API Gateway to authorize remote API access to device data.
* AWS Cognito User Pool to authenticate user access.
* AWS CloudFront and S3 site for device apps.
* AWS Route53 domain for device apps.
* AWS Lambda functions for cloud-side device management.
* AWS IoT Core policies and message routing rules.
* AWS IoT Things to model your devices in the cloud.

## Dedicated Device Clouds

A dedicated device cloud is created in your AWS account so you have the ultimate in the control and privacy of your device data. With a dedicated device cloud, device data goes directly from your devices to the device cloud in your AWS account. The device data is not sent through EmbedThis servers. The data is encrypted throughout and you have total control.

Dedicated clouds support an enhanced set of AWS services beyond those available with hosted device clouds. These include:

* Device log file capture and storage in AWS CloudWatch logs
* Audit operations via AWS CloudTrail
* Device AWS keys to initiate AWS API operations from the device
* Ability to have server-side custom logic responding to device events

If you expect to create more than 1,000 devices over the lifetime of your product, you should use a dedicated device cloud for your production deployment as hosted device clouds are limited to 1,000 devices.

## Device Apps

For each device cloud you can create one or more device apps from which to manage your devices. Apps can be uniquely configured for your devices. They can be extensively customized with your logo, product name, device data and device specific screens and interface including custom logic.

Device apps are hosted by EmbedThis on a sub-domain of your choosing under the ioto.me domain. You can select a unique sub-domain that reflects your company or product's brand. Alternately, you can choose and associate a custom domain name.

## Device Certificates

Devices require X.509 certificates to securely connect and communicate with the cloud. The certificates are used to uniquely identify and authenticate devices and then to encrypt communications to prevent tampering or eavesdropping.

Ioto will automatically create and distribute the required certificates as devices are assigned to a device cloud. This eliminates the pain of certificate distribution.

## Device Communications

During device provisioning, the Ioto service will setup the necessary AWS resources to enable secure efficient messaging via AWS IoT core using the MQTT protocol.

MQTT is a messaging protocol for IoT. It is a lightweight publish/subscribe messaging transport that is ideal for connecting remote devices.

When connected, your management applications can control devices, send commands and retrieve data using the MQTT messaging service.

## Device Data Aggregation

Collecting, aggregating and sending device data to a central management store can be complex and costly. Ioto takes the hassle out of exporting device data to the cloud by synchronizing the Ioto device agent database with an AWS DynamoDB database in your device cloud.

Data written on the device to the management database will be transparently exported to the cloud. Similarly, data written to the cloud database will be distributed to the appropriate devices as required. No programming is required.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-device and per-table basis.

This is similar to AWS Global Tables, but instead of acting inside AWS between AWS regions, it is between an AWS region and a device.

This replicated device database is unique to Ioto and dramatically simplifies the creation of IoT solutions.

## Device Metrics and Analytics

AWS provides a comprehensive metric service via CloudWatch Metrics. The Ioto agent can emit metrics that will be captured by the device cloud and managed by CloudWatch.

Using these metrics, you can create detailed device analytics and dashboards to focus on any aspect of your device or fleet performance.

## Device Access Keys

For dedicated device clouds, Ioto can optionally create and manage AWS IAM access keys for your devices. AWS uses IAM access keys to authenticate and authorize actors on AWS resources. The Ioto device cloud can create specific IAM keys to enable devices to issue requests to the device cloud and AWS services.

The Ioto generated temporary IAM access keys have tightly controlled access permissions. The keys are automatically reissued as required and can be centrally controlled.


## Device Logging

For dedicated device clouds, device logs and files can be captured and sent to AWS CloudWatch logs for storage, governance and analysis.

The Ioto agent can be configured without coding, to capture any O/S log or program output and send it to CloudWatch Logs. The Ioto agent log is similarly exportable.


<!--
## Account Audit

For dedicated device clouds, Ioto configures and enables CloudTrail, which captures an audit trail of **all** activity on your account and device cloud.  This records a complete log to AWS S3 so you can reliably audit operations and determine root cause of any security incidents.

--># Support


EmbedThis offers three types of support:

* Community Support
* Basic Commercial Support
* Developer Commercial Support

Community support is provided by the community via the public [Ioto Github Site](https://github.com/embedthis/ioto/discussions). 

Basic commercial support provides guidance covering installation and operational usage of the product.

Developer commercial support provides developer help for design and implementation issues. This covers embedded development, cloud-based device management, developer coding and debugging issues. Developer support requires that basic support also be enabled.

If you are interested in commercial paid support programs, please sign up via the Builder portal at: [https://admin.embedthis.com](https://admin.embedthis.com).

## Security Center

The Builder portal has a comprehensive product security center that is used to track issues and security notices. To display product issues, go to the [Builder Products List](https://admin.embedthis.com/product) and define or select your product. This will display the product security center below the product list.

## Community Support

The public [Ioto Github Site](https://github.com/embedthis/ioto/discussions) provides an avenue for you to ask questions, share your ideas and engage with other community members. Support here is a community-based and not offered directly by EmbedThis.

## Commerical Support

With a paid support program, you can open a new support case via the Builder by clicking on Create Case. 

When you open a support case, please make sure you do the following:

* Fully describe any issue &mdash; don't be too brief
* The exact sequence of operations to provoke the issue
* Specify the software version and how you built it
* Describe your system platform: O/S and hardware
* Provide a stand-alone test case that reproduces the issue
* If relevant, upload edited log files and command line trace

It is easy to be too brief in describing issues. To solve quickly, please provide as much detail as you can when describing issues.

### Product Issues

The Builder online site is used to track issues and security notices.

Go to the [Builder Products List](https://admin.embedthis.com/product) to see the product list and product security center.

To open a bug report, use the [Builder Support Center](https://admin.embedthis.com/support) to open
a case ticket.


# Support Cases

With an active support plan, you can use the integrated Builder support center to open support cases and track them to conclusion.

![Support Cases](/images/builder/support-case.png){class="screen"}

When opening a support case, you supply:

* A short case issue subject
* A detailed issue description
* The relevant product experiencing the issue
* Attach relevant files or logs
* The issue severity
* A list of additional recipients

### Issue Description

Please provide a complete and detailed description.

A good description is a clear and complete description of what the issue is. Please explain in sufficient detail. Most people are too brief in the description and it results in delays addressing issues as support staff go back and forth with questions. Please spend some time writing a complete description.

If you can, please include a link to a gist or repository containing a test case or sample that reproduces your issue. Reproductions should be short, correct, self-contained and should not contain code that isn't relevant to the issue. Please do NOT just paste code from your project. Explaining how to reproduce the issue alone is typically insufficient.

### Issue Severity

You can set the issue severity which helps EmbedThis staff understand the impact of your issue. Set to low, medium, high or critical. Please do not overstate the issue severity. NOTE: the severity does not equate to a priority with which your issue will be addressed.

### Additional Recipients

By default, cases will be sent via email to you for your records. You can include a comma separated list of email recipients who will also receive a copy of the case issue exchanges.

## Close Case

When an issue is closed to your satisfaction, click the close case button.
# EmbedThis<sup>&reg;</sup> Builder

The Builder is a site and service that helps you create and manage your internet connected devices. It is used to define your connected device products, download device agent software, and configure, control and manage cloud-based services. It is also the portal to purchase subscriptions, receive support, and resolve issues with the guidance of EmbedThis staff. 

To get started with the Builder, you need to create an account.

![Builder Site](/images/builder/home.png){class="screen"}

## Builder Overview

Using the Builder you can perform the following tasks:

* Create product definitions for your connected devices.
* Select, license, and purchase embedded device agents.
* Create and deploy device clouds from which to manage your devices.
* Upload device data models for synchronizing device data in the cloud.
* Configure and manage Over-The-Air software upgrades for your devices.
* Access support documentation and samples.
* Connect with Embedthis support to raise and track support issues.
* Purchase and pay online for your EmbedThis subscriptions.

## Getting Started

Depending on your use case, your process flow with the Builder will vary.

We've created guided walk-throughs depending on your role:

* [For Product Managers](start/for-product-managers.md)
* [For Cloud Engineers](start/for-cloud-engineers.md)
* [For Embedded Engineers](start/for-embedded-engineers.md)
* [For Purchasing and Procurement Roles](start/for-purchasing.md)

And your use case:

* [Cloud-Managed Devices](start/cloud-managed.md)
* [Device-Managed Devices](start/device-managed.md)
* [Managing Subscriptions](plans/subscriptions.md)
# Action Triggers

An Action Trigger will monitor a data source and evaluate device and service data to see if a predefined condition is true and if so, invoke the associated action.

Three varieties of action triggers are supported:

* Direct
* Streamed
* Polled

**Direct** triggers respond to user actions or HTTP requests to the device cloud endpoints.

**Streamed** triggers monitor data as it is received by the device cloud from devices.

**Polled** triggers run at a per-trigger frequency. This can be set to any number of minutes, hours, or days.  While event triggers are run whenever the designated event is received by the Ioto device cloud.

Source | Type | Description
-|-|-
Database Value | Polled | Read a device database item value.
Database Sync | Event | Monitor synchronized device data that matches trigger expressions in the device schema.
HTTP | Event | Respond to an incoming HTTP request.
Metric | Polled | Monitor device and service metrics.
User | Event | Respond to a user action from a device app.

## Matching Triggers

When a trigger event is received or polled, the associated trigger data is evaluated and compared with a **trigger expression**. If the expression evaluates to true, the trigger action is automatically invoked.  For example, if you were polling a **temperature** field for a device, you could define a trigger expression to activate when the temperature exceeds 100 degrees.

When a trigger is activatated, it will pass parameters to the action to customize its behavior based on the specific trigger conditions.

## Trigger Expressions

The trigger expression is a JavaScript like expression that is evaluated to yield a true or false result.
If true, the Trigger action is invoked.

The trigger expression is provided with a context of variables that can be accessed by the expression. The context is a blend of user provided variables and internal state. The fields for a database item are provided as named variables. For metric data sources, the metric result is provided as a **value** variable. For example, you can test a metric value via:

```
value > 0
```

See [Expressions](../../apps/config/expressions.md) for more information on the expression syntax.


## Database Value

Database values can be queried according to a polling schedule. To specify the database item to query, you must specify the:

* Table name
* Item keys
* Item filter properties

The Builder and Device Cloud provides data modeling and storage of application data. Data items can be retrieved by specifying the appropriate item key. Other properties can be provided to further filter the data to be queried.

## Polled Metric Value 

Metric values can also be queried according to a polling schedule. To specify the metric item to query, you must specify the:

* Metric namespace
* Metric name
* Metric dimensions
* Metric statistic
* Metric period

Metrics are grouped into namespaces and have a unique metric name. Metrics can also have dimensions where a set of resources may have unique metric values for each resource.

The metric statistics supported are: min, max, avg, sum, count and current. Sum is the sum of values over the request period. Count is the number of values sampled over the period. Current is the most recent updated value.

The metric period should be set to the last 5 minutes, hour, day, week, month or year.

The Builder console provides pulldown lists for each of these fields based on the available metrics on your system.

For more information on metrics, please see [Metrics](/agent/metrics/#metric-naming).

## Streamed Device Data

As device data is sent to the device cloud, data can be used to activate an automation trigger.

## REST API requests

You can issue REST API requests to invoke an automation.

```bash
https://DEVICE_CLOUD/tok/trigger/invoke
```

The POST request accepts a JSON body with the following parameters:

* name
* context

Where **name** is the name of the trigger to invoke. The **context** contains data that will be made available to your automation trigger and action request message/body. These context values can be expanded by using a **${data}** token in the message/body. You can add any context variables you wish to the context.

For example:

```bash
curl -X POST \
    https://xxxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com/tok/action/invoke \
    -H 'Authorization: xxxxxxxxxxxxxxxxxxxxxxxxxx' \
    -H 'Content-Type: application/json' \
    -d '{"name":"AutomationTest", "context":{"data":42}}'
```

When you edit your automation in the Builder, the sample curl command will be displayed.

See [Authentication](/ioto/ref/authentication.html) for how to authenticate HTTP requests.

## UI Triggers

The UI triggers is an alias for the REST API trigger. The DevCore framework will invoke the REST API when a user clicks on a widget with the associated action defined.# Automations Overview

When developing an IoT solution, it's ideal to implement **automatic**, pre-programmed responses for when your devices or fleet encounter important conditions. Constantly monitoring every aspect of device status around the clock is **impractical**. By defining automated actions, you can enhance your device fleet's intelligence, responsiveness, and availability.

Automated actions can transform your device cloud from a passive data repository into an intelligent, active and adaptive service. For example, automated actions can be used for the following scenarios:

* **Display device errors** in an alert list in the manager device UI.
* **Aggregate fault metrics** for devices and create dashboards for fleet health.
* **Send alert email** notifications to field staff for servicing.
* **Integrate with systems** and services from 3rd parties. 
* **Invoke device actions** in response to user input or measured device state.
* **Compute device state** to be reflected in the device app.

The Builder provides Automated Actions that can detect a wide variety of conditions and automatically initiate configured actions to alert or respond accordingly.

## Ioto Automations

The Builder enables automation via Actions and Alerts. Automation Actions monitor device and cloud states to evaluate data and determine if a predefined trigger condition is met. Automated Actions are invoked by condition triggers to respond and implement a specific remedy or notification. Alerts are a type of action that create human readable messages for display by the Builder console or device app.

The EmbedThis Builder is used to create Actions that are deployed to the relevant device cloud and device apps. To create an Action, navigate to the Automations sidebar menu option and click Add Action.

![Action List](/images/builder/action-list.avif){class="screen"}

When creating an Action, you define the **Trigger** that monitors device or cloud state for specific conditions. **Condition Triggers** can be defined for various sources, including device data, device metrics, cloud state, HTTP endpoints, or device app actions.

To learn more, read about: 

* [Condition Triggers](triggers.md)
* [Actions](actions.md)
* [Alerts](alerts.md)
# Alerts

The Builder provides special actions to create Alert message notices.

Alert notices can be created in either the Builder or device app via the the **Alert** and **Builder Alert** actions. When combined with triggers, Alert notices provide log of device error and other important conditions and state.

Alerts log messages are saved in the Builder and Device Cloud databases. Alert notices are uniquely fingerprinted by the trigger context at the time of activation. Repeat alerts for the same fingerprint are aggregated and a count of repeats is displayed in the console.

![Alert View](/images/builder/alert-view.png){class="screen"}
# Actions

When triggered, automation actions run to implement an appropriate notification or response action. Examples of automation actions include creating alerts, defining metrics, performing device operations, updating the device database and sending email notifications.

Automation actions respond to initiation by triggers and utilize the trigger context as parameters to tailor the action's execution.

### Action Types

Type | Description
-|-
Builder Alert | Create an alert in the Builder account
Builder Metric | Create a metric in the Builder account
Database | Create, update or remove an item in the device database
Device | Perform a device operation: release or reboot
Manager Alert | Create an alert in the device app account
Manager Metric | Define a device metric
HTTP | Invoke a HTTP REST API
Email* | Send an email message
Lambda* | Invoke a Lambda 
MQTT Message* | Send an MQTT message
EventBridge* | Send an EventBridge event

The Email, Lambda, MQTT and EventBridge actions require a dedicated device cloud.

Some actions are configured with specific parameters. For example, an email action defines the email recipients, whereas an HTTP action defines the HTTP method, URL and HTTP headers. The action parameters are combined with the trigger parameters when the action is run.

## Message Context

Most actions have a message or request body textarea. This message can contain context variables that are expanded at runtime. For example, an email action could take a email message:

    The metric value is ${value}

When the action is invoked, the `${value}` reference is replaced with the metric value. The context of variables is a blend of variables provided to the trigger (such as via a HTTP POST body), the result of the trigger (metric or database value) and internal state.

## Rearming Delay

After a trigger has been activated and an associated action has been run, it can be useful to suppress further actions for a period of time. The rearm delay can be one or more minutes to suppress further triggers from activating.

## Enable

Actions can be enabled or disabled at any time.

![Action List](/images/builder/action-list.png){class="screen"}# Creating Apps

For each device cloud, you can create one or more apps to manage your devices. 

You can create one or more device apps using the Builder's app list.

![App List](/images/builder/app-list.png){class="screen"}

From the App list, click on the `Add` button to create a new app or click on the `Edit` icon for an existing app. This will display the App panel from which you can create and modify an app's configuration.

![App Modify](/images/builder/app-modify.png){class="screen width-70"}

### App Domain Name

Apps are hosted by EmbedThis on a sub-domain of your choosing under the **ioto.me** domain. You can select a unique sub-domain that reflects your company or product's brand. The sub-domain name you choose must be globally unique. Alternatively, you can register your own domain name and point that to the underlying app site.

To use an Ioto sub-domain, enter the sub-domain name of your choosing. To use a self-hosted domain, check the "Self Hosted Domain" checkbox and enter your full domain name.

### App Code Base

You can create apps based upon the [EmbedThis DevCore](/apps/) UI framework or you can create your own bespoke app using a custom code base.

By default, apps are created using DevCore which provides the core app functionality needed by most device management apps.

You can rebuild the DevCore and upload either a custom build or your own bespoke app using the Ioto cloud APIs.

Once created, the app can be customized by using the build-in app designer. 

## Versions

When using the DevCore UI framework, you can select the version of the framework to use when creating the app. The "**latest**" version option uses the latest stable version of the framework. The "**beta**" version option uses the most recent development version of the framework. Otherwise, you can select a specific version number. If you select "**latest**" or "**beta**" and you save the app configuration, the underlying framework code is automatically updated.

## Owner Email

For each app, you can specify the owner email address. This email address is used to grant **owner** permissions when that user logs into the app. The **owner** role has full access to the app and utilize the built-in low-code app designer to modify the app. The owner can invite other users to join the app by sending them an invitation email.

## User Allow List

You can restrict access to the app to a specific list of users. To do this, enter the email domains or addresses of the users you want to allow access to the app. If you specific a domain, all users with email addresses under that domain will be allowed access. If you specific an email address, only that user will be allowed access. You can specify multiple email domains or addresses by entering one per line.

## Preserve Assets

When updating an app's configuration, the Builder will overwrite existing assets. If the **preserve Assets** option of the app configuration panel is selected, assets under the app's **"theme/"** directory will be preserved. This is useful when using the low-code app designer to preserve the app's display, theme and other themeable assets.

If you are using a custom code base that contains assets under the **"theme/"** directory and have selected the preserve assets option, the assets in the code base under a **theme/** directory will **NOT** will overwrite any exist assets under **theme/**.
# Device Apps

The Builder enables the creation of device management apps tailored to your devices and services. It supports app configurations for both local management through the agents embedded web server and remote management via the cloud.

With the flexibility to create multiple apps, the Builder can cater to diverse user groups such as end-users, developers, and support teams. For cloud-based management, the Builder seamlessly hosts and globally distributes these applications through device clouds, ensuring efficient deployment and accessibility at scale.

![Home Page](/images/eco/eco-home.avif){class="screen width-50 center"}

<div class="clear" />

## DevCore UI Framework

Device management apps can be developed using the EmbedThis `DevCore` UI framework or implemented as custom solutions leveraging the Ioto APIs. The `DevCore` framework is a flexible and robust UI library designed for managing devices across mobile, tablet, and desktop platforms. It provides core features such as authentication, state management, request handling, navigation and routing, as well as tools for device configuration and data visualization.

## Default Management App

Device applications are defined from the Builder's App list after specifying key parameters, such as the app name, title, logo, serving domain, code base, and the app UI display.

The UI of an app based upon the `DevCore` is defined via a `display.json5` configuration file. This defines the UI navigation and page order. The display config file permits quick and easy modification of the app to add and remove UI pages. 

### Developer App

When you first define an app, the Builder creates a default management app based upon on the DevCore framework. This app has generic `Developer` UI definition suitable for testing your devices as you develop your IoT solution. This app can be progressively customized or extended to meet custom UI requirements.

![Ioto Device App](/images/manager/standard.avif){class="screen"}

## Low-Code App Designer

Once the app is created, you can launch the app from the Builer's app list and then you can modify the app UI and pages using the integrated low-code `App Designer`. This tool offers a visual interface for designing app UI pages efficiently greatly reducing development time.

![App Designer](/images/builder/flow-layout.avif){class="screen width-100"}

For scenarios requiring deeper customization, EmbedThis provides full control over the app's user interface via the `display.json5` UI definition file. Custom UI components can be developed and added to the display definition to address unique requirements. Additionally, with access to the app's source code, engineers can fine-tune both functionality and appearance to meet specific use cases.

### Custom Apps

If you have specific requirements that mean you cannot use the App Designer and the DevCore, you can utilize the Builder and Ioto service APIs directly and create your device app using any app framework you require.

## Sample Desktop App

![Home Page](/images/manager/home.png){class="screen"}
# Authentication Tokens

The EmbedThis Builder and the Ioto service use tokens to securely authenticate and authorize access to the builder and device clouds.

Each token can be used for a purpose that is specified via the token's **type**. When used for this purpose, the token bearer can assume the tokens **role** to act upon the system.

![Token List](/images/builder/token-list.png){class="screen"}

The Token List is segmented into three groups

* Service Tokens &mdash; Tokens for access to the Builder service and Product ID tokens for registration.
* Cloud Tokens &mdash; Tokens for access to Device Clouds.
* Device Tokens &mdash; Device tokens for access by devices to a Device Cloud.

Tokens have the follow properties:

* Type &mdash; the token purpose
* Description &mdash; human readable token description
* Enable &mdash; whether the token is currently enabled or disabled
* Expires &mdash; the date upon which the token expires and cannot be used
* Role &mdash; the authorized role the token bearer will assume
* ID &mdash; the token ID to present when using the token for access
* Cloud &mdash; the device cloud ID if the token is created by the device cloud


## Token Type

The following token types are currently used by the Builder and Ioto

* BuilderAPI &mdash; Used for general API access to the Builder API as an administrator.
* ProductID &mdash; Used when registering devices in the device.json5 file.
* CloudID &mdash; Used when claiming devices for management for a device cloud.
* CloudToBuilder &mdash; Used by device clouds to issue requests to the builder.
* BuilderToCloud &mdash;  Used by the builder to issue requests to a device cloud.

![Token Modify](/images/builder/token-edit.png){class="screen"}


## Token Description

The token description may be modified to help you document the purpose of a specific token.

## Token Enable

A token can be temporarily disabled by **suspending** a token. Should you experience a cyber attack or breach, you can immediately suspend tokens to minimize the damage while you investigate. When all is clear, you can **resume**, **replace** or **delete** the offending tokens.

## Token Expiry

Each token will expire on a specified date. You can modify tokens to change the expiry date.

## Token Role

When a token is presented, it grants the access to the relevant resources using the token's role.

The following roles are supported:

* public &mdash; Grants minimum privilege appropriate for unauthenticated users.
* user &mdash; Grants read-only access at the "user" level.
* admin &mdash; Grants administrator access which provides general read/write access.
* owner &mdash; Grants administrator and owner access which provides access to billing.
* device &mdash; Grants access suitable for a device.
* builder &mdash; Grants access suitable for the builder to act upon a device cloud.

## Token Actions

* New &mdash; Create a new token. If you selected an existing token, the new token will clone the properties of the original token. The original token is not impacted.
* Replace &mdash; An original token is expired and a new active token is created with the same type, description and role.
* Resume &mdash; Resume a suspended token.
* Suspend &mdash; Suspend a token. The expiry date is not changed.
* Delete &mdash; Delete a token.

## Using Tokens

When using REST APIs, you can present the token ID in the X-Token or Authorization HTTP headers. The format should be like:

```
X-Token: 01GEXXXXXXXXXXXXXXXXXXXXXX
```

From the token list, you can select the **clipboard** icon in the token's ID column to copy the ID to your PC's clipboard.

Embedthis has deep and broad experience creating embedded device, management interfaces and web applications that have been deployed in hundreds of millions of devices world-wide.

>We specialize in doing *tough, critical* technology and applications. Our clients usually have stringent requirements and high expectations. We pride ourselves in exceeding these expectations.

## Service Models

We can work with your team in a variety of ways:

**Outsourced development**. Give us the whole or a piece of your project and we will deliver back to you complete, reliable, secure and documented solutions. Our work is clean, proven and easy to assimilate back into your organization. We'll even train you.

**Consultant**. Use us to help, validate and confirm your designs and directions. We can help spare you critical mistakes.

**Team member**. Regard us as one of your team. We can do the hard parts and participate in your development process and deliver critical pieces on time and under budget. Some companies keep us on retainer as an ongoing part of their team.

Embedthis can work on a time and materials basis or fixed price quotation after the provision of detailed requirements.

## Capabilities

Embedthis has extensive experience with many platforms and technologies including:

* IoT and cloud-based device management especially AWS and AWS IoT.
* Linux, Windows, VxWorks, FreeRTOS and other embedded operating systems.
* X86, Arm, Mips and other embedded CPUs.
* TCP/IP, TLS, MQTT and other networking.
* AWS Cloud including: IoT, DynamoDB, Lambda, IAM, CloudFront, EC2, ECS, ...
* Javascript, HTML, VueJS and single page web applications.
* Embedded Device security.

Please contact us at [sales@embedthis.com](mailto:sales@embedthis.com) to discuss your project needs or sign up and pay-as-you-go at the [Builder Support Center](https://admin.embedthis.com/support).

## Consulting Help

Whether you have a new device project or an existing product, a review of your embedded management design can spot and fix potential issues. We can review your design, security and code to ensure you are on the right path.

### Cloud Management

Managing devices from the cloud is non-trivial. It requires familiarity with both embedded design and cloud environments. Embedthis can guide you through the process of moving to the cloud. We can assist with:

* Setting up your EmbedThis Ioto account
* Configuring your AWS IoT account
* Building and integrating the Ioto agent
* Creating a connected embedded device
* Connecting to the cloud and device communications
* Creating cloud-based management applications

### Data Modeling and Mapping

It is critical when designing your device data schema to ensure that you can support all your desired analytics and operational management requirements. We can assist in creating and reviewing your device data model so that it can meet your needs of today and tomorrow.

## Billing

Consulting services hours can be purchased as needed via the [Builder Support Center](https://admin.embedthis.com/support).

There is a minimum commitment of 2 hours and you can purchase developer services as you require.


## Contact

To discuss your project, please contact us at [Embedthis Services](mailto:services@embedthis.com).

## Customer Quotes

> "Embedthis are hands down the best embedded engineering team I have ever worked with. Their code is exceptionally clean, elegant, and an inspiration to avid software developers. Embedthis knows how to hit a deadline and provide extraordinary transparency in the development process. If you're doing embedded work, I can't think of anyone that would be better to have on your team. They are really pushing the edge of what tiny processors can do, putting the web platform on the head of a pin. Literally." *Scott Penberthy, Gilt Group.*

>"Embedthis are great to work with and they played a critical role in designing and building our embedded web management application. They were well organized, knew how to cleanly walk through the process; guiding us each step of the way. They provided excellent support as we worked through the final details to modify the code before delivery to our customer." *Greg Hoepfner, Colmek.*

>"Embedthis was an integral part of our development and they did outstanding work for us. They consistently exceeded our expectations while delivering complex pieces of technology. They enabled us to launch to market much sooner than expected and their code was clean, compact and very high quality." *Roy Satterthwaite, Bling Software.*
# Devices

The Builder maintains a list of all devices for each device cloud in your account.
From this list you can `release` and `remove` devices. Most device management tasks are done from the Device app.

![Devices](/images/builder/device-list.avif){.screen}

For each device, the device list shows the device name, the device cloud, and the device state. The state is whether the device is claimed or not by a user for management.

From the list you can release a device from being managed by a user. This is useful when a device is transferred to a new user.

You can also remove a device from the device cloud. This is useful when a device is no longer in use and you want to remove it from the device cloud.

![Devices](/images/builder/release-device.avif){.screen}
# Device Table Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-table basis.

## Databases

The Ioto service creates an AWS DynamoDB database table called **ioto** in each device cloud. The **ioto** database table contains the device data and cloud management data for all connected devices in that cloud.

Similarly, the Ioto device agent creates a local embedded database to hold structured data for the device.

These two databases are connected and Ioto replicates changes between device and cloud to keep them in sync.

## Why Synchronization?

The Ioto Database Synchronization service dramatically eases the task of centralizing the data management of a pool of devices. Each device can store data locally and it will be transparently, efficiently and automatically replicated to the cloud. Once in the cloud, it can be easily interrogated and queried for analytics, operational control and intelligence.

Each side has fast, predictable local access to the data. Coupled with reliable replication semantics you can work locally while Ioto takes care of the replication.

## How It Works

To replicate cloud-side data, the Ioto service uses AWS DynamoDB streams to capture modifications made to the cloud-side table data. The stream is connected to a Lambda function that encodes and sends the updates via MQTT messages to a special message topic that is only known to the specific device.

The Ioto device agent subscribes to this topic and receives MQTT messages containing the changed data. The agent then applies those changes to the local database.

In reverse, the Ioto agent registers a database trigger that is called whenever local changes are made to the device's database. When the trigger is invoked, the agent sends an MQTT message with the changes to the Ioto service that updates the cloud database.

Ioto keeps track of the last update sent and received and will retransmit lost updates.

When a device is rebooted after being offline, it sends a "sync" message to the Ioto service to retrieve all changes made to the cloud database since the last change notification was received from the cloud. In this way, changes made while the device is offline or disconnected are not lost.

## Controlling Replication

The cloud-side Ioto DynamoDB table (ioto) and the Ioto agent database both use a [OneTable](https://doc.onetable.io/) schema that defines application data entities, how items are stored, what indexes are used and how to process table data. For example:

```js
const DeviceSchema = {
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault: {sync: 'up'},
    },
    models: {},
}
```

The **"process"** property of the schema defines how to process table data and how tables are synchronized between the device and cloud.

For each database item type in the schema, you can create an entry in the "process" property that specifies where items of that type should be stored and how they should be synchronized.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for item types that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Requirements

Any model that defines a **sync** direction of "up" or "down" must include the following properties in the model definition:

Property | Definition | Description
-|-|-
updated | {type: 'date', readonly: true} | Timestamp for when the item was last updated
_source | {type: 'string', hidden: true} | The source of the last update

The **updated** timestamp property is used to determine the set of updates that have been made to the database since the device last connected to the device cloud. The **_source** property is used to determine the direction of synchronization for an item.

The **bin/make-schema** script that is used when building the Ioto agent and apps will automatically add these properties for synchronized models.# Database Processing

The **schema.process** is a map of properties that control how data is stored in the database and how the data is processed. 

The `process` definitions define the following attributes:

* Where the database item will be stored: device / cloud / both.
* In what direction the database syncronization will flow: to-device / to-cloud / both.
* What metrics should be created from the data stream.

For each item type, you may define an entry in the **process** collection. For example:

```js
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

Each map entry may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| enable | `string` | Control where the item is stored. Set to 'cloud' for in the cloud, 'device' for on the device and 'both' if in both locations. Defaults to 'both'. |
| sync | `string` | Define the direction of the data synchronization. Set to 'down' for down to the device, 'up' for up to the cloud, or 'both' for bi-directional. Defaults to null. |
| metrics | `Array` | Array of metric definitions. See below for details.|
| notify | `boolean` | Issue an AWS EventBridge notification event for matching data. Defaults to false.|

## Database Synchronization

Ioto Device Tables takes the pain out of synchronizing device data into the cloud. It automatically and transparently synchronizes data between your devices and the cloud.

The database synchronization is full-duplex in that data can be modified in the device or in the cloud and it will be replicated to the other side. The synchronization is controllable on a per-item basis.

The **"enable"** property can be set to **"cloud"** if items of that type should exist only in the cloud database. Set the property to **"device"** if the items should exist only in the device. Set to **"both"** if they should exist in both databases. The default is **"both"**.

The **"sync"** property defines the synchronization direction. Set to **"up"** to indicate the device data should be synchronized from the device up to the cloud. Set to **"down"** to indicate the cloud data should be replicated down to the device and set to **"both"** to replicate in both directions.

>To design for effective synchronization, it is best to have the **"sync"** direction be either **"up"** or **"down"** and not **"both"**. You should only select "both" for items that are not transactionally critical, as changes from the cloud or device may overwrite changes coming from the other directions.

Synchronization is done on a per-item basis and not field by field. This means that if you update a field in an item, the entire item will be updated on the peer side.

## Metrics

For data that is synchronized to the cloud, you can create custom metrics from the data stream. These metrics can then be displayed or graphed in the device apps.

These metrics can be created by creating a Builder Automation action to trigger when specific data values are encountered.

<!--
In the **process** section for an item, define a **metrics** array of metric definitions. Each definition selects a data item value to be converted to a metric.

For example:
```
const DeviceSchema = {
    process: {
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: [{Temperature: 'temp'}],
                dimensions: [{Device: 'deviceId'}]
            }]
        }
    },
    ...
}
```

This will create a `temperature` metric from the item's `temp` attribute.

Metric definitions may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| buffer | `map` | Metric buffering directives. Defaults to null.|
| dimensions | `array` | Array of metric dimensions. Defaults to null.|
| fields | `array` | Array of metrics to create. Array metric entries may contain field attribute names or a map of a field attribute to a metric name. |
| namespace | `string` | Metric namespace for the metric. Must be set to 'Embedthis/Device'. |
| where | `string` | Conditional expression to select items for which to create metrics. |

The metric `namespace` scopes the metrics and must be set to 'Embedthis/Device'. Other namespaces may be supported in the future.

The `fields` property contains an array with one or more metric definitions. Each definition may be either:

* An item attribute name which is used to identify the value AND to name the metric.
* A map of an item attribute name to a metric name.

For example:

```js
{
    fields: ['temperature', 'status', 'speed']
}
```

This would create three metrics using the item's `temperature`, `status` and `speed` attributes. The metrics would take the same name.

Wheras:

```js
{
    fields: [{Temp: 'temperature'}, {Online: 'status'}, {Level: 'speed'}]
}
```

This would create the metrics: `Temp`, `Online` and `Level` from the `temperature`, `status` and `speed` item attributes.

The `dimensions` property contains an array of dimensions that scope the metric. The elements of the dimensions array can be either field names or objects that map field names into a dimension name. If the values are quoted, they are used as literal values. If unquoted, they are regarded as database item field names.

For example:

```js
process: {
    Fault:   { 
        sync: 'up' 
        metrics: [{
            namespace: 'Embedthis/Device',
            fields: ['temperature'],
            dimensions: [{}, {Device: 'deviceId'}]
        }]
    }
}
```
#### Where Expressions

The `where` property can be used to select matching items for which to create metrics. `Where` expressions use a query language is based on familiar Javascript expressions with some additional operators. Item attributes are expressed as variable names and literal values are expressed as JavaScript values.

For example: the expression:

    error == "critical" && component == "PS1"

See [Database Metrics](/agent/metrics/) for details.
-->

## Event Notification

For dedicated device clouds, you can issue AWS EventBridge events for matching database items via the **notify** property.  The `notify` property is set to the EventBridge bus name. It can be set to "default" or any custom EventBridge bus name.

The database item will be passed to the EventBridge bus as the event context data using the `Embedthis/Ioto` as the event **Source**.

For example:

```js
{
    Store: {
        enable: 'both',
        sync: 'up',
        notify: 'default',
    }
}
```
# Model Attributes

The database schema supports the following attribute properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| default | `string` | Default value to use when creating model items or when reading items without a value.|
| generate | `string|boolean` | Set to 'ulid' or 'uuid' to automatically create a new ID value for the attribute when creating new items.|
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. If unset, the field will use the table default value for isoDates. Default to the schema params value. |
| nulls | `boolean` | Set to true to store null values or false to remove attributes set to null. Default false. |
| required | `boolean` | Set to true if the attribute is required. |
| schema | `object` | Nested schema. |
| ttl | `boolean` | When set to true for date fields, the date value will define when the item should be transparently removed. |
| type | `Type or string` | Field data type. |
| value | `string` | Template to derive the value of the attribute. These attributes are "hidden" by default. |


If the **default** property defines the default value for an attribute. If no value is provided for the attribute when creating a new item, the **default** value will be used.

If the **isoDates** property is defined and not-null, it will override the table isoDates value. Set to true to store the field date value as an ISO date string. Set to false to store the date as a Unix epoch date number.

The **schema** property permits nested field definitions. The parent property must be an Object as the type of items in arrays are defined using the **items** property.

The **type** properties defines the attribute data type. Valid types include: String, Number, Boolean, Date, Object, Null, Array, Buffer (or Binary) and Set. The object type is mapped to a **map**, the array type is mapped to a **list**. Dates are stored as Unix numeric epoch date stamps unless the **isoDates** parameter is true, in which case the dates are store as ISO date strings. Binary data is supplied via **buffer** types and is stored as base64 strings in DynamoDB.

The **value** property defines a literal string template that is used to compute the attribute value. This is useful for computing key values from other properties, creating compound (composite) sort keys or for packing fields into a single DynamoDB attribute when using GSIs.

String templates are similar to JavaScript string templates. The template string may contain **${name}** references to other fields defined in the entity model. If any of the variable references are undefined when an API is called, the computed field value will be undefined and the attribute will be omitted from the operation.

If you call **find** or any query API and do not provide all the properties needed to resolve the complete value template, such as if some of the ${var} references are unresolved, OneTable will take the resolved leading portion and create a **begins with** key condition for that portion of the value template.
# Database Schemas

Ioto uses database schemas to define what are the database data entities and how these will be stored in the database.

A schema specifies the application item types called models. If you are from a SQL background, think "tables". The schema also defines the item fields, indexes and other data access and replication parameters.

Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) schema format, implementing the [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).

The same schema is used for the cloud side AWS DynamoDB table and for the device side embedded database.

## Schema Definition

Schemas look like this:

```js
const DeviceSchema = {
    format: 'onetable:1.1.0',
    version: '0.0.1',
    indexes: {
        primary: {hash: 'pk', sort: 'sk'},
    },
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault:   { 
            sync: 'up',
            triggers: true,
        },
    },
    //  These are the database tables
    models: {
        Status: {
            pk: {type: 'string', value: 'status#'},
            sk: {type: 'string', value: 'status#'},
            parameters: {type: 'object'},
            version: {type: 'string'},
            updated: {type: 'date'},
        },
        Fault: {
            pk: {type: 'string', value: 'device#${deviceId}'},
            sk: {type: 'string', value: 'fault#${id}'},
            deviceId: {type: 'string', required: true},
            id: {type: 'string', generate: 'ulid'},
            timestamp: {type: 'date', required: true},
            source: {type: 'string', required: true},
            severity: {
                type: 'string',
                required: true,
                enum: ['info', 'warn', 'error', 'critical', 'fatal'],
            },
            subject: {type: 'string', required: true},
            message: {type: 'string', required: true},
        },
    },
    params: {
        isoDates: true,
        timestamps: true,
    },
}
```

## Schema Purpose

AWS DynamoDB can operate most efficiently at scale when using a single table with multiple application entities stored in the one table. To make this design pattern easy to implement, application data schemas such as the one used by [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) provide the mapping between application level entities and raw database items.

Ioto uses the OneTable schema in both the DynamoDB table and in the Ioto agent database.

When coupled with a high-level database API such as that offered by OneTable and by the Ioto Agent Database, accessing and managing device data is both performant and straightforward.

## DynamoDB Schema

In Device Clouds, Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) NodeJS library for all access to the **ioto** DynamoDB table. This library has an extensive suite of features beyond those implemented by the Ioto device agent database.

Please consult the [OneTable](https://github.com/sensedeep/dynamodb-onetable) library and [OneTable Documentation](https://doc.onetable.io/) for background.

## Schema Properties

The valid properties of the **schema** object are:

| Property |  Type  | Description                                                                                  |
| -------- | :----: | -------------------------------------------------------------------------------------------- |
| format   | string | Reserved. Must be set to **onetable:1.1.0**                                                  |
| indexes  | object | Hash of indexes used by the table.                                                           |
| models   | object | Hash of item types describing the item keys, indexes and attributes.                    |
| params   | object | Hash of properties controlling how data is stored in the table.                              |
| process  | object | Hash of items describing where the items should be stored and how they should be replicated. |
| version  | string | A SemVer compatible version string.                                                          |

The **format** property specifies the schema format version and must be set to **onetable:1.1.0**.

The **indexes** property specifies the key structure for the primary, local and secondary indexes.

The **models** property contains one or more database item types with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties.

The **params** property defines additional parameters for table data formats.

The **process** map defines how database items should be processed, stored, replicated and whether metrics should be calculated from the data stream.

The **version** property defines a version for your Database design. It must be a [SemVer](https://semver.org/) compatible version string. The version string is used by tools and consumers of the schema to understand compatibility constraints for the schema and stored data.

## Schema Models

The schema defines the database item types as models. For example, consider a music example:

```js
models: {
    album: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        songs:  { type: 'number' },
    },
    artist: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        address: {
            type: Object, schema: {
                street: { type: 'string' },
                city: { type: 'string' },
                zip: { type: 'string' },
            },
        },
    }
}
```

For each item type, all the entity fields are defined by specifying the field type, validations and other operational characteristics (uniqueness, IDs and templates).

The valid types are: array, binary, boolean, date, number, object, and string.

The database will automatically add an item type property via the **\_type** attribute. This is set to the name of the model. You can modify this via the **params.typeField** setting.

## Value Templates

The value of a field can be computed based on the value of other fields and a formatting "value template". This is useful for decoupling your key structure from your entity fields.

The value template is like a Javascript string literal where the value of fields are expressed in a "${field}" format. At runtime, the field references are expanded with the item's value for the named field.

In the example above, the primary key "pk" is calculated from the entity type **\_type** and the **name** field by using the value template: **${_type}:${name}**.

## Nested Schemas

For object attributes, you can define a nested schema for the object properties, as in the example above (repeated below).

A nested schema uses the **schema** property to define a nested map of attributes. Schemas can be nested to an arbitrary depth.

```js
address: {
    type: Object, schema: {
        street: { type: 'string' },
        city: { type: 'string' },
        zip: { type: 'string' }
    }
}
```

## Database Indexes

Schema indexes are defined using the **schema.indexes** property.

The **indexes** property can contain one or more indexes and must contain the **primary** key. Additional indexes will be treated as secondary Indexes.

!!!Note
    Ioto currently only supports the primary index.

```js
const MySchema = {
    indexes: {
        primary: {
            hash: 'pk',         //  Schema property name of the hash key
            sort: 'sk',         //  Schema property name of the sort key
        },
        //  Zero or more global secondary or local secondary indexes
        gs1: {
            hash: 'gs1pk',
            sort: 'gs1sk',
        }
    }
}
```

## Schema Params

The **schema.params** is a map of properties that control how data is stored in the database. It may contain the following properties:

| Property | Type | Description |
| -------- | :--: | ----------- |
| createdField | `string` | Name of the "created" timestamp attribute. Defaults to "created". |
| hidden | `boolean` | Hides templated (value) attributes in Javascript properties. Default true. |
| isoDates | `boolean` | Set to true to store dates as Javascript ISO strings vs epoch numerics. Default false. |
| nulls | `boolean` | Store nulls in database attributes vs remove attributes set to null. Default false. |
| timestamps | `boolean | string` | Make "created" and "updated" timestamps in items. Set to true to create both. Set to 'create' for only "created" timestamp and set to "update" for only an "updated" timestamp. See also: "updatedField" and "createdField" properties. Default false. |
| typeField | `string` | Name of the "type" attribute. Default "_type". |
| updatedField | `string` | Name of the "updated" timestamp attribute. Default "updated". |

For example:

```js
const MySchema = {
    params: {
        isoDates: true,
        timestamps: true,
    }
}
```


## References

- [DynamoDB OneTable Overview](https://www.sensedeep.com/blog/posts/2021/dynamodb-onetable-tour.html)
- [DynamoDB with OneTable Schemas](https://www.sensedeep.com/blog/posts/2021/dynamodb-schemas.html)
- [Data Modeling for DynamoDB](https://www.sensedeep.com/blog/posts/2021/dynamodb-singletable-design.html)
- [SenseDeep DynamoDB Data Browser](https://www.sensedeep.com/blog/posts/series/dynamodb-studio/data-browser.html)
- [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).
# Device Tables Overview

Ioto Device Tables is a global, replicated, multi-active database solution that transparently synchronizes data between devices and the cloud.

Similar to AWS DynamoDB Global Tables for replicating data between AWS regions, Ioto Device Tables connects a cloud-side AWS DynamoDB database to a device-resident Ioto embedded database.

Device Tables take the pain out of replicating data between devices and the cloud. Without additional code, it will automatically and transparently synchronize data and state between your devices and the cloud.

Device Tables delivers fast, predictable local read and write access while offering automatic replication of changes.

## Database Replication Features

* Transparent replication between cloud and devices.
* Bi-directional synchronization.
* Per-table synchronization control.
* Resilient catch-up should the device or cloud go offline.
* Database triggers for notification when state data changes.
* Automatic creation of CustomMetrics from the device data stream.

## Challenge

>Aggregating device data in the cloud is not a simple problem.

To centralize device state typically requires several crucial steps:

* State must be captured in the device.
* State must be sent reliably to the cloud despite network disconnections.
* State must be stored and managed in the cloud.
* Conflicts with simultaneous updates must be resolved.
* State updates from the cloud must be sent to the device reliably despite devices being offline.

These factors combine to make centrally aggregating device data decidedly non-trivial.

>Ioto Device Tables solves these issues for you, so you can focus on your device specific logic and value.

## Ioto Agent Embedded Database

The Ioto agent embedded database is an ultra high performance NoSQL database for embedded applications. It supports fast, in-memory, local data access and optional transparent synchronization of data to and from the cloud. The Ioto agent embedded database is designed to be compatible with AWS DynamoDB so that it can easily replicate structured device data to the cloud. It is modeled after [AWS DynamoDB](https://aws.amazon.com/dynamodb/) and the [OneTable](https://doc.onetable.io/) access library.

The database uses Red/black binary search indexes and has controllable local persistence to disk and to the cloud on a per-table basis.

## JSON documents

The database stores items as JSON documents that are a nested collection of properties to arbitrary depth. As JSON is one of the most prevalent data exchange formats, storing data in JSON greatly reduces data replication and API transmission costs.

Ioto includes a powerful JSON query engine that you can use to query and manipulate JSON documents.

## Database Features

* High performance NoSQL management document database.
* JSON document items with flexible query API.
* Efficient import and export of database items.
* Red/black binary search indexes.
* Simple, non-waiting API.
* Controllable persistence with change triggers.
* Transparent bi-directional data synchronization with the cloud.
* Unified data schema between device and cloud databases.
* Based on AWS DynamoDB and DynamoDB OneTable.

# Dashboard

Manage UI Dashboards.

## Create
**Endpoint**

```HTTP
POST /dashboard/create

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Default |
| - | - | - | - |
| css | array |  |  |
| design | boolean |  |  |
| emulate | string |  |  |
| dashboard | boolean |  |  |
| fixed | boolean |  |  |
| framed | boolean |  |  |
| full | boolean |  |  |
| live | boolean |  |  |
| name | string | yes |  |
| options | object |  |  |
| range | object |  |  |
| refresh | number |  |  |
| snap | boolean |  |  |
| toolbar | boolean |  |  |
| type | string |  |  |
| widgets | array |  | [] |
| widgetCss | array |  |  |

**Widget** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Find
**Endpoint**

```HTTP
POST /dashboard/find

```
**Authorized User Role**

```
user

```
**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Get
**Endpoint**

```HTTP
POST /dashboard/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| name | string |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



## Remove
**Endpoint**

```HTTP
POST /dashboard/remove

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

## Update
**Endpoint**

```HTTP
POST /dashboard/update

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Default |
| - | - | - | - |
| css | array |  |  |
| design | boolean |  |  |
| emulate | string |  |  |
| fixed | boolean |  |  |
| framed | boolean |  |  |
| full | boolean |  |  |
| id | string |  |  |
| layout | string |  |  |
| live | boolean |  |  |
| name | string | yes |  |
| options | object |  |  |
| range | object |  |  |
| refresh | number |  |  |
| snap | boolean |  |  |
| toolbar | boolean |  |  |
| type | string |  |  |
| widgets | array |  | [] |
| widgetCss | array |  |  |

**Widget** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



**Response** 

| Field | Type |
| - | - |
| accountId | string |
| css | array |
| design | boolean |
| emulate | string |
| fixed | boolean |
| framed | boolean |
| full | boolean |
| id | string |
| layout | string |
| live | boolean |
| name | string |
| range | object |
| refresh | number |
| snap | boolean |
| toolbar | boolean |
| widgetCss | array |
| widgets | array |

**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |


**Widgets** 

An array of Widgets items.

| Field | Type | Notes |
| - | - | - |
| action | object |  |
| accept | string | File input accept type. |
| anchor | object |  |
| axes | object | Graph axes. |
| css | array |  |
| dashboard | string | Target dashboard to select. |
| dimensions | object | Metric and data dimensions. |
| field | string | Database model field. |
| fields | array | Database table fields. |
| fixed | boolean |  |
| form | string |  |
| footer | string |  |
| format | string |  |
| framed | boolean |  |
| header | string |  |
| height | string | Pixel height. |
| id | string | Unique widget UUID. |
| input | string | Input type. |
| items | string | Input selection items. |
| label | string | Input label. |
| legend | object | Reserved. |
| left | string | Left position (x coord). |
| limit | number | Items limit. |
| max | number | Maximum data value. |
| min | number | Minimum data value. |
| metric | string | CloudWatch Metric. |
| model | string | Database model name. |
| namespace | string | Metric namespace. |
| options | object | Custom options. |
| pivot | string | Table pivot column. |
| placeholder | string | Input placeholder. |
| prefix | string |  |
| range | object |  |
| rows | number | Number of rows in textarea input. |
| show | string |  |
| statistic | string | Math statistic. |
| subtitle | string |  |
| suffix | string |  |
| text | string | Static widget value. |
| ticks | number | Number of axis ticks on x axis. |
| title | string | Widget title. |
| top | string | Top position (y coord). |
| type | string | Widget type. |
| units | string | Metric units. |
| url | string | Image URL. |
| validate | string | Input validation RegExp. |
| width | string | Widget width in pixels. |
| z | number | Z order. |

**Action** 

| Field | Type | Notes |
| - | - | - |
| type | string |  |
| target | string |  |
| conditions | array | Automation Action Conditions. |


**Range** 

| Field | Type |
| - | - |
| anchor | string |
| start | date |
| period | number |
| refresh | number |
| override | boolean |
| timezone | string |



# Metric

API to manage metrics including the ability to get and set metrics, and to get a list of available metrics.<br><br>        The Ioto service creates metrics for device and service data. It stores the current live and historical metric values. Metrics are calculated for for the last "5 minutes", hour, day, week, month, and year. Statistics are kept for the average, min, max, count and the sum of metric values.<br>        <br>        Metrics are named and grouped into [Namespaces](/ioto/metrics/#metric-naming) with metric [Dimensions](/ioto/metrics/#metric-naming) selecting instances of a metric for a specific resoure.

**See Also**

* [Metrics](/ioto/metrics/)

## Get
Get an accumulated metric. <br><br>                This API is used by devices to retrieve a metric statistic over the MQTT protocol.<br>                <br>                To get metrics over REST HTTP, use the **fetch** API.

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /metric/get

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Default | Notes |
| - | - | - | - |
| dimensions | object |  | Dimensions for metric. |
| metric | string |  | Metric name. |
| period | number | 300 | Metric timespan period. |
| statistic | string | avg | Metric statistic. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Metric** 

An array of Metric items.

| Field | Type | Notes |
| - | - | - |
| dimensions | object | Dimensions for the metric. |
| metric | string | Metric name. |
| namespace | string | Always set to Embedthis/Device. |
| owner | string | The service owning the metric. |
| period | number | Metric timespan period. |
| points | array | Array of data points. |
| samples | number | Number of data points in the period. |

**Dimensions** 

Dimensions for the metric.

| Field | Type |
| - | - |
| * | any |


**Point** 

An array of Points items.

| Field | Type | Notes |
| - | - | - |
| value | number | Metric value. |
| timestamp | number | Last update to the metric value in seconds since Jan 1, 1970. |
| count | number | Number of data values contributing to the metric value. |


## GetMetricList
Get a list of available metrics.

**Endpoint**

```HTTP
POST /metric/getMetricList

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Role | Notes |
| - | - | - | - | - |
| cloudId | string | yes | owner | Override, device cloud containing the metrics. |
| namespace | string |  |  | Metric namespace. If not provided, the API returns a list of namespaces. |
| metric | string |  |  | If not provided, returns a list of available metrics. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| namespaces | array | Returns the requested namespace. If not provided, returns a list of available namespaces. |
| metrics | array | If a namespace is provided, returns a list of available metrics. |
| dimensions | array | If a namespace and metric are provided, returns a list of available metric dimensions. |

## GetDeviceSchema
**Endpoint**

```HTTP
POST /metric/getDeviceSchema

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| cloudId | string |

**Response** 

A object.


## Fetch
Fetch metric values.<br>                <br>                This API fetches multiple metric values in a single request.

**Endpoint**

```HTTP
POST /metric/fetch

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| items | array | yes | Array of metric requests. |
| deviceId | string | yes | Device ID owning the metrics. |

**Metric Request** 

An array of Items items.

| Field | Type | Notes |
| - | - | - |
| accumulate | boolean | Accumulate result into a single result. |
| cloudId | string | Device Cloud ID. |
| dimensions | object | Dimensions for metric. |
| field | string | Database field name. |
| metric | string | Metric name. |
| model | string | Database model name. |
| namespace | string | Must be set to Embedthis/Device. |
| period | number | Metric timespan period. |
| statistic | string | Metric statistic. Select from: avg, min, max, count, sum. |


**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Metric** 

An array of Metric Array items.

| Field | Type | Notes |
| - | - | - |
| dimensions | object | Dimensions for the metric. |
| metric | string | Metric name. |
| namespace | string | Always set to Embedthis/Device. |
| owner | string | The service owning the metric. |
| period | number | Metric timespan period. |
| points | array | Array of data points (see below). |
| samples | number | Number of data points in the period. |
| * | any |  |

**Dimensions** 

Dimensions for the metric.

| Field | Type |
| - | - |
| * | any |


**Point** 

An array of Points items.

| Field | Type | Notes |
| - | - | - |
| value | number | Metric value. |
| timestamp | number | Last update to the metric value in seconds since Jan 1, 1970. |
| count | number | Number of data values contributing to the metric value. |


## Set
Set a metric value.<br><br>                This API is used by devices to emit a metric value. It is sent over MQTT rather than via REST.

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /metric/set

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Notes |
| - | - | - |
| metric | string | Metric name. |
| value | number | Metric value. |
| dimensions | array | Array of dimensions for metric. |
| buffer | object | Metric buffering options. |

# Provision

Device provisioning and management APIs.<br><br>These APIs provide devices with the necessary provisioning APIs to manage communications with a device cloud.

## GetCerts
Provision a device with MQTT certificates.<br><br>After a device has been claimed for management by a user into a device cloud, the device can call "getCerts" to request provisioning of MQTT certificates to secure communications.<br><br>This call returns the certificate, private key and communications endpoint to use for secure MQTT communications with the device cloud.

**Endpoint**

```HTTP
POST /provision/getCerts

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

MQTT certificate and endpoints for device communications.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Manager Account ID. |
| certificate | string | X.509 certificate. |
| endpoint | string | MQTT host endpoint for communciations. |
| id | string | Device ID. |
| key | string | X.509 certificate key. |
| port | number | MQTT TCP/IP port number. |
| thing | string | AWS IoT Core thing name for the device. |

## GetCreds
**Get IAM credentials**

Get IAM credentials for use in the device that is hosted in a dedicated cloud.<br><br>This will create temprorary IAM credentials based on the configured Cloud.deviceRole (default IotoDeviceRole).<br>These credentials can be used with appropriate AWS SDK or Ioto AWS Sigv4 APIs.

**Endpoint**

```HTTP
POST /provision/getCreds

```
**Authorized User Role**

```
device

```
**Response** 

A set of AWS IAM credentials that can be used with AWS APIs.

| Field | Type | Notes |
| - | - | - |
| accessKeyId | string | AWS access key ID. |
| secretAccessKey | string | AWS secret access key. |
| sessionToken | string | AWS credentials session token. |
| expires | date | When the credentials expire. |
| region | string | AWS region. |

## Update
**Device update**

Check for software updates.

**Endpoint**

```HTTP
POST /provision/update

```
**Authorized User Role**

```
update

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| product | string | yes |
| version | string | yes |
| test | boolean |  |
| * | any |  |

**Response** 

| Field | Type | Notes |
| - | - | - |
| checksum | string | Download checksum. |
| version | string | Version to update to. |
| url | string | Download URL for the software update. |
| update | string | Selected update (quote on report). |

## UpdateReport
**Device update report**

Post update status.

**Endpoint**

```HTTP
POST /provision/updateReport

```
**Authorized User Role**

```
update

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| update | string | yes |
| success | boolean | yes |

# Manager

Manage Manager.

## Get
**Endpoint**

```HTTP
POST /manager/get

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| app | string |
| certArn | string |
| cloudFront | string |
| cloudId | string |
| css | string |
| distributionId | string |
| display | string |
| domain | string |
| error | string |
| id | string |
| logo | string |
| name | string |
| owner | string |
| priorDomain | string |
| provisioned | date |
| region | string |
| title | string |
| type | string |
| version | string |

## GetSignedUrl
**Endpoint**

```HTTP
POST /manager/getSignedUrl

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| clean | boolean |
| command | string |
| filename | string |
| mimeType | string |

**Response** 

A signed URL string.


## Provision
**Endpoint**

```HTTP
POST /manager/provision

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| id | string | yes |
| assets | object |  |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| app | string |
| certArn | string |
| cloudFront | string |
| cloudId | string |
| css | string |
| distributionId | string |
| display | string |
| domain | string |
| error | string |
| id | string |
| logo | string |
| name | string |
| owner | string |
| priorDomain | string |
| provisioned | date |
| region | string |
| title | string |
| type | string |
| version | string |

## Update
**Endpoint**

```HTTP
POST /manager/update

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| app | string |
| cloudId | string |
| css | string |
| display | string |
| domain | string |
| id | string |
| logo | string |
| name | string |
| owner | string |
| priorDomain | string |
| region | string |
| title | string |
| version | string |

**Response** 

| Field | Type |
| - | - |
| accountId | string |
| app | string |
| certArn | string |
| cloudFront | string |
| cloudId | string |
| css | string |
| distributionId | string |
| display | string |
| domain | string |
| error | string |
| id | string |
| logo | string |
| name | string |
| owner | string |
| priorDomain | string |
| provisioned | date |
| region | string |
| title | string |
| type | string |
| version | string |

# Alert

Manage Alerts.

## Find
**Endpoint**

```HTTP
POST /alert/find

```
**Authorized User Role**

```
user

```
**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Alert** 

An array of Alert items.

| Field | Type | Notes |
| - | - | - |
| seq | string |  |
| accountId | string |  |
| context | object |  |
| cloudId | string | Owning device cloud ID. |
| count | number |  |
| id | string | Unique alert ID. |
| name | string |  |
| message | string |  |
| severity | string |  |
| subject | string |  |
| resolved | boolean |  |
| timestamp | date |  |

## Get
**Endpoint**

```HTTP
POST /alert/get

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

**Response** 

| Field | Type | Notes |
| - | - | - |
| seq | string |  |
| accountId | string |  |
| context | object |  |
| cloudId | string | Owning device cloud ID. |
| count | number |  |
| id | string | Unique alert ID. |
| name | string |  |
| message | string |  |
| severity | string |  |
| subject | string |  |
| resolved | boolean |  |
| timestamp | date |  |

## Remove
**Endpoint**

```HTTP
POST /alert/remove

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |

## Update
**Endpoint**

```HTTP
POST /alert/update

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| id | string |
| resolved | boolean |

**Response** 

| Field | Type | Notes |
| - | - | - |
| seq | string |  |
| accountId | string |  |
| context | object |  |
| cloudId | string | Owning device cloud ID. |
| count | number |  |
| id | string | Unique alert ID. |
| name | string |  |
| message | string |  |
| severity | string |  |
| subject | string |  |
| resolved | boolean |  |
| timestamp | date |  |

# Account

Account Management. <br>        <br>        Account APIs operate on the user account utilized when obtaining the login AccessToken. If using a CloudAPI token, which provides the **owner** role capability, the target account can be provided via the **accountId** request property to most APIs. <br><br>        Note: Accounts are created by the User.login API when a new user first logs in.

## Create
**Create an account**

This API will create the account record and the account's first user. Subsequent users can be added via the User.create API. .

**Endpoint**

```HTTP
POST /account/create

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| email | string | yes | A unique, valid email address to use as the master account email address and the first user's email address. |
| name | string | yes | Account or company name. |

**Response** 

| Field | Type |
| - | - |
| account | Account |
| user | User |

**Account** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |


**User** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |


## Close
**Close account**

Close an account and remove all allocated resources.  This will remove all users, devices, dashboards, and the account itself.  This operation cannot be reversed. <br>                <br>                This API can be invoked by a user closing their device app account. It can also be invoked to close any user account if caller has the **owner** role via the CloudAPI token. .

**Endpoint**

```HTTP
POST /account/close

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Override account to close. |

## Get
**Get account**

Get an account that match the supplied properties. If no email or id provided, return the logged in account.

**Endpoint**

```HTTP
POST /account/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Query by account ID. |
| email | string | owner | Query by email. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

## Find
**Find accounts**

Find a list of accounts that match the supplied properties. If no email or id provided, return list of accounts (requires "owner" role).

**Endpoint**

```HTTP
POST /account/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner | Query by account ID. |
| email | string | owner | Query by email address. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Account** 

An array of Account items.

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

## UpdateIdentity
Update the account name and email address.

**Endpoint**

```HTTP
POST /account/updateIdentity

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string | owner |  |
| email | string |  | Account email address. |
| name | string |  | Account or company name. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |

# Store

This API provides MQTT messages to get/set values from the key/value Store.<br>        <br>        If you need a REST API, use the Generic API with the **_type** set to 'Store'.

## Get
**Get data from the store**

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /store/get

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type |
| - | - |
| key | string |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account. |
| deviceId | string | Owning device. |
| key | string | Data item key. |
| value | object | Data item value. |
| type | string | Data type. Set to "number" or "string". |
| updated | date | When data item last updated. |
| expires | date | When data item should be deleted. |

## Set
**Set data in the store**

**Protocol**

```
MQTT

```
**Endpoint**

```
mqtt: /store/set

```
**Authorized User Role**

```
device

```
**Request Body** 

| Field | Type | Notes |
| - | - | - |
| key | string | Data item unique key. |
| expires | number | Date when to expire. Set to number of milliseconds since Jan 1, 1970. Date.getTime(). |
| value | object | Set to a number or string. |
| type | string | Set to "number" or "string". |

# User

User Management.

## Create
Create a new user and optionally send an email invitation to join the service. When the user follows the invitation and registers, their email address wil be confirmed before they are logged into the service.

**Endpoint**

```HTTP
POST /user/create

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| email | string | yes | User email address. |
| role | string | yes | Authorized role. Select from "user", "admin" or "owner". |
| sendInvite | boolean |  | Send an email invitation. |

**Response** 

A user record.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Get
**Endpoint**

```HTTP
POST /user/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role |
| - | - | - |
| email | string | admin |
| id | string | admin |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Find
**Endpoint**

```HTTP
POST /user/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role |
| - | - | - |
| email | string | admin |
| id | string | admin |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of merics. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**User** 

An array of User items.

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## Login
**Login the authenticated user**

**Endpoint**

```HTTP
POST /user/login

```
**Authorized User Role**

```
public

```
**Request Body** 

| Field | Type |
| - | - |
| invite | string |
| register | boolean |

**Response** 

Account and user records with useful cached data.

| Field | Type | Notes |
| - | - | - |
| account | object |  |
| user | object |  |

**Account** 

| Field | Type | Notes |
| - | - | - |
| activity | date |  |
| closed | boolean | Set to true when account closed. |
| cloudId | string | Owning device cloud ID. |
| created | date | Date account created. |
| email | string | Account email. |
| id | string | Unique account ID. |
| name | string | Account or company name. |


**User** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |


## Remove
**Endpoint**

```HTTP
POST /user/remove

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type |
| - | - |
| email | string |
| id | string |

## Update
**Update a user identity**

**Endpoint**

```HTTP
POST /user/update

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type |
| - | - |
| email | string |
| first | string |
| id | string |
| last | string |
| preferences | object |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

## UpdateRole
**Endpoint**

```HTTP
POST /user/updateRole

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Role |
| - | - | - |
| id | string |  |
| role | string | admin |
| sendInvite | boolean |  |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accountId | string | Owning account ID. |
| activity | date |  |
| cloudId | string | Device cloud ID. |
| email | string | User email address. |
| first | string | First name. |
| id | string | User ID. |
| last | string | Surname. |
| role | string | Authorized role. |

# Action

Manage Automated Actions.<br><br>        Actions implement automated responses for specific device and cloud conditions. Actions are invoked by triggers to respond and implement a specific remedy or notification. .

## Find
Find actions by matching properties.

**Endpoint**

```HTTP
POST /action/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required |
| - | - | - |
| cloudId | string | yes |
| type | string |  |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | Array of items. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Action** 

An array of Action items.

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string |  |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean |  |
| error | string |  |
| expression | string |  |
| format | string |  |
| id | string |  |
| message | string | Message template/properties. |
| name | string |  |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string |  |
| trigger | string | Source of action trigger. |
| type | string |  |

## Get
Get an action by ID for a cloud.

**Endpoint**

```HTTP
POST /action/get

```
**Authorized User Role**

```
admin

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string |  | Action ID. |
| cloudId | string | yes |  |
| type | string | yes |  |

**Response** 

| Field | Type | Notes |
| - | - | - |
| args | object | Action args. |
| buffer | object | Buffer optimizations for metrics. |
| cloudId | string | Owning device cloud ID. |
| context | object | Trigger expression context, merged with user params. |
| description | string |  |
| destination | string | URL, email address, function name, topic, phone number. |
| due | number | When the action is next due. |
| enable | boolean |  |
| error | string |  |
| expression | string |  |
| format | string |  |
| id | string |  |
| message | string | Message template/properties. |
| name | string |  |
| poll | number | Delay between pollng the trigger. |
| rearm | number | Time period to suppress triggering. |
| severity | string |  |
| trigger | string | Source of action trigger. |
| type | string |  |

## Invoke
Invoke an action by ID or name.

**Endpoint**

```HTTP
POST /action/invoke

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Notes |
| - | - | - |
| id | string | Action ID. |
| name | string | Action name if ID not provided. |
| params | object | Parameters for the action. |
| context | object | Context for the action. |

**Response** 

A string.


# Test

Test the API interface.

## Ping
**Ping device cloud**

Simple ping request.

**Endpoint**

```HTTP
POST /test/ping

```
**Authorized User Role**

```
public

```
**Response** 

The string "pinged" with a new line appended.


# Device

Device Management API.<br><br>When devices are initialized with the Ioto agent, they will "register" with the Builder service using their device ID (ClaimID) at https://admin.embedthis.com/api. The device registration API is part of the Builder API. See [Device Registration](/ioto/provisioning/registration.md).<br><br>Once registered, the device then remains under the management of the Builder until it is **"claimed"** by a user for management using the "Device Claim" API.  When claimed, the device is redirected to the device cloud when it next invokes the "register" API.

## Get
The Get API will fetch a device by its ID (ClaimID).

**Endpoint**

```HTTP
POST /device/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Role | Notes |
| - | - | - | - | - |
| id | string | yes |  | Device Claim ID. |
| accountId | string |  | owner | Manager account ID. Required if using CloudAPI token. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Claim
Claim a device for management by a device cloud.<br><br>Once a device has registered itself with the builder, a user can claim the device for management.<br>The claim ID would typically be printed on the device label during manufacturer.<br><br>A claim request may specify the device as a test device where it will not be counted towards the subscription device count.

**Endpoint**

```HTTP
POST /device/claim

```
**Authorized User Role**

```
claimDevice

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

The claimed device.

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Find
Find matching devices filtered by matching properties.

**Endpoint**

```HTTP
POST /device/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Role | Notes |
| - | - | - | - |
| id | string |  | Device Claim ID. |
| accountId | string | owner | Manager account ID. Required if using CloudAPI token. |
| productId | string |  | Product registration ID from the Builder product list. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of devices owned by the user. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Device** 

An array of Device items.

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

## Remove
Release a device from management by a device cloud. Releasing a device returns it to the builder to be available for claiming by another cloud.

**Endpoint**

```HTTP
POST /device/remove

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| id | string | yes | Device claim ID. |

**Response** 

| Field | Type | Notes |
| - | - | - |
| accessed | date | When the device was last accessed. |
| accountId | string | Owning manager account ID. |
| created | date | When the device was first claimed. |
| id | string | Device Claim ID. |
| product | string | Builder Product name. |
| productId | string | Builder Product ID. |
| test | boolean | Device is for test purposes. |
| version | string | Firmware version. |
| checked | string | Checked version. |

# Generic

Generic Access to Database Data.<br>        <br>        The Generic controller provides "generic" access to database items without requiring specific database models for different database items. By providing the database item "_type" and the required item properties, you can query and modify database items.

## Create
**Endpoint**

```HTTP
POST /generic/create

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. This must be a deviceId claimed by the manager account of the authenticated user. |
| * | any |  | Item attributes to create. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

The created item.

| Field | Type | Notes |
| - | - | - |
| _type | string | Database item type. |
| * | any | Item attributes. |

## Get
Get a data item from a database table.

**Endpoint**

```HTTP
POST /generic/get

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Optional item attributes to filter the selected item. |

**Response** 

The retrieved item.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

## Find
Find data items from a database table.

**Endpoint**

```HTTP
POST /generic/find

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Optional item attributes to filter selected items. |

**Query String Options** 

| Field | Type | Notes |
| - | - | - |
| filter | string | Full text string to filter for. |
| next | object | Pagination token for the next page. |
| prev | object | Pagination token for the previous page. |
| limit | number | Number of items to retrieve. |
| index | string | Database index to use. |
| exists | boolean | Set to true to require the item exists, otherwise set to null to perform an upsert. |

**Response** 

Paged response.

| Field | Type | Notes |
| - | - | - |
| data | array | An array of devices owned by the user. |
| next | string | Paged cursor to use for the next page of items. |
| prev | string | Pages cursor to use for the previous page of items. |

**Item** 

An array of Item items.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

## Remove
Remove a data item.

**Endpoint**

```HTTP
POST /generic/remove

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Other item attributes sufficient to identify the item. |

## Update
Update a data item.

**Endpoint**

```HTTP
POST /generic/update

```
**Authorized User Role**

```
user

```
**Request Body** 

| Field | Type | Required | Notes |
| - | - | - | - |
| _type | string | yes | Database item type. |
| deviceId | string |  | Device ID owning the item. |
| * | any |  | Other item attributes sufficient to identify the item. |

**Response** 

The updated data item.

| Field | Type | Notes |
| - | - | - |
| * | any | Item attributes. |

# Desktop Device App Screen Shots

The following screenshots show some of the functionality of the Standard device app when using the desktop skin.

## Home Screen

![Home Page](/images/manager/dashboard.avif){class="screen"}

## Forms

![Form](/images/manager/cloudkick.avif){class="screen"}

## Dashboard Widgets Screen

![Home Page](/images/manager/dashboard.avif){class="screen"}

## Metrics

![Metrics](/images/manager/custom-metrics.avif){class="screen"}

## Login

![Login](/images/manager/developer-login.avif){class="screen"}

## Table Inline Edit

![Store Table](/images/manager/store-table.avif){class="screen"}




# Mobile Screen Shots

The following screenshots show some of the functionality of the Standard device app when using the mobile skin.

## Home Screens

![Eco Page](/images/eco/eco-home.avif){class="screen"}

![Home Page](/images/mobile/home.avif){class="screen"}

## Dark Mode

![Dark Mode Home Page](/images/mobile/home-dark.avif){class="screen"}

## Login

![Login](/images/eco/eco-login.avif){class="screen"}

## Alert Details

![Alert](/images/mobile/alert.avif){class="screen"}

## Metric Range

![Range](/images/mobile/range-pick-dark.avif){class="screen"}

## Confirmations

![Confirm](/images/mobile/confirm-dark.avif){class="screen"}

## Home Menu

![Menu](/images/mobile/menu-dark.avif){class="screen"}

## Device List

![Menu](/images/mobile/device-list-dark.avif){class="screen"}

## Claim Device

![Claim](/images/eco/eco-claim.avif){class="screen"}

![Menu](/images/mobile/device-list-dark.avif){class="screen"}# Replaced Pattern

The Replaced pattern involves building a completely custom device management application using the Ioto cloud service APIs directly. This approach provides maximum flexibility and control, allowing you to use any UI framework, programming language, or development approach that meets your specific requirements.

When the DevCore framework doesn't align with your technical requirements or architectural constraints, you can develop a custom application that integrates with Ioto's cloud services while maintaining complete control over the user interface and application logic.

## Development Approach

The Replaced pattern gives you complete freedom to:

- **Choose Your Framework** - Use VueJS, Angular, native mobile frameworks, or any preferred technology
- **Custom Architecture** - Implement your own application structure and patterns
- **Direct API Integration** - Access Ioto cloud services through REST APIs
- **Platform-specific Development** - Create web, mobile, or desktop applications

## Technical Requirements

When developing a custom application, ensure compliance with these requirements:

### API Integration
- **Ioto REST APIs** - Use the Ioto cloud service APIs for device communication
- **Authentication** - Implement proper authentication mechanisms
- **Data Synchronization** - Handle real-time device data updates appropriately

### Deployment Package
- **ZIP Archive** - Package your application as a ZIP file
- **Entry Point** - Include a top-level `index.html` file
- **Static Assets** - Include all necessary CSS, JavaScript, and media files

## Development Process

### 1. API Integration

Integrate with Ioto cloud services using the REST APIs:

```javascript
// Example API integration (using fetch)
const deviceData = await fetch('/api/devices', {
  headers: {
    'Authorization': 'Bearer ' + authToken,
    'Content-Type': 'application/json'
  }
});
```

### 2. Application Development

Build your application using your preferred technology stack:

- **Frontend Framework** - VueJS, Angular, vanilla JavaScript, or other preferred frameworks
- **Build Tools** - Webpack, Vite, or other bundlers as needed
- **Testing** - Implement appropriate testing strategies for your codebase

### 3. Packaging

Package your completed application:

```bash
# Example build and packaging
npm run build
cd dist
zip -r ../app.zip .
```

## Deployment

### Uploading to Builder

1. Login to the [Builder](https://admin.embedthis.com)
2. Navigate to the apps list
3. Click `Add` for new apps or `Edit` for existing apps
4. Select **Custom App** option
5. Upload your `app.zip` archive
6. Click **Save**

The Builder deploys the application to your associated Ioto device cloud, which typically takes a few minutes.

## When to Use Replaced Pattern

The Replaced pattern is suitable for:

- **Unique Technical Requirements** - Applications requiring specific frameworks or technologies
- **Legacy System Integration** - Apps that need to integrate with existing systems
- **Mobile Applications** - Native iOS or Android applications
- **Complex User Interfaces** - Applications with sophisticated UI requirements beyond DevCore capabilities
- **Performance-Critical Applications** - Apps requiring optimized performance characteristics

## Development Considerations

- **API Documentation** - Thoroughly understand the Ioto REST APIs before starting development
- **Authentication Management** - Implement secure authentication and session management
- **Error Handling** - Develop robust error handling for API communication
- **Testing Strategy** - Plan comprehensive testing including API integration tests
- **Maintenance Overhead** - Consider the ongoing maintenance requirements for custom applications

## API Documentation

For detailed API information and implementation guidance:

* [Ioto Cloud Service](/ioto/)
* [Ioto Cloud APIs](/ioto/ref/)

## Example Use Cases

- **Enterprise Integration** - Applications that need to integrate with existing enterprise systems
- **Specialized Interfaces** - Industry-specific user interfaces and workflows
- **Multi-platform Applications** - Applications targeting multiple platforms with shared backend services
- **High-performance Applications** - Applications with specific performance or scalability requirements# Customized Pattern

The Customized pattern extends the Standard app using the built-in low-code App Designer. This approach allows you to modify the app's branding, themes, features, UI pages, and navigation without writing custom code. The result is a tailored application that meets your specific device management requirements.

![Eco Page](/images/eco/eco-home.avif){class="screen width-60 center"}

## Customization Capabilities

The App Designer enables you to create custom pages using graphical widgets and user interactions for device management and control. By arranging input and output widgets in UI pages, you can build composite interfaces optimized for your devices.

A customized app typically includes:

- **Custom UI Pages** - Tailored interfaces for specific device functions
- **Cloud-side Actions** - Automated responses to user and device inputs
- **Device-specific Workflows** - Database updates, device commands, and user notifications

## App Designer

Access the App Designer by selecting `Designer` from the app's sidebar. The designer option is available only to users with the `owner` role as specified in the Builder's App Settings.

![Ioto Device App](/images/manager/page-designer.avif){class="screen"}

### Designer Features

The App Designer provides the following customization options:

**Branding & Appearance**
- Set application name and logo
- Customize themes including colors, borders, and light/dark modes
- Configure visual styling elements

**Page Management**
- Create and modify UI pages
- Define page layouts and widget arrangements
- Configure page-specific functionality

**Navigation Structure**
- Define app navigation hierarchy
- Set up menu structures and routing
- Configure user access patterns

## Device Data Schema

The device data schema defines entities, properties, and data types for your devices. This schema enables the app to dynamically generate and customize the user interface based on your specific requirements.

### Schema Configuration

Configure the schema through the Builder's cloud settings:

1. Navigate to `Clouds` in the Builder
2. Select your device cloud
3. Open the Cloud Modify configuration panel

![Cloud Modify](/images/builder/cloud-modify.avif){class="screen width-60"}

By default, the schema operates as a generic key-value store suitable for initial development. As your project evolves, you'll likely want to define custom data entities to better manage and represent device-specific data.

## When to Use Customized Pattern

The Customized pattern is ideal for:

- **Small to Medium-scale Deployments** - Applications requiring moderate customization
- **Brand-specific Applications** - Apps needing custom branding and themes
- **User-focused Interfaces** - Applications with specific user experience requirements
- **Rapid Development** - Projects requiring quick customization without extensive coding

## Related Documentation

For more information about device schemas and database configuration:

* [Device Tables / Database Schemas](../database/schemas/)
* [Database Replication](../database/replication.html)# Design Patterns

The Builder supports a progressive approach to device management app development, allowing you to start with a default DevCore-based app and incrementally customize it to meet your specific requirements. This approach enables rapid prototyping while maintaining the flexibility to create fully customized applications.

You can create multiple apps for each product definition to serve different user segmentsfor example, a consumer app for end-users, a professional version for premium customers, and a developer app for your support team.

## Customization Levels

The Builder provides four levels of customization, each offering increasing flexibility and control:

| **Level** | **Pattern** | **Description** |
|-----------|-------------|-----------------|
| 1 | [Standard](standard.md) | Deploy the default manager app without modifications. Ideal for development prototyping and internal data-centric devices. |
| 2 | [Customized](customized.md) | Customize the app using the built-in visual App Designer to create UI pages and define branding, logos, and device data schemas. Best for small to medium-scale deployments. |
| 3 | [Rebuilt](rebuilt.md) | Rebuild the app code with custom UI components and logic, then use the App Designer to create pages leveraging your custom components. Suitable for larger-scale apps with specific interface requirements. |
| 4 | [Replaced](replaced.md) | Replace the app entirely with a custom application using Ioto cloud service APIs. Ideal for unique requirements or specific UI frameworks and languages. |

## Choosing the Right Pattern

- **Level 1-2**: Quick deployment with minimal development overhead
- **Level 3**: Balance between customization and development efficiency  
- **Level 4**: Maximum control with full development responsibility

Select the pattern that best matches your development timeline, customization needs, and team capabilities.
# Rebuilt Pattern

The Rebuilt pattern involves extending the DevCore framework with custom UI components and logic, then rebuilding the application for deployment. This approach provides greater flexibility than the Customized pattern while maintaining the benefits of the DevCore foundation.

When the standard DevCore framework capabilities don't meet your specific device management requirements, you can modify the source code, add custom components, and rebuild the application with your enhancements.

## Development Process

The Rebuilt pattern follows this workflow:

1. **Copy the Source** - Start with the standard DevCore app as a foundation
2. **Customize** - Add your custom UI components and logic
3. **Rebuild** - Compile the modified application
4. **Upload** - Deploy through the Builder platform

## Setting Up Your Custom App

The DevCore framework download includes a `standard` app template located in the `./apps/standard` directory. This pristine version serves as the foundation for your customizations.

### Copying the Foundation

Create your custom app by copying the standard template:

```bash
$ cp -r apps/standard apps/myapp
```

This creates a complete copy of the DevCore framework that you can modify without affecting the original.

### Customization Options

Using the DevCore source code, you can:

- **Add Custom Components** - Create specialized UI widgets for your devices
- **Modify Existing Logic** - Enhance or replace standard functionality
- **Integrate Third-party Libraries** - Add external dependencies as needed
- **Implement Custom Workflows** - Create device-specific management processes

## Building Your App

Rebuild your customized application using the make command:

```bash
$ make APP=myapp clean build
```

### Build Output

The build process generates:

* **DevCore Framework** - The DevCore library
* **Custom Manager App** - Your modified DevCore application
* **Ioto Agent Services** - Required backend services
* **Deployment Package** - Ready-to-upload app.zip file

The built application is located in the `apps/myapp/ui/dist` directory and includes the `app.zip` archive for deployment via the Builder.

## Deployment

### Uploading to Builder

1. Login to the [Builder](https://admin.embedthis.com)
2. Navigate to the apps list
3. Click `Add` for new apps or `Edit` for existing apps
4. Select **Custom App** option
5. Upload your `app.zip` archive
6. Click **Save**

The Builder deploys the application to your associated Ioto device cloud, which typically takes a few minutes.

## When to Use Rebuilt Pattern

The Rebuilt pattern is suitable for:

- **Custom UI Requirements** - Applications needing specialized interface components
- **Complex Business Logic** - Device management with custom workflows
- **Third-party Integration** - Apps requiring external library integration
- **Large-scale Applications** - Projects with specific performance or functionality needs

## Development Considerations

- **Build Environment** - Ensure you have the necessary development tools installed
- **Version Control** - Track your customizations for future updates
- **Testing** - Thoroughly test custom components before deployment
- **Documentation** - Document your modifications for maintenance

## Related Documentation

For detailed implementation guidance, see the [Standard App](/apps/samples/standard/) in the Ioto Agent documentation.

# Standard Pattern

The Standard pattern deploys the default DevCore-based device management app without modifications. This approach enables immediate project startup by providing essential device connectivity and management capabilities out of the box.

The Standard app includes a developer UI skin and provides core functionality optimized for both mobile and desktop applications. This pattern is ideal for rapid prototyping, development testing, and internal data-centric projects.

![Ioto Device App](/images/manager/standard.avif){class="screen"}

## Core Features

The Standard app provides the following capabilities:

**Authentication & Access Control**
- User authentication and login systems
- Role-based access control

**User Interface**
- Navigation bars and routing
- Data display panels and dashboards
- Real-time updating widgets
- Data editing forms

**Device Management**
- Device claiming and release
- Multi-device management
- Device data property editor
- Connectivity to local HTTP agents and cloud services

**Technical Foundation**
- Pre-configured VueJS and Vuetify frameworks
- DevCore framework integration
- Mobile and desktop responsive design

## When to Use Standard Pattern

The Standard pattern is suitable for:

- **Rapid Prototyping** - Quick validation of device management concepts
- **Development Testing** - Internal testing and evaluation environments
- **Data-Centric Applications** - Scientific or research applications requiring basic device data access
- **Proof of Concept** - Demonstrating device connectivity and basic management capabilities

## Getting Started

1. Create a new app using the Standard pattern from the Builder
2. Configure your device schema and connection parameters
3. Deploy and connect your devices
4. Access the management interface through the provided URL

The Standard pattern provides immediate functionality while preserving the option to customize or rebuild the application as requirements evolve.

:::info 
The Standard pattern significantly reduces initial development time for device management applications.
:::
# DevCore Manager Package

The foundation of the DevCore Framework is the `devcore` package. This package provides essential services necessary for mobile or desktop device management applications.

The DevCore is a VueJS/Vuetify extension that provides structure for your device management application. It provide the essential authentication, routing and data management services to manage one or more devices.

The DevCore provides the following features:

- Setup and configuration of VueJS and Vuetify frameworks
- Application structure with navigation bars, data display panels, dashboards and widgets and  data editing forms
- User authentication, login and access control
- Dashboards and data and graphical widgets with dynamic live updating
- Data property editor to view and modify device data
- User navigation and request routing
- Collection of core VueJS UI components for management applications
- Device claim, release and management
- Ability to connect to local HTTP device agents or cloud services

Using the DevCore as a foundation, you can elimiate countless months of developer time in creating a device management solution.

## Installation

The DevCore package is installed from [NPM DevCore](https://www.npmjs.com/package/embedthis/devcore).

```bash
npm install @embedthis/devcore
```

## Rebuilding from Source

The DevCore can be rebuilt from source that can be downloaded from the [Builder](https://admin.embedthis.com) or [GitHub](https://github.com/embedthis/devcore).

To build, type:

```bash
make
```

After building the `framework/dist` directory will contain the `devcore` package. The `apps/standard/ui/dist` directory will contain the `standard` app which uses the `devcore` package.

## Using the DevCore

The DevCore package is imported in the app's main routine. To initialize the framework, import the **createManager** API. For example:

```js
import {createManager} from '@embedthis/devcore'

const manager = createManager({
    components: { ... },            //  Additional VueJS components
    display: Display,               //  UI Display definition
    router,                         //  VueJS router
    schema: Schema,                 //  Database schema
    vue,                            //  Vue instance
    vuetify,                        //  Vuetify instance
    widgets: {graph: GraphWidget},  //  Additional dashboard widgets
}, {
    api: Connect.api,               //  Backend URL prefix. Use "/api" for local and Connect.js when cloud-based.
    cognito: Connect.cognito,       //  Cognito config when cloud-based
    profile: Ioto.profile,          //  Execution profile
    tunnel: 'generic',              //  Tunnel requests via 'generic' controller when cloud-based
})
```

The **createManager** API accepts configured [VueJS](https://vuejs.org), [Vuetify](https://vuetifyjs.com/en/) and [Vue Router](https://router.vuejs.org/) instances. You can configure these as you wish, but a typical setup would look like the following. Assuming the main components is sourced from `src/main.js`:

```js
import * as components from 'vuetify/components'
import * as directives from 'vuetify/directives'
import Display from '../theme/display.json'

let vue = createApp(Main)
let router = createRouter({
    history: createWebHashHistory(),
    routes: [],
})
let vuetify = createVuetify(
    vuetifyProps({
        components: components,
        directives: directives,
        icons: AdditionalIcons,
    })
)
vue.use(vuetify)
```

A Manager instance is created with arguments (first parameter) that define the UI display, VueJS components and other configuration options. Here is a table of the createManager first parameter arguments.

Property | Description
-|-
components | A map of VueJS components
display | The [display.json5](../config/display.md) UI route definition file
schema | The device database [schema](../config/schema.md)
models | A map of [REST data models](../config/models.md)
widgets | A map of additional [dashboard widgets](../config/display-properties.md#viewwidgets)
router | A configured [VueJS](https://router.vuejs.org/) router instance
vue | A configured [VueJS](https://vuejs.org/) instance
vuetify | A configured [Vuetify](https://vuetifyjs.com/en/) instance

The Manager constructor also takes an **"options"** argument (second parameter) that supplies additional app configuration information. 

The following properties should be provided via the **options**:

Property | Description
-|-
api | Backend API URL prefix. Use "/api" for local and Connect.js when cloud-based.
build | Build version number. Single number build version.
cognito | AWS Cognito user authentication configuration. Set to connect.cognito when cloud-based.
host | API host name override. Use when the API host name is not the same as the app host name.
profile | Operational profile (dev, prod)


### API Endpoint

When a device app is hosted by the cloud, the Ioto service adds a **Connect.js** configuration file to the app site that can be imported from the top level of your app. The **Connect.js** script provides the **api** endpoint address and the AWS Cognito user authentication endpoint configuration. Both are required for cloud-based device apps.

Here is a sample Connect.js:

```js
{
    "api": "https://xxxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com",
    "builder": "https://api.admin.embedthis.com",
    "cognito": {
        "userPoolId": "ap-southeast-2_xxxxxxxxx",
        "clientId": "xxxxxxxxxxxxxxxxxxxxxxxxxx"
    }
}
```

This file should be imported and the **"api"** and **"cognito"** properties used in the Manager options. For example:

```js
import Connect from '../Connect.js'
createManager({
    ...
}, {
    ...
    api: Connect.api,                   //  Backend cloud service API
    cognito: Connect.cognito,           //  Cognito config
})
```

## DevCore Exports

The DevCore package exports a suite of configured service objects and support functions.

### Service Objects

Name | Description
-|-
Auth | Primary authentication service
Feedback | User UI informational feedback service
Progress | User activity progress bar service
Rest | REST HTTP service
Routes | Navigational routes service
Rules | Input valiation rules
State | Global application state service


### Support Functions

Name | Signature | Description
-|-|-
can | can(role) | Can the logged in user perform the given role
createManager | createManager(params, options) | Create and initialiate a manager instance
getVue | getVue() | Return the initialized Vue instance
getModel | getModel(model) | Return the schema data model definition
getModels | getModels() | Return a list of the schema data models
getRoute | getRoute() | Return the Vue Router object for the current UI page
getRoutePath | getRoutePath() | Return the current Vue router URL
getRouter | getRouter() | Return the Vue router instance
navigate | navigate(url, query) | Navigate the UI to the given URL
vuetifyProps | vuetifyProps(params) | Convert the given params to Vuetify constructor args

<!--
## UI Components

The DevCore class provides a suite of UI components, including:

Component | Description
-|-
- Form validation rules
- Debug logging
- App state store
- Browser session storage
- Themes with light and dark modes
- SVG Icons
- Date and calendar UI component
- Vue cards
- Date  
- Drag and drop support
- User activity feedback and operation progress
- High level form input management
- Data table
- Application, sidebar and tabbed navigation
- User access control
- User signposts


- Background
- List of services
- Display, Schema

vu-form
    props
    CSS
    validation
    loading
    feedback
    save/pre/post
    progress
    confirm
    clickaway
app.feedback
app.progress

vu-input
    props
vu-table
    props
    fields
    events
    selection
    filtering
Panels
    events
icon aliases

Display -- review display tour

## Manager API

- App context
--># Vue Components

The DevCore uses the [Vue.js](https://vuejs.org) framework for building the user interface.

[Vue.js](https://vuejs.org) is a progressive JavaScript framework that is ideal for building user interfaces and single-page device management applications. 

One of the core features of Vue.js is its reactive data binding system, which ensures that the user interface updates automatically and efficiently in response to data changes. This reactivity makes it easier to develop dynamic device management applications where the content changes based on device state, user interactions or other factors without requiring manual DOM updates.

Vue.js also emphasizes a component-based architecture, where the application is built using small, reusable components. Each component in Vue has its own HTML, CSS, and JavaScript, allowing for more organized and maintainable codebases. This component-based approach facilitates the development of complex applications by breaking them down into smaller, manageable pieces.

Moreover, Vue.js offers a variety of tools and supporting libraries for advanced application needs, including Vue Router for page routing, and Vite build tool for project tooling. These tools are designed to work seamlessly with Vue, enabling developers to build robust, high-performance web applications.

Overall, Vue.js stands out for its ease of use, flexibility, and efficient data handling capabilities, making it a favorite among web developers for both small and large projects.

[VueJS Documentation](https://vuejs.org/guide/introduction.html)

## Vue Router

The DevCore uses the [Vue Router](https://router.vuejs.org/) for UI navigation.

Vue Router is the official router for Vue.js. It integrates closely with Vue.js to enable the building of single-page applications (SPAs) with ease. Vue Router allows for the creation of complex navigational structures within Vue applications, managing the synchronization between the browser's URL and your application's Vue components.

Here are some key features and capabilities of Vue Router:

* Dynamic Route Matching: You can design routes to match dynamic paths, allowing for parameterized URLs. This is particularly useful for creating user or item-specific pages based on IDs or other unique identifiers from the URL.

* Nested Routes: Vue Router supports nested routes, enabling the development of nested component structures that reflect nested URLs. This is useful for applications that have a hierarchical structure requiring a UI that reflects this complexity.

* Programmatic Navigation: Besides linking to specific routes with `<router-link>`, Vue Router allows for programmatic navigation. This means you can navigate to different pages programmatically using JavaScript, which is useful for actions like redirecting a user after a form submission.

* Navigation Guards: Vue Router provides navigation guards that allow you to hook into the routing process for operations like authentication checks before entering a route, or fetching data before a component is rendered.

* Lazy Loading: To improve performance, Vue Router supports lazy loading of route components. This means components are only loaded when they are needed for the current route, reducing the initial load time of the application.

* History Mode: Vue Router supports HTML5 history mode, which uses the history.pushState API to achieve URL navigation without a page reload. This creates a better user experience, with URL paths that look "normal" (without the hash # symbol) and are SEO-friendly.

Integrating Vue Router into a Vue.js application involves defining a set of routes, each associated with a component. When the application's URL changes, Vue Router matches the URL to the defined routes and renders the corresponding component, making it a vital part of creating SPA experiences with Vue.js.

The DevCore uses a **Display.json5** configuration file that is automatically translated into route tables for the Vue Router.


## Vuetify

The DevCore uses the [Vuetify.js](https://vuetifyjs.com/en/) design framework for UI components that is ideal for creating consistent, usable device management web applications.

Vuetify is a popular [Material Design](https://m3.material.io/) Framework for [Vue.js](https://vuejs.org). It provides a comprehensive suite of pre-made Vue components that are ready to use and fully customizable, adhering to Google's Material Design principles. Vuetify is designed to help developers create beautiful, responsive layouts and applications quickly and efficiently, without needing to spend a lot of time on CSS and design.

The framework offers a wide array of UI components, including buttons, dialogs, cards, data tables, and many more, all designed to work out of the box with Vue.js applications. These components are built to be accessible and internationalization-friendly, making it easier to create web applications that are accessible to a wide audience.

Vuetify is built on top of Vue.js, meaning it inherits Vues reactivity and component-oriented architecture, allowing for a seamless integration into Vue projects. This makes it an excellent choice for developers looking to leverage Vue.jss capabilities while also maintaining a consistent, attractive design across their application with minimal effort.

Additionally, Vuetify includes support a range of pre-designed themes, and comprehensive documentation, making it a powerful tool for developers building Vue.js applications that need to be both functional and aesthetically pleasing. 

For device management applications, Vuetify can significantly speed up development time and ensure your application follows the best practices of Material Design.# App State

The DevCore includes a state management service that serves as a centralized state store for all the components in the application. 

The state service allows arbitrary data to be centrally stored and shared between app components. One or more State stores can be created for different state. 

The primary advantages of using a centralized state store is the predictable ordering of state changes and the uncoupling of components that need to share state.

## State Stores

The DevCore provides the following state stores:

Name|Description
-|-
app | State data regarding the app in general
auth | User authentication data
config | Configuration data from the ioto.json5 and other config files
context | Application specific state and data

## Accessing State

```js
import {State} from '@embedthis/devcore'

let darkMode = State.app.dark
```

## Creating a State Store

You typically should not need to create a new store and can store your application state in the **State.context** object.

If you do wish to create a new state store, create a state class and use the **Store.add** to add the store to the centralized state service.

State stores are available as properties on the **State** object.

```js
import {Store, State} from '@embedthis/devcore'
class MyState {
    temp = 0
    speed: 42
    increment() {
        temp++
    }
    get speed() { return this.speed }
    set speed(v) { this.speed = v }
    async stop() {
        await database.stop()
    }
}
Store.add('my', new MyState())

console.log(State.my.temp)
State.my.stop()
console.log(State.my.speed)
```

## The App Store

The **App** store holds application global state including:

Property | Description
-|-
brightMode | Current app dark/light mode
dark | True if in dark mode
display | Current active display
fullDisplay | Full set of all possible displays
manager | Reference to the app manager object
mobile | True if the app is running on a mobile device
prefers | Hash of user preferences such as the current cloud or device
schema | Device cloud schema
started | When the app session started

## Auth State

The **Auth** state store holds authentication state including:

Property | Description
-|-
account | Account object
accountName | Account name
accountId | Account ID
auth | Authentication tokens
authenticated | Boolean set to true when the user credentials are authenticated
authorized | Boolean set to true when the user is fully logged in
email | User's login email address
ready | Set to true when the user is logged in and the app is ready to start
role | User's authenticated role
user | User object
username | User login name
userId | User ID

## Config State

The **Config** store holds general config state including:

Property | Description
-|-
api | Backend cloud service API
cognito | Cognito config
build | App build number
profile | Execution profile (prod | dev)
name | App name
title | App display title
version | App version (x.y.z)

## The Context Store

The **Context** store is a special store that is used to store application specific state and data, including:

Property | Description
-|-
agent | navigator.userAgent
desktop | window.innerWidth
height | window.innerWidth
inputs | Widget input form values 
language | navigator.language
mobile | window.innerWidth
width | window.innerWidth


## Alternatives

If you are building your own custom build of the DevCore, you can also use other state stores such as [Pinia](https://pinia.vuejs.org/) for your own state management.# DevCore Framework

Device Apps that utilize the **DevCore** save **months** if not **years** of development time compared to creating your own device management app from scratch.

Device apps generally need to perform the following core functions as a minimum:

* Login and authenticate users
* Claim devices for management
* Configure device settings
* Display device information and statistics
* Allow user control of the device device

The DevCore Framework provides the following essential features:

Feature | Description
-|-
Framework | Application structure with navigation bars, data display panels, dashboards and widgets and data editing forms
Authentication | User authentication, login and access control
Navigation | User navigation and request routing
Dashboards | Dashboards and graphical widgets with dynamic live updating
Interaction | Connect user interactions with device and cloud commands and operations
Property Editor | Editor to view and modify device data
Provisioning | Device claim, release and management
Integration | Ability to connect to local HTTP device agents or cloud services

The DevCore Framework is **responsive** and supports mobile, tablet or desktop interfaces. It will seamlessly scale to the appropriate screen size and intelligently switches between **dark** and light modes of operation. It also supports customized displays and themes for specific device configurations if required.

The DevCore can be installed from [NPM DevCore](https://www.npmjs.com/package/embedthis/devcore). It can be rebuilt with source downloaded from the [Builder](https://admin.embedthis.com) or [GitHub](https://github.com/embedthis/devcore). With this approach, you can completely customize the manager for your app.

Alternatively, you can create your own bespoke device manager app using the Ioto APIs for ultimate control.
# Display Page Routing

Apps based on the DevCore UI framework are configured using a **display.json5** configuration file that defines the app's features, themes, pages and panels. You can upload a custom display.json5 which will be used by your app. 

The display.json5 file defines the following items:

* Displayed Name
* Display color theme including dark and light modes
* Menu items and options
* UI pages
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

The initial display.json5 configuration file defines a "developer" skin for the app.

To upload, check the **Upload Display** and click on the Display file selection box to select a **display.json5** file to upload.

To clear a previously uploaded display, click on "Clear Display".

For more information about the Display file, See the manager documentation:

* [Ioto Device Apps](/apps/)
* [Display](display.html)
* [Display Properties](display-properties.html)
# Database Schemas

Ioto uses database schemas to define how items will be stored in the database.

A schema specifies the database item types, entity fields, indexes and other data access and replication parameters.

Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) schema format, implementing the [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).

The same schema is used for the cloud side AWS DynamoDB table and for the device side embedded database.

## Schema Definition

Schemas look like this:

```js
const DeviceSchema = {
    format: 'onetable:1.1.0',
    version: '0.0.1',
    indexes: {
        primary: {hash: 'pk', sort: 'sk'},
    },
    process: {
        /*
            Where the item is stored (cloud, device, both. Default is both)
            Synchronization direction. Up to the cloud, down or both. Default is none.
        */
        Status: {enable: 'cloud'},
        Fault:   { 
            sync: 'up' 
            metrics: [{
                namespace: 'Embedthis/Device',
                fields: ['temperature'],
                dimensions: [{Device: 'deviceId'}]
            }]
        },
    },
    models: {
        Status: {
            pk: {type: 'string', value: 'status#'},
            sk: {type: 'string', value: 'status#'},
            parameters: {type: 'object'},
            version: {type: 'string'},
            updated: {type: 'date'},
        },
        Fault: {
            pk: {type: 'string', value: 'device#${deviceId}'},
            sk: {type: 'string', value: 'fault#${id}'},
            deviceId: {type: 'string', required: true},
            id: {type: 'string', generate: 'ulid'},
            timestamp: {type: 'date', required: true},
            source: {type: 'string', required: true},
            severity: {
                type: 'string',
                required: true,
                enum: ['info', 'warn', 'error', 'critical', 'fatal'],
            },
            subject: {type: 'string', required: true},
            message: {type: 'string', required: true},
        },
    },
    params: {
        isoDates: true,
        timestamps: true,
    },
}
```

## Schema Purpose

AWS DynamoDB can operate most efficiently at scale when using a single table with multiple application entities stored in the one table. To make this design pattern easy to implement, application data schemas such as the one used by [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) provide the mapping between application level entities and raw database items.

Ioto uses the OneTable schema in both the DynamoDB table and in the Ioto agent database.

When coupled with a high-level database API such as that offered by OneTable and by the Ioto Agent Database, accessing and managing device data is much easier.

## DynamoDB Schema

Ioto uses the [DynamoDB OneTable](https://github.com/sensedeep/dynamodb-onetable) NodeJS library for all database access to the Ioto DynamoDB database. 

Please consult the [OneTable](https://github.com/sensedeep/dynamodb-onetable) library and [OneTable Documentation](https://doc.onetable.io/) for full details.

## Updating the Schema

![Updating the Schema](/images/builder/cloud-modify.png){class="screen"}

## Schema Properties

The valid properties of the **schema** object are:

| Property |  Type  | Description                                                                                  |
| -------- | :----: | -------------------------------------------------------------------------------------------- |
| format   | string | Reserved. Must be set to **onetable:1.1.0**                                                  |
| indexes  | object | Hash of indexes used by the table.                                                           |
| models   | object | Hash of model entities describing the model keys, indexes and attributes.                    |
| params   | object | Hash of properties controlling how data is stored in the table.                              |
| process  | object | Hash of model entities describing where the model should be and how it should be replicated. |
| version  | string | A SemVer compatible version string.                                                          |

The **format** property specifies the schema format version and must be set to **onetable:1.1.0**.

The **indexes** property specifies the key structure for the primary, local and secondary indexes.

The **models** property contains one or more item definitions with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties.

The **params** property defines additional parameters for table data formats.

The **process** map defines how database items should be processed, stored, replicated and whether metrics should be calculated from the data stream.

The **version** property defines a version for your database. It must be a [SemVer](https://semver.org/) compatible version string. The version string is used by tools and consumers of the schema to understand compatibility constraints for the schema and stored data.

## Schema Models

The schema defines a model for each item type. For example, consider a music example:

```js
{
    album: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        songs:  { type: 'number' },
    },
    artist: {
        pk:     { type: 'string', value: '${_type}:${name}' },
        sk:     { type: 'string', value: '${_type}:' },
        name:   { type: 'string', required: true },
        address: {
            type: Object, schema: {
                street: { type: 'string' },
                city: { type: 'string' },
                zip: { type: 'string' },
            },
        },
    }
}
```

For each item type, all the entity fields are defined by specifying the field type, validations and other operational characteristics (uniqueness, IDs and templates).

The valid types are: array, binary, boolean, date, number, object, and string.

The database will automatically add an item type via the **\_type** attribute to each model. This is set to the name of the type. You can modify this via the **params.typeField** setting.

## Value Templates

The value of a field can be computed based on the value of other fields and a formatting "value template". This is useful for decoupling your key structure from your entity fields.

The value template is like a Javascript string literal where the value of fields are expressed in a "${field}" format. At runtime, the field references are expanded with the item's value for the named field.

In the example above, the primary key "pk" is calculated from the entity type **\_type** and the **name** field by using the value template: **${_type}:${name}**.

## Nested Schemas

For object attributes, you can define a nested schema for the object properties, as in the example above (repeated below).

A nested schema uses the **schema** property to define a nested map of attributes. Schemas can be nested to an arbitrary depth.

```js
address: {
    type: Object, schema: {
        street: { type: 'string' },
        city: { type: 'string' },
        zip: { type: 'string' }
    }
}
```

## References

-   [DynamoDB OneTable Overview](https://www.sensedeep.com/blog/posts/2021/dynamodb-onetable-tour.html)
-   [DynamoDB with OneTable Schemas](https://www.sensedeep.com/blog/posts/2021/dynamodb-schemas.html)
-   [Data Modeling for DynamoDB](https://www.sensedeep.com/blog/posts/2021/dynamodb-singletable-design.html)
-   [SenseDeep DynamoDB Data Browser](https://www.sensedeep.com/blog/posts/series/dynamodb-studio/data-browser.html)
-   [OneTable Schema Spec](https://github.com/sensedeep/dynamodb-onetable/blob/main/doc/schema-1.1.0.md).
# Display Properties

## Example

Here is a subset example of a display.json5 file:

```js
{
    name: 'Kickstart',
    version: '1.0.0',
    format: '1.2.0',
    displays: [ {
        expression: "width >= 1024",
        name: "Desktop",
        description: "Device App",
        theme: {
            dark: { 
                title: 'Device App',
                logo: '/images/ioto-logo.png',
                colors: {},
                formats: {},
                variables: {}
            },
            light: { ... },
        },
        views: [
            { path: '/', name: 'home' },
            { name: 'Login', path: '/auth', component: 'Login' },
            {
                name: 'devices',
                path: '/devices',
                icon: '$devices',
                menu: 'Device',
                component: 'GenericList',
                table: {
                    model: 'Device',
                    subtitle: 'Click on a device to explore',
                    fields: [
                        {name: 'product'},
                        {name: 'description'},
                        {name: 'model'},
                        {name: 'id', title: 'Device ID'},
                        {name: '*', launch: '/devices/:id/overview'}
                    ],
                    actions: {
                        add: { count: 0, launch: 'claim' },
                        release: { 
                            count: 2,
                            invoke: 'DeviceRelease', 
                            confirm: true 
                        }
                    }
                },
                panels: [
                    {
                        name: 'claim',
                        component: 'DeviceClaim',
                        button: 'Claim Device'
                    }
                ]
            },
        ]
    }]
}
```

Here is an example view that uses the dashboard component and informational widgets:

```js
{
    name: 'fleet',
    title: 'Fleet Overview',
    path: '/fleet',
    icon: '$gauge',
    role: 'user',
    menu: 'Fleet'
    component: 'Dashboard',
    widgets: [
        {
            type: 'graph',
            title: 'CPU Metric over 5 mins',
            data: {
                owner: 'account',
                namespace: 'Embedthis/Device',
                metric: 'cpu',
                span: 'min5',
                dimensions: [{Device: 'deviceId'}],
            },
            axes: {y: 'CPU', x: 'Time'},
            width: '25%',
        },
    ],
}
```

## description

| Name | description |
|-|-|
| Description | Textual description of the device. |
| Synopsis | `description: "Short, one sentence description"` |

**Example**

```js
description: 'Display for the Acme Rocket device'
```

## features

| Name | features |
|-|-|
| Description | Enable features for the display UI |
| Synopsis | `features: { "debug": true | false }` |

**Example**

```js
features: {
    debug: false
}
```

## features.auth

| Name | features |
|-|-|
| Description | Authentication features for the display UI |
| Synopsis | `auth: { "social": true | false }` |

**Example**

```js
features: {
    auth: {
        forgot: true,
        login: true,
        social: true,
    }
}
```

Property | Description
-|-
forgot | Support forgot my password recovery
login | Display and require user login
social | Support login via Google, Facebook or Amazon. (Requires cloud-based managemement).



## features.cloud
| Name | features |
|-|-|
| Description | Control cloud features |
| Synopsis | `cloud: { multiple: true | false }` |

This is useful to support apps that can connect to multiple device clouds.

The following properties are supported

Property | Type | Description
-|-|-
enable | Boolean | Enable cloud connectivity
multiple | Boolean | App supports multiple clouds

**Example**

```js
features: {
    cloud: {
        enable: true,
        multiple: false,
    }
}
```

## features.dash
| Name | features |
|-|-|
| Description | Control dashboard features |
| Synopsis | `dash: { edit: true | false }` |

This property collection controls the dashboard.

The following properties are supported

Property | Type | Description
-|-|-
actions | Boolean | Enable editing widget actions
database | Boolean | Enable widgets to access database fields
edit | Boolean | Enable the widget editing panel
enable | Boolean | Enable dashboards
metrics | Boolean | Enable widgets to access metrics
multiple | Boolean | Enable support for multiple dashboards per user
name | String | Name of the dashboard to load by default. Set to "auto" to load "Mobile" on phones and "Desktop" otherwise.
responsive | Boolean | Enable widget maximizing on mobile devices


## features.demo

| Name | features |
|-|-|
| Description | Enable demonstration mode |
| Synopsis | `demo: { enable: true | false } ` |

**Example**

```js
features: {
    demo: {
        enable: true,
    }
}
```

## features.debug

| Name | features |
|-|-|
| Description | Enable debug mode |
| Synopsis | `debug: true | false` |

This is useful to enable or disable debug code while developing new features.



## features.nav
| Name | features |
|-|-|
| Description | Control app navigation features |
| Synopsis | `nav: { sidebar: true }` |

This property collection controls the app's navigation features. The following properties are supported:

Property | Type | Description
-|-|-
alerts | Boolean | Display automation alerts icon in the navbar
cookies | String | Reserved
dark | Boolean | Include an icon to toggle dark mode
doc | String | URL link to app documentation site
fleet | Boolean\|String | Support multiple claimed devices in the one UI. Can be set to 'smart' to dynamically determine based on the number of claimed devices.
help | Boolean | Reserved
login | Boolean | Display login name/email in top navbar menu
navbar | Boolean | Display a top-level navigation bar
profile | Boolean | Display user profile in top navbar menu
settings | Boolean | Display account settings in top navbar menu
sidebar | Boolean | Display navigation sidebar
signposts | Boolean | Display signposts at the top of pages

## redirect

| Name | redirect |
|-|-|
| Description | Redirect the browser to a new location
| Synopsis | `redirect: "URL"`
| Notes | If set to a URL, you can use **:token** segments that will be expanded at runtime from the application route context.

**Example**

The :deviceId will be replaced with the selected device ID from the device list.

```js
redirect: '/devices/:deviceId/overview'
```

## theme

| Name | theme |
|-|-|
| Description | Define the display theme configuration |
| Synopsis | `theme: { properties ... }` |

**Example**

```js
theme: {
    light: {
        title: 'Acme Rocket',
        logo: '/images/acme-logo.png',
        colors: {},
        formats: {},
        variables: {}
    },
    dark: {},
}
```

## theme.light

| Name | theme.light |
|-|-|
| Description | The light mode theme.|
| Synopsis | `light: { ... }` |

```js
theme: {
    dark: {
        colors: {
            primary: '#3F51B5',
            secondary: '#707070',
            accent: '#82B1FF',    
            error: '#fb6d6d',
            info: '#2196F3',
            success: '#4CAF50',
            warning: '#FB8C00',
            extra: '#00cdcd',
            anchor: '#1976D2',
            nav: '#3f51b5'
        },
    }
}
```
## theme.dark

| Name | theme.dark |
|-|-|
| Description | The dark mode theme.|
| Synopsis | `dark: { ... }` |

## theme.MODE.logo

| Name | theme.MODE.logo |
|-|-|
| Description | The logo displayed in the navigation bar and login screen.|
| Synopsis | `logo: "/images/NAME.png"` |
| Notes | The logo should be small, square and have a transparent background.|

```js
theme: {
    logo: '/images/acme.png'
}
```

## theme.MODE.colors

| Name | theme.MODE.colors |
|-|-|
| Description | The theme colors.|
| Synopsis | `colors: {...}` |

```js
dark: {
    colors: {
        background: "#111217",
        surface: "#333333",
        "surface-variant": "#666666",
        primary: "#3F51B5",
        secondary: "#707070",
        accent: "#82B1FF",
        error: "#fb6d6d",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00",
        border: "#606060",
        text: "#DEDEDE",
        "surface-bright": "#CCCCCC",
        "background-lighten-1": "#080808",
        "text-lighten-1": "#808080",
        "border-lighten-1": "#444444"
    },
},
```

## theme.MODE.formats

| Name | theme.MODE.formats |
|-|-|
| Description | The theme formats.|
| Synopsis | `formats: {...}` |

```js
dark: {
    formats: {
        mstime: "mmm d, H:MM:ss:l",
        time: "mmm d, HH:MM:ss",
        fulltime: "ddd d mmm h:MM:ss tt",
        date: "mmm d, yyyy"
    },
},
```


## theme.MODE.variables

| Name | theme.MODE.variables |
|-|-|
| Description | The theme variables.|
| Synopsis | `variables: {...}` |

```js
dark: {
    variables: {
        "font-size": "15px"
    },
},
```

## theme.MODE.title

| Name | theme.MODE.title |
|-|-|
| Description | The device title displayed in the navigation bar.|
| Synopsis | `title: "Few word title"` |

```js
light: {
    title: 'Acme Rocket'
}
```

## timeouts

| Name | timeouts |
|-|-|
| Description | Define timeout periods for various manager refresh tasks. |
| Synopsis | `timeouts: { dashboard: seconds }`|
| Note | The dashboard time governs how frequently dashboard widgets are updated. You can provide a numeric value in seconds or a textual value such as "3secs".

**Example**

```js
timeouts: {
    dashboard: '10secs'
}
```

## version

| Name | version |
|-|-|
| Description | The version number of your display.json5 file (SemVer). |
| Synopsis | `version: "SemVer compatible version"` |

**Example**

```js
version: '1.2.3'
```

## views

| Name | views |
|-|-|
| Description | Array of UI pages to define
| Synopsis | `views: [ { view }, ...]` |
| Note | Views may also be nested under a view. Such nested views are presented as tabbed views under a common parent view.

**Example**

```js
{
    name: 'fleet',
    title: 'Fleet Overview',
    path: '/fleet',
    icon: '$gauge',
    component: 'Fleet',
    role: 'user',
    menu: 'Fleet',
    period: 10
    views: [
        { /* Tabbed sub-views */ },
    ]
}
```


## view.component

| Name | view.component |
|-|-|
| Description | VueJS component to display for the view
| Synopsis | `component: "ComponentName"`
| Note | The component can be an inbuilt DevCore component or it can be a component provided by the extension components defined via the **modules** property.<br><br>The inbuilt components are listed below.

**Example**

```js
{
    component: 'Generic',
},
```

**Inbuilt VueJS Components**

These components can be referenced in the display.json5 file.

* AccountSettings
* Dashboard
* GenericList
* GenericEdit
* DeviceClaim
* DeviceClaimModal
* DeviceRelease
* Forgot
* Login
* UserPassword
* UserList
* UserProfile


## view.enable

| Name | view.enble |
|-|-|
| Description | Enable or disable the view
| Synopsis | `enable: true | false | expression`

May be set to true or false to statically enable or disable a view. May also be set to a JavaScript expression to enable or disable the view based on the current app context. For example:

```js
enable: "width >= 1024"
```

See [Expressions](expressions.md) for more information on the expression syntax.

**Example**

```js
enable: 'width >= 1024 && language == /en/ && someContextProperty'
```

## view.height

| Name | view.height |
|-|-|
| Description | Default view widget height
| Synopsis | `height: Pixels`
| Note | This defines the default height for the view's widgets

**Example**

```js
{
    height: 300
}
```

## view.icon

| Name | view.icon |
|-|-|
| Description | Icon to display in menus
| Synopsis | `icon: "mdi-NAME"`
| Note | The icon name is the name of an icon alias. You should use the icon alias name with an "$" prefix.

**Example**

```js
{
    icon: '$edit'
},
```

The Manager class provides a subset of the [Material Design Icons](https://materialdesignicons.com/). Applications can import and add additional aliases when initializing the Manager class.

The following icon aliases are provided as standard:

Icon Alias | Icon Name
-|-
account| account
alert| alert
auto| brightnessauto
aws| aws
bell| bell
bookmark| bookmarkmultiple
bookshelf| bookshelf
bridge | bridge
calendar | calendar
cancel | close-circle
checkboxindeterminate | minus-box
checkboxoff | checkbox-blank-outline
checkboxon | checkbox-marked
clear | close-circle
cart | cart
click | cursordefaultclick
clipboard | clipboardtext
clock | clockoutline
cloud | cloud
close | close
cog | cog
cogoutline | cogoutline
collapse | chevron-up
complete | check
copy | contentcopy
critical | flash
cube | cubesend
dark | brightness3
dashboard | monitordashboard
delete | close-circle
delimiter | circle
devices | devices
down | chevrondown
download | download
dropdown | menu-down
edit | pencil
error | close-circle
expand | chevron-down
email | email
error | alertcircleoutline
eye | eye
eyedropper | eyedropper
eyeoff | eyeoff
facebook | facebook
function | function
file | paperclip
first | page-first
gauge | gauge
grid | viewgridoutline
google | google
info | information
last | page-last
lan | lan
launch | launch
leftarrow | arrowleftbold
light | brightness5
login | login
loading | cached
menu | menu
minus | minus
next | chevron-right
plus | plus
magnify | magnify
medical | medicalbag
monitor | monitor
offline | flashoutline
online | checkcircleoutline
open | lockopen
phone | phone
play | play
plusboxoutline | plusboxoutline
prev | chevron-left
radiooff | radiobox-blank
radioon | radiobox-marked
ratingempty | star-outline
ratingfull | star
ratinghalf | star-half-full
rightarrow | arrowrightbold
reload | reload
redo | redo
resize | resizebottomright
rss | rss
run | run
sortasc | arrow-up
sortdesc | arrow-down
security | security
send | send
start | raystartarrow
stop | stop
support | hospitalbox
swap | swapverticalbold
subgroup | menu-down
success | check-circle
tap | gesturetapbutton
up | chevronup
unfold | unfold-more-horizontal
warning | alert-circlewarn | alertcircleoutline
wizard | autofix
wrench | wrench

To add icons when initializing the Manager, import the icons and add to the **vuetifyProps** when calling **createVuetify**.

```js
import {mdiFormatListBulletedSquare} from '@mdi/js'

const Icons = {
    events: mdiFormatListBulletedSquare,
}

async function main() {
    let vue = createApp(Main)
    let router = createRouter({
        history: createWebHashHistory(),
        routes: [],
    })
    let vuetify = createVuetify(
        vuetifyProps({
            components: components,
            directives: directives,
            icons: Icons,
            theme: Display.theme.theme,
        })
    )
}
```

And then supply the icons when calling 

```js
```


## view.menu

| Name | view.menu |
|-|-|
| Description | Display the view in the sidebar menu with the given text
| Synopsis | `menu: 'MenuTitle`

**Example**

```js
{
    menu: 'MyMenuItem'
},
```


## view.name

| Name | view.name |
|-|-|
| Description | Name of the view
| Synopsis | `name: "One-word-name"`
| Note | This name is used in several places including as a page title and VueJS route name.

**Example**

```js
{
    name: 'fleet'
},
```


## view.panels

| Name | view.panels |
|-|-|
| Description | Array of slide in panels that overlay the view.
| Synopsis | `panels: [ { panel }, ...]`
| Note | Panels are defined inside a parent view. Panels are invoked via buttons defined in the panel properties that are displayed in the parent view. A typical use case is a parent view list of device components and a panel to edit a selected component. For example: from a parent view of device fans, a fan could be selected and an edit panel could modify the fan's operational properties.

**Example**

```js
panels: [
    {
        name: 'claim',
        component: 'DeviceClaim',
        role: 'admin',
        button: 'Claim Device',
        width: '500px'
    }
]
```


## view.panel.button

| Name | view.panel.button |
|-|-|
| Description | Button text to display in the parent view's table.
| Synopsis | `role: "User-role"`
| Notes | The button will be automatically displayed by panel view parents that use the **GenericList** component. If you are using a custom view parent component, you will need to manage the buttons display in that component.

**Example**

```js
{
    button: 'admin',
},
```


## view.panel.component

| Name | view.panel.component |
|-|-|
| Description | VueJS component to display for the panel
| Synopsis | `component: "ComponentName"`
| Note | The component can be an inbuilt Ioto Manager component or it can be a component provided by the extension components defined via the **modules** property.<br><br>The inbuilt components are listed below.

**Example**

```js
{
    component: 'TempPanel',
},
```

## view.panel.fields

| Name | view.panel.fields |
|-|-|
| Description | Array of fields to edit
| Synopsis | `fields: [ {field definition}, ...]`
| Note | This defines an array of fields to edit when using the GenericEdit component. Input fields have a defined "type" which determines the HTML component used to edit the field value. Supported field types include: checkbox, combo, date, label, password, radio, select, slider, switch, text and textarea.

**Example**

```js
{
    panels: [
        {
            name: 'edit',
            component: 'GenericEdit',
            role: 'admin',
            fields: [
                {
                    name: 'name',
                    type: 'label',
                    role: 'user',
                    props: {'max': 100},
                    width: 6,
                }
            ]
        }
    ]
},
```

## view.panel.fields.label

| Name | view.panel.fields.label |
|-|-|
| Description | Field displayed label
| Synopsis | `label: "fieldLabel"`
| Note | The field label is displayed before the input field. If not provided, the field name is converted to PascalCase and used by default.

**Example**

```js
{
    label: 'Speed'
}
```


## view.panel.fields.name

| Name | view.panel.fields.name |
|-|-|
| Description | Field name
| Synopsis | `name: "oneWordName"`
| Note | If a field title is not provided, the field name is converted to PascalCase and is used as the input field title.

**Example**

```js
{
    name: 'speed'
}
```


## view.panel.fields.role

| Name | view.panel.fields.role |
|-|-|
| Description | Required user role to display the field
| Synopsis | `role: "User-role"`
| Notes | The user role may be selected from "public", "user", "admin", "support" or "owner". The public role permits unauthenticated access. The other roles require a login with the requisite role.

**Example**

```js
{
    rolew 'admin'
},
```


## view.panel.fields.select

| Name | view.panel.fields.select |
|-|-|
| Description | Selectable options for switch fields.
| Synopsis | `select: {options, ...}`

**Example**

```js
{
    select: {online: true, offline: false}
},
```
## view.panel.fields.type

| Name | view.panel.fields.type |
|-|-|
| Description | Field's input UI display type
| Synopsis | `type: "Type"`
| Note | If the type is not provided, the Manager attempts to sleuth the type based on the data value provided to edit.

**Example**

```js
{
    name: 'status',
    type: 'switch',
    select: {online: true, offline: false},
    width: 6
}
```

**The supported panel field data types are:

** checkbox
** combo
** date
** label
** password
** radio
** select
** slider
** switch
** text
** textarea


## view.panel.fields.width

| Name | view.panel.fields.width |
|-|-|
| Description | Number of columns the input field should occupy.
| Synopsis | `width: "1-12"`
| Note | The width is expressed as a number of columns between 1 and 12. The GenericEdit component uses a layout grid of 12 columns. GenericEdit will pack fields to fill a row, before starting a new display row.

**Example**

```js
{
    name: 'User Password',
    type: 'password',
    select: {online: true, offline: false},
    width: 6
}
```



## view.panel.name

| Name | view.panel.name |
|-|-|
| Description | Unique panel name
| Synopsis | `name: "Name"`

**Example**

```js
{
    name: 'TempEdit',
},
```


## view.panel.role

| Name | view.panel.role |
|-|-|
| Description | Required user role to allow access
| Synopsis | `role: "User-role"`
| Notes | The user role may be selected from "public", "user", "admin", "support" or "owner". The public role permits unauthenticated access. The other roles require a login with the requisite role.

**Example**

```js
{
    role: 'admin',
},
```



## view.panel.title

| Name | view.panel.title |
|-|-|
| Description | Panel Title
| Synopsis | `title: "Title"`
| Notes | If the panel title is not provided, a title is created using the name of the **model** defined in the parent view **table** property. The model name is prefixed with 'Create' or 'Modify' as appropriate. For example, if the model was "Port" and an existing port item was selected in the table, the panel title would be "Modify Port".

**Example**

```js
{
    title: 'Temperature Settings',
},
```


## view.panel.width

| Name | view.panel.width |
|-|-|
| Description | Display width of the panel
| Synopsis | `width: "NNpx"`
| Notes | The default panel width is 700px.

**Example**

```js
{
    width: '500px',
},
```



## view.path

| Name | view.path |
|-|-|
| Description | URL path for the view
| Synopsis | `path: "/URL/PATH"`
| Note | The URL path is used by VueJS when constructing the app routes and at runtime for navigating the views.

**Example**

```js
{
    path: '/device/list',
},
```


## view.refresh

| Name | view.refresh |
|-|-|
| Description | Update period to refresh the view's data
| Synopsis | `refresh: Number | "period"`
| Notes | This is the period for refreshable components to update their data. The period may be a number of seconds or a string equivalent.

**Example**

```js
{
    refresh: '5secs',
},
```


## view.role

| Name | view.role |
|-|-|
| Description | Required user role to allow access
| Synopsis | `role: "User-role"`
| Notes | The user role may be selected from "public", "user", "admin", "support" or "owner". The public role permits unauthenticated access. The other roles require a login with the requisite role.

**Example**

```js
{
    role: 'user',
},
```


## view.table

| Name | view.table |
|-|-|
| Description | View data table definition
| Synopsis | `table: {table-properties}`
| Note | The GenericList component displays database model items as a table. The table can be extensively customized by table properties.

**Background**

The table is displayed by retrieving items from the **table.model** database model type. The columns of the table are defined via the **table.fields** and are displayed in order. Table action menu options are derived from the **table.actions** collection with buttons from any relevant view panels.

** Data Table**
![Data Table](/images/manager/table.png){class="screen"}

**Example**

This example formats the image above:

```js
{
    table: {
        model: 'Event',
        fields: [
            {name: 'edit', icon: '$edit'},
            {name: 'timestamp', width: '5%'},
            {
                name: 'severity',
                width: '5%',
                icon: {
                    info: {name: '$info', color: 'green'},
                    warn: {name: '$warn', color: 'orange'},
                    error: {name: '$error', color: 'red'},
                    critical: {name: '$critical', color: 'red'}
                }
            },
            {name: 'source'},
            {name: 'subject', align: 'left'},
            {name: 'message'},
            {name: '*', launch: 'edit'}
        ],
        actions: {
            edit: {count: 1, launch: 'edit'},
            delete: {count: 2, confirm: true}
        }
    }
}
```


## view.table.actions

| Name | view.table.actions |
|-|-|
| Description | Actions that can be performed on selected table items.
| Synopsis | `actions: { action, ...}`
| Notes | The action collection has one or more action definitions. Each definition is a set of properties that scopes how many items can be manipulated (count), the view panel to display (panel), if user confirmation is required before taking the action (confirm) and whether a launch button should be displayed (launch).

**Example**

```js
{
    table: {
        actions: {
            edit: {count: 1, launch: 'edit'},
            delete: {count: 2, confirm: true}
        }
    }
}
```


## view.table.actions.confirm

| Name | view.table.actions.confirm |
|-|-|
| Description | Display a dialog requesting user confirmation before invoking the action.
| Synopsis | `confirm: true | false`

**Example**

```js
{
    table: {
        actions: {
            delete: {count: 2, confirm: true}
        }
    }
}
```


## view.table.actions.count

| Name | view.table.actions.count |
|-|-|
| Description | Number of selected items the action supports.
| Synopsis | `count: Number`
| Notes | Set count to 0 for "add" actions that require no selected items. Set count to 1 for actions that can operate on only 1 item at a time. Set count to 2 for actions that can operation on multiple selected items.

**Example**

```js
{
    table: {
        actions: {
            delete: {count: 2, confirm: true}
        }
    }
}
```


## view.table.actions.invoke

| Name | view.table.actions.invoke |
|-|-|
| Description | Panel name to display or URL to navigate to when the action is invoked
| Synopsis | `invoke: "ComponentName"`
| Notes | The invoke property defines a VueJS component that will be invoked when the action is triggered. The component will be passed properties containing the data item (item) and the data model (model).

**Example**

```js
{
    table: {
        actions: {
            restart: {count: 2, launch: 'NetRestart'}
        }
    }
}
```


## view.table.actions.launch

| Name | view.table.actions.launch |
|-|-|
| Description | Panel name to display or URL to navigate to when the action is invoked
| Synopsis | `launch: "PanelName" | "URL"`
| Notes | If set to a URL, you can use **:token** segments that will be expanded at runtime from the application route context.

**Example**

```js
{
    table: {
        actions: {
            add: {count: 0, launch: 'claim'}
        }
    }
}
```


## view.table.actions.panel

| Name | view.table.actions.panel |
|-|-|
| Description | Panel to display when the action is invoked
| Synopsis | `panel: "PanelName"`
| Notes | Panels can only be used for actions of count 0 or 1.

**Example**

```js
{
    table: {
        actions: {
            edit: {count: 1, launch: 'edit'}
        }
    }
}
```

## view.table.fields

| Name | view.table.fields |
|-|-|
| Description | Define the table fields (columns) to display.
| Synopsis | `fields: [ {field-definitions}, ...]`
| Notes | The fields define each column in the displayed table. A field definition includes the data items name, with display formatting options.<br><br>A pseudo field with the name "*" may be defined to specify a launch action that will be invoked as a default when a row/column combination is click.

**Example**

```js
{
    table: {
        model: 'Port',
        fields: [
            {name: 'edit', icon: '$edit', width: '5%'},
            {name: 'name', align: 'center'},
            {
                name: 'status',
                align: 'center',
                icon: {
                    online: {name: '$online', color: 'green'},
                    offline: '$offline'
                }
            },
            {name: 'negotiate', align: 'center', icon: '$check'},
            {name: 'duplex', align: 'center', icon: '$check'},
            {name: 'flowControl', align: 'center', icon: '$check'},
            {name: 'jumbo', align: 'center', icon: '$check'},
            {name: 'speed', align: 'center'},
            {name: '*', launch: 'edit'}
        ]
    }
}
```


## view.table.fields.align

| Name | view.table.fields.align |
|-|-|
| Description | Align the table column
| Synopsis | `align: "center | left | right"`

```js
{
    align: 'center'
}
```

## view.table.fields.css

| Name | view.table.fields.css |
|-|-|
| Description | CSS style name
| Synopsis | `style: "RuleName"`
| Note | CSS rule to apply to the displayed field cells. The CSS rule must exist in a custom component.

```js
{
    css:: 'unit-status'
}
```

## view.table.fields.icon

| Name | view.table.fields.icon |
|-|-|
| Description | Display an icon representing the field value
| Synopsis | `icon: "iconAliasName" | {value-map}`
| Notes | When set to a map value, the field value is used as an index into the map. If the index is not found, the "default" index is used. The map value may be either an icon name or a map containing a "name" property that specifies the icon name and a color property that specifies the color to use for the icon.

```js
{
    icon: 'mdi-pencil'

    // or
    icon: {
        online: {name: '$online', color: 'green'},
        offline: '$offline',
        default: '$offline'
    }
}
```

## view.table.fields.launch

| Name | view.table.fields.launch |
|-|-|
| Description | Panel to launch or URL to navigate to
| Synopsis | `launch: "PanelName" | "URL"`
| Notes | If set to a URL, you can use **:token** segments that will be expanded at runtime from the application route context.

```js
{
    launch: 'edit'
}
```

## view.table.fields.name

| Name | view.table.fields.name |
|-|-|
| Description | Name of the data item field to display
| Synopsis | `name: "fieldName"`
| Note | If a field.title property is not specified, the name is converted to PascalCase and used as the title.

```js
{
    name: 'id'
}
```


## view.table.fields.style

| Name | view.table.fields.style |
|-|-|
| Description | CSS style to apply to column cells
| Synopsis | `style: "CSS properties; ..."`

```js
{
    style: 'max-width: 400px; text-overflow: ellipsis;'
}
```


## view.table.fields.title

| Name | view.table.fields.title |
|-|-|
| Description | Column title to display for the field
| Synopsis | `title: "Column Title"`

```js
{
    title: 'Current Temperature'
}
```

## view.table.fields.width

| Name | view.table.fields.width |
|-|-|
| Description | Set the preferred width of the column.
| Synopsis | `width: "NNpx" | "NN%"`
| Note | This will set the initial preferred width of the column.

```js
{
    width: '5%'
}
```


## view.table.sort

| Name | view.table.sort |
|-|-|
| Description | How to sort the rows of the table
| Synopsis | `sort: "column:asc|desc"`

**Example**

This will sort the table based on an ascending order of the "name" column.

```js
{
    table: {
        sort: 'name:asc',
    }
}
```



## view.table.model

| Name | view.table.model |
|-|-|
| Description | Database model name to retrieve for table data
| Synopsis | `model: "ModelName"`

**Example**

```js
{
    table: {
        model: 'Event',
    }
}
```


## view.widgets

| Name | view.widgets |
|-|-|
| Description | Set of widgets to display when using the Dashboard component.
| Synopsis | `widgets: [ {widget}, ...]`
| Note | The widgets property defines an ordered set of widgets to be displayed by the Dashboard component. The enclosing view must set the component property to "Dashboard".

**Example**

```js
{
    views: [ {
        name: 'Overview',
        component: 'Dashboard',
        widgets: [
            {
                type: 'gauge',
                title: 'Network IO',
                min: 0,
                max: 10000,
                data: { model: 'Stats', field: 'io' }
            }
        ]
    } ]
}
```

**Supported Widget Types**

* button
* event
* file
* form
* gauge
* graph
* image
* input
* led
* numeric
* progress
* service
* shape
* sign
* text
* table

## view.widget.accept

| Name | view.widget.accept |
|-|-|
| Description | Define file types acceptable for use with a file up load widget
| Synopsis | `accept: 'image/*'`


## view.widget.action

| Name | view.widget.action |
|-|-|
| Description | Automation actions to invoke when the widget is clicked
| Synopsis | `action: { type: 'trigger', target: 'MyAction'}`

Widget actions are used to react to user input.

Therre are three action types:

* trigger - Invoke a device cloud automation trigger
* link - Navigate to a new URL in the app
* dashboard - Display the named dashboard

The action target is the name of the automation action, the navigation URL or the dashboard name, depending on the action type.

For **trigger** types, when the widget is clicked, the set of conditions are evaluated. For the first condition that evaluates to true, the specified automation trigger is invoked in the device cloud with the condition parameters.

**Example**

```js
{
    action: {
        type: 'trigger',
        trigger: 'MyAction',
        conditions: [{
            expression: 'expression-to-eval',
            params: {}
        }]
    }
}
```

**Example**

```js
{
    action: {
        type: 'link',
        target: '/ports',
    }
}
```

## view.widget.axes

| Name | view.widget.axes |
|-|-|
| Description | Axes labels for "graph" and "time" widgets.
| Synopsis | `axes: {"x" "text", "y": "Text"`

**Example**

```js
{
    axes: {
        x: 'Time', 
        y: 'KB'
    },
}
```

## view.widget.data

| Name | view.widget.data |
|-|-|
| Description | Map specifying the widget data source
| Synopsis | `data: {properties...}`

Note | The data.model property specifies the database model name. The data.field specifies the data field within that model.

Data can be sourced from the Ioto cloud database or Ioto metrics. To access data from the database, specify a **model**, **field** and row selection **where** expression.

**Database Example**

```js
{
    data: {
        model: 'Test',
        field: 'cpu',
    }
}
```

This will select the **cpu** field from the **Test** table. You can also use a **where** clause to select a table item (row). For example:

```js
{
    data: {
        model: 'Test',
        field: 'value',
        where: '${name} = {cpu}',
    }
}
```

This will select the **value** field from the **Test** table using the item (row) where the **name** field has the value "cpu".

**Metric Example**

To select an Ioto Metric, first define the metric to be created using the ...

Specify the metric **owner**, **namespace**, **metric** to select the desired metric. Then specify the metric data span to be one of "5min", "hr", "day", "wk", "mth" or "year". Set the metric statistic to be one of "avg", "min", "max", "count", "current" or "sum".

Metrics can have dimensions that further select the desired metric value. 

```js
{
    data: {
        owner: 'account',
        namespace: 'Embedthis/Device',
        metric: 'cpu',
        span: 'day',
        statistic: 'p90',
        dimensions: [{Device: 'deviceId'}],
    }
}
```


## view.widget.datetime

| Name | view.widget.datetime |
|-|-|
| Description | Enable the input widget calendar selection by date, time or datetime
| Synopsis | `datetime: 'datetime'"

**Example**

```js
{
    datetime: 'date'
}
```


## view.widget.field

| Name | view.widget.field |
|-|-|
| Description | Widget field text
| Synopsis | `field: "address"

The `field` property defines the input form field name in which to store the input data.

**Example**

```js
{
    field: 'firstName'
}
```

## view.widget.fields

| Name | view.widget.fields |
|-|-|
| Description | Table widget fields to display
| Synopsis | `fields: [table field names, ...],

The `fields` property defines the table widget fields and their order of display.

**Example**

```js
{
    fields: ['car', 'battery', 'house']
}
```

## view.widget.footer

| Name | view.widget.footer |
|-|-|
| Description | Widget footer text
| Synopsis | `footer: "Footer Text"

The widget header and footer are rendered over the widget in a standard position. You can modify the style and position of the header and footer by using Widget CSS properties.

**Example**

```js
{
    footer: 'Active Ports'
}
```

## view.widget.form

| Name | view.widget.form |
|-|-|
| Description | Form widget name
| Synopsis | `form: "FormName"

The form widget displays a "Save" button that when clicked will submit the values of all input widgets that refer to the form.

If the `widget.text` property is defined, that text will be used instead of "Save".

Input widgets can be used stand-alone without a form in which case, they will submit their value immediately when changed.

If input widgets refer to a form widget, they are only submitted to the cloud when the Save button is clicked.


## view.widget.format

| Name | view.widget.format |
|-|-|
| Description | Numeric display format
| Synopsis | `format: "Format String"

The format string is used to format numeric values.
The following format specifiers can be used:

Character | Description
-|-
0 | digits with leading zero
# | digit 
, | Thousand separators
% | format as percent
+ | Always show sign
- | Show sign if negative
^ | Round up
v | Round down

**Example**

```js
{
    format: '-0#,###.#^'
}
```

## view.widget.framed

| Name | view.widget.framed |
|-|-|
| Description | How to frame the widget
| Synopsis | `framed: boolean | null`

If set to true, the widget will be rendered in a frame. If set to false, it will not have a frame.
If set to null, which is the default, the widget will use the Dashboard frame setting.

**Example**

```js
{
    framed: true
}
```

## view.widget.header

| Name | view.widget.header |
|-|-|
| Description | Widget header text
| Synopsis | `header: 'Widget Header Text'`

The widget header and footer are rendered over the widget in a standard position. You can modify the style and position of the header and footer by using Widget CSS properties.

**Example**

```js
{
    header: 'Temperature Today'
}
```


## view.widget.height

| Name | view.widget.height |
|-|-|
| Description | Widget height in pixels
| Synopsis | `height: Pixels`

**Example**

```js
{
    height: '300'
}
```


## view.widget.input

| Name | view.widget.input |
|-|-|
| Description | Type of input widget
| Synopsis | `input: 'input type'`

If the widget type is set to `input`, the widget.input property defines the type of input.

The supported Input widget types are:

* Checkbox
* Combo
* Date
* File
* Password
* Radio
* Select
* Slider
* Switch
* Text Field
* Text Area

**Example**

```js
{
    input: 'text'
}
```

## view.widget.items

| Name | view.widget.items |
|-|-|
| Description | Set of items to use with the input widget selections
| Synopsis | `items: [{Array or Map}]`

The input `select`, `radio` and `combo` input types utilize selection items. You can provide
either an array of items or a map of items and their corresponding selection values.

**Example**

```js
{
    items: {red: '#FF0000', blue: '#0000FF'}
or
    items: ['red', 'blue', 'yellow'],
}
```


## view.widget.label

| Name | view.widget.label |
|-|-|
| Description | Label to use for input widgets
| Synopsis | `label: 'text label'`

**Example**

```js
{
    label: 'First Name'
}
```


## view.widget.limit

| Name | view.widget.limit |
|-|-|
| Description | Limit of items for the table widget to display 
| Synopsis | `limit: Number'`

The table widget will display items up to the limit and will provide pagination icons to navigate to the next page of results.

**Example**

```js
{
    limit: 20
}
```


## view.widget.left

| Name | view.widget.left |
|-|-|
| Description | Offset from the left of the display to position the widget
| Synopsis | `left: 100`

This property can be used to absolutely position a widget. The property can be set to the number of pixels or to a percentage fraction less than one.

If set to 0.25, the widget will be positioned 1/4 across the page.

**Example**

```js
{
    top: 0,
    left: 0.25,
    height: 100,
    width: 100,
}
```

## view.widget.max

| Name | view.widget.max |
|-|-|
| Description | Maximum data value
| Synopsis | `max: Value`
| Note | This defines the maximum value the data field may take. It is used to scale the widget display. The default is to set the maximum field value observed.

**Example**

```js
{
    max: 100
}
```

## view.widget.min

| Name | view.widget.min |
|-|-|
| Description | Minimum data value
| Synopsis | `min: Value`
| Note | This defines the minimum value the data field may take. It is used to scale the widget display. The default is set to the minimum field value observed.

**Example**

```js
{
    min: 100
}
```

## view.widget.options

| Name | view.widget.options |
|-|-|
| Description | Map of widget specific options
| Synopsis | `options: { properties }'`

Custom widgets can configure and store private options in the widget.options map.

**Example**

```js
{
    options: {
        span: 10000
    }
}
```


## view.widget.placeholder

| Name | view.widget.placeholder |
|-|-|
| Description | Placeholder text to use for input widgets
| Synopsis | `placeholder: 'text'`

The input widget can display placeholder text before a user has entered text.

```js
{
    placeholder: 'Enter a valid phone number'
}
```


## view.widget.prefix

| Name | view.widget.prefix |
|-|-|
| Description | Text prefix to prepend to the displayed value 
| Synopsis | `prefix: 'text'`

The prefix is displayed before the value text. If the prefix contains a `icon:` leading portion, the prefix will be interpreted as an icon.

**Example**

```js
{
    prefix: 'icon:$alarm'
}
```

## view.widget.range

| Name | view.widget.range |
|-|-|
| Description | The time range for data displayed
| Synopsis | `range: {period: Seconds}`

**Example**

```js
{
    range: {
        period: 3600
    }
}
```


## view.widget.statistic

| Name | view.widget.statistic |
|-|-|
| Description | Metric statistic to display
| Synopsis | `statistic: 'avg'`
| Note | Select from "avg", "min", "max", "count", "current" or "sum".

**Example**

```js
{
    statistic: 'sum'
}
```

## view.widget.suffix

| Name | view.widget.suffix |
|-|-|
| Description | Text suffix to append to the displayed value 
| Synopsis | `suffix: 'text'`

The suffix is displayed after the value text. If the suffix contains a `icon:` leading portion, the suffix will be interpreted as an icon.

**Example**

```js
{
    suffix: 'icon:$alarm'
}
```

## view.widget.text

| Name | view.widget.text |
|-|-|
| Description | Text to display. 
| Synopsis | `text: 'message'`

Some widgets such as the Button widget, can display a fixed messages instead of a data source value.

**Example**

```js
{
    text: 'Click Me'
}
```

## view.widget.ticks

| Name | view.widget.ticks |
|-|-|
| Description | The number of data items on the x axis
| Synopsis | `ticks: Number`

**Example**

```js
{
    ticks: 12
}
```

## view.widget.timezone

| Name | view.widget.timezone |
|-|-|
| Description | The timezone to use with the input widget when using a date input field
| Synopsis | `timezone: 'timezone'`

**Example**

```js
{
    timezone: 'utc'
}
```


## view.widget.title

| Name | view.widget.title |
|-|-|
| Description | Widget title to display
| Synopsis | `title: "Title"`
| Note | See also widget.footer


**Example**

```js
{
    title: 'Network IO',
}
```

## view.widget.url

| Name | view.widget.url |
|-|-|
| Description | Source URL for image widgets
| Synopsis | `url: 'URL'`

Image widgets can load images by specifying the widget.url property.

**Example**

```js
{
    url: 'https://example.com/sunset.jpg',
}
```


## view.widget.top

| Name | view.widget.top |
|-|-|
| Description | Offset from the top of the display to position the widget
| Synopsis | `top: 10`

This property can be used to absolutely position a widget.

**Example**

```js
{
    top: 0,
    left: 100,
    height: 100,
    width: 100,
}
```

## view.widget.type

| Name | view.widget.type |
|-|-|
| Description | Type of widget
| Synopsis | `widgets: [ {widget}, ...]`
| Note | The widget type must be set to one of: event, gauge, graph, led, numeric, progress, text, time.


**Example**

```js
{
    type: 'gauge',
    title: 'Network IO',
}
```

## view.widget.validate

| Name | view.widget.validate |
|-|-|
| Description | Validation regular expression for input widgets
| Synopsis | `validate: 'Regular Expression'`

The input widget can use the `validate` property to test user entered data conforms to the required data format.

The regular expression is NOT enclosed in slash delimiters.

**Example**

```js
{
    validate: '^[0-9]+$'

}
```


## view.widget.width

| Name | view.widget.width |
|-|-|
| Description | Widget width in pixels or percentage
| Synopsis | `width: Pixels|Percentage`

**Example**

```js
{
    width: '25%'
}
```

## view.widget.z

| Name | view.widget.z |
|-|-|
| Description | Set the z-order of a widget when using the Exact dashboard layout
| Synopsis | `z: Number`

The Exact dashboard layout engine positions widgets exactly and permits widgets to overlap.
By setting the Z ordering, you can overlay widgets to create a desired effect.

The default `z` value is 0.

**Example**

```js
{
    z: 2
}
```# REST Models

To facilitate the easy access to device data, the DevCore utilizes REST models that provide access methods to get, find, update and manage remote device data.

A REST model adapts Javascript requests for data into HTTP requests to a backend service. The DevCore REST models can communciate with cloud-based or local device backends with change.

## Constructing

For each device data entity, REST models can be created using the DevCore's Rest constructor. For example:

```js
import {Rest} from '@embedthis/devcore'

const Port = new Rest('port')
```

Once constructed, the app can use the model to manage the controlled entity:

```js
let portList = await Port.find()
let port = await Port.get({name: 'eth-00'})
await Port.remove({id: port.id})
```

## Standard Models

The DevCore framework provides a set of standard models that can be used to manage the device and device data. These models are located in the `framework/models` directory. These include:

    Account, Action, Alert, Dashboard, Device, Generic, Manager, Metric and User

These REST models references can be imported by the **getModels** function:

```js
import {getModels} from '@embedthis/devcore'

const {Alert, Dashboard, User} = getModels()
```

## Standard Methods

The Rest constructor will create the following standard access methods:

Method | Method | URL | Description
|-|-|-|-|
get | POST | /:controller/get | Get a data item
find | POST | /:controller/find | Find a set of matching items
remove | POST | /:controller/remove | Remove an item
update | POST | /:controller/update | Update an item

Where **:controller** is replaced with the name provided to the Rest constructor. The Ioto cloud service only implements the "POST" method whereas the Ioto agent embedded web server supports all HTTP verbs.

## Custom Methods

You can provide additional methods for custom methods via an additional argument to the Rest constructor.

```js
const Port = new Rest('port', {
    rest: { method: 'POST', uri: '/:controller/reset' },
    ...
})
```

## Embedded Web Server

The Ioto embedded web server can define Action methods that connect with each of the REST model request methods via the **webAddAction** C API. 

Hosted device clouds provide standard backend methods. So to implement custom Rest methods, you use a different technique where the logic is implemented inline in the Rest method.

When using the local web server, ensure you set the DevCore `api` property to `/api`.

## Inline Custom Methods

You can provide inline methods to implement Rest methods with centralized logic for device operations. 

For example:

```js
const Port = new Rest('port', {
    reset: { invoke: async (fields) => {
        //  Custom logic
    }},
    ...
})
```

## Tunnels Requests

Hosted device cloud requests for non-standard models are handled by a **"Generic"** cloud controller rather than individual controllers for each Rest instance.

Consequently, Rest requests are "tunneled" though the "Generic" controller. To achieve this, the tunnel mapping is specified via the Rest constructor.

```js
const Port = new Rest('port', {}, {
    tunnel: 'Port',
})
```

This will tunnel Port requests to the Generic controller to access the **"Port"** database entity.

## Adding Context

It is sometimes convenient to add application context to the Rest request properties. This can be done via the **"context"** property.

The **context** method is provided the request body properties. These can be modified to add or remove values. 

The **state.app.context** collection stores the **deviceId** and other values added via the **state.app.addContext** method.

For example: this will add the deviceId to all requests:

```js
const Port = new Rest('port', {},
    context: (body) => {
        body.deviceId = state.app.context.deviceId
        return body
    }
)
```

## Rest API Properties

The Rest API method definitions can use the following properties:

Property | Description
-|-
base        | Base url to use instead of the config.api
body        | Post body data
clear       | Clear prior feedback
feedback    | If true, emit feedback on success. Default, emit only on errors.
invoke      | Function to invoke instead of issuing URI request
log         | Set to true to trace the request and response
method      | HTTP method verb
nologout    | Don't logout if response is 401
noparse     | Don't json parse any JSON response
noprefix    | Don't prefix the URL. Use the window.location host address.
progress    | If true, show progress bar.
raw         | If true, return the full response object (see below). If false, return just the data.
refresh     | To control cache refresh
throw       | If false, do not throw on errors
uri         | URI template. Fields prefixed with ":" are expanded.# App Display

You can customize the structure of an app's pages, menus, navigation, panels and add custom UI components.

## Display Configuration

The app's user interface is defined by a JSON5 configuration file named `display.json5`. The file is in a [JSON5](https://json5.org/) format which approximates native JavaScript.

The display.json5 file controls the following display items:

* Multiple display definitions for various device types
* Display color theme including dark and light modes
* Menu items and options
* UI pages
* Data tables and fields
* Device data edit property panels
* Dashboards and widgets
* Configurable Options

When imported by a `main.js` file, the display.json5 file will be reformatted to a `display.js` JavaScript file to it can be imported.

Here is a subset example of a display.json5 file:

```js
{
    name: 'MyApp',
    version: '1.0.0',
    format: '1.2.0',
    displays: [ {
        name: 'Desktop',
        expression: 'width > 1024',
        description: 'Display for MyApp',
        features: {
            dash: {
                actions: true,
                edit: true,
                database: true,
                metrics: true,
            }
        },
        theme: {
            dark: {
                title: 'Device App',
                logo: '/images/ioto-logo-dark.png',
                ...
            },
            light: { 
                logo: '/images/ioto-logo-light.png',
                ...
            },
        },
        views: [{
            path: '/', name: 'home', redirect: 'devices' 
            views: [
                { path: 'login', component: 'Login' },
                {
                    path: 'devices',
                    menu: 'Devices'
                    icon: 'devices',
                    component: 'GenericList',
                    table: {
                        model: 'Device',
                        title: 'Devices',
                        subtitle: 'Click on a device to explore',
                        fields: [
                            {name: 'product'},
                            {name: 'description'},
                            {name: 'model'},
                            {name: 'id', title: 'Device ID'},
                            {name: '*', launch: '/devices/:id/overview'}
                        ],
                        actions: {
                            add: { count: 0, launch: 'claim' },
                            release: { 'count': 2,
                                invoke: 'DeviceRelease', confirm: true }
                        }
                    },
                    panels: [ {
                        name: 'claim',
                        component: 'DeviceClaim',
                        button: 'Claim Device'
                    } ]
                }
            ]
        }]
    } ]
}
```

## Quick tour

A minimal display.json5 will consist of some top level properties, and a set of displays.

**For Example**

```js
{
    name: 'MyDeviceApp',
    version: '1.0.0',
    format: '1.2.0',
    displays: [{
        expression: 'width <= 640',
        features: {...},
        theme: {...},
        views: [
            { path: '/', name: 'home', views: [
                { path: 'login', component: 'Login' },
            ]},
            ...
        ]
    }]
}
```

The `name` is the internal name of the app. This name is not displayed to the user. The version is your app version. The format is the version of the display format and should be set to **1.2.0**.

The `displays` array contains one or more display definitions. Each display definition contains a matching expression that is evaluated to determine if the display should be used.

Each display definition contains a `title` that is used as the application title in the navigation bar and login panel. The `features` define a set of configurable options for the display.

The `views` define one or more views. If a view has `menu` property set, the app sidebar will display the view icon to launch the view. Views can be nested to create a multi-level navigation hierarchy. Nested views inhert the parent view's role and parent path as a prefix.

See [Display properties](display-properties.md) for a full list of display properties.

## Display Expressions

The `expression` property is a JavaScript (like) expression that is evaluated to determine if the display should be used.

The expression is evaluated in the context of the current device and can access the following properties:

Property | Description
--- | ---
agent | The current device agent
desktop | true if the current device is a desktop device
height | The height of the current device
language | The current device language
mobile | true if the current device is a mobile device
width | The width of the current device

Here are some examples of expressions:

```js
width < 640
width >= 640 && width <= 1024
width > 1024 && language == /en/
true // always use this display
```

## Display Themes

The `themes` property within a display definition defines the light and dark mode color themes for the app. It may also specify the product logo image to use, font-sizes and default date and time formats.

Here is an example theme:

```js
theme: {
    dark: {
        logo: '/images/logo.png',
        formats: {
            mstime: 'mmm d, H:MM:ss:l',
            time: 'mmm d, HH:MM:ss',
            fulltime: 'ddd d mmm h:MM:ss tt',
            date: 'mmm d, yyyy'
        },
        colors: {
            background: '#111217',
            surface: '#000000',
            primary: '#3F51B5',
            secondary: '#707070',
            error: '#fb6d6d',
            info: '#2196F3',
            success: '#4CAF50',
            warning: '#FB8C00',
            accent: '#82B1FF',
            'on-accent': '#FFFFFF',
            none: '#000000',
            sidebar: '#363636',
            extra: '#00CDCD',
            anchor: '#1976D2',
            nav: '#3F51B5',
            text: '#DBDBDB',
            form: '#363636',
            border: '#666666',
            'none-lighten-1': '#282828',
            'background-lighten-1': '#080808',
            'text-lighten-1': '#808080',
            'border-lighten-1': '#444444'
        },
        variables: {
            'font-size': '15px'
        }
    },
    light: {
        colors: {
            background: '#F7F7F7',
            surface: '#FFFFFF',
            primary: '#3F51B5',
            secondary: '#707070',
            error: '#fb6d6d',
            info: '#2196F3',
            success: '#4CAF50',
            warning: '#FB8C00',
            accent: '#82B1FF',
            'on-accent': '#FFFFFF',
            none: '#FFFFFF',
            sidebar: '#FFFFFF',
            extra: '#00CDCD',
            anchor: '#1976D2',
            text: '#484848',
            nav: '#3F51B5',
            form: '#FFFFFF',
            border: '#CCCCCC',
            'none-lighten-1': '#FAFAFA',
            'background-lighten-1': '#F0F0F0',
            'text-lighten-1': '#A0A0A0',
            'border-lighten-1': '#DDDDDD'
        },
        variables: {
            'font-size': '15px'
        }
    }
},
```

## Navigation

The `DevCore` framework provides two axes of navigation:

* Sidebar for top-level items
* Horizontal tabs below the app navigation bar

![App](/images/manager/home.png){class="screen"}

The sidebar is populated with items that have a `menu` property set. The horizontal tab menu is built from child views under a parent view that defines an empty `tabs` array property.

On a mobile display, the tabs navigation is placed at the bottom of the page.

## Views

UI pages are created for each item defined under the `views` properties. Each view is a displayable page for a specific browser URL.

The view defines a `name`, navigation `path` and typically a rendering `component`.

```js
{
    views: [
        { name: 'Home', path: '/', redirect: '/dashboard' },
        {
            name: 'Fleet',
            path: '/fleet',
            component: 'Fleet',
        },
        {
            name: 'account',
            path: '/account',
            icon: '$account',
            redirect: 'profile',
            menu: 'Account',
            tabs: [],
            views: [
                {
                    name: 'profile',
                    path: 'profile',
                    component: 'UserProfile'
                },
                ...
            ]
        }
    ]
}
```

If a view defines child views under a `views` property, those child views are presented as tabbed menu options under the parent view if the parent defines an empty `tabs` array.

Views may define a `redirect` property to redirect the browser to another target view.

## Table Views

The `DevCore` framework provides a **GenericTable** component that can be used to display device data as a table.

![Table](/images/manager/table.png){class="screen"}

The table component is a flexible component that can:

* Display data in pages
* Select data items for operations
* Select data via a search box
* Resize columns
* Reorder columns with drag and drop

Table views present data items that can be selected via checkboxes or by clicking on table cells. The display.json5 table definitions can specify how to respond to item selection and cell clicks via `actions`.

An **actions** definition will specify which panels to launch or components to run when the relevant action is invoked.

```js
{
    table: {
        model: 'Device',
        fields: [
            {name: 'product'},
            {name: 'id', title: 'Device ID'},
            {name: '*', launch: '/devices/:id/overview'}
        ],
        actions: {
            add: { count: 0, launch: 'claim' },
            release: { count: 2, invoke: 'DeviceRelease' }
        }
    }
}
```

In this example: when a row in the table is clicked, the wild-card field definition ("*") will cause the browser will be redirected to the `/devices/ID/overview` page.

If table items are selected, depending on the count of items selected, the appropriate action will cause a panel to be "launched" or component to be "invoked" as required.

## Custom Views

The `DevCore` framework is a VueJS single-page app that provides core components to create responsive, interactive device management apps. Custom components will thus be VueJS components. 

Instead of using the GenericList component for a tabular view, you can create custom components to extend the DevCore. Custom views can be any VueJS page of your design -- the sky's the limit.

## Panels

To facilitate editing the properties of a data item, you can defines UI Panels.  A parent view may define zero or more panels that can be invoked to operate on selected data items from the parent view.

![Panel](/images/manager/panel.png){class="screen"}

The panel will animate and slide out from the right side of the screen when launched by a view action or button.

Panels are defined under a views `panels` property.

```js
{
    panels: [
        {
            name: 'claim',
            component: 'DeviceClaim',
            button: 'Claim Device',
            width: '500px'
        }
    ]
}
```

A panel has a `name` and a `component` to render and operate the panel. It may specify a `button` which will be added to the parent view table to launch the panel. Alternatively, panels may be launched via view table actions.

## Dashboards

The DevCore has a `Dash` component that can be used in any view to provide a graphical canvas to display interactive widgets connected to live device data.

Some of the supported widget types are:

* button
* event
* form
* gauge
* graph
* image
* input
* led
* numeric
* progress
* sign
* table
* text

Here is an example view:

```js
{
    name: 'Overview',
    title: 'Device Overview',
    menu: 'Overview',
    path: '/overview',
    icon: '$dashboard',
    component: 'Dash',
    widgets: [
        {
            type: 'gauge',
            name: 'Network IO',
            data: {
                model: 'Stats',
                field: 'io',
            },
            width: '.23',
        },
    ]
}
```

## Widget Data

You can connect device metric or database data to widgets via the `data` property.

To connect with database data, set the `model` and `field` properties. The `model` defines the database entity model. The `field` defines the database item attribute (column).

An optional `where` property defines a matching expression that is used to select the qualifying item (row).

```js
{
    data: {
        model: 'Test',
        field: 'cpu',
        where: '${name} = {cpu}',
    }
}
```

For metric data, define the `namespace`, `metric`, `dimensions`, `statistic` and `period` properties.

```js
{
    data: {
        namespace: 'Embedthis/Device',
        metric: 'UpdateSuccess',
        dimensions: [],
        statistic: 'avg'
        period: 3600,
    }
}
```

## Designing Pages and Widgets

It can be an easy and effective way to design your pages and widget layouts by using the low-code App Designer. Once the page is the way you like it, you can then export the page from the Pages list. This will export a JSON5 file that can then be modified and pasted into the display.json5.

## Authorizing Access

It may be required to control access to specific views based on the authorized role of a user. For example, you may only want administrators to be able to view certain resources.

The DevCore framework allows the visibility of views, panels, table columns and panel fields to be controlled depending on the user's authorized role.

By specifying a `role` property, you can require that the user have at least this capability to access the designated element.

For example, to only allow access to a view by adminstrators:

```js
{
    "name": "fleet",
    "component": "Fleet",
    "role": "admin",
},
```

## Configurable Options

See the [Display properties](display-properties.md) for a full list of display features.

## Examples

The Ioto apps distribution includes several management applications that include **display.json5** files to customize the appearance of the app.

# Expressions

The Builder and DevCore framework use JavaScript-like expressions throughout the system to provide flexible control over processing logic and application UI behavior. These expressions enable dynamic configuration and conditional logic without requiring code changes.

## Expression Usage

Expressions are used in the following contexts:

### UI Control
- **View.enable** - Enable or disable specific views based on conditions
- **Widget.show** - Control widget visibility dynamically

### System Logic
- **Software Update Policy** - Determine if updates should be applied to specific devices
- **Automated Actions** - Control conditional logic in if/then/else statements

## Expression Context

Expressions are JavaScript-style statements that resolve to boolean results. They have access to context variables that vary depending on the usage context.

### Context Variables

The following variables are available in expression contexts:

| Variable | Type | Description | Context |
|----------|------|-------------|---------|
| `agent` | String | Browser user agent string | UI contexts |
| `dark` | Boolean | True if in dark mode | UI contexts |
| `design` | Boolean | True if widget is in design mode | Widget contexts |
| `desktop` | Boolean | True if running on desktop (not mobile) | UI contexts |
| `framed` | Boolean | True if board is framing widgets | Widget contexts |
| `height` | Number | Browser height dimension (window.innerHeight) | UI contexts |
| `language` | String | Browser language setting (navigator.language) | UI contexts |
| `light` | Boolean | True if in light mode | UI contexts |
| `mobile` | Boolean | True if running on mobile device ( 640px width) | UI contexts |
| `value` | Various | Widget data or input value | Widget contexts |
| `width` | Number | Browser width dimension (window.innerWidth) | UI contexts |

## Expression Examples

### Basic Conditions
```javascript
// Simple value comparison
value > 0
value == "active"
value != null

// Boolean conditions
dark && mobile
light || desktop
```

### Device-Based Conditions
```javascript
// Screen size conditions
width < 640                    // Mobile devices
width >= 640 && width <= 1024  // Tablet devices
width > 1024                   // Desktop devices

// Combined device conditions
mobile && language == "en"     // English mobile users
desktop && !dark              // Desktop light mode
```

### String Operations
```javascript
// String matching
agent ^= "Chrome"             // User agent starts with "Chrome"
language $= "US"              // Language ends with "US"
value >< "error"              // Value contains "error"

// Regular expressions
agent =~ /Chrome|Firefox/     // Chrome or Firefox browsers
language =~ /^en/             // English language variants
```

## Expression Operators

### Arithmetic Operators
`+` `-` `*` `/` `%` `^` `(` `)`

### Comparison Operators
`==` `!=` `<` `<=` `>` `>=`

### Logical Operators
`&&` `||` `!`

### String Operators
| Operator | Description |
|----------|-------------|
| `^=` | Starts with |
| `^!=` | Does not start with |
| `$=` | Ends with |
| `$!=` | Does not end with |
| `><` | Contains |
| `<>` | Does not contain |

### Regular Expression Support
Regular expressions (delimited by slashes) can be used with equality operators:

```javascript
agent =~ /Mobile/              // Mobile user agent
value =~ /^[0-9]+$/           // Numeric values only
```

## Expression Limitations

### Performance Constraints
- **Term Limit** - Maximum of 50 terms per expression
- **Runtime Protection** - Prevents denial of service attacks
- **Evaluation Timeout** - Expressions must complete within reasonable time

### Type Support
The expression engine supports:
- Numbers (integers and floating-point)
- Boolean values (true/false)
- String literals (quoted strings)
- Regular expressions (slash-delimited)
- Null values

## Best Practices

### Performance Optimization
- Keep expressions simple and focused
- Avoid complex nested conditions when possible
- Use appropriate operators for string comparisons
- Test expressions with expected data ranges

### Maintainability
- Document complex expressions clearly
- Use descriptive variable names in context
- Group related conditions with parentheses
- Avoid overly complex regular expressions

### Security Considerations
- Validate expression inputs where possible
- Be aware of term limits for complex expressions
- Consider performance impact of frequent evaluations

## Common Use Cases

### Responsive Design
```javascript
// Show widget only on desktop
desktop && width > 1024

// Hide widget on mobile
!mobile
```

### Feature Toggles
```javascript
// Enable feature for specific language
language == "en" || language == "fr"

// Show advanced features for power users
value == "admin" || value == "power"
```

### Conditional Updates
```javascript
// Update policy for production devices
value.environment == "production" && value.version < "2.0"

// Emergency updates only
value.priority == "critical"
```

## Debugging Expressions

### Testing Approaches
- Use simple test cases to validate logic
- Test with different context variable values
- Verify boolean results match expectations
- Check for edge cases with null or undefined values

### Common Issues
- Incorrect operator precedence
- Missing parentheses in complex conditions
- Type mismatches in comparisons
- Regular expression syntax errors

# Demo App

The Demo app is a simple cloud-based app that demonstrates sending data to the device cloud.

The Demo app uses the Standard device app with a customized data schema and custom device metrics.

The Demo App is an example of a [Customized Device App](/apps/patterns/). This means it adds a device data schema to the Standard device app.

![Demo Dashboard](https://www.embedthis.com/images/demo/demo-home.avif){class="screen"}

The Demo App demonstrates

* How to download and build the Ioto agent with custom extensions
* How to create a custom database schema
* How to create a device cloud and device app
* How to send device data to the cloud

This sample will:

* Download and build the Ioto device agent with custom logic.
* Create a regional device cloud.
* Create a device app.
* Create a custom metric based on the device data.

## Device Agent

The Demo app extends the Ioto agent by providing an extension code module, database schema and agent configuration. 

## Device App

The Demo app uses the unmodified, Standard device app &mdash; so you don't need to build or upload a device app. 

The Demo app UI is designed to run on a mobile device, but can also be used on a desktop.

## Steps

<!-- no toc -->
- [Create Product](#create-product)
- [Download Agent](#download-agent)
- [Build Agent](#build-agent)
- [Create Device Cloud](#create-device-cloud)
- [Create Device App](#create-device-app)
- [Run Agent](#run-agent)
- [Launch Device App](#launch-device-app)
- [Claim Device](#claim-device)
- [Device Data](#device-data)
- [Show Data Metrics](#data-metrics)
- [Show Data Widgets](#data-widgets)

## Create Product

The first step is to create an Demo product definition in the [Builder](https://admin.embedthis.com/).

Navigate to the [Builder](https://admin.embedthis.com/clouds) site and select `Products` in the sidebar menu and click `Add Product`. Then create a product definition by entering a product name and description of your choosing. Select the `Ioto Agent` and select `By Device Volume` and enter `1` in the Total Device field. Your first device is free.

![Demo Product](https://www.embedthis.com/images/demo/demo-product-edit.avif){class="screen width-80"}

## Download Agent

Once the product definition is created, you can click `Download` from the Products list and save the source distribution to your system. The eval version of Ioto will be fine for this solution.

![Product List](https://www.embedthis.com/images/builder/product-list.avif){class="screen width-80"}

Take note of the `Product ID` in the product listing. You can also click on the product ID to copy it to the clipboard. You will enter this product ID in the Ioto configuration file: `apps/demo/config/device.json5`. 

## Build Agent

To build the Ioto agent with Demo extensions, first extract the source files from the downloaded archive:

    $ tar xvfz ioto-demo-src.tgz

Before building, edit the `apps/demo/config/device.json5` file and paste in the Product ID into the `product` property.
 
Then build Ioto with the Demo app, by typing:

    $ make APP=demo

This will build Ioto, the Demo app and will copy the Demo config files to the top-level `./config` directory.

## Create Device Cloud 

Before running Ioto, you need to create a Device Cloud for your agent to communicate with. The device cloud manages communication with devices and stores device data. 

To create a device cloud, navigate to the [Builder Clouds List](https://admin.embedthis.com/clouds) by selecting `Clouds` from the side menu. Then click `Add Cloud`. Enter your desired cloud name, and select `Hosted by Embedthis` in a region close to you. You can create the cloud and connect one device for free.

Check the `Upload Schema` option and upload the `./config/schema.json5` file from your extracted Ioto source code. This schema defines the database for the Demo app.

## Create Device App

To view your device state, you need to create a device app. This will create an instance of the Standard device app and host it globally on the EmbedThis Ioto device cloud.

Select `Apps` from the Builder side menu and click `Add App`. Enter your desired app name (Demo) and pick a domain name for your Demo app. The domain will be a subdomain of the `ioto.me` domain and will be automatically registered and published for you. Later, if you create a dedicated device cloud, you can select your own custom domain with any TLD extension.

The Demo App uses the Standard device app UI. In the future, if you wish to customize the UI, you can modify, rebuild or replace the portions or the whole of the underlying standard app with your own custom app.

The Standard device app is a DevCore VueJS app that provides the following components:

* Login and auth
* Navigation
* Device claiming
* Dashboards & widgets
* Device Metrics and analytics
* Device data display and tables
* Alerts
* Responsive mobile & desktop presentation
* Dark/light mode support

After creating the app, you need to wait a few minutes (and sometimes up to 30 minutes) to let the domain name entries propagate globally. While waiting, you can start the Ioto agent.

## Run Agent

The easiest way to run the Ioto agent with Demo extensions is to type:

```bash
$ make run
```

When Ioto is run, the Demo app will run a demo routine that updates the `Service` table with a counter every 30 seconds. The demo is configurable via the `ioto.json5` "demo" configuration collection. The demo can be configured to tailor the delay, number of updates and the mechanism used to perform updates. See comments in the `demoApp.c` for details.

In the console output, you will see a unique device ID displayed. This is a `Device Claim ID` that you can use to claim the device for exclusive management by your Demo app. Take note of that device claim ID.

When Ioto starts, it will register with the Builder and wait to be claimed by your Demo App.

## Launch Device App

From the Builder apps list, click the "launch" column to run your device app. This will launch your default browser and navigate to the domain URL you chose when creating the app.

![App List](https://www.embedthis.com/images/builder/manager-list.avif){class="screen width-80"}

Once launched, you will need to register and create a new account with the device app. This is an "end-user" account for the owner of the device.

> Note: this is not the same as your Builder login. 

![Demo Login](https://www.embedthis.com/images/demo/demo-login.avif){class="screen width-80"}

Enter a username and password and click register. A registration code will be emailed to you. Enter that code in the next screen to complete the registration.


## Claim Device

Once logged in, you can `claim` your device.

Select `Devices` from the sidebar menu and click `Claim Device` and then enter the claim ID shown in the Ioto agent console output. 

![Demo Claim](https://www.embedthis.com/images/demo/demo-claim.avif){class="screen width-80"}

The Ioto agent will poll regularly to see if it has been claimed. After starting, the Ioto delay between polling gradually increases. If the agent has been running a long time, the polling period may be up to 1 minute in length. You can restart the agent to immediately check with the Builder.

## Import Dashboard

After claiming, you can import the Demo dashboard from `./config/Display.json5`. 

Select `Dashboards` from the sidebar menu and click `Actions/Import` and select the `./config/Dashboard.json5` file. 

After loading the dashboard, you can select the DemoHouse dashboard from the Dashboard list to display the Demo Dashboard.

Note: you can remove the Default dashboard at any time as it is not used by this sample.


## Show Device Data

After claiming the device for management, you will start to see device data in the device app. Navigate to `Device Data` and you will see a list of database tables.

![Table List](https://www.embedthis.com/images/demo/demo-table-list.avif){class="screen width-80"}

From the table list, click on the `Service` table to display its contents. 

![Service Table](https://www.embedthis.com/images/demo/demo-service-table.avif){class="screen width-80"}

You can edit values inline, your select a row and click edit to display the item edit panel.

![Table Edit](https://www.embedthis.com/images/demo/demo-table-edit.avif){class="screen width-80"}

## Show Data Metrics

You can create data metrics from device data so that you can track and manage device data values over time.  Metrics can be used to provide data for dashboard widgets such as graphs and gauges. Metrics can also be used to invoke automatic actions via metric triggers.

To create a device metric, navigate to the Builder `Automations` page and select the `Actions` tab, select your device cloud and click `Add Action`. Give your action a name like "Metric" and select `Metric` from the action type list. Some actions take addition parameters, but the ManageMetric action does not.

Then select the `Triggers` tab and click `Add Trigger`. 

![Demo Trigger](https://www.embedthis.com/images/demo/demo-trigger-add.avif){class="screen width-80"}

Select `Database Update` as the Trigger Source and select the name of your Action created above as the Action. Select "COUNTER" as the Metric Name, "Device=${deviceId}" as the Metric Dimensions and "${value}" as the Metric Value.

This will create a metric named "COUNTER" for each device and use the `value` field from the Service table as the value.


### Data Widgets

You can display device data as graphical widgets from the device app's dashboard. Click `Home` to display the dashboard.

Then click the `+` plus icon to open the `Create Widget` panel and select "Graph" as the Widget type from the selection list. Then click the `Data` tab at the top to configure the data source for the widget.

Select `Database` as the namespace, `Service` as the table name and `value` as the item field. 

Then click `Save`. This will display your graph on the dashboard.

![Demo Dashboard](https://www.embedthis.com/images/demo/demo-home.avif){class="screen width-80"}


## How It Works

The following section provides a background on some of the design and implementation of the Demo app.

### Device Agent

The Ioto device agent is extended via an Demo module. There are three files:

File | Description
-|-
demoApp.c | Code for the Demo extension

This module uses the Ioto `ioStart` and `ioStop` hooks to start and stop the extension. When linked with the Ioto agent library, these hooks replace the stub functions and are called by Ioto on startup and shutdown.

The ioStart routine checks if the `demo.enable` property is true in the `ioto.json5` configuration file. If true, it schedules the `evalDemo` routine to run when Ioto connects to the cloud by using the `ioOnConnect` API.

### Database 

The database schema is used by both the Ioto agent and device cloud to define the Demo data app tables and items.

The `apps/demo/config/schema.json5` defines the overall schema and the `DemoSchema.json5` file defines the Demo specific portions.

The underlying agent database and the cloud database are based on the [AWS DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html) database which is a highly scalable, high-performance, NoSQL, fully managed database.

There are 2 database tables. These are:

Name | Sync Direction | Purpose
-|-|-
Service | up | A service-level table with a single item.
Log | up | Log table that creates new items with each update.

The Ioto database synchronization automatically replicates data up to the cloud and down to the device according to the sync direction. You do not need to explicitly send data to or from the cloud (unless you want to). Ioto database replication does this transparently, reliably and efficiently.

### Device App 


The Demo App is an example of a [Customized Device App](/apps/patterns/). This means it adds device data schema to the Standard device app.

## See More

For another sample, checkout the [EcoHouse Sample](/apps/samples/eco/).

## Directories

| Directory | Purpose                      |
| --------- | -----------------------------|
| config    | Configuration files          |
| src       | Demo App C source code       |

## Key Files

| File               | Purpose                                   |
| -------------------| ------------------------------------------|
| DemoSchema.json5   | Demo database schema file                 |
| ioto.json5         | Primary Ioto configuration file           |
| schema.json5       | Complete database schema file             |
| src/*.c            | Device-side app service code              |
# Unit Testing Application

The Unit (test) application builds Ioto with test suites that can exercise the various Ioto subsystems.

This app is used by EmbedThis and customers to verify operation of Ioto.

## Building

To build the Unit application select the APP and run make:

```bash
$ make APP=unit clean build
```

The build will achieve the following goals:

* Build the Ioto agent with unit test suites 
* Copy the required configuration to the ./config directory

The Ioto agent binary will be located in the build/PROFILE/bin/ioto file.

Change the **ioto.json5** services property collection to enable or disable Ioto services.

## Testing

Run Ioto using:

```bash
$ make run
```

Currently the TestMe unit test suite is required to exercise the Ioto unit tests. 

A subset of the unit tests are located under the **./test** directory.# Auth Application

The Auth application builds a simple (trivial) user interface for testing the Ioto web user login primitives.

## Overview

The Auth application is a low-level sample for testing user login and authentication access. It is not intended to be used as the basis for any production application.

The Auth app offers a simple UI to login and logout as an "admin" or "guest" user. When logged in as a guest, you will have limited access to certain pages.

## Building

To build the Auth application select the APP and run make:

```bash
$ make APP=auth clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for local device management
* Build the Auth local web application
* Copy the required configuration to the ./config directory
* Copy the required local web site to the ./site directory

The Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The Auth application will be located under the **./site** directory.

## Running

Run Ioto using:

    $ make run

Then browse to

    https://localhost:4443

You will probably see a warning about the connection not being secure or "Your connection is not private". This is expected. This is a browser warning that the application is using a test TLS/SSL certificate. You may proceed as instructed and the app home page will be displayed.

![Auth Home](/images/ioto/auth-app.png){class="screen"}

## Test Users

The auth app defines two test users:

* admin
* guest

Both have a password of **"demo"**. 

You can login using either account and then test accessing the various UI tabs. The guest account will have access to only a subset of pages.# Kickstart Screen Shots

The following screenshots show some of the functionality of the Kickstart manager application.

## Home Screen

![Home Page](/images/kickstart/home.png){class="screen"}

Home page in dark mode:

![Dark Home Page](/images/kickstart/home-dark.png){class="screen"}

The Kickstart home screen with dashboard and pulldown notification event window.

## Widgets

![Gauge Widget](/images/kickstart/gauge.png){class="screen"}
![LED Widget](/images/kickstart/LedWidget.png){class="screen"}
![Numeric Widget](/images/kickstart/NumericWidget.png){class="screen"}
![Graph Widget](/images/kickstart/GraphWidget.png){class="screen"}

The dashboard can use graphical widgets connected to a server-side data source. Data is pushed from the server over WebSockets. A gauge can define a min to max range and it uses animation to smooth transitions between data points.

## Graphs
![Graphs](/images/kickstart/graphs.png){class="screen"}

Server data can be plugged into charts for graphical display. Ioto provides primitives to convert device data to JSON that can be easily connected to a suite of charts.

## Sidebar Navigation

![Navigation](/images/kickstart/navigation.png){class="screen"}

Kickstart supports multi-level navigation. The current option is highlighted with show/hide indicators. Menus can be hidden if the authenticated user does not have the required permissions.

![Sub Menus](/images/kickstart/submenu.png){class="screen"}

## Events Screen

![Events](/images/kickstart/events.png){class="screen"}

The events log describes system events of interest according to severity. You can create events in the server for any custom condition.

## Feedback

![Feedback](/images/kickstart/feedback.png){class="screen"}

Error messages and user feedback are transparently channeled to the browser and displayed with appropriate color coding. This may be customized by modifying the application theme stylesheet.

![Feedback Theme](/images/kickstart/feedback-2.png){class="screen"}

## Login Screen

![Login](/images/kickstart/login.png){class="screen"}

Kickstart include a complete user login mechanism. Passwords are securely hashed using Blowfish encryption. Kickstart automatically ensures the login form and request are transported using SSL.
After login, users can be granted access to parts of the application dependent on their configured roles.

## Dialogs

![Dialogs](/images/kickstart/dialog.png){class="screen"}

Kickstart includes easy to use confirmation modal dialogs to confirm destructive actions.

![Modals](/images/kickstart/modal.png){class="screen"}
# Kickstart Application

The Kickstart app is a sample VueJS single-page application that you can use as a starting point for your device management applications. 

Kickstart demonstrates the capabilities and experience provided by an application created with Ioto and VueJS. It includes includes a UI/UX for a sample router/switch application. Kickstart uses proven designs and best-practices to lower development risk. It includes most of the required elements for a secure web application, so you can eliminate months off your development schedule.

The Kickstart App is an example of a [Customized Device App](/apps/). This means it rebuilds the Standard device app to add custom UI components, a customized data schema and dashboard.

![Kickstart](/images/kickstart/home.png){class="screen"}

## Kickstart Components

* User management
* User login
* Property edit
* Alert notification
* Event log
* Dashboard
* Dynamic tables and graphs
* Paged Data Tables
* Navigation
* Search
* Granular access control per page
* Help

Read the [Kickstart Components](./specs.md) for full details.

## Kickstart Screens

See the [Kickstart Screen Images](./screenshots.md) for a close up look.

## Building

To build the Kickstart application select the APP and run make:

```bash
$ make APP=kickstart clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for local device-based management.
* Build the Kickstart application.
* Copy the required configuration to the ./config directory.
* Copy the Kickstart app to the ./site directory.
* Initialize the Ioto local database with login user definitions.

After building, the Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The Kickstart application will be copied to the **./site** directory.

## Running

To run Ioto, type:

```bash
$ make run
```

## Browsing

To view the Kickstart home page, launch your browser and navigate to the URL:

```
https://localhost:4443
```

You will probably see a warning about the connection not being secure or "Your connection is not private". This is expected. This is a browser warning that the application is using a test TLS/SSL certificate. You may proceed as instructed and the app home page will be displayed.

You can login with the test user credentials:

Username | Password
-|-
**admin** | demo

## Demo

The Kickstart app includes some mock device data that emulates a simple router device with data updates every 5 seconds. 

![Console](/images/ioto/console-app.png){class="screen"}

The source to increment the database counter is in **apps/console/src/demo.c**.

## Device Schema

The Kickstart app defines a suite of device entities in the database schema via the configuration file: **apps/kickstart/config/schema.json5**. This includes database entities for Events, Ports, Port Mappings, Stats, and VLANs.

For more information about the device schema, See:

* [Device Tables / Database Schemas](/apps/database/schemas/)
* [Database Replication](/ioto/database/replication.md)

## Configuring the Kickstart Display

The Kickstart user interface is defined by the **apps/kickstart/config/display.json5** config file that can be modified or extended to suit your specific needs. 

The display.json5 file defines the following items:

* UI features
* Displayed Name
* Display color theme including dark and light modes
* Logo to display in the navigation bar
* Menu items and options
* UI pages and panels
* UI navigation routes
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

For more information about the display file, read [App Display](/apps/config/display.html).# Kickstart Specs

Kickstart is an Ioto VueJS application that includes the following UI components:

* User management
* User login
* Property edit
* Alert notification
* Event log
* Dashboard
* Dynamic tables and graphs
* Paged Data Tables
* Navigation
* Search
* Help
* Granular access control per page

## Security

* Best practices security configuration
* Transport Layer Security (TLS/SSL)
* Secure user login
* Password storage with Blowfish hashing and salting
* Granular access control per-page or per URI
* Sandboxed resource limits
* Defensive counter-measures for DOS attacks
* Access and access violation logging
* Content Security Policy to minimize cross-site scripting
* CrossOrigin sharing support
* Hidden frame hijack prevention
* Hardened against Crime, Breach, Beast and Lucky 13 exploits
* Executes with minimal privilege in Chroot jail
* Safe portable runtime to protect against memory leaks and buffer overflows
* Angel monitoring process

## Performance

* Highly responsive UI with sub-second page transitions.
* Excellent request throughput and scaling.
* Small memory footprint even under heavy load (~1.5MB including TLS, database and entire application).
* HTML, Javascript and stylesheets minified, compiled and compressed into a single file.
* Data interchange with server via optimized JSON requests and responses.

## Pre-integrated Components

* VueJS 3 client-side Javascript library.
* Builds with the modern [Vite](https://vitejs.dev/) build tool.
* [Vuetify 3](https://vuetifyjs.com/en/) Material Design look and feel.
* Themeable SASS style sheets.
# Eco House App

The Eco House app is a demonstration, cloud-based energy management app that emulates a house with solar panels, battery and EV car. It provides configuration for the Ioto device agent, and a stylized mobile app for managing the "home". 

The Eco App is an example of a [Customized Device App](/apps/patterns/). This means it uses the Standard device app UI with a customized data schema, dashboard and devic-cloud automations.

![Eco House Dashboard](https://www.embedthis.com/images/eco/eco-home.avif){class="screen width-60"}

The Eco House App demonstrates

* How to easily create an interactive mobile device app UI.
* How to extend the Ioto device agent with custom data and logic.
* How to quickly create and deploy an IOT solution with the EmbedThis Builder.

This is not a "trivial" sample. To develop this sample from scratch without the Builder and Ioto would typically take many months of development with associated risk.

This sample will:

* Download and build a device agent with custom logic managing an ECO House.
* Create a regional device cloud to manage devices.
* Create and host a device app.
* Create a custom Eco House UI and control panel dashboard.
* Connect user actions from the app with custom logic to control the Eco House.

## Device Agent

The Eco House app extends the Ioto agent by providing an extension code module, database schema and agent configuration. In a "real" home, the Ioto agent with Eco extension would be run on an embedded device such as a [Raspberry PI](https://www.raspberrypi.com/) with wired connections to the solar panels, battery, gateway and EV chargers. For this sample, we run the device agent on a PC/Notebook to simulate a real Eco house embedded device.

## Device App

The Eco House app uses the unmodified, Standard device app UI available from the Builder &mdash; so you don't need to build or upload an app. 

The Eco House app is designed to run on a mobile device, but can also be used on a desktop.

## Steps

<!-- no toc -->
- [Create Product](#create-product)
- [Download Agent](#download-agent)
- [Build Agent](#build-agent)
- [Create Device Cloud](#create-device-cloud)
- [Create Device App](#create-device-app)
- [Run Agent](#run-agent)
- [Launch Device App](#launch-device-app)
- [Claim Device](#claim-device)
- [Import Dashboard](#import-dashboard)
- [Create Automation](#create-automation)

## Create Product

The first step to create the Eco House App is to create a product definition in the [Builder](https://admin.embedthis.com/).

Navigate to the [Builder](https://admin.embedthis.com/clouds) site and select `Products` in the sidebar menu and click `Add Product`. Then create a product definition by entering a product name and description of your choosing. Select the `Ioto Agent` and select `By Device Volume` and enter `1` in the Total Device field. Your first device is free.

![Create Eco Product](https://www.embedthis.com/images/eco/eco-product-edit.avif){class="screen width-80"}

## Download Agent

Once the product definition is created, you can click `Download` from the product list and save the source distribution to your system. The eval version of Ioto will be fine for this solution.

Take note of the `Product ID` in the product listing. You can also click on the product ID to copy it to the clipboard. You will enter this product ID in the Ioto configuration file: `apps/eco/config/device.json5`. 

## Build Agent

To build the Ioto agent with Eco extensions, first extract the source files from the downloaded archive:

    $ tar xvfz ioto-eval-src.tgz

Before building, edit the `apps/eco/config/device.json5` file and paste in the Product ID into the `product` property.
 
Then build Ioto with the Eco app, by typing:

    $ make APP=eco

This will build Ioto, the Eco app and will copy the Eco config files to the top-level `./config` directory.

## Create Device Cloud 

Before running Ioto, you need to create a Device Cloud for your agent to communicate with. The device cloud manages communication with devices and stores device data. 

To create a device cloud, navigate to the [Builder Clouds List](https://admin.embedthis.com/clouds) by selecting `Clouds` from the side menu. Then click `Add Cloud`. Enter your desired cloud name, and select `Hosted by Embedthis` in a region close to you. You can create the cloud and connect one device for free.

Check the `Upload Schema` option and upload the `./config/schema.json5` file from your extracted Ioto source code. This schema defines the database for the Eco House app.

## Create Device App

To view your device state, you need to create a device app that will host the Eco App UI. This will create your Eco House App UI and host it globally on the EmbedThis Ioto device cloud.

Select `Apps` from the Builder side menu and click `Add App`. Enter your desired app name (EcoHouse) and pick a domain name for your Eco app. The domain will be a subdomain of the `ioto.me` domain and will be automatically registered and published for you. Later, if you create a dedicated device cloud, you can select your own custom domain with any TLD extension.

You can specify an app logo for your device app. For now, you can use the `apps/eco/config/eco-logo.avif` logo file.

The Eco App uses the Standard device app UI navigation with a custom dashboard UI. In the future, if you wish to completely customize the UI, you can modify, rebuild or replace the portions or the whole of the underlying app with your own custom app.

The Standard device app is a DevCore VueJS app that provides the following components:

* Login and auth
* Navigation
* Device claiming
* Dashboards & widgets
* Device Metrics and analytics
* Device data display and tables
* Alerts
* Responsive mobile & desktop presentation
* Dark/light mode support

After creating the app, you need to wait a few minutes (and sometimes up to 30 minutes) to let the domain name entries propagate globally. While waiting, you can start the Ioto agent.

## Run Agent

The easiest way to run the Ioto agent with Eco House extensions is to type:

```bash
$ make run
```

In the console output, you will see a unique device ID displayed. This is a `Device Claim ID` that you can use to claim the device for exclusive management by your Eco House app. Take note of that device claim ID.

When Ioto starts, it will register with the Builder and wait to be claimed by your Eco House App.

## Launch Device App

From the Builder apps list, click the "launch" column to run your device app. This will launch your default browser and navigate to the domain URL you chose when creating the app.

![App List](https://www.embedthis.com/images/builder/manager-list.avif){class="screen"}

Once launched, you will need to register and create a new "end-user" account with the device app. 

> Note: this is not the same as your Builder login. 

![Eco Login](https://www.embedthis.com/images/eco/eco-login.avif){class="width-50"}

Enter a username and password and click register. A registration code will be emailed to you. Enter that code in the next screen to complete the registration.

## Claim Device


Once logged in, you can `claim` your device.

Select `"Devices"` from the sidebar menu and click `Claim Device` and then enter the claim ID shown in the Ioto agent console output. 

![Eco Claim](https://www.embedthis.com/images/eco/eco-claim.avif){class="screen width-50"}

The Ioto agent will poll regularly to see if it has been claimed. After starting, the Ioto delay between polling gradually increases. If the agent has been running a long time, the polling period may be up to 1 minute in length. You can restart the agent to immediately check with the Builder.

## Import Dashboard

After claiming, you can import the Eco house dashboard from `./config/Display.json5`. 

Select `Dashboards` from the sidebar menu and click `Actions/Import` and select the `./config/Dashboard.json5` file. 

After loading the dashboard, you can select the EcoHouse dashboard from the Dashboard list to display the Eco Dashboard.

Note: you can remove the Default dashboard at any time as it is not used by this sample.

## Create Automation

To respond to user actions in the Eco House App, you create a `Builder Automation Action` and `Trigger`. Then when the user clicks an Eco House App button, a request is sent to the device cloud which invokes the trigger and action. 

In the Eco House sample, the `Charge Car` button is connected to a database update action in the device cloud. The Eco extensions in the Ioto agent subscribe to watch changes to this table and can react when the user wants to charge the car.

To configure a Builder action, navigate to the Builder `Automations` page and select the `Actions` tab, select your device cloud and click `Add Action`. Give your action a name like "Database" and select `Database` from the action type list. Some actions take addition parameters, but the database action does not.

Then select the `Triggers` tab and click `Add Trigger`. 

![Eco Trigger](https://www.embedthis.com/images/eco/eco-trigger-add.avif){class="screen width-70"}

Select `User Trigger` as the Trigger Source and select the name of your Action created above as the Action. Select `Upsert` and `Desired` as the database entity.

Now, when a user clicks the `Charge Car` button in the Eco App, that will send a message to the Automation trigger which will update the `Desired` database entity. The Eco App defines which field to update in the button widget. The imported Dashboard will have this already configured. 

If you are interested, you can put the dasboard into development mode by disabling `Fixed Design` and `Frameless Widgets` in the Dashboard edit panel.

![Eco Dashboard](https://www.embedthis.com/images/eco/eco-dash-edit.avif){class="screen width-70"}

Then you can modify a widget configuration by clicking the "Pencil" icon at the top right of the widget. This will display the Widget properties panel.

![Eco Widget](https://www.embedthis.com/images/eco/eco-widget-action.avif){class="screen width-70"}

## How It Works

The following section provides a background on some of the design of the Eco House app.

### Device Agent

The Ioto device agent is extended via an Eco House module. There are three files:

File | Description
-|-
eco.h | Eco House header
eco.c | Implementation of the ioStart and ioStop routines 
ecoApp.c | Code for the Eco House extension

This module uses the Ioto `ioStart` and `ioStop` hooks to start and stop the extension. When linked with the Ioto agent library, these hooks replace the stub functions and are called by Ioto on startup and shutdown.

The ioStart routine checks if the `demo.enable` property is true in the `ioto.json5` configuration file. If true, it schedules the `ecoManager` routine to run when Ioto connects to the cloud by using the `ioOnConnect` API.

### Database 

The database schema is used by both the Ioto agent and device cloud to define the Eco House database.

The `apps/eco/config/schema.json5` defines the overall schema and the `EcoSchema.json5` file defines the Eco House specific portions.

The underlying agent database and the cloud database are based on the [AWS DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html) database which is a highly scalable, high-performance, NoSQL, fully managed database.

There are 5 database tables. These are:

Name | Sync Direction | Purpose
-|-|-
Capacity | up | Stores battery capacity of the home and EV batteries
Charge | up | Stores the battery charge of the home and EV batteries
Desired | down | Stores the desired state of charging the EV
Flow | up | Stores the current flows to and from all components
State | up | Stores the current charging state of the EV

The Ioto database synchronization automatically replicates data up to the cloud and down to the device according to the sync direction. You do not need to explicitly send data to or from the cloud (unless you want to). Ioto database replication does this transparently, reliably and efficiently.

When the `Charge Auto` button in the Eco House App is clicked, the associated widget action sets the `Desired.car` field to true. This change is then replicated down to the device agent and the Eco House extension is notified of the change. 

### Device App 

The Eco House App is an example of a [Customized Device App](/apps/patterns/). This means it adds device data schema, custom dashboards to the Standard device app, and utilizes cloud-side automated actions to react to user and device input.

The Eco house device app provides a highly usable, responsive mobile and desktop UI.

### Modifying a Dashboard

The Eco House dashboard can be modified by selecting `Edit` from the dasboard list in the Eco app. Then disable `Fixed` and disable `Frameless Widgets`. This will display the dashboard toolbar and make it easy to see the widget size so that you can move and resize widgets. Using the toolbar, you can add or remove widgets and style individual widgets.

## Directories

| Directory | Purpose                                               |
| --------- | ------------------------------------------------------|
| config    | Configuration files                                   |
| src       | App C source code to link with Ioto                   |

## Key Files

| File               | Purpose                                   |
| -------------------| ------------------------------------------|
| Dashboard.json5    | Primary Ioto configuration file           |
| EcoSchema.json5    | Eco House database schema file            |
| ioto.json5         | Primary Ioto configuration file           |
| schema.json5       | Complete database schema file             |
| src/*.c            | Device-side app service code              |
# Standard Application

The Standard application is used by EmbedThis to create the default device app that is configured when apps are created. However, you can also use it as a basis for creating your own bespoke cloud-based management application.

The Standard application includes core functionality useful for most cloud-based management apps by offering:

* User authentication (login/logout)
* User account registration (email verification, forgot password support)
* App navigation and menus
* Sidebar navigation 
* Display light / dark mode support
* Dashboards with information widgets (graphs, gauges, tables, numerics)
* Device data display, management and updating
* Device claiming and registration


## Building

To build the Standard application, download the DevCore framework and select the APP and run make:

```bash
$ make APP=standard clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for cloud-based management
* Build the standard application
* Copy the required configuration to the ./config directory

After building, the Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The application will be located under the **apps/standard/ui/dist** directory which will contain the individual application files and a **app.zip** ZIP file that is ready for uploading via the Builder to the Ioto cloud service for hosting the UI.

## Deploying

To deploy the application, logon to the [Builder](https://admin.embedthis.com) site to create and configure a device app. 

From the Builder app list, click on the **Add App" icon or the **Edit** icon to modify ann app.

![App List](/images/builder/app-list.png){class="screen"}

This will display the app configuration panel.

![App Designer](/images/builder/app-edit.png){class="screen"}


## Domain Name

If your app is hosted by Embedthis, select a sub-domain of your choosing under the **ioto.me** domain. You can select a unique sub-domain that reflects your company or product's brand. The sub-domain name you choose must be globally unique. 

If you are using a **dedicated** device cloud, you can register your own domain name and point that to the underlying app. To use a self-hosted domain, check the "Self Hosted Domain" checkbox and enter your full domain name. If using a self-hosted domain, you will need to use a Domain Registrar of your choosing.

## App Upload

To upload the built app, select **Custom App** and click on the **Zip File** upload field. Navigate to the **apps/NAME/ui/dist/app.zip** file and then Save. This will upload the application and deploy to the Ioto service in the appropriate cloud region. It may take a few minutes for the application to be deployed by the Ioto service.

## Device Schema

The Ioto service uses the Ioto agent database schema to define what device specific data should be stored in the cloud and what are the device manageable entities.

The schema describes the device entities and their data properties and data types. Using this schema, the Ioto service and app are able to understand your device-specific data.

Ioto defines a default schema when you create the device cloud. This schema supports a generic key/value store. Initially, you can use the default schema, but as you progress, you may wish to define your own data entities to store device specific data. In this case, you will need to upload your application database schema to the Builder using the **Cloud/Edit** configuration panel.

For more information about the device schema, See:

* [Device Tables / Database Schemas](/apps/database/schemas/)
* [Database Replication](/ioto/database/replication.md)

## Configuring the App Display

The app user interface is defined by a JSON configuration file called **display.json5** that can be modified or extended to suit your specific needs.

The display.json file defines the following items:

* Displayed Name
* Display color theme including dark and light modes
* Menu items and options
* UI pages
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

The initial display.json5 configuration file defines a "developer" skin for the app. 

For more information about the display file, read [App Display](/apps/config/display.md).

## Learn More?

See [Apps Documentation](/apps/) for Apps configuration and operation details.# Blank Application

The Blank application builds Ioto with the required application integration start/stop callback functions but does not provide any user interface. This app is useful for building Ioto to operate "headless" as an embedded device agent or embedded web server without a user interface.

## Building

To build the Blank application select the APP and run make:

```bash
$ make APP=blank clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for local device management via the embedded web server
* Copy the required configuration to the ./config directory

The Ioto agent binary will be located in the build/PROFILE/bin/ioto file.

Change the **ioto.json5** services property collection to enable or disable Ioto services.

## Running

Run Ioto using:

```bash
$ make run
```# Management Applications

The Ioto source distribution and the Ioto Apps package contain a suite of management apps to help you get started with Ioto.

Some management apps provide browser-based UIs that are [VueJS](https://vuejs.org/) apps. These apps communicate with either the local Ioto web server or with the cloud-based Ioto service.

These apps are provided with the **Ioto Agent** source distribution.

Name | Pattern | Description
-|-|-
[ai](./auth/) | Local | Sample app to use the integrated OpenAI APIs.
[auth](./auth/) | Local | Simple embedded web server user/group authentication.
blink | Local | Minimal ESP32 (only) blink app to demonstrate linking with Ioto on ESP32 microcontrollers.
[demo](./demo/) |  [Standard](/apps/patterns/)  | Cloud-based demo app for Ioto with data exchange.
[blank](./blank/) | N/A | Headless application without a UI.


These additional apps are provided as part of the **Ioto Apps** download package.

Name | Pattern | Description
-|-|-
[cloudkick](./cloudkick/) | [Rebuilt](/apps/patterns/) | Cloud-based version of Kickstart.
[console](./console/) | Local | Local developer console for Ioto.
[eco](./eco/) | [Customized](/apps/patterns/) | Cloud-based Eco House sample app.
[kickstart](./kickstart/) | [Rebuilt](/apps/patterns/)| Local Kickstart sample "router" management app.

Read [Building Ioto](/agent/user/building.md) for details of how to build the integrated **auth**, **demo** and **blank** apps. The other apps are provided as part of the **Ioto Apps** download package. Read [Building Apps](./building.md) for details.

## Application Structure

Each application directory is organized with a similar directory /file structure:

Name | Description
-|-
Makefile | Top-level makefile for the application
README.md | Integrated documentation for the app
config | Directory containing the ioto.json5 and other configuration files
ui | VueJS user interface app (if present)
src | Device-resident code to integrate with Ioto

If the app provides a user interface, the **ui** directory will contain:

Name | Description
-|-
src | UI [VueJS](https://vuejs.org) source code for the app
ui/vite.config.js | [Vite](https://vitejs.dev) build configuration instructions
reports | Build assets size metrics
Makefile | UI Makefile
ui/public | Public assets for the UI (html pages, style sheets, images) 
ui/public/index.html | UI home page# Building Ioto Sample Apps

This Ioto Apps distribution provides several sample device management applications for Ioto and includes a copy of the Ioto agent distribution.

The Ioto samples are available as source code distributions from the [Builder Site](https://admin.embedthis.com/product). To download, first create an account and login, then navigate to the product list, select the Ioto Eval and click the download link. Then select the desired Ioto or Ioto sample package.

<a href="https://admin.embedthis.com/product" target="_blank">
    <button class="button">Download Source Package</button>
</a>

The Ioto samples distribution contains all the required source files, headers, and build tools to build both the Ioto agent and Ioto samples.

Several build environments are supported: 

-   **Linux** &mdash; Linux 4 with GNU C/C++
-   **Mac OS X** &mdash; Mac OS X 11 or later
-   **Windows** &mdash; Windows 11 with WSL v2
-   **ESP-32** &mdash; Using the [ESP IDF](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/index.html) in VS Code

For other environments, you will need to cross-compile. The source code has been designed to run on Arduino, ESP32, FreeBSD, FreeRTOS, Linux, Mac OS X, VxWorks and other operating systems. Ioto supports the X86, X64, Riscv, Riscv64, Arm, Arm64, and other CPU architecutres. Ioto can be ported to new platforms, operating systems and CPU architectures. Ask us if you need help doing this.

## Preparing to Build

To build the samples, NodeJS must first be installed. NodeJS is used as part of the build process to build the UI apps.

To install Node, go to:

```
https://nodejs.org/en/
```

and download the LTS distribution. Follow the instructions to install.

## Management Apps

The Ioto apps distribution includes several demo apps for local or cloud-based management. Apps demonstrate device-side logic and include the client-side UI to manage devices. 

Name | Directory | Description
-|-|-
cloudkick | apps/cloudkick | Cloud-based Kickstart sample "router" ui.
console | apps/console | Local developer console for Ioto.
eco | apps/eco | EcoHouse demonstration app.
kickstart | apps/kickstart | Local Kickstart sample "router" management app.

The "console" app is a local developer management app that communicates with the local web server in Ioto. This app is ideal for testing local management.

Each application has a README.md in the app directory that describes the application and provides operational instructions.

You can select the desired app when building via the **APP=NAME** option:

```bash
$ make APP=kickstart
```

## Configuration

You do not need to use a `configure` program when building via make. Instead, you simply run **make** and select your desired App. This will copy the App's configuration and conditionally compile the required services based on the App's **ioto.json5** configuration settings.

The configurable Ioto services are:

* database -- Enable the embedded database
* demo -- Demonstrate sending data to the cloud
* keys -- Get AWS IAM keys for local AWS API invocation (dedicated clouds only)
* logs -- Capture log files and send to AWS CloudWatch logs (dedicated clouds only)
* mqtt -- Enable MQTT protocol
* provision -- Dynamically provision keys and certificates for cloud based management
* register -- Register with the Ioto Builder
* serialize -- Run a serialization service when making the device
* shadow -- Enable AWS IoT shadow state storage
* sync -- Enable transparent database synchronization with the cloud
* url -- Enable client HTTP request support
* web -- Enable the local embedded web server

## Building with Make

If you are using ESP32, please follow the instructions in the [Building ESP32](/agent/user/building-esp32.md) document.

The top level Makefile parses your selected App's **ioto.json5** configuration file, detects your operating system and CPU architecture and then invokes the appropriate project Makefile for your system.

To build, nominate your selected app via the "APP=NAME" makefile option:

```bash
$ make APP=console
```

## Running Ioto

To run ioto, type:

```bash
$ make run
```

or add the directory **build/bin** to your PATH environment variable.

```bash
export PATH=`make path`

$ ioto -v
```

If your selected app enables the web server, Ioto will listen for connections on ports 9090 for HTTP and 4443 for HTTPS and serve documents from the **./site** directory when run with the **dev** profile. When run with the **prod** profile, it will serve documents from **/var/www/ioto** and will listen on port 80 and 443.

## Build Profiles

You can change Ioto's build and execution **profile** by editing **ioto.json5**. Two build profiles are supported:

-   dev
-   prod

The **dev** profile will configure Ioto suitable for developement. It will define use local directories for state, web site and config files. It will also define the "optimize" property to be "debug" which will build Ioto with debug symbols.

The **prod** profile will build Ioto suitable for production deployment. It will define system standard directories for state, web site and config files. It will also define the "optimize" property to be set to "release" which will build Ioto optimized without debug symbols. 

The **ioto.json5** configuration file has some conditional properties that are applied depending on the selected **profile**. These properties are nested under the **conditional** property and the relevant set are copied to overwrite properties of the same name at the top level. This allows a single configuration file to apply different settings based on the current value of the profile property.

You can override the **"optimize"** property by building with a "OPTIMIZE=release" or "OPTIMIZE=debug" make environment variable.

### Debugging

To build Ioto with additional memory and stack debug checks, enable the **ME_FIBER_CHECK_STACK** compilation variable. This will cause the Ioto runtime to check stack integrity and track overall stack and fiber usage. This does have a performance impact and should only be used in debug builds.

```bash
DFLAGS=-DME_FIBER_CHECK_STACK=1 make clean build
```

### Stack Size

Ioto uses [fiber coroutines](/agent/dev/fiber.md) for parallelism instead of threads or callbacks. The size of fiber stacks is defined via the **limits.stack** property in the **ioto.json5** configuration file. Set this value to be sufficient for your application needs. 

In general, it is recommended that you avoid the use of large stack-based allocations and use heap allocations instead. It is also advised to limit the use of recursive algorithms.

A default stack of 32K should be sufficient for core Ioto use on 32-bit systems. For 64-bit systems, 64K should be a minimum.

## Directories

| Directory | Purpose                                                                  |
| --------- | ------------------------------------------------------------------------ |
| apps      | Managmement applications                                                 |
| bin       | Build tools                                                              |
| build     | Build artifacts                                                          |
| scripts   | Device management scripts including OTA script                           |
| state     | Ioto runtime state configuration, certificates, database and web pages   |

## Key Files

| File              | Purpose                                                      |
| ------------------| ------------------------------------------------------------ |
| LICENSE.md        | License information                                          |
| device.json5      | Device registration file                                     |
| display.json5     | UI display configuration for management apps                 |
| ioto.json5        | Primary Ioto configuration file                              |
| schema.json5      | Database schema                                              |
| signature.json5   | Web server REST API signnatures                              |
| web.json5         | Embedded web server configuration                            |
# Console Application

The Console application is a developer device app for local device management over HTTP using the Ioto embedded web server. 

The Console application includes core functionality useful for most device management apps by offering:

* User authentication (login/logout)
* App navigation and menus
* Sidebar navigation 
* Display light / dark mode support
* Dashboards with information widgets (graphs, gauges, tables, numerics)
* Device data display, management and updating

The console uses the DevCore UI framework to provide this functionality.

## Building

To build the Console application select the APP and run make:

```bash
$ make APP=console clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for local device-based management.
* Build the Console application.
* Copy the required configuration to the ./config directory.
* Initialize the Ioto local database with login user definitions.

After building, the Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The device app will be copied to the **./site** directory.

## Running

To run Ioto, type:

```bash
$ make run
```

## Browsing

To view the Console, launch your browser and navigate to the URL:

```
https://localhost:4443
```

You will probably see a warning about the connection not being secure or "Your connection is not private". This is expected. This is a browser warning that the application is using a test TLS/SSL certificate. You may proceed as instructed and the app home page will be displayed.

You can login with the test user credentials:

Username | Password
-|-
**admin** | demo

## Demo

The Console app includes a simple demonstration that increments a database counter every ten seconds.
This demo consists of timed event running inside Ioto that increments a counter and the Console UI dashboard that displays the counter value via graph, gauge, table and numeric widgets.

![Console](/images/ioto/console-app.png){class="screen"}

The source to increment the database counter is in **apps/console/src/demo.c**.

## Device Schema

The Console app defines a Demo table in the database schema via the **apps/console/config/schema.json5** that includes the **DemoSchema.json5**.

For more information about the device schema, See:

* [Device Tables / Database Schemas](/apps/config/schema.html)
* [Database Replication](/ioto/database/replication.html)

## Configuring the Console Display

The Console user interface is defined by the **apps/console/config/display.json5** config file that can be modified or extended to suit your specific needs. 

The display.json file defines the following items:

* UI features
* Displayed Name
* Display color theme including dark and light modes
* Logo to display in the navigation bar
* Menu items and options
* UI pages and panels
* UI navigation routes
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

The initial display.json5 configuration file defines a "developer" skin for the console. 

For more information about the display file, read [App Display](/apps/config/display.html).

## Learn More?

See [App Documentation](/apps/) for Device app configuration and operation details.# CloudKick Application

The CloudKick app is a variant of the Kickstart app that communicates with the cloud instead of the local web server. It reuses most of the Kickstart UI but provides a different database schema and communication adapters.

CloudKick demonstrates the capabilities and experience provided by an application created with Ioto and VueJS. It includes includes a UI/UX for a sample router/switch application. CloudKick uses proven designs and best-practices to lower development risk. It includes most of the required elements for a secure web application, so you can eliminate months off your development schedule.

The CloudKick App is an example of a [Customized Device App](/apps/patterns/). This means it rebuilds the DevCore standard app to add custom UI components, a customized data schema and dashboard.

![CloudKick](/images/manager/cloudkick.png){class="screen"}

## CloudKick Components

* User management
* User login
* Property edit
* Alert notification
* Event log
* Dashboard
* Dynamic tables and graphs
* Paged Data Tables
* Navigation
* Search
* Granular access control per page
* Help

Read the [Kickstart Components](../kickstart/specs.md) for full details.

## Building

To build the CloudKick application select the APP and run make:

```bash
$ make APP=cloudkick clean build
```

The build will achieve the following goals:

* Build the Ioto agent with required services for cloud-based management
* Build the CloudKick application
* Copy the required configuration to the ./config directory

After building, the Ioto agent binary will be located in the build/PROFILE/bin/ioto file. The clouckick application will be located under the **apps/cloudkick/ui/dist** directory which will contain the individual application files and a **app.zip** ZIP file that is ready for uploading via the Builder to the Ioto cloud service for hosting the UI.

## Deploying

To deploy the CloucKick application, logon to the [Builder](https://admin.embedthis.com) site to create and configure an App.

From the Builder App list, click on the **Add App" icon or the **Edit** icon to modify an app.

![App List](/images/builder/app-list.png){class="screen"}

This will display the app configuration panel.

![App Designer](/images/builder/app-edit.png){class="screen"}


## Domain Name

If your app is hosted by Embedthis, select a sub-domain of your choosing under the **ioto.me** domain. You can select a unique sub-domain that reflects your company or product's brand. The sub-domain name you choose must be globally unique. 

If you are using a **dedicated** device cloud, you can register your own domain name and point that to the underlying Ioto manager site. To use a self-hosted domain, check the "Self Hosted Domain" checkbox and enter your full domain name. If using a self-hosted domain, you will need to use a Domain Registrar of your choosing.

## App Upload

To upload the built CloudKick app, select **Custom App** and click on the **Zip File** upload field. Navigate to the **apps/cloudkick/ui/dist/app.zip** file and then Save. This will upload the app and deploy to the Ioto service in the appropriate cloud region. It may take a few minutes for the application to be deployed by the Ioto service.

## Device Schema

The CloudKick app uses a custom device data schema to model the device. The schema describes the device entities and their data properties and data types. Using this schema, the Ioto service and the CloudKick app are able to understand the ClouKick device-specific data.

To apply this schema to the cloud, open the **Builder Cloud/Edit** configuration panel and select the **Device Data Schema** section. The upload the schema from the `apps/cloudkick/upload/schema.json5` file. This will be created when you build the CloudKick app.

For more information about the device schema, See:

* [Device Tables / Database Schemas](/apps/config/schema.md)
* [Database Replication](/ioto/database/replication.md)

## Configuring the CloudKick Display

The CloudKick user interface is defined by the **apps/cloudkick/config/display.json5** config file that can be modified or extended to suit your specific needs. 

The display.json5 file defines the following items:

* UI features
* Displayed Name
* Display color theme including dark and light modes
* Logo to display in the navigation bar
* Menu items and options
* UI pages and panels
* UI navigation routes
* Data tables and fields
* Device data edit property panels
* Dashboard data and widgets to display

For more information about the display file, read [App Display](/apps/config/display.md).

## Learn More?

See [Apps Documentation](/apps/) for Apps configuration and operation details.# Account Settings

The account settings page displays and manages the device user's account name and billing email address.

![Settings](/images/builder/settings.avif){class="screen width-60"}

The settings page will be enabled if the user is an "owner" of the account. You become an owner by having a member role of "owner".

## Name

The account name is defined when a user creates their account. They can change their account name here if required.# Create an Account

To use the EmbedThis Builder site, you need to register and create an account. This is a simple, one-time task that will take you just a few minutes.

If you have been invited to an account by a co-worker, please click on the link in the invite email. That will ensure you become a member of the account that invited you.

To register, navigate to the Builder site at [https://admin.embedthis.com](https://admin.embedthis.com) and click on the Register tab.

All use of the EmbedThis Builder service and the device agent software is governed by the [Embedthis Terms of Use](https://www.embedthis.com/about/terms.html).

## Register

When you navigate to the admin site, you will see the login / registration dialog.

![Register](/images/eco/eco-login.png){class="screen width-50"}

You may register using an email address and password or you may use a social media account from Amazon, Facebook, or Google. If you register by email and password, you will be sent a confirmation code to validate your email address. This code will come from the domain sender: no-reply@verificationemail.com.

Once registered, you will be automatically logged in to the Builder site. Later, you can invite team members to join you on your account.
# Members

User's can invite and add team members to their account and designate member's roles.

Administrative users can add, remove or modify organization members.

![Invite Member](/images/builder/invite-member.png){class="screen"}

## Inviting Users

To add a user to a Manager account, invite them via the "Add Member" button on the Member List page.

When invited, the user is sent an invitation email with instructions. When clicking or entering the link provided, the user can register and login to your account.

## Member Role

When inviting a user or later when modifying the user's configuration, a user can be assigned a role. This role may be:

* user
* admin
* owner

User role members can view information but not change product, subscription or organization configuration. Users can view and open support issues and download software.

In addition to user roles capabilities, admin members can perform constructive or destructive operations on the organization. Admin users can create product definitions, configure subscriptions and confirm purchases.

In addition to the admin role, owners can control the entire account. They can add and modify billing cards and close the account.

## Remove Member

Administrative users can remove other users at any time. Once removed, the user will lose all access to the manager and relevant devices.
# Personal Profile

The personal profile displays the user's login information including their login information and personal preferences.

![Profile](/images/builder/profile.avif){class="screen width-60"}

## Changing Name

If the user has logged in using an email address and password, they can change their personal profile including first and last name.

## Social Media Login

If the user has logged on via a social media account such as Google or Amazon, and they wish to change they profile, they need to do that via their social media account.

<!--
## Guide Hints

The Guide hint toggle controls the display of UI sign-posts that guide the user's use of the manager. While they can dismiss the guide posts individually on their respective pages, they can also turn off the Guide Hints toggle to turn off all sign-posts. If they decide to enable again in the future, they can select **Re-Enable** which will redisplay all posts including those they have individually dismissed.

--># Ioto<sup>&reg;</sup> IoT Apps

IoT device management apps enable you to control and monitor your devices and cloud services. With the Builder, you can create tailored apps for device management that support both local management through the agent's embedded web server and remote management via the cloud.

Apps can be customized for different user groupsend-users, developers, and support teams. For cloud-based management, the Builder handles global deployment by hosting and distributing apps through device clouds.

## Development Approaches

IoT apps can be built using two approaches:

1. **DevCore UI Framework** - A low-code framework designed specifically for device management
2. **Custom Development** - Direct use of Ioto APIs with your preferred framework

## DevCore UI Framework

DevCore is a JavaScript UI library designed for device management across mobile, tablet, and desktop platforms. It provides essential components including authentication, state management, request handling, navigation, device configuration, and data visualization.

![Home Page](/images/eco/eco-home.avif){class="screen width-50 center"}

### Key Features

* **Pre-built Components** - Authentication, navigation, dashboards, graphs, deployment, input forms, and monitoring
* **Customization** - Product branding, color schemes, and custom UI screens
* **Visual Designer** - Integrated low-code app page designer for building screens and dashboards
* **Data Widgets** - Display device data with advanced metrics and statistics
* **Extensible API** - Create custom UI components when needed

### App Designer

The integrated App Designer provides a visual, drag-and-drop interface for creating app UIs without extensive coding. It includes over 30 widgets for graphs, tables, numerics, shapes, gauges, buttons, images, and input controls.

![App Designer](/images/manager/page-designer.avif){class="screen width-100"}

Use the App Designer to customize your app's appearance and create or modify UI pages through the visual interface.

:::info 
DevCore can significantly reduce development time for device management applications.
:::

## Standard App Template

The Builder provides a pre-built device management app based on the DevCore framework. This Standard app can be extensively customized using the integrated App Designer without requiring you to rebuild the DevCore library or create custom UI components from scratch.

## Creating and Managing Apps

Create new IoT apps from the Builder's App list interface.

![App List](/images/builder/app-list.avif){class="screen"}

Once created, launch your app from the Builder's app list to access the integrated App Designer for UI modifications.

![Page List](/images/manager/page-list.avif){class="screen"}

## Custom Development

For use cases where DevCore doesn't meet your requirements, you can develop applications directly using the Builder and Ioto service APIs with any framework of your choice. This approach provides maximum flexibility for unique device management requirements.

# Creating DashBoards

You can create any number of dashboards from the Dashboard list.

![Dashboard List](/images/builder/dash-list.png){class="screen width-100"}

From the Dashboard list you can click the `Add` button to create a new dashboard or click on the `Edit` icon to modify an existing dashboard. When clicked, the dashboard configuration panel will be displayed.

The `Design` icon is used to launch the dashboard designer so you can modify the dashboard, content layout and styling.  While the `Show` icon is used to display the dashboard. 

## Modifying Dashboards

You can configure the board's properties and settings using the dashboad configuration panel. 

![Dashboard](/images/builder/dash-edit.png){class="screen width-50"}

## Dashboard Name

Each dashboard is given a unique name that is displayed in the dashboard list.

## Dashboard Layout

Dashboards have the choice of using one of two layout engines:

Name | Description
-|-
Exact | Layout widgets with exact positioning
Grid | Layout widgets on a grid

### Exact Layout

The `Exact` layout engine will position and size widgets wherever you place and configure them with per-pixel resolution. Widgets can overlap and cover widgets behind them. The exact layout does not use a grid.

The exact layout is useful to create composite dashboards with less regular widget placement.

### Grid Layout

The `Grid` layout will align widgets on a 20 pixel grid.

### Live Data

By default, dashboards will automatically update widget data based on the defined **Refresh Period**. You can disable **Live Data** update which can help you to focus on styling and arranging widgets without any display updates to break your concentration. 

### Framed Widgets

Widgets can be framed with a thin border. If you are creating a dashboard with a grid of data graphs, gauges and metrics, you typically frame the widgets with a consistent border.

![Framed Widgets](/images/builder/framed-widgets.avif){class="screen"}

If you are creating a composite page, you may wish to combine widgets so that the boundaries between widgets are less visible. In this case, disabling widget frames can assist to create a cohesive single page interface. For example, the EcoHouse app combines widgets to create a single page dashboard.

![Eco House](/images/eco/eco-home.avif){class="screen width-50"}

In this case, it is typically helpful to enable frames while you are designing a page and then disable frames when you are complete.

## Show Toolbar

If the `Show Toolbar` option is enabled, a toolbar is displayed at the top of the dashboard. The toolbar can be used to select dashboards, change the data date range, refresh data, and modify dashboard and widget configuration. You can also click a `designer` icon to quickly return to the designer for more significant changes to the dashboard.

![Widget Toolbox](/images/builder/dashboard-toolbar.avif){class="screen width-80"}

### Refresh Period

You can define the default refresh rate for metrics and data widgets. Set the refresh rate to your desired update period in seconds. However, do not set needlessly low as this will impose increased load on your service.

### Device Emulation

When designing pages for a mobile app, it can be helpful to perform your design on a desktop PC and emulate the mobile device. Selecting a **mobile** device to be emulated will resize the dashboard to be that of an iPhone 15 Pro Max.

Dashboards are responsive and should scale up and down as browser windows are resized or when run on mobile devices of differing dimensions.

### Time Range

You can define an absolute or relative time period to use for metric data supplied to your widgets.
A relative time range may be set to the most recent number of minutes, hours, days, weeks, months or years. An absolute time range can specify a fixed start and end date.

If the dashboard has a **toolbar** widget, users can change the time range at any time.

### Dashboard CSS Properties

Dashboards can be styled with any valid CSS property. For example, you can set the background to red and foreground color to blue via:

Name | Value
-|-
background | red
color | blue

### Default Widget CSS Properties

Simlarly to Dashboard CSS properties, you can define default widget properties that are applied to all widgets. These can be overridden per-widget in the Widget edit panel. You can display a color picker by clicking the pencil icon in the table.

## Exporting and Importing Dashboards

You can export a dashboard to a JSON file by selecting the dashboard and clicking the `Export` option under `Actions`. You can import a dashboard from a JSON file by clicking the `Import` action.

## Creating and Selecting Dashboards

To create a new dashboard, click "Add Dashboard" from the dashboard list.

When you have finished creating or editing your dashboard, you can **Save** to persist your changes. You can rename a dashboard by entering a new name and clicking Save. 

Click **Copy** to copy an existing dashboard to a new dashboard. The **Apply** button saves your changes without dismissing the edit panel. Dashboards can be deleted via the `Delete` button.

You can create multiple dashboards that focus on different service aspects. For example, you may want a dashboard that features service load graphs and metrics and another dashboard to focus on outages and errors.

You can easily switch between dashboards by clicking on the name of the dashboard in the Dashboard toolbar. You can also, create enable a "dashboard switch" action to a button widget that lets you rapidly switch to another dashboard by clicking a button widget in the dashboard.# Dashboards

![Dashboard](/images/builder/dashboard.png){class="screen"}

Dashboards are the window into your device and device cloud state. Dashboards display interactive, graphical information for your devices, account and service. They combine interactive widgets to create composite dashboards that can focus on a particular aspect of your service.

Dashboards can be created by you or by your customers. Any number of dashboards can be created for your service. The set of dashboards create are saved uniquely for each user.

## Difference between Dashboards and Pages

Dashboards and Pages are similar in that they both display widgets. However, dashboards are designed to display data metrics via graphical widgets. Pages are designed to combine multiple graphical elements, including widgets, to create a composite device page. 

## Widgets

Dashboards render data via graphical widgets from the Ioto service and your own device metrics. 

Widgets can be added, removed, styled, positioned, and resized to meet your specific requirements. Dashboards supports 30 different types of widgets, including: gauges, graphs, numeric, text, image, data table and input widgets.

Widgets can dynamically style their colors, backgrounds, fonts, and overall presentation.
Widgets can be combined to create cohesive displays that intuitively convey important device and cloud state.

Input widgets such as buttons and switches can invoke actions when pressed or activated by the user. These actions can invoke devices-based commands such as rebooting a device, or perform cloud-based operations such as updating the device database or sending an SMS alert.

Dashboards offer support for:

- Graphical widgets such as graphs, gauges, and numeric and text displays.
- No-code drag-and-drop dashboard and widget designer.
- Customizable layouts with adjustable positioning and sizing of widgets.
- Responsive designs that adapt to various screen sizes.
- Creation of multiple dashboards, each focusing on different aspects of services.
- A gallery featuring additional widgets and data sources.
- The ability to save and share dashboard configurations with team members in your organization.

Dashboards enable you to monitor the performance of your devices and device clouds effectively.

## Widgets and Layouts

The Dashboard facility utilizes the `Board` component of the `DevCore` UI framework. The Dashboards and Pages facilities both leverage the `Board` component. See the Board documention for details regarding:

* [Widgets](../widgets/)
* [Layouts](../boards/layouts.md)
* [Toolbar](../boards/toolbar.md)



# Board Toolbar

The board toolbar provides icons and buttons to modify dashboard and page presentation.

![Navbar](/images/builder/dashboard-toolbar.png){class="screen width-80"}

The toolbar is displayed when in design mode at the top of dashboards and pages. You can enable the toolbar to be displayed outside design mode by selecting the **Show Toolbar** option in the Board modify panel.

The following fields and icons are provided:

Icon | Description
-|-
Dashboard | Selection list of available dashboards
Range | Time range for metrics data for widgets
Timer | Countdown timer to the next widget data refresh
Expand | Expand widgets to full width of the display
Dashboard | Open the Dashboard Panel to modify the dashboard
Plus | Open the Widget Panel to add a new widget to the dashboard
Show | Show the board or launch the designer
Save | Save the current layout
Reset | Reset the current layout and discard unsaved changes

## Time Range 

You can customize the time range for the metric data given to dashboard widgets. You can select the period to be per hour, day, week, month or custom period using the **Range** button.

## Timer Reload

The timer counts down until the next data refresh is due. You can click the timer to refresh the data immediately.
When in design mode, the count down is disabled to stabilize the display. You can still refresh the data by clicking the timer.


## Expanding Widgets

If you are using the grid layout, you can click an **Expand** icon in the dashboard toolbar to stretch widgets to the full width of the display and remove redundant white space. This will align widgets on the left and the right of the dashboard. This is useful to quickly align and apportion a grid of widgets.

## Modify Dashboard

Clicking the **Dashboard** icon will open the modify dashboard panel.

## Add Widgets

Clicking the plus icon will open the **Add Widget** panel. You can also add widgets by draging a widget from the widget sidebar toolbox.

## Show Board

The dashboad can be placed in a **"design"** or **"fixed"** mode. When in design mode, the dashboard can be modified and widgets can be added, removed, resized and configured. When in fixed mode, all changes are prevented.

Production apps would typically put their dashboards in fixed mode.

When Design mode is enabled, the widget selection toolbox is displayed at the left side of the dashboard and a Dashboard toolbar is displayed at the top. 

## Save

When you have made changes to the dashboard, you can persist the changes by clicking the **Save** (or **Deploy** icon for pages). Any changes made will not be persistently saved until you click the **Save** button.

## Reset

Clicking the **Reset** icon will discard any unsaved changes and reset the page to the last saved version.
# Board Layouts

![Dashboard](/images/builder/dashboard.png){class="screen"}

When designing dashboards and pages, you have the choice of using one of two layout engines:

Name | Description
-|-
Exact | Layout widgets with exact positioning
Grid | Layout widgets on a grid

The selected layout engine is only used when designing dashboards or pages. The **Exact** layout engine is always used when not designing dashboards or pages.

Both layout engines support responsive layouts. When widgets are positioned, the relative position to the left side of the browser, and the width of the widget are saved as a percentage of the browser window size. Thereafter, if the window is resized, or if the app is viewed on a different sized mobile device, the widget will be scaled according to the size of the device. This permits a single dashboard design to scale for widely different user interface dimensions.

### Exact Layout

The **Exact** layout engine will position and size widgets wherever you place and configure them with per-pixel resolution. Widgets can overlap and cover widgets behind them. The exact layout does not use a grid.

![Exact Layout](/images/builder/exact-layout.png){class="screen"}

The exact layout is useful to create composite pages where widget boundaries are not visible (using frameless widgets). For example:

![Eco House](/images/eco/eco-home.avif){class="screen width-50"}

### Grid Layout

The **Grid** layout engine is the default layout engine and is typically easier to arrange widgets. The grid layout engine will position widgets so that widgets align on a 20 pixel grid and no widgets overlap.

![Grid Layout](/images/builder/grid-layout.png){class="screen"}

## Widget Placement

You can adjust the position of widgets on the dashboard by moving and resizing widgets. To move a widget, click the widget and drag it to a new location. To resize a widget, click and drag the resize handle located at the bottom right corner to your preferred size. If you are using the grid layout, the dashboard automatically rearranges other widgets to prevent overlap and ensure clear visibility. If you are using the exact layout engine, widgets will be placed exactly where you position them.

If widgets are moved, a **Save** button will appear in the widget toolbar. Click Save to persist your changes, click the **Reset** icon to discard your changes.

## Expanding Widgets

If you are using the grid layout, you can click an **Expand** icon in the dashboard toolbar to stretch widgets to the full width of the display and remove redundant white space. This will align widgets on the left and the right of the dashboard. This is useful to quickly align and apportion a grid of widgets.

## Zooming a Widget

If you Cmd-Click a widget, it will be zoomed to full screen display. Press the escape key to restore the widget to normal size.

## Responsive Design

When widgets are positioned, the relative position to the left side of the browser, and the width of the widget are save as a percentage of the browser window size. Thereafter, if the window is resized, or if the app is viewed on a different sized mobile device, the widget will be scaled according to the size of the device. This permits a single dashboard design to scale for widely different user interface dimensions.

# Board Configuration

Boards are configured using the **Board Configuration Panel**. This panel is accessible from the toolbar when viewing a page or dashboard, or from the list of dashboards or pages.

The configuration options are slightly different depending on whether you are editing a `Page` or a `Dashboard`.

## Board Configuration

When editing a page or a new dashboard, you can define the board's properties including: name, layout, refresh period, device emulation, time range, and CSS properties.

![Dash Edit](/images/builder/dash-edit.png){class="screen width-80"}

## Board Properties

### Name

Each dashboard requires a unique name, which is displayed in the list of dashboards. Pages do not have a name.

### Layout Engine

Boards can use one of two layout engines to position widgets:

| Name  | Description                                        |
| :---- | :------------------------------------------------- |
| Exact | Positions widgets with per-pixel accuracy.         |
| Grid  | Aligns widgets to a 20-pixel grid.                 |

The **Grid** layout engine is useful for creating structured layouts where alignment and consistency are important. It is also ideal when first creating a dashboard or page so you can easily position widgets on a grid.

The **Exact** layout engine is ideal for creating composite pages where widget boundaries are meant to be invisible. Widgets can overlap, providing complete creative control.

### Resizing the Display

When the display is resized, the widgets will be resized to maintain their horizontal aspect ratio. This enables a single display to be responsive and adapt to different screen sizes. When using the **Grid** layout engine, the widgets will be resized to fit the grid.

### Refresh Period

This setting defines the default refresh rate for metrics and data-driven widgets. The value is in seconds. Choose a reasonable period to avoid unnecessary load on your services.

### Device Emulation

For designing mobile interfaces on a desktop, you can emulate a mobile device. Selecting the **Mobile** option will resize the board to the dimensions of an iPhone 15 Pro Max. This is a design aid; boards are responsive and will adapt to various screen sizes.

### Time Range

You can set a default time range for data displayed in your widgets. This can be a relative period (e.g., "last 24 hours") or an absolute time range with specific start and end dates. If the board includes a `Toolbar` widget, users can modify the time range.

## Styling

### Board Styling

You can apply custom CSS to the entire board. For example, to set the background and foreground colors, you would provide:

| Name       | Value |
| :--------- | :---- |
| background | red   |
| color      | blue  |

### Default Widget Styling

You can define default CSS properties that will be applied to all widgets on the board. These defaults can be overridden for individual widgets in their respective configuration panels. A color picker is available to assist in selecting colors.

## Widget Frames

Widgets can be displayed with or without a visible border or "frame".

*   **Framed widgets** are suitable for grid-based dashboards where a clear separation between widgets is desirable.
*   **Frameless widgets** are often used in composite page designs to create a seamless, integrated user interface.

It can be helpful to enable frames during the design phase for easier layout management and then disable them for the final presentation.

Framed widgets by default have a solid background color. Frameless widgets have a transparent background. This can be overridden by defining a CSS property for the widget's **.card** component and set the **background** to **transparent**.

![Framed Widgets](/images/builder/framed-widgets.avif){class="screen"}
# Boards and Widgets

A `Board` is a UI component that provides a canvas and a suite of widgets to create composite UI pages, often called dashboards. Boards are a feature of the `Pages` and `Dashboards` components in the DevCore framework.

![Dashboard](/images/builder/dashboard.png){class="screen"}

Boards are used to create interactive user interfaces for monitoring and managing devices. They combine various widgets to present data and offer controls for device and cloud operations.

## Capabilities

Boards provide a powerful set of features for creating effective user interfaces:

*   **Extensive Widget Library**: Choose from over 30 widgets, including gauges, graphs, data tables, numeric and text displays, images, and various input controls. A gallery of additional widgets is also available.
*   **Drag-and-Drop Designer**: Visually design your boards. Add, remove, position, and resize widgets with ease to create custom layouts.
*   **Dynamic and Responsive**: Widgets can dynamically change their appearance based on data. The board layouts are responsive and adapt to different screen sizes.
*   **Custom Styling**: Customize the look and feel of widgets, including colors, backgrounds, and fonts to create cohesive and intuitive displays.
*   **Multiple Boards**: Create multiple boards, each tailored to display different aspects of your services or devices.

## Data Sources

Widgets can render data from multiple sources, including:

*   The Builder service
*   The Ioto service
*   Custom device metrics

## Actions

Input widgets, such as buttons and switches, can trigger actions when activated. These actions can perform device-centric commands, like rebooting a device, or execute cloud-based operations, such as updating a database record or sending an SMS alert.

Boards enable you to effectively monitor the performance of your devices and cloud services.

## See Also

*   [Board Configuration](config.md)
*   [Board Layouts](layouts.md)
*   [Board Toolbar](toolbar.md)



# Asset Designer

The Asset designer is used to configure the app's theme by uploading additional app assets. Such assets can include logos, icons, images, media, stylesheets and VueJS custom components. 

![Asset Designer](/images/manager/asset-designer.avif){class="screen width-80"}

## Asset Zip

The uploaded assets must be a zip file containing the assets to be uploaded. The zip file will be applied over the top of the existing assets. To upload images and other themeable assets, place the images under the `/theme` directory.

## Theme Directory

The `./theme` directory is special and its contents can be preserved across updates to the underlying DevCore UI framework by the Builder. When you update the app in the Builder, select the `Preserve Theme` option to preserve the theme assets under the `./theme` directory.

It is good practice to place your assets in the `./theme` directory for this reason.

## Import App

You can import an existing app `display.json5` file by clicking the **Import App** button. This will import the display.json5 and apply to the current app.

## Export App

You can export the current app by clicking the **Export App** button. This will export the current app display as a `display.json5` file.# Pages

The DevCore framework enables you to create custom UI pages for different aspects of device operation and performance. You can build focused interfaces for specific functions, such as control panels for key device parameters, performance dashboards with service load graphs and metrics, or diagnostic pages for monitoring outages and errors.

Pages are created using drag-and-drop functionality to arrange widgets on a canvas. They can be styled with CSS properties, including background colors or images, to create professional interfaces tailored to your device management needs.

You can also create pages that utilize custom UI components of your own design.

![Kickstart Page](/images/manager/dashboard.avif){class="screen"}

## Page Architecture

The Page Designer utilizes the DevCore framework's `Board` component, which provides the foundation for both pages and dashboards. This component offers:

- **Widget Management** - Comprehensive widget library for data display and user input
- **Layout Systems** - Flexible positioning and sizing options
- **Responsive Design** - Automatic adaptation to different screen sizes
- **Styling Control** - CSS-based customization capabilities

For detailed information about the underlying components, see:

* [Widgets](../widgets/)
* [Layouts](../boards/layouts.md)
* [Toolbar](../boards/toolbar.md)

## Page Features

The DevCore framework provides comprehensive tools for creating device management interfaces. You can create pages and configure how they are integrated into the app. For each page you can configure:

- **Page Navigation** - The page navigation URL and menu items
- **Page Title** - The title displayed at the top of the page
- **Page Component** - The VueJS component used to render the page
- **Page Order** - The display order in relevant app menus
- **Page Authentication** - The required user role to access the page
- **Page Content** - The page content and layout

## Page Management

From the Pages list you can add or modify pages. Add a page by clicking the `Add` button. Click the `edit` icon to modify an existing page.

![Page List](/images/manager/page-list.avif){class="screen"}

After creating a page, access the Page Designer by clicking the `Design` icon in the pages list. Only pages that use the `Page` component will have a `Design` icon. Other pages have fixed layouts and contents and cannot be edited via the Page Designer.

### Page Order

You can configure the page order by dragging and dropping pages in the list. The page order defines the sequence in the app sidebar menu or tabbed menus.

## Creating and Editing Pages

When adding or editing a page, the page properties panel will be displayed.

![Page Edit](/images/manager/page-edit.avif){class="screen width-80"}

### Page Navigation

Under the `Page Navigation` section you can configure the page navigation URL and menu items. The page navigation URL is the URL that will be used to access the page. The menu items are the items that will be displayed in the app sidebar menu. You can configure the page menu icon and user access role.

The page title is the title that will be displayed at the top of the page.

### Page Appearance

For pages that use the `Page` component, you can configure the page appearance:

* **Design Layout** - Set the design-time page layout to `Grid` or `Exact`. The Grid layout is the default and snaps widgets to a 20-pixel grid. The Exact layout allows you to position widgets with exact coordinates.
* **Frame Widgets** - Enable or disable widget frames. Frame widgets display a border around the widgets.
* **Toolbar** - Enable or disable the page toolbar. The toolbar displays the page title and action buttons at runtime.
* **CSS Properties** - Set page colors, fonts, borders and more using CSS properties.
* **Widget CSS Properties** - Set common properties to be inherited by all widgets.

![Page Appearance](/images/manager/page-appearance.avif){class="screen width-80"}

### Page Component

The Page Component tab configures the VueJS component used to render the page and the component properties. The `Page` component is the default component that supports the Page Designer and widgets.

## Page Designer

After creating a page, access the Page Designer by clicking the `Design` icon in the pages list.

When the Page Designer is launched, you will see the page canvas with the page title and toolbar. To the left is the widget toolbox.

![Page Designer](/images/manager/page-designer.avif){class="screen"}

### Page Canvas

The page canvas is the main area where you can design the page layout and content. It is where you can add and position widgets, and it scales according to the screen size.

The page canvas uses percentage-based sizing and positioning of widgets. As the window is scaled or resized, the widgets will resize to maintain the same relative width and will adjust their position to occupy the same relative position. This offers automatic scaling and consistent presentation across different devices and screen sizes.

Note that you can always use the multiple-display capability if you have specific device requirements that cannot be met by responsive design.

When placing and configuring widgets, you can drag them to the desired position and size on the canvas. You can also anchor widgets to a specific position relative to the canvas edges. This is useful to create fixed position elements like page titles or footers.

### Adding Widgets

You can add widgets to the page canvas in two ways:

* **Drag and Drop** - Drag widgets directly from the widget toolbox onto the page canvas
* **Add Widget Panel** - Click the `Add Widget` plus icon in the page toolbar (second icon from the right)

![Add Widgets](/images/builder/widget-toolbox.png){class="screen width-60"}

When first adding a widget, the widget configuration panel will be displayed so you can define or modify the widget properties:

- **Widget Type** - Select the appropriate widget for your data
- **Widget Presentation** - Customize the widget appearance and style
- **Data Source** - Connect the widget to real-time or historical metrics or device data
- **Actions** - Configure cloud-side user actions in response to user interaction

![Add Widgets](/images/builder/widget-add.png){class="screen width-60"}

### Widget Library

The widget toolbox contains a library of widgets that you can add to the page canvas. The widget library is organized into categories:

**Output Widgets**
- Graphs, gauges, numeric displays, text, images, event indicators, data tables

**Input Widgets**
- Buttons, checkboxes, comboboxes, select lists, date pickers, file inputs, sliders, switches, text areas, radio buttons

See the [Widgets](../widgets/) page for more information about the widgets available.
See the [Input Widgets](../widgets/input/) page for more information about the input widgets available.
See the [Output Widgets](../widgets/output/) page for more information about the output widgets available.

## Widget Layout

The Page Designer supports two design-time layout engines:

### Grid Layout

- **Automatic Alignment** - Widgets snap to a 20-pixel grid
- **No Overlap** - Prevents widgets from overlapping
- **Easier Positioning** - Simplified widget arrangement
- **Recommended for Beginners** - More intuitive for new users

### Exact Layout

- **Pixel-Perfect Positioning** - Place widgets with exact coordinates
- **Overlap Support** - Widgets can overlap and layer
- **Composite Interfaces** - Create seamless, integrated UI pages
- **Advanced Control** - Full control over widget positioning

### Design Workflow

When creating pages, it is recommended to use the `Grid` layout and the `Framed` option for your initial design. This will make it easier to position and arrange widgets. When you have your rough design complete, you can switch to `Exact` layout without frames for the final presentation. The `Exact` layout is useful to create pixel-perfect interfaces and permits widgets to overlap and layer.

## Best Practices

### Design Workflow
1. **Plan Layout** - Sketch page structure before building
2. **Start with Grid** - Use grid layout for initial widget placement
3. **Use Framed Mode** - Enable widget frames during design
4. **Test Responsiveness** - Check behavior across different screen sizes
5. **Optimize for Target** - Switch to exact layout for pixel-perfect control if needed

### Widget Organization
- **Group Related Widgets** - Arrange functionally related elements together
- **Consider Information Hierarchy** - Place important information prominently
- **Maintain Consistency** - Use consistent styling across widgets
- **Plan for Mobile** - Consider mobile viewing experience

### Performance Considerations
- **Limit Widget Count** - Too many widgets can impact performance
- **Optimize Data Sources** - Ensure efficient data connections
- **Test with Real Data** - Verify performance with actual device data
- **Monitor Resource Usage** - Check memory and CPU impact

### Page Configuration
- **Use Appropriate Layout** - Choose Grid for ease of use, Exact for precision
- **Consider User Roles** - Set appropriate authentication requirements
- **Test Navigation** - Verify menu integration and URL routing
- **Optimize for Purpose** - Tailor page features to intended use case

# Displays

The App Designer supports creating multiple display configurations for different device types including mobile, tablet, and desktop. You can create a single responsive display that adapts to all device types or create specific displays optimized for particular form factors.

Each display definition contains a JavaScript expression that determines whether the display should be used on the current device based on device properties and capabilities.

![Display List](/images/manager/display-list.avif){class="screen width-100"}

## Creating Displays

To create a new display, click the `Add` button. To edit an existing display, click the `edit` icon.

When configuring a display, you adjust the following settings:

### Basic Configuration

- **Display Name** - Internal identifier for the display
- **Expression Type** - The expression used to determine if the display should be used on the current device
- **Theme** - The theme applied to the display, including app title, logos, colors, fonts, and data formats

![Display Add](/images/manager/display-add.avif){class="screen width-80"}

### Page Sets

When creating a new display, you can select the initial page set to use. Choose from `minimal` or `standard`:

**Minimal Page Set**
- Login page
- Password reset page
- User registration page

**Standard Page Set**
- All minimal pages plus:
- Device selection pages
- Device data display pages
- Dashboard pages
- Alert management pages
- Account settings pages

## Display Selection Expressions

The Expression Type defines how the display is selected for different devices:

### Predefined Options
- **Mobile** - Pre-configured for mobile devices
- **Tablet** - Pre-configured for tablet devices  
- **Desktop** - Pre-configured for desktop devices
- **Responsive** - Single display adapting to all device types
- **Custom** - Custom JavaScript expression for specific requirements

### Expression Context

Custom expressions are evaluated at runtime and can access the following device properties:

| Property | Type | Description |
|----------|------|-------------|
| `agent` | String | Current device user agent |
| `desktop` | Boolean | True if current device is desktop |
| `height` | Number | Device screen height in pixels |
| `language` | String | Current device language setting |
| `mobile` | Boolean | True if current device is mobile |
| `timezone` | String | Current device timezone |
| `width` | Number | Device screen width in pixels |

### Expression Examples

```javascript
// Width-based selection
expression: 'width < 640'                    // Mobile devices
expression: 'width >= 640 && width <= 1024' // Tablet devices
expression: 'width > 1024'                   // Desktop devices

// Language-based selection
expression: 'language == "en"'               // English language
expression: 'language =~ /^en/'              // English variants

// Combined conditions
expression: 'width > 1024 && language == "en"' // English desktop
expression: true                             // Always use this display
```

For comprehensive expression syntax documentation, see [Expressions](../config/expressions.md).

## Display Themes

The display theme configuration controls the visual appearance of your application, including colors, fonts, logos, and data formats.

![Display Colors](/images/manager/display-colors.avif){class="screen width-80"}

### Display Colors

The display colors section defines the `light` and `dark` theme colors for the app. The DevCore framework uses the [Material Design](https://m3.material.io/theme-builder) color system. Colors are applied to the app and can be overridden by individual page themes.

#### Custom Logos

For both `light` and `dark` modes you can define custom logos to be displayed in the app navbar and login page. Logo files should be uploaded and placed in the `./theme` directory.

#### Color Picker

You can edit each theme color or add new theme colors. Each color is converted to a CSS variable and can be utilized in the widget and page appearance panels. Click the `edit` pencil icon for a color line to display the color picker and select your desired color.

### Display Variables

Display CSS variables customize the rendering factors used by the app, such as `font-size` and `font-family`. The DevCore framework uses default values for most variables, but you can override them to match your requirements.

![Display Variables](/images/manager/display-variables.avif){class="screen width-80"}

### Display Formats

The DevCore framework displays data in various formats. You can configure display formats for the app to suit your language and locale requirements.

If you need to support incompatible formats for different locales, you can create multiple display definitions and use different display formats for each display definition.

![Display Formats](/images/manager/display-formats.avif){class="screen width-80"}

## Theme Management

### Import and Export

You can import and export theme definitions to and from JSON files. This is useful for checkpointing and backing up display definitions.

### Apply Predefined Themes

The DevCore framework supplies a set of predefined themes that you can apply to the display. When you apply a theme, it overwrites your current theme settings. If you want to preserve your current theme settings, export the theme to a JSON file before applying a new one.

The provided themes include both light and dark modes:

* **RedShift** - A theme with a red base color
* **GreenSprout** - A theme with a green base color
* **RoseQuartz** - A theme with a pink base color

## Best Practices

### Expression Design
- Use simple expressions when possible for better performance
- Test expressions across different device types and screen sizes
- Consider screen orientation changes in mobile devices
- Document complex expressions for future maintenance

### Theme Configuration
- Maintain consistent color schemes across light and dark modes
- Test themes on different device types to ensure readability
- Use appropriate contrast ratios for accessibility
- Consider branding requirements when customizing logos and colors

### Performance Considerations
- Limit the number of display definitions to avoid complexity
- Use responsive design when possible instead of device-specific displays
- Test theme performance on target devices
- Optimize custom logo file sizes for faster loading

## Related Documentation

For comprehensive display configuration options, see [Display Properties](../config/display-properties.md).# App Designer

The App Designer is a visual, low-code tool for creating and customizing device management application interfaces. It enables you to modify UI controls, data displays, themes, colors, and branding without writing custom code.

The App Designer runs within the device app and is available to users with the `owner` role.

![Device Page Designer](/images/manager/page-designer.avif){class="screen"}

## Core Components

The App Designer consists of four main components:

* **Display Manager** - Configure display settings for different device types
* **Page Designer** - Create and modify UI pages with drag-and-drop functionality
* **Feature Designer** - Configure app features and capabilities
* **Asset Designer** - Manage logos, images, stylesheets, and custom components

## Display Manager

The Display Manager supports creating multiple display configurations for various device types including mobile, tablet, and desktop. Typically, you would create a single responsive display that adapts to different device types. However, you can also create specific displays for particular form or usage factors.

Each display definition contains a JavaScript expression evaluated at runtime to determine if the display should be used on the current device. The expression can access device properties such as `agent` `width` `height` `language` `version` and `timezone`.

![Display Edit](/images/manager/display-edit.avif){class="screen width-100"}

### Display Configuration

For each display, you can customize:

- **Display Matching** - The expression used to determine if the display should be used on the current device.
- **Theme Settings** - App title, logos, colors, fonts, and data formats

## Page Management

The App Designer enables you to create and modify UI pages for each display. The Pages tab shows all pages in the app, displaying the UI path, menu name, icon, and rendering component.

![Page Designer](/images/manager/page-list.avif){class="screen width-100"}

### Page Operations

- **Add Pages** - Click `Add` and select the `Page` component
- **Reorder Pages** - Drag and drop page list items
- **Edit Properties** - Click the edit icon to modify page settings
- **Visual Design** - Use the Page Designer for drag-and-drop page creation

## Page Configuration

For each page, you can customize it using the Page configuration panel.

![Page Edit](/images/manager/page-edit.avif){class="screen width-60"}

Pages have the following configuration options:

**Basic Settings**
- **UI Path** - Required routing path for the page
- **Internal Name** - Optional identifier for internal use
- **Menu Integration** - Icon and placement in sidebar menu

**Security Settings**
- **Access Control** - Specify the required user roles for who can view and interact with the page. (`owner`, `admin`, `user`, `public`, `inherited`)

**Navigation Options**
- **Tab Navigation** - Enable tabbed display for child pages
- **Parent-Child Relationships** - Organize pages hierarchically

## Page Designer

Pages are implemented by composing UI elements as widgets on a background "canvas". Widgets can be added, removed, posiitioned and resized as needed.

The Page Designer provides a drag and drop visual design interface for page layout and content. The Page Designer offers over 30 widgets for building interfaces:

**Output Widgets**
- Audio, Event, Image, Label, LED, Line, Metric, Progress, Shape, Tabs, Toolbar, Video

**Input Widgets**
- Button, Form, Input controls, Sliders

**Data Widgets**
- Info Cards, Guages, Numerics, Tables, Charts

![Page Designer](/images/manager/page-designer.avif){class="screen width-80"}

## Feature Designer

The Feature Designer configures the app's supported capabilities including authentication, navigation, cloud management, and visualization features.

![Feature Designer](/images/manager/feature-designer.avif){class="screen width-80"}

Use the Feature Designer to:

- **Enable/Disable Features** - Control which capabilities are available
- **Configure Authentication** - Control user authentication methods
- **Manage Navigation** - Configure navigation features and presentation
- **Dashboards** - Configure user dashboards 
- **Cloud Integration** - Configure cloud service connections

## Asset Designer

The Asset Designer manages additional app resources including logos, images, favicons, stylesheets, and custom VueJS components.

![Asset Designer](/images/manager/asset-designer.avif){class="screen width-80"}

### Asset Management

- **Upload Assets** - Add logos, images, and custom stylesheets
- **Custom Components** - Upload VueJS components for extended functionality
- **Device-specific Assets** - Configure different assets for mobile, tablet, and desktop

### Asset Visibility

Uploaded assets are available to all app displays, but can be configured for specific device form factors. For example, you can upload different logos for mobile devices or different themes for light and dark modes.

## Development Workflow

1. **Configure Displays** - Set up device-specific display configurations
2. **Create Pages** - Build UI pages using the visual designer
3. **Arrange Widgets** - Position and configure widgets on pages
4. **Configure Features** - Enable required app capabilities
5. **Upload Assets** - Add branding and custom resources
6. **Test Interface** - Verify functionality across device types

## Access Control

The App Designer requires `owner` role access for security. This ensures only authorized users can modify the application interface and configuration.
# Feature Designer

The `Feature Designer` is used to configure the app's supported features. This includes the app's features, such as authentication, navigation, cloud management, and visualization features.

![Feature Configurator](/images/manager/feature-designer.avif){class="screen width-80"}

# Features

| Group | Path| Tip |
|-|-|-|
| **Authentication**| `auth.forgot`  | Forgot password recovery                 |
| **Authentication**| `auth.login`   | Login required to use app                |
| **Authentication**| `auth.register`| Enable user registration                 |
| **Cloud**     | `cloud.enable`     | Enable cloud-based management            |
| **Dashboards**| `dash.enable`      | Enable user dashboards                   |
| **Dashboards**| `dash.edit`        | Enable dashboard editing                 |
| **Dashboards**| `dash.database`    | Enable dashboards database access        |
| **Dashboards**| `dash.metrics`     | Enable dashboard metrics                 |
| **Dashboards**| `dash.multiple`    | Support multiple dashboards              |
| **Navigation**| `nav.alerts`       | Display alert notifications in navbar    |
| **Navigation**| `nav.cookies`      | Display navigation cookies in tabbed pages |
| **Navigation**| `nav.dark`         | Display dark theme option in navbar      |
| **Navigation**| `nav.doc`          | Display documentation link in navbar     |
| **Navigation**| `nav.login`        | Display user login and submenu           |
| **Navigation**| `nav.help`         | Support help panel                       |
| **Navigation**| `nav.profile`      | Display user account profile link        |
| **Navigation**| `nav.settings`     | Display user account settings link       |
| **Navigation**| `nav.sidebarHide`  | Auto-hide the sidebar when not active    |
| **Widgets**   | `widget.actions`   | Enable widget actions                    |
| **Widgets**   | `widget.multiCloud`| Widgets should support multiple clouds   |
# Widget Presentation

Widgets can be styled by anchoring their position, defining their stacking order and via CSS properties.

![Widget Presentation](/images/builder/widget-edit-presentation.avif){class="screen width-60"}

### Anchoring Widget Position

If you are using the **Exact** layout engine for your board, you can anchor widgets to various positions of the board. This is useful for example if you wish to anchor a widget to the bottom center of the board.

You can select a vertical and and a horizon anchor position with an offset. The offset can be expressed as a number of pixels or as a percentage of the board's height/width.

If you are using the **Grid** layout engine, widgets will be always compacted on the grid and anchoring widgets is not compatibile with the grid placement strategy.

### Z Stacking Order

With the **Exact** layout engine, widgets are permitted to overlap. You can define their stacking order by setting a positive **z-index** value for each widget. The default value is zero. You can also set the z-index by Cmd-Clicking on a widget to bring it to the foregound. This will set its z-index to the highest of all widgets.

## Show Expression

You can define an expression to determine if the widget should be displayed. The **show expression** is a JavaScript like expression that is evaluated to yield a true or false result.

The **show** expression is provided with a context of variables that can be accessed by the expression. The widget data value is provided in the **"value"** named variables. You can test this result using a Javscript like expression. For example:

    value > 0

See [Expressions](../config/expressions.md) for more information on the expression syntax.


### CSS Properties

Widgets will initially display with a default theme based on the current light or dark mode. However, you can override any CSS property for the widget to customize the widget size, colors and style. The WidgetEdit Presentation panel provides a CSS editor to help you define the CSS properties for the widget.

By default, the Widget will inherit any default widget CSS properties defined in the board configuration or by the defined application theme.

The CSS Property name can be any standard CSS property name. For example:

Name | Value
-|-
background | red

If the property name is **class*, the class name value will be added if the widget value is not zero (false). Otherwise the class name will be removed. For example:

Name | value
-|-
class | "my-class"

#### CSS Syntax

CSS names and values can be conditionally applied to specific elements based on runtime data.

![CSS Editor](/images/builder/css-edit.avif){class="screen width-100"}

#### IF Expression

The **IF** clause is an optional expression that evaluates to determine if the CSS property is applied or not. It can use the widget's `value` in the expression.

For example:

IF | Element | Property | Value
-|-|-|-
value == 'some-value' && width <= 640 | .footer | background | red

See [Expressions](../config/expressions.md) for more information on the expression syntax.

#### Element Paths

A CSS property can be applied to a specific widget DOM element that is described by the component path. A component path can select elements by specifying a path that includes CSS class names, element names and element IDs. 

For example:

    .area.footer
    .header#title
    .header,p

You can specify a path from the root of the widget to the element you want to style. 

Standard paths include:

Path | Description
-|-
.header | The widget header.
.footer | The widget footer.
.prefix | The prefix text before the widget value.
.suffix | The suffix text after the widget value.
.card | The widget card enclosing the widget content.

For example, to set the widget background to transparent, use:

    .card | background | transparent

#### CSS Property Names

CSS property names can be any relevant standard CSS property name, the special **class** property, a custom Vuetify or DevCore CSS properties.

If the **class** property is used, the given value will be added to the element as a CSS class name. For example:

    class | my-class

This will add the **my-class** class to the element.

Most DevCore widgets use an underlying Vuetify component to render their content. To pass properties to the underlying Vuetify component, use a **--w-** component prefix on the CSS property name. This will strip the **--v-** prefix and provide the property to the Vuetify component. For example:

The Image widget uses the Vuetify **v-img** component to render the image. To pass a gradient to the Image widget, you can use the **--w-gradient** CSS property which will define the **gradient** property on the Vuetify v-img element. 

```css
--w-gradient | linear-gradient(to right, red, green)
```
You can also pass parameters to custom DevCore widgets by prefixing the property name with **--w-**.  For example, to set the graph area color for the graph widget, use:

    --w-fill-color | red

The **--w-** properties are interpreted internally by the relevant widget. Each widget type documents the subcomponents utilized by that widget type.

#### CSS Values

The CSS value can be a single value or a colon separated list of values if an expression is supplied. In this case, the property value can supply two values separated by a colon. If the expression is true, the value before the colon is used, otherwise the one after the colon. For example:

Expression | Components | Property | Value
-|-|-|-
value == true | .status | background | **red:green**

If the expression evaluates to true, the element with a **.status** class will have its background will be set to **red**. If the expression evaluates to false, the background will be set to **green**.


## Notes

CSS values do not need to include a trailing semicolon.# Basic Widget Configuration

The **Basic** widget configuration includes the widget type, title and other fields that are relevant for the selected widget type.

![Basic Configuiration](/images/builder/widget-edit.avif){class="screen width-60"}

Depending on the widget type, different configuration fields will be presented from the following list:

Name | Description
-|-
accept | File types to accept for the File upload widget
datetime | Set to "date", "time" or "datetime" for the date input widget.
field | Database field to update for input widgets
fields | Database fields to display for table widgets
footer | Widget footer to display at the bottom of the widget
form | Associated form widget to post input form fields
format | Widget numeric format string
header | Widget header text to display at the top of the widget
items | Selection items to use with input select and combo widgets
label | Input field label
max | Maximum expected data value
min | Minimum expected data value
multiple | Allow multiple selections for an input combo widget
pivot | Pivot the table widget data. Rows vs columns.
placeholder | Place holder text to use for input text widgets.
prefix | Text prefix to display before the value for numeric widgets.
presentation | Graph presentation.
rows | Numer of rows to display for a text area input widget
subtitle | Subtitle to display for the table widget
suffix | Suffix text to display after a numeric value
text | Static text to use for the widget value
timezone | Timezone to use for the date input wiget
url | URL to use for image and sound widgets
validate | Regular expression to use for validating text inputs.

## Dynamic Tokens

Some fields utilize **${variable}** references that are expanded at runtime based on other input and context data. For example, the **header**, **footer** and **title** fields can use dynamic tokens. For example:

A header could be set to:

```
City: ${city}
```

##Formatting Numerics

The format field is used when formatting numberic widgets.

For example, the following will format numbers with an optional sign followed by the number portion with thousand separators and one decimal place. The number will be rounded up.

```
-0#,###.#^
```

The formatter characters are:

Character | Description
-|-
0 | digits with leading zero
\# | digit 
, | Thousand separators
% | format as percent
\+ | Always show sign
\- | Show sign if negative
^ | Round up
v | Round down
# Text Widget

The text widget is a simple text input. It may be used stand-alone or as part of a form.

![Text Widget](/images/widgets/text-widget.avif){class="screen width-60"}

## Configurable components

Class Name | Description
-|-
card | Background card component
primary | Text input component

## Widget Properties

Name | Description
-|-
label | Field label
form | Name of the form to submit the text to.

## CSS Properties

These CSS properties configure the underlying Vuetify text input component.

Property | Description
-|-
background | Background color
color | Text color
--w-variant | Set to elevated, flat, tonal, outlined, text or plain.
--w-density | Set to compact, default or comfortable.
--w-ripple | Set to enable the ripple effect.# Radio Widget

The radio widget provides a simple radio selection. It may be used stand-alone or as part of a form.

![Radio Widget](/images/widgets/radio-widget.avif){class="screen width-80"}

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
form | Name of the form to submit to.
label | Radio label text
value | The initial radio value

## CSS Properties

These CSS properties configure the underlying radio component.

Element | CSS Property | Description
-|-|-
&nbsp; | background | Background color of the button
&nbsp; | color | Text color of the button
&nbsp; | --v-density | Set to compact, default or comfortable.
&nbsp; | --v-ripple | Set to enable the ripple effect.
card | background | Background color of the card# Slider Widget

The slider widget provides a linear slider selection. It may be used stand-alone or as part of a form.

![Slider Widget](/images/widgets/slider-widget.avif){class="screen width-80"}

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
form | Name of the form to submit to.
label | Radio label text
min | The minimum value of the slider
max | The maximum value of the slider
value | The initial slider value

## CSS Properties

These CSS properties configure the underlying slider component.

Element | CSS Property | Description
-|-|-
&nbsp; | background | Background color of the slider
&nbsp; | --v-density | Set to compact, default or comfortable.
&nbsp; | --v-ripple | Set to enable the ripple effect.
&nbsp; | --v-density | Set to compact, default or comfortable.
&nbsp; | --v-ripple | Set to enable the ripple effect.
card | background | Background color of the card# Form Widget

The form widget coordinates the input from a collection of input widgets.
It provides a button to submit the form.

![Form Widget](/images/widgets/form-widget.avif){class="screen width-80"}

Input widgets can designate a form name. When the corresponding form is then submitted, the form widget will gather the input values and submit them to the widget action.

## Configurable components

Class Name | Description
-|-
card | Background card component
primary | Primary form component

## Widget Properties

Name | Description
-|-
form | Name of the form. Use this name in the input widgets to specify the form
text | Text to display in the form button. Defaults to "Save"
validate | Regular expression to validate the form input

## CSS Properties

Element | CSS Property | Description
|-|-|-|
&nbsp; | font-size | Font size of the form text. Scales by default according to the widget size
&nbsp; | font-weight | Font weight of the form text. Defaults to bold
button | color | Color of the form text
button | background | Background color of the form button. Defaults to accent
button | --v-variant | Set to elevated, flat, tonal, outlined, text or plain
button | --v-block | Set to true to make the button full width
button | --v-density | Set to compact, default or comfortable
button | --v-ripple | Set to enable the ripple effect
# Button Widget

The button widget provides a simple clickable button and is typically used with widget actions to navigate to a new app page or to invoke a cloud-side automated action.

![Button Widget](/images/widgets/button-widget.avif){class="screen width-80"}

A text button is used to display text with optional prefix and suffix icons. If you want an icon button without text, use the [Icon widget](./icon.md).

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component
prefix | Button text prefix icon
suffix | Button text suffix icon

## Widget Properties

Class Name | Description
-|-
form | Name of the form to submit to.
value | Button text to display if widget.text not set
prefix | Button prefix icon
suffix | Button suffix icon
text | Button text

## CSS Properties

These CSS properties configure the underlying button component.

Property | Description
-|-
background | Background color of the button
color | Text color of the button
border-radius | Round the button corners
box-shadow | Add a shadow to the button
--w-variant | Set to elevated, flat, tonal, outlined, text or plain.
--w-block | Set to true to make the button full width.
--w-density | Set to compact, default or comfortable.
--w-ripple | Set to enable the ripple effect.# File Widget

The file widget provides a file selection dialog to upload file. It may be used stand-alone or as part of a form.

![File Widget](/images/widgets/file-widget.avif){class="screen width-80"}

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
form | Name of the form to submit to.
label | File label text
value | The initial date value

## CSS Properties

These CSS properties configure the underlying button component.

Element | CSS Property | Description
-|-|-
&nbsp; | background | Background color of the button
&nbsp; | color | Text color of the button
&nbsp; | --v-density | Set to compact, default or comfortable.
&nbsp; | --v-ripple | Set to enable the ripple effect.
card | background | Background color of the card# Date Widget

The date widget provides a date dialog to select dates and times. It may be used stand-alone or as part of a form.

![Date Widget](/images/widgets/date-widget.avif){class="screen width-80"}

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
form | Name of the form to submit to.
datetime | Set to 'date', 'time' or 'datetime'. Defaults to 'datetime'.
label | Checkbox label text
timezone | The timezone to use for the date picker. Defaults to the user's timezone.
value | The initial date value

## CSS Properties

These CSS properties configure the underlying button component.

Element | CSS Property | Description
-|-|-
&nbsp; | background | Background color of the button
&nbsp; | color | Text color of the button
card | background | Background color of the card
&nbsp; | --v-density | Set to compact, default or comfortable.
&nbsp; | --v-ripple | Set to enable the ripple effect.# Checkbox Widget

The checkbox widget provides a simple clickable checkbox. It may be used stand-alone or as part of a form.

![Checkbox Widget](/images/widgets/checkbox-widget.avif){class="screen width-80"}

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
form | Name of the form to submit to.
label | Checkbox label text
value | The checkbox value

## CSS Properties

These CSS properties configure the underlying button component.

Property | Description
-|-
background | Background color of the button
color | Text color of the button
card.background | Background color of the card
--v-density | Set to compact, default or comfortable.
--v-ripple | Set to enable the ripple effect.# Select Widget

The select widget provides selection from a list of options. It may be used stand-alone or as part of a form.

![Select Widget](/images/widgets/select-widget.avif){class="screen width-80"}

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
form | Name of the form to submit to.
label | Checkbox label text
items | List of items to display in the select list. JSON array of strings.
value | The checkbox value

## CSS Properties

These CSS properties configure the underlying button component.

Element | CSS Property | Description
-|-|-
&nbsp; | background | Background color of the button
&nbsp; | color | Text color of the button
&nbsp; | --v-density | Set to compact, default or comfortable.
&nbsp; | --v-ripple | Set to enable the ripple effect.
card | background | Background color of the card# Password Widget

The password widget is a text input where the password text is not echoed back to the user. 

![Password Widget](/images/widgets/password-widget.avif){class="screen width-60"}

## Configurable components

Class Name | Description
-|-
card | Background card component
primary | Password input component

## Widget Properties

Name | Description
-|-
form | Name of the form to submit the text to.
label | Field label

## CSS Properties

These CSS properties configure the underlying Vuetify button component.

Property | Description
-|-
background | Background color
color | Text color
--w-variant | Set to elevated, flat, tonal, outlined, text or plain.
--w-density | Set to compact, default or comfortable.
--w-ripple | Set to enable the ripple effect.# Input Widget Types

Input widgets are used to gather user input and submit to the cloud via **Automated Actions**.  Input widgets can be used standalone or multiple input widgets can be grouped together with a form widget.

## Standalone Input Widgets

When used standalone, the input widget will submit the input value to the cloud via its configured Widget Actions. Actions invoke the named cloud-side automation with parameters determined by the **if** statement.

![Widget Actions](/images/devcore/widget-edit-actions.avif){class="screen width-80"}

## Form Widgets

When used in a form widget, the form widget will gather the relevant input widget values and invoke the form widget action with all the input values. To do this, input widgets designate the form name. Then, when the corresponding form is then submitted, the form widget will gather the input values and submit them to the widget action.


![Form Widget](/images/widgets/form-widget.avif){class="screen width-80"}

## Widget Data

When using individual input widgets, it can be convenient to store data in the Ioto key/value Store table. When using a form widget, it is best to use a dedicated database table that can retrieve a single record that contains all the input values for the form widgets.

## Widget Database Actions

If using individual input widgets, the widget action can be configured to store the input value in the Ioto key/value Store table. If using a form widget, the widget action is best configured to store the form input values in a dedicated database table.

## Widget Types

The following input widget types are supported:

Widget | Description
-|-
[button](./button) | Clickable button
[checkbox](./checkbox) | Checkbox
[combobox](./combobox) | Combination Box
[date](./date) | Date
[file](./file) | File
[form](./form) | Input form
[password](./password) | Password
[radio](./radio) | Radio
[select](./select) | Select
[slider](./slider) | Slider
[switch](./switch) | Switch
[text](./text) | Text Field
[textarea](./textarea) | Text Area

# Icon Widget

The icon widget provides a clickable icon button and is typically used with widget actions to initiate a cloud-side automated action or local UI navigation.

![Icon Widget](/images/widgets/icon-widget.avif){class="screen width-60"}

To display text in a button, use the [Button Widget](./button.md).

## Configurable components

Class Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Name | Description
-|-
form | Name of the form to submit to.
text | Button icon (E.g. $cog)

## CSS Properties

CSS Property | Description
-|-
background | Background color of the button
Text color of the button
border-radius | Round the button corners
box-shadow | Add a shadow to the button
--v-variant | Set to elevated, flat, tonal, outlined, text or plain
--v-block | Set to true to make the button full width
--v-density | Set to compact, default or comfortable
--v-ripple | Set to enable the ripple effect# Textarea Widget

The text widget is a simple text input. It may be used stand-alone or as part of a form.

![Textarea Widget](/images/widgets/textarea-widget.avif){class="screen width-60"}

## Configurable components

Class Name | Description
-|-
card | Background textarea card component
primary | Textarea component

## Widget Properties

Name | Description
-|-
label | Field label
form | Name of the form to submit the text to.

## CSS Properties

These CSS properties configure the underlying Vuetify textarea component.

Property | Description
-|-
background | Background color of the textarea
color | Text color# Combobox Widget

The combobox widget provides a combination box selection widget. It may be used stand-alone or as part of a form.

![Combobox Widget](/images/widgets/combobox-widget.avif){class="screen width-80"}

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
form | Name of the form to submit to.
label | Checkbox label text
items | List of items to display in the combobox. JSON array of strings.
value | The checkbox value

## CSS Properties

These CSS properties configure the underlying button component.

Property | Description
-|-
background | Background color of the button
color | Text color of the button
card.background | Background color of the card
--v-density | Set to compact, default or comfortable.
--v-ripple | Set to enable the ripple effect.# Switch Widget

The switch widget provides a simple on/off selection switch. It may be used stand-alone or as part of a form.

![Switch Widget](/images/widgets/switch-widget.avif){class="screen width-80"}

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
form | Name of the form to submit to.
label | Switch label text
value | The initial switch value

## CSS Properties

These CSS properties configure the underlying switchcomponent.

Element | CSS Property | Description
-|-|-
&nbsp; | background | Background color of the button
&nbsp; | color | Text color of the button
&nbsp; | --v-density | Set to compact, default or comfortable.
&nbsp; | --v-ripple | Set to enable the ripple effect.
card | background | Background color of the card# Widget Data

Widgets can retrieve and display metric and database information for devices and for device cloud and Builder services.  Widgets automatically refresh the displayed data according to the board refresh rate. Widgets can present current data or data for historial metrics.

The **Widget Data** panel configures the widget data source, table, metrics, dimensions and statistic to display. 

![Widget Data](/images/builder/widget-edit-data.avif){class="screen width-60"}

## Data Sources

The Builder dashboard can provide widget data from the Builder service or from any Device Cloud. If you are using a device App, the data source is always your device cloud for the app.

If using the Builder dashboard, select the desired data source from the **Source** pulldown list. Depending on your device clouds you will one or more data sources:

* Service: Builder
* Hosted: Hosted Cloud Name
* Dedicated: Dedicated Cloud Name

## Data Namespaces

Available device and cloud data is grouped into namespaces that define a realm of available data for presentation. The Builder and Device Clouds create a large selection of service and device metric that provide real-time and historical data.


The supported metric namespaces are:

Namespace | Board | Description
-|-|-
Database | App | Device database data
Embedthis/Device | App | Device metrics
Embedthis/Admin | Builder | Builder service metrics
Embedthis/Cloud | Builder | Cloud service metrics including software updates
Embedthis/Ioto | Builder | Cloud service metrics for Ioto including the number of devices claimed, connected, provisioned and message traffic metric
Embedthis/Manager | Builder | End-user metrics including the number of user registrations and device app sessions.

Some namespaces are only available in the Builder and some only in device Apps.

If you are using a dedicated device cloud, the namespace list will include the standard and custom AWS CloudWatch metrics for services you are currently utilizing or have enabled.

### Device Database Data

The special namespace **"Database"** is available in App pages and dashboards and represents raw device database data.

![Widget Database Data](/images/builder/widget-data-database.avif){class="screen width-60"}

After selecting the `Dashboard` namespace, select the database table and field (column) value you require. 

#### Filter Expressions

For multi-row tables, you can enter a filter expression of the form:

    field=value

This will select the desired database table row/item where the field matches the value. You can use **${variable}** references in the field that are expanded at runtime based on other input and context data. For example:

```
/city/${city}/temperature
```

This will select the temperature metric for the city specified by the **city** variable. If an input widget is used to provide the city value, the expression will be expanded at runtime.


### Metric Data

For **metric** namespaces, you specify the metric name, statistic and dimensions to select a required metric.

![Widget Metric Data](/images/builder/widget-data.avif){class="screen width-60"}

The available metrics are provided in the **Metric** pulldown selection list.

The supported metric **statistics** are: min, max, avg, sum, count and current. **Sum** is the sum of values over the request period. **Count** is the number of values sampled over the period. **Current** is the most recent updated value.

Some metrics have dimensions where specific resources have unique metric values. For example, you may have a "Temperature" metric for a device but also have "Temperature" metrics for each element of the device.

The **Resource Dimensions** pulldown list provides the available metrics on your system.

## Literal Widget Data

If you are creating a button or text widget, you can specify literal widget data instead of rendering dynamic database or metric data.

## Override Date

You can override the default date range by providing a widget-specific date range. The period can be set to a range relative to the current time, such as: the last 5 minutes, hour, day, week, month or year. Alternatively, it can be set to a fixed timespan.

<!--
For more information on metrics, please see [Metrics](/doc/agent/metrics.html#metric-naming).
-->
# Numeric Widget

The numeric widget displays numeric text. The number can be static text or it can be a dynamic widget value

![Numeric Widget](/images/widgets/numeric-widget.avif){class="screen width-80"}

The number text will be dynamically scaled according to the size of the widget and will be centered by default.

## Configurable components

Class Name | Description
-|-
card | Numeric widget card component
primary | Primary numeric component

## Widget Properties

Name | Description
-|-
prefix | Optional prefix text to display before the text
suffix | Optional suffix text to display after the text
text | Alternate numeric text to display
value | Widget numeric data value to display

## CSS Properties

Element | CSS Property | Description
-|-|-
&nbsp; | font-size | Set the font size of the numeric text. Defaults to max(10px, min(min(18cqw, 18cqh), 144px))
&nbsp; | font-weight | Set the font weight of the numeric text. Defaults to bold.
&nbsp; | background | Background color
&nbsp; | color | Text color
&nbsp; | justify-content | Set to left to left align the text.
.prefix | font-size | Set the font size of the prefix text. Defaults to max(10px, min(min(5cqw, 5cqh), 36px))
.suffix | font-size | Set the font size of the suffix text. Defaults to max(10px, min(min(5cqw, 5cqh), 36px))


<!--
## Custom CSS Properties

Name | Description
-|-
--># Label Widget

The label widget displays a text label. The label can be static text or it can be a dynamic widget value

![Label Widget](/images/widgets/label-widget.avif){class="screen width-80"}

The label text will be dynamically scaled according to the size of the widget.

## Configurable components

Class Name | Description
-|-
card | Label widget card component
primary | Primary label component

## Widget Properties

Name | Description
-|-
prefix | Optional prefix text to display before the text
suffix | Optional suffix text to display after the text
text | Label text to display
value | Widget data value to display if text not defined

## CSS Properties

Element | CSS Property | Description
-|-|-
&nbsp; | font-size | Set the font size of the label text. Defaults to max(10px, min(min(18cqw, 18cqh), 144px))
&nbsp; | font-weight | Set the font weight of the label text. Defaults to bold.
&nbsp; | background | Background color
&nbsp; | color | Text color
&nbsp; | justify-content | Set to left to left align the text.
.prefix | font-size | Set the font size of the prefix text. Defaults to max(10px, min(min(5cqw, 5cqh), 36px))
.suffix | font-size | Set the font size of the suffix text. Defaults to max(10px, min(min(5cqw, 5cqh), 36px))
# Shape Widget

Draw simple shapes.

![Shape Widget](/images/widgets/shape-widget.avif){class="screen width-80"}

The Shape widget can draw simple shapes such as circles, squares and rectangles.
The shapes can be drawn in a variety of line types and can be styled with CSS.

## Configurable components

Class Name | Description
-|-
card | Label widget card component
primary | Primary label component

## Widget Properties

Name | Description
-|-

## CSS Properties

CSS Property | Description
-|-
class | CSS class name to apply to the shape. Set to `circle` or `square`.# Metric Table Widget

The metric table widget displays a metric dimensions in a tabular format.

![Metric Table Widget](/images/widgets/metric-widget.avif){class="screen width-80"}

For metrics that have a large number of dimensions, it can be useful to display the dimensions themselves in a table. You can select the date range using the toolbar.

The table has a reload button to refresh the data if it has changed.

## Pagination

The table properties support a `pageSize` property to set the number of rows to display. The default is 7. If there are more rows than the pageSize, the table will display a pagination control.

## Filtering

The table widget supports basic filtering using a caseless full text search. The filter is applied to all columns.

## Sorting

The table widget supports sorting on any column. You can click any column to sort on that column. Another click will reverse the sort.

## Configurable components

Class Name | Description
-|-
card | Label widget card component
primary | Primary label component

## Widget Properties

Name | Description
-|-
columns | Ordered array of column definitions
pageSize | Initial number of rows to display
subtitle | Table title
value | Widget data value to suply an array or map of values

## CSS Properties

Property | Description
-|-# Toolbar Widget

The Toolbar widget displays the board (page or dashboard) toolbar as a widget. This is useful for full page displays that want to provide users with the toolbar to select date ranges and other run-time board settings.

![Toolbar Widget](/images/widgets/toolbar-widget.avif){class="screen width-80"}

## Configurable components

Class Name | Description
-|-
card | Label widget card component
primary | Primary label component

## Widget Properties

Name | Description
-|-
value | Widget data value to suply an array or map of tab items

## CSS Properties

Property | Description
-|-# Speedometer Widget

The Speedometer widget provides a gauge display for a numeric value.

![Speedometer Widget](/images/widgets/speedometer-widget.avif){class="screen width-80"}

The speedometer displays a sweeping needle and background area with minimum and maximum values. A numeric reading is also displayed.

The speedometer widget animates the movement no the needle in response to large updates.

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
format | Format the value using a format string. Defaults to "{value}".
min | Minimum value of the speedometer. Defaults to 0.
max | Maximum value of the speedometer. Defaults to 100.
value | Value to display on the speedometer. Defaults to 0.

## CSS Properties

These CSS properties configure the underlying button component.

Property | Description
-|-
background | Background color of the button
color | Text color of the button
--w-fill-color | The fill color of the speedometer arc (defaults to --v-theme-primary with opacity).
--w-text-color | The color for text elements like value and labels (defaults to --v-theme-text).
--w-needle-color | The color of the speedometer's needle (defaults to --v-theme-text-darken-1).
--w-units | Optional units to display next to the value.# Image Widget

The image widget displays an image from a URL. It can be used to provide backgrounds or foreground images.

![Image Widget](/images/widgets/image-widget.avif){class="screen width-80"}

The image URL can take one of three formats:

* A string URL with `${var}` references
* Map of URLs candidates
* List of URL candidates

## String URL

If the URL is a string, the string will expand `${var}` references and then be used as the image to display. 

## Map of URLs

If a map of URLs is provided, the image is selected based on the current widget data `value`. In this manner, an appropriate image can be selected based on run-time data. For example: a weather image could display a sunny image when the temperature is above 70 degrees or a cloudy image when the temperature is between 50 and 70 degrees.

```js
url: {
    sunny: 'https://example.com/sunny.jpg',
    cloudy: 'https://example.com/cloudy.jpg',
    '*': 'https://example.com/default.jpg',
}
```

## List of URLs

If the URL value is a list, the list contains candidate URLs with expressions that are evaluated at run-time to select the best match. For example:

```js
[
    { 
        expression: 'temp > 40', 
        value: 'https://example.com/audio/hot.mp3',
    },
    {
        expression: true,
        value: 'https://example.com/audio/temperate.mp3'
    }
]
```

## Auto Scale

The image scales to the size of the widget. How the image fills the widget area is controlled by the `object-fit` and `object-position` properties.

## Configurable components

Class Name | Description
-|-
card | Background image card component
primary | Primary image component

## Widget Properties

Name | Description
-|-
url | URL string, map or list of URLs
value | Widget data value to select the image from the URL map

## CSS Properties

Property | Description | Example
-|-|-
border | Add borders around images | `border: 2px solid #ccc`
clip-path | Clip image | `clip-path: circle(50% at 50% 50%);`
filter | Apply visual effects like blur or grayscale | `filter: grayscale(100%) blur(2px)`
opacity | Adjust image transparency | `opacity: 0.7`
object-fit | Controls how an image fills its container (e.g., stretch, crop, scale) | `object-fit: cover`, or fill, contain, none, or scale-down
object-position | Controls where the image is anchored | `object-position: top right`
border-radius | Round image corners or create circular images | `border-radius: 8px` or `border-radius: 50%`
--w-gradient | Apply a gradient over the image | to top right, rgba(100,115,201,.33), rgba(25,32,72,.7)# Video Widget

The video widget plays a video from a URL. 

![Video Widget](/images/widgets/video-widget.avif){class="screen width-100"}

The video URL can take one of three formats:

* Simple string
* Map of URLs candidates
* List of URL candidates

## String URL

If it is a simple URL string that video file will be played. 

```js
url: 'https://www.youtube.com/embed/eIG5z-DcrIo'
```

## Map of URLs

If it is a map, the widget value is used as a key to the map to select a corresponding URL. A key of "*" will be selected if there is no better match.

```js
url: {
    sunny: 'https://www.youtube.com/embed/eIG5z-sunny'
    cloudy: 'https://www.youtube.com/embed/eIG5z-cloudy',
    '*': 'https://www.youtube.com/embed/eIG5z-default',
}
```

## List of URLs

If the URL value is a list, the list must contain candidates with expressions that are evaluated at run-time to select the best match. For example:

```js
[
    { 
        expression: 'temp > 40', 
        value: 'https://www.youtube.com/embed/eIG5z-DcrIo',
    },
    {
        expression: true,
        value: 'https://www.youtube.com/embed/eIG5z-other'
    }
]
```

Autoplay of video is typically prevented by the browser and may require the video to be muted at first.

## Configurable components

Class Name | Description
-|-
card | Background card component
primary | Primary video component

## Widget Properties

Name | Description
-|-
url | URL string, map or list of URLs
value | Widget data value used to select the image from the URL map or list

## CSS Properties

Name | Description
-|-
--w-autoplay | Set to true to autoplay the video. Defaults to false.
--w-end | End time of the video in seconds.
--w-fullscreen | Set to true to allow the video to be played in fullscreen. Defaults to false.
--w-loop | Set to true to loop the video. Defaults to false.
--w-start | Start time of the video in seconds.# Progress Widget

Display a progress bar.

![Progress Widget](/images/widgets/progress-widget.avif){class="screen width-80"}

The Progress widget can be used to display the progress of a long running operation.

## Configurable components

Class Name | Description
-|-
card | Label widget card component
primary | Primary label component

## Widget Properties

Name | Description
-|-
value | Widget data value that is interpreted as a number between 0 and 100.

## CSS Properties

Property | Description
-|-# Audio Widget

The audio widget plays a sound file from a URL. It can autoplay a sound without a play button UI or it can display a play/pause button to control the audio playback.

![Audio Widget](/images/widgets/audio-widget.avif){class="screen width-80"}

The audio URL can take one of three formats:

* A string URL
* Map of URL candidates
* List of URL candidates

## String URL
If it is a simple URL string, that audio file will be played. Any `${var}` references will be expanded at run-time.

```js
url: 'https://example.com/audio/hot-${temp}.mp3',
```

## Map of URLs

If it is a map, the widget value is used as a key to the map to select a corresponding URL. A key of `*` will be used if there is no better match.

```js
url: {
    sunny: 'https://example.com/audio/sunny.mp3',
    cloudy: 'https://example.com/audio/cloudy.mp3',
    '*': 'https://example.com/audio/rainy.mp3',
}
```

## List of URLs

If the URL value is a list, the list contains candidate URLs with expressions that are evaluated at run-time to select the best match. For example:

```js
[
    { 
        expression: 'temp > 40', 
        value: 'https://example.com/audio/hot.mp3',
    },
    {
        expression: true,
        value: 'https://example.com/audio/temperate.mp3'
    }
]
```

## Auto Play
Autoplay of audio is typically prevented by the browser. To enable, you may need to invoke your browser with a specific flag. For example:

```bash
chrome.exe --autoplay-policy=no-user-gesture-required
```

## Configurable components

Class Name | Description
-|-
card | Audio widget card component
primary | Primary audio player component

## Widget Properties

Name | Description
-|-
prefix | Optional prefix icon (defaults to "$play" and "$pause")
text | Play button text (defaults to "Play")
url | URL string, map or list of URLs
value | Widget data value used to select the audio from the URL map or list

## CSS Properties

Name | Description
-|-
color | Color of the play/pause button
background | Background color of the play/pause button
font-size | Font size of the play/pause button
font-weight | Font weight of the play/pause button
--w-autoplay | Set to true to autoplay the audio file. Defaults to false.
--w-duration | Duration to play the audio file. Set to a number of seconds or repeat to loop the audio file. Defaults to no limit
--w-loop | Set to true to loop the audio file. Defaults to false.# Table Widget

The table widget displays a widget data in a tabular format.

![Table Widget](/images/widgets/table-widget.avif){class="screen width-80"}

The table widget displays dynamic database or metric data as a table. The table supports filtering, sorting and pagination. 

The table has a reload button to refresh the data if it has changed.


## Column Configuration

You can configure and format the columns to display the data as you want. The Widget Properties panel has a `Columns` section that allows you to configure the columns. The columns are defined as a JSON6 array of objects with the following properties:

* name - The name of the column
* width - The width of the column. Enter a percentage of the table width.
* title - The title of the column
* desktop - Display only on desktop displays
* mobile - Display only on mobile displays

For run-time column configuration, you can resize columns by clicking on the column dividor and then dragging to adjust the column size. To reset columns to their original configuration, Control+Click any column and then click the `Reset Layout` button.

## Pagination

The table properties support a `pageSize` property to set the number of rows to display. The default is 7. If there are more rows than the pageSize, the table will display a pagination control.

## Filtering

The table widget supports basic filtering using a caseless full text search. The filter is applied to all columns.

## Sorting

The table widget supports sorting on any column. You can click any column to sort on that column. Another click will reverse the sort.

## Configurable components

Class Name | Description
-|-
card | Label widget card component
primary | Primary label component
buttons | Table action buttons

## Widget Properties

Name | Description
-|-
columns | Ordered array of column definitions
pageSize | Initial number of rows to display
subtitle | Table title
value | Widget data value to suply an array or map of values

## CSS Properties

Property | Description
-|-# Info Widget

The Info widget is a composite widget card that includes a numeric result, header, icon and sparkline.

![Info Widget](/images/widgets/info-widget.avif){class="screen width-80"}

Class Name | Description
-|-
card | Label widget card component
header | Header label component
icon | Icon component
primary | Primary label component
prefix | Prefix label component
suffix | Suffix label component
value | Numeric value component

## Widget Properties

Name | Description
-|-
value | Widget data value to suply an array or map of values

## CSS Properties

Element | CSS Property | Description
-|-|-
.header | font-size | Font size of the header label
.header | color | Text color of the header label# Tabs Widget

The Tabs widget displays a series of tab menu items.

![Tabs Widget](/images/widgets/tabs-widget.avif){class="screen width-80"}

The Tabs widget can take one of two formats:

* A map of {name, to} items
* An array of label:URL items

If a map is provided, the tabs will use the map keys as the menu text and the `to` property as the destination app URL. If an array is provided, the widget will expect `label:URL` items.

## Tabs Title

If the widget `header` property is set, it will be used as the title of the tabs widget and will be displayed to the left of the tabs..

## Configurable components

Class Name | Description
-|-
card | Label widget card component
primary | Primary label component

## Widget Properties

Name | Description
-|-
value | Widget data value to suply an array or map of tab items

## CSS Properties

Property | Description
-|-# Output Widget Types

The following widget types are supported:

Widget | Description
-|-
[audio](./audio) | Audio player
[event](./event) | Table of top alerts
[gauge](./gauge) | Numeric gauge
[graph](./graph) | Numeric graph
[image](./image) | Image
[label](./label) | Text label
[led](./led) | LED indicators
[metric](./metric) | Table of metrics
[numeric](./numeric) | Numeric value
[progress](./progress) | Progress widget
[shape](./shape) | Arbitrary shape
[speedometer](./speedometer) | Alternate Numeric gauge
[table](./table) | Tabular data
[tabs](./tabs) | Tabbed navigation
[toolbar](./toolbar) | Dashboard toolbar
[video](./video) | Video player
# LED Widget

The LED widget displays a series of LED indicators. 

![LED Widget](/images/widgets/led-widget.avif){class="screen width-80"}

The LED data can take one of two formats:

* An array of truthy values
* A map of labels with truthy values

If a map is provided, the widget will use the map keys as the LED labels. If an array is provided, the widget LED indicators will be in the order of the array and will not be labeled.

The LED indicators will be green if the value is truthy, yellow if the value is zero and red otherwise.

## Configurable components

Class Name | Description
-|-
card | Label widget card component
primary | Primary label component
leds | LED indicators component
labels | LED labels component

## Widget Properties

Name | Description
-|-
value | Widget data value to suply an array or map of values

## CSS Properties

Element | CSS Property | Description
-|-|-
.leds | background | Background color of the LED indicators
.labels | background | Background color of the LED labels# Event Widget

The event widget displays the top alert entries from the alert table.

![Event Widget](/images/widgets/event-widget.avif){class="screen width-80"}

## Configurable components

Class Name | Description
-|-
card | Background image card component
primary | Primary image component

## Widget Properties

Name | Description
-|-
max | Maximum number of alerts to display. Defaults to 7.
value | Alerts database table values

## CSS Properties

Property | Description
-|-
color | Color of the event text
font-size | Font size of the event text# Gauge Widget

The gauge widget provides a gauge display for a numeric value.

![Gauge Widget](/images/widgets/gauge-widget.avif){class="screen width-80"}

The gauge displays a sweeping needle and background area with minimum and maximum values. A numeric reading is also displayed.

The gauge widget animates the movement no the needle in response to large updates.

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
format | Format the value using a format string. Defaults to "{value}".
min | Minimum value of the gauge. Defaults to 0.
max | Maximum value of the gauge. Defaults to 100.
value | Value to display on the gauge. Defaults to 0.

## CSS Properties

These CSS properties configure the underlying button component.

Property | Description
-|-
background | Background color of the button
color | Text color of the button
--w-fill-color | The fill color of the gauge arc (defaults to --v-theme-primary with opacity).
--w-text-color | The color for text elements like value and labels (defaults to --v-theme-text).
--w-needle-color | The color of the gauge's needle (defaults to --v-theme-text-darken-1).
--w-units | Optional units to display next to the value.# Graph Widget

The graph widget provides graphical line chart display for historical and current widget data.

![Graph Widget](/images/widgets/graph-widget.avif){class="screen width-80"}

## Configurable components

Name | Description
-|-
card | Background button card component
primary | Button component

## Widget Properties

Class Name | Description
-|-
presentation | Presentation mode for the graph. Defaults to "line".
value | Value to display on the graph. Defaults to 0.

## CSS Properties

These CSS properties configure the underlying button component.

Property | Description
-|-
background | Background color of the graph
color | Text color of the graph
font-family | Font family of the graph labels. Defaults to Inter.
font-size | Font size of the graph labels. Defaults to 12px.
--w-fill-color | Color of the graph fill. Defaults to --v-theme-primary with 0.15 opacity.
--w-grid-color | Color of the graph grid. Defaults to --v-theme-accent with 0.25 opacity.
--w-last-fill-color | Color of the last graph point fill. Defaults to --v-theme-secondary-lighten-2 with 0.35 opacity.
--w-line-color | Color of the graph lines. Defaults to --v-theme-accent-darken-1.
--w-line-curve-tension | Tension of the graph lines. Defaults to 0.1.
--w-line-width | Width of the graph lines. Defaults to 2px.
--w-predict | Extrapolate the last point of the graph if incomplete period. Defaults to false.
--w-point-radius | Radius of the graph points. Defaults to 3px.
--w-span-gaps | Whether to span gaps between points. Defaults to true.
--w-tick-color | Color of the graph ticks. Defaults to --v-theme-accent-darken-1.
--w-tick-size | Size of the graph ticks. Defaults to 14px.# Line Widget

The Line widget draws a single line.

![Line Widget](/images/widgets/line-widget.avif){class="screen width-80"}

The Line widget can draw a single line with a variety of styles. The line can be rotated and styled with CSS.

## Configurable components

Class Name | Description
-|-
card | Label widget card component
primary | Primary label component

## Widget Properties

Name | Description
-|-
value | Widget data value to suply an array or map of values

## Common CSS Properties

Property | Description
-|-
border-top-style | Define the line style. Seleect from: none, hidden, dotted, dashed, solid, double, groove, ridge, inset, outset
border-top-width | Define the width of the line
border-top-color | Define the color of the line
transform | Line transformation. E.g. `rotate(45deg)`# Dashboard Widgets

Dashboard Widgets present device and service service information in a discrete, graphical and interactive manner.
Widgets can be combined to create integrated UI pages that focus on various aspects of your device and service.

The Dashboard supports over 30 different widget types that address a wide range of display and interactive input needs. These include: gauges, graphs, numerics, text, image, sound, and input widgets.

![Widet Toolbox](/images/builder/grid-layout.avif){class="screen width-80"}

## Adding Widgets

To add widgets to the dashboard, drag a widget from the widget sidebar toolbox to the desired location on the dashboard.

This will render a box where the widget will be placed and will then display the widget properties slide-out panel. From this panel, you can select your widget configuration.

![Widget Toolbox](/images/builder/widget-toolbox.avif){class="screen width-60"}

You can also add a widget by clicking on the **"Plus"** icon in the Dashboard toolbar. 

![Navbar](/images/builder/dashboard-toolbar.avif){class="screen width-60"}

## Widget Configuration

When creating or modifying a widget, the widget modify panel is used to configure the widget type, presentation, style, data source and associated automation actions.

![Add Widget](/images/builder/widget-edit.avif){class="screen width-60"}

There are four tabs to control the various aspects of a widget:

Name | Description
-|-
Basic | Widget type and extra output fields
Presentation | Widget position and styling
Data | Data source for the widget
Actions | Automated action to run when the widget is activated

From this panel you can save your changes and click Apply button if you wish to save changes, but keep the panel open for futher modifications.

## Deleting Widgets

From this panel you can also delete a widget or copy a widget to a new widget. 

To learn more:

* [Widget Basic](basic.md)
* [Widget Presentation](presentation.md)
* [Widget Data](data.md)
* [Widget Actions](actions.md)

# Widget Actions

Widgets can invoke actions when a widget is activated by user action, such as clicking a button. A widget actions can peform operations on devices, on the device cloud or initiate creating an alert or sending a notification. Widgets can configure one or more actions.

A widget action can be initiated by:

* Clicking a widget
* Updating the value of an input widget or input form
* Clicking a widget form submit button

When activated, the widget will invoke the associated action. There are two kinds of actions:

* UI Links
* Change Dashboard
* Automated Actions

## Input Widgets

Input widgets capture a user value and provide that value to the action via the **value** property. Form widgets capture a set of user values from associated input widgets and provide that value to the form's action.

## UI Links

UI links are in-app page redirections where the App will navigate to the nominated page.

## Change Dashboard

Change dashboard actions allow another dashboard to be selected when a button is clicked.

## Automated Actions

Automated Actions are cloud-side actions defined by the builder to operate on devices our the device cloud. If selected, an **Action Name** selection list will display the available actions.

![Widget Actions](/images/builder/widget-edit-actions.avif){class="screen width-80"}

### If / Then / Else / If

An widget can provide a context data to the automated action by configuring a set of properties that are used when an expression is true or not.  This is structured as a sequence of if/then/else statements. If the epxression is true, the properties provided by the **then** clause will passed as parameters to the action.

For example, the EcoHouse app tests the value of a **ChargeCar** Button widget to enable or disable charging.

In this image, the **{car: false}** properties are provided to a Database update action which set the **car** field of a **Desired** state table to false.

## If expressions

The **If** expression is a JavaScript like expression that is evaluated to determine which set of parameters should be provided to the automated action.

The **If** expression is provided with a context of variables that can be accessed by the expression. The widget data value is provided in the **"value"** named variables. You can test this result using a Javscript like expression. For example:

    value > 0

See [Expressions](../config/expressions.md) for more information on the expression syntax.

